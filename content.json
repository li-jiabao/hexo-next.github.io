{"pages":[],"posts":[{"title":"","date":"2021-03-03T07:30:49.594Z","path":"wiki/2021-03-03-IO Operation/","text":"","tags":[],"categories":[]},{"title":"","date":"2021-03-03T07:30:49.594Z","path":"wiki/2021-03-03-Local class/","text":"","tags":[],"categories":[]},{"title":"","date":"2021-03-03T07:30:49.591Z","path":"wiki/2021-03-03-Annoymous class/","text":"","tags":[],"categories":[]},{"title":"","date":"2021-03-03T07:30:49.591Z","path":"wiki/2021-03-03-Concurrency/","text":"","tags":[],"categories":[]},{"title":"","date":"2021-03-03T07:30:49.591Z","path":"wiki/2020-12-06-Modifying-a-Manifest-File/","text":"Modifying a Manifest FileYou use the m command-line option to add custom information to the manifest during creation of a JAR file. This section describes the m option. The Jar tool automatically puts a default manifest with the pathname META-INF/MANIFEST.MF into any JAR file you create. You can enable special JAR file functionality, such as package sealing, by modifying the default manifest. Typically, modifying the default manifest involves adding special-purpose headers to the manifest that allow the JAR file to perform a particular desired function. To modify the manifest, you must first prepare a text file containing the information you wish to add to the manifest. You then use the Jar tool’s m option to add the information in your file to the manifest. The basic command has this format: 123jar cfm *jar-file manifest-addition input-file(s)* Let’s look at the options and arguments used in this command: The c option indicates that you want to create a JAR file. The m option indicates that you want to merge information from an existing file into the manifest file of the JAR file you’re creating. The f option indicates that you want the output to go to a file (the JAR file you’re creating) rather than to standard output. manifest-addition is the name (or path and name) of the existing text file whose contents you want to add to the contents of JAR file’s manifest. jar-file is the name that you want the resulting JAR file to have. The input-file(s) argument is a space-separated list of one or more files that you want to be placed in your JAR file. The m and f options must be in the same order as the corresponding arguments. The remaining sections of this lesson demonstrate specific modifications you may want to make to the manifest file.","tags":[],"categories":[]},{"title":"github加速","date":"2021-03-03T06:35:05.729Z","path":"wiki/2021-03-03-github加速/","text":"hosts修改找到github.com和github.global.ssl.fastly.Net的ip地址添加到host的域名映射中去 使用梯子有梯子的话使用git的代理设置git config --global http.https://github.com.proxy socks5://127.0.0.1:7891 不使用梯子在github链接中加入cnpmjs.orggit clone https://github.com.cnpmjs.org/*** 使用浏览器插件github加速其 http://download.eclipse.org/jdtls/snapshots/jdt-language-server-0.63.0-202010141717.tar.gz","tags":[{"name":"杂记","slug":"杂记","permalink":"http://example.com/tags/%E6%9D%82%E8%AE%B0/"}],"categories":[{"name":"杂记","slug":"杂记","permalink":"http://example.com/categories/%E6%9D%82%E8%AE%B0/"}]},{"title":"Class","date":"2021-03-03T05:46:28.651Z","path":"wiki/2021-03-03-Class/","text":"getClass()方法查找的是对象的类，不是通过类变量去查找的，这个和动态绑定确定类型的时候是一致的。Field、Method、Constructor也是类 Class类Class是一个类（类本身也对象，原始数据类型不是），这个类中包含了众多的方法，这些方法可以用来获取其他对象的信息反射：利用Class类==从对象获取类的信息、初始化或者调用等操作==的这一过程叫做反射reflection正射：是指从类获取对象的这一过程，也就是类实例化这一过程。这一过程的具体流程：==JVM首先会加载ClassName.class，加载到内存之后，在方法区/堆（具体哪一个有争议）中，在方法区/堆中创建一个Class对象对应ClassName类== ==获取Class对象==： Class.forName(“com.Student”)==参数传递完整的包加类名== obj.getClass() ClassName.class Class对象提供的一些功能： 运行时判断对象所属类和父类以及包obj.getClass(); // 获取Class类obj.getClass().getSimpleName(); // 获取类名obj.getClass().getName(); // 获取完整路径的类名obj.getClass().getPackage(); //获取包名obj.getSuperClass(); // 获取父类，返回的也是Class对象obj.getInterfaces();obj.getInterface(); //返回接口的Class对象，可以调用getMethods()等方法 运行时创建任意类的一个类对象 可以使用getInstance()或者newInstance()ClassType obj = ClassObj.newInstance();使用Class对象中的newInstance()返回类对象。但是如果==类没有无参数构造方法，会报错==。因为newInstance()==调用的时类的无参数构造方法== 还可使用getConstructor()方法获取构造器后调用newInstance()传入对应参数构造对象 123456Constructor&lt;?&gt; [] cons = ClassObj.getConstructors();// 获取类下面的构造方法列表// 获取到的方法还能使用getParameterType()等获取方法的详情`ClassName obj = (ClassName)cons[0].newInstance(); // 需要进行强制类型转换，不然可能报错，而且这里面的newInstance// 是可以传参数的只是需要依据是哪一个构造方法来确定传入的参数个数和顺序. 运行时获取类定义的成员变量和方法Field、Method、Constructor是类，代表的类中的fields，methods和constructorsgetFields(); // 获取public字段，静态和非静态在这里没有区别getDeclaredFields(); // 获取所有的字段field.get(object); // 获取属性值field.set(object, value); // 设置修改publicfield.setAccessible(true); // 设置了权限后可以修改访问private属性和方法getMethods(); // 获取所有的共有方法，或访问到父类的getDeclaredMethods(); 获取所有的方法，不会获取到父类的调用获取到的方法method.invoke(obj, parameter); // 使用invoke方法，传入对象和参数，无参数就传入null，即可调用方法，对于private方法，可以修改权限后调用，setAccessible(true). 在运行时调用任意一个类对象的方法 123456789101112131415public static void main(String[] args)&#123; Class&lt;?&gt; clObj = Class.forName(&quot;Person&quot;); Method[] methods = clObj.getDeclaredMethods(); // 获取所有的方法，没有父类的 for (Method method: methods)&#123; method.setAccessible(true); // 设置true，所有方法都有权限访问了 methos.invoke(person, ...args: null); // 调用方法 &#125; Method method = clObj.getMethod(&quot;methodName&quot;, String.class); // 获取特定的方法，第一个参数方法名 // 第二个参数，参数类型的class对象或者无参数时null。 &#125; 生成动态代理 反射reflection的优缺点优点反射可以在不知道运行哪一个类的情况下，获取到类的信息，创建对象以及操作对象，==方便扩展==，是框架设计的灵魂，框架在设计的时候，为了降低耦合度，不能将类型写死，需要考虑扩展功能==降低了耦合度==，变得更加灵活，在==运行时去确定类型==，绑定对象，体现了==多态==的特性 缺点反射需要动态类型，JVM没办法优化这部分代码，==执行效率或相对直接初始化对象而有所降低==，业务代码不建议使用。反射可以访问到private的属性和方法，会==破坏封装性==，有安全隐患，还会==破坏单例==的设计。反射会使得==代码变得复杂，不容易维护==。","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Linux","date":"2021-03-02T16:27:42.000Z","path":"wiki/Linux/","text":"Linux系统安装 官网下载镜像源，制作启动盘，启动盘软件制作使用ventoy,这个软件制作的启动盘，既可以当成启动盘，还可当作存储盘使用 重启进入bios,不同的主办型号需要按不同的BIOS键 进入BIOS之后进行一些必要的设置 将AHCP设置为true,开启uefi关闭传统的启动引导方式 选择启动顺序为U盘在最前面，或者选中u盘进行启动 启动后选择制作的ISO镜像进行安装","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}]},{"title":"Hello World","date":"2021-03-02T15:48:30.218Z","path":"wiki/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Start","slug":"Start","permalink":"http://example.com/tags/Start/"}],"categories":[{"name":"Start","slug":"Start","permalink":"http://example.com/categories/Start/"}]},{"title":"jekyll语法","date":"2021-03-01T16:34:31.896Z","path":"wiki/2021-03-03-jekyll语法/","text":"语法规则&#123;&#123; page.title &#125;&#125;输出预先定义好的变量，作为页面的content内容，示例展示的page.title变量的值 &#123;% control/logic flow%&#125;这个标签包裹的是逻辑流或者控制结构，下面是两个示例： 123456789&#123;% if page.show_sidebar %&#125; &lt;div class&#x3D;&quot;sidebar&quot;&gt; sidebar content &lt;&#x2F;div&gt;&#123;% endif %&#125;&#123;% for url in site.urls %&#125;&#123;% endfor %&#125; Filter&#123;&#123; \"hi\" | capitalize &#125;&#125;展示大写的HI而不是小写的&#123;&#123; \"/assets/style.css\" | relative_url&#125;&#125;使用相对路径，抹除掉baseurl变量值，在网站布置在子域名下的时候很有用&#123;&#123; \"/assets/style.css\" | absolute_url`展示绝对路径 `&#123;&#123; site.members | group_by:\"graduation_year\" &#125;&#125;根据特定的内容进行分组，还可以用正则匹配，group_by_exp&#123;&#123; site.members | find/find_exp:\"item\",\"item.graduation_year < 2014\" &#125;&#125;查找命令 use liquid在page的开头加上：Front Matter 123456---# 加上这个是为了告诉jekyll处理liquidmynumber: 5# 可以使用page.mynumber来访问这个变量--- Layout","tags":[{"name":"Blog","slug":"Blog","permalink":"http://example.com/tags/Blog/"}],"categories":[{"name":"Blog","slug":"Blog","permalink":"http://example.com/categories/Blog/"}]},{"title":"使用jekyll主题","date":"2021-03-01T14:22:26.931Z","path":"wiki/2021-03-03-使用jekyll主题/","text":"主题安装网上下载配置 在主题官网下载：1.org 2.com 3.dev 解压到需要的目录下 进入到该目录下，执行bundle安装所需的依赖和主题 4.执行：bundle exec jekyll server 可以在http//localhost:4000查看主题情况 gem下载主题 在你的jekyll站点的Gemfile中添加：gem &quot;jekyll-theme-chirpy&quot; 然后在你的配置文件： _config.yml:中加入：theme: jekyll-theme-chirpy 然后在命令行下执行：bundle 从gem下载下来的主题文件复制到你的站点目录下面找到主题文件位置的命令：bundle info --path jekyll-theme-chirpy 一般主题文件的git repository中都有详细的安装教程，可以按照安装教程来执行 github pages配置jekyll主题devepr主题首先进入到主题的github主题repository当中，然后查看READMME.md文档，学习怎么配置 一般是首先fork目录到自己的github中，然后在该repository中点击使用这个为模板创建自己的repositroy。等待创建完成，然后便可以将这个目录克隆到本地中，然后在本地进行修改配置并且进行jekyll的本地配置查看，当然如果非常了解jekyll的使用配置的话，将会非常容易的定制化自己的博客界面。 克隆到本地之后，需要进行下列的操作： git clone https://github.com/your_github_username/your_github_username.github.io.git cd your_github_username ruby -v gem install bundler bundler -v bundle add jekyll bundle exec jekyll -v bundle update bundle install bundle exec jekyll serve --watch 更新： git remote -v git remote add upstream https://github.com/sujaykundu777/devlopr-jekyll.git git fetch upstream git checkout master git merge upstream/master git push 很多主题类似","tags":[{"name":"Blog","slug":"Blog","permalink":"http://example.com/tags/Blog/"}],"categories":[{"name":"Blog","slug":"Blog","permalink":"http://example.com/categories/Blog/"}]},{"title":"jekyll配置管理博客","date":"2021-02-28T17:07:50.045Z","path":"wiki/2021-03-03-jekyll配置管理博客/","text":"由于jekyll是ruby语言开发的，因此需要先配置ruby环境 安装ruby并配置sudo pacman -S ruby gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/配置ruby中国镜像源gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/配置清华镜像源 安装jekyll和buddlegem install jekyll bundle 配置环境变量，安装的需要配置环境变量的文件在~/.local/share/gem/ruby/gem/2.7.0/bin 配置buddle镜像： bundle config mirror.https://rubygems.org https://gems.ruby-china.com这一步之后不用修改Gemfile中的source了 生成博客文件jekyll new blog_name进入博客文件：cd blog_name开启server检查配置：bundle exec jekyll server SSL 证书错误正常情况下，你是不会遇到 SSL 证书错误的，除非你的 Ruby 安装方式不正确。 如果遇到 SSL 证书问题，你又无法解决，请修改 ~/.gemrc 文件，增加 ssl_verify_mode: 0 配置，以便于 RubyGems 可以忽略 SSL 证书错误。 -–:sources: https://gems.ruby-china.com:ssl_verify_mode: 0 如果你在意 Gem 下载的安全问题，请正确安装 Ruby、OpenSSL，建议部署 Linux 服务器的时候采用 这个 RVM 安装脚本 的方式安装 Ruby。 其他说明 Bundler::GemspecError: Could not read gem at /home/xxx/.rvm/gems/ruby-2.1.8/cache/rugged-0.23.3.gem. It may be corrupted.，这类错误是网络原因下载到了坏掉的文件到本地，请直接删除那个文件。 请珍惜社区资源，勿基于本镜像做二次镜像网站，我们会定期检查 CDN 请求量统计，单日请求量过大（流量超过 20 G） 的 IP 将会被永久屏蔽。","tags":[{"name":"Blog","slug":"Blog","permalink":"http://example.com/tags/Blog/"}],"categories":[{"name":"Blog","slug":"Blog","permalink":"http://example.com/categories/Blog/"}]},{"title":"网络设置","date":"2021-02-28T16:08:57.012Z","path":"wiki/2021-03-03-网络设置/","text":"网络设置安装一些配置网络必须的包 sudo pacman -S networkmanager network-manager-applet iw ppp rp-pppoe 后面的两个软件包在设置pppoe连接时必须的包，前面的两个是网络管理包，iw也是一个网络管理的连接包 进入配置界面：命令行下输入：nmtui就可以进入网络选择配置的界面，选择自己想要的网络配置项进去连接就好了","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"免费代理配置","date":"2021-02-27T13:40:24.168Z","path":"wiki/2021-03-03-免费代理配置/","text":"免费代理除了免费之外，没有什么有点，速度满，不安全，但是只在某些情况下使用的话还是可以考虑使用的 v2ray下载安装archlinu：sudo pacman -S v2ray qv2ray安装完成之后便可以打开软件了进入软件之后，需要进行两步设置： 在首选项的入站设置中勾选系统代理，并在连接设置取消勾选绕过中国大陆 选中群组，点击分组进入到分组设置，然后有好几种添加代理的方式，一种是复制vmess://或者ssr等开头的文本，第二种是通过分享二维码，第三种是设置订阅设置，复制订阅节点链接即可设置好了之后，便可以测试代理是否可用以及速度。就算上述步骤设置好了之后，并不像windows下面一样，选中全局配置即可在所有的软件中使用代理，而是需要在chromium等软件中利用ghelper设置代理。 进入ghelper插件，点击进入管理界面，选择代理 输入代理的ip和port以及协议，然后在插件管理中打开即可 在linux的i3桌面下也是支持右击设置系统代理的，为什么需要设置ghlepe的代理是因为chromium的代理不支持，而google-chrome是可以的 manjaro系统下面不需要设置ghelper也可以访问，因为KDE/GONME桌面环境支持在通知栏中来管理V2RAY的系统代理设置，因此全局系统代理，是否在环境中设置好就可以，这个有待考量，反正manjaro下面可以不设置ghelper的代理，在满就爱如哦系统代理设置中的vpn界面已经为我们设置好了全局系统代理，和window下类似的 windows下载好v2ray软件之后，打开软件进入，选择从剪切板导入或者其他方式导入，然后导入之后便可以看到代理的详细信息，然后便可以进行测速，想要全局可用或者打开代理，还得在右下角右击该v2ray图表，然后选择http代理，打开全全局代理，就可以开始使用了","tags":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"}]},{"title":"YouCompleteMe插件","date":"2021-02-27T13:05:55.821Z","path":"wiki/2021-03-03-YouCompleteMe插件/","text":"安装前准备sudo pacman -S base-devel git java python npm nodejs go cmake安装一些安装所需的包 下载找到官网的仓库地址，克隆到本地的vim插件文件夹下面，~/.vim/pack/vendor/start/ 子模块更新git submodule update --init --recursive同步放在该仓库下的其他子模块仓库，并更新 completer安装根据自己的需要，安装需要的补全插件模块Cfamily：./installer.py --cland-completerjava：./installer.py --java-completer类似，还可以直接安装全部的补全插件./installer.py --all 速度慢的问题go：export GOPROXY=https://goproxy.io设置go的代理设置npm：npm config set registry https://registry.npm.taobao.org设置npm镜像java的补全jdt下载慢：自己手动下载下来对应的版本放在对应的目录下面即可cland下载慢：也可以自己手动下载对应版本 安装完成的配置配置global ycm_extra_conf：let g:ycm_global_ycm_extra_conf=&#39;file_path&#39;开启vim文件甄别：:filetype indent plugin on一般这一步完成之后，应该可以补全了 之后便可以按照自己的需求去进行相关的配置了","tags":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/tags/vim%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/categories/vim%E4%BD%BF%E7%94%A8/"}]},{"title":"trojan代理配置","date":"2021-02-27T12:45:22.953Z","path":"wiki/2021-03-03-trojan代理配置/","text":"准备工作安装配置nginx：sudo pacman -S nginx-mainlinenginx的配置文件在/etc/nginx/nginx.conf配置如下： 1234567891011121314151617181920212223242526user root;worker_processes 1;error_log /var/log/nginx/error.log warn;# pid /var/run/nginx.pid; # 多余pidduplicate的情况，注释掉这一行events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;/$remote_addr - /$remote_user [/$time_local] &quot;/$request&quot; &#x27; &#x27;/$status /$body_bytes_sent &quot;/$http_referer&quot; &#x27; &#x27;&quot;/$http_user_agent&quot; &quot;/$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 120; client_max_body_size 20m; #gzip on; server &#123; listen 80; server_name $your_domain; root /usr/share/nginx/html; index index.php index.html index.htm; &#125;&#125; 设置伪装站点rm -rf /usr/share/nginx/html/* #删除目录原有文件cd /usr/share/nginx/html/ #进入站点更目录wget https://github.com/V2RaySSR/Trojan/raw/master/web.zipunzip web.zipsystemctl restart nginx.service 配置trojan配置文件在：/etc/nginx/xxx.json的形式配置文件示例在/usr/share/trojan/examples/***也是json文件，复制到配置文件目录下，再按自己情况进行相应的修改就好，下面是服务器的配置文件示例： 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; &quot;run_type&quot;: &quot;server&quot;, &quot;local_addr&quot;: &quot;0.0.0.0&quot;, &quot;local_port&quot;: 443, &quot;remote_addr&quot;: &quot;127.0.0.1&quot;, # 伪装用的话，需要指向webserverip和port &quot;remote_port&quot;: 80, &quot;password&quot;: [ &quot;00000000&quot; ], &quot;log_level&quot;: 1, &quot;ssl&quot;: &#123; &quot;cert&quot;: &quot;/usr/src/trojan-cert/fullchain.cer&quot;, &quot;key&quot;: &quot;/usr/src/trojan-cert/private.key&quot;, &quot;key_password&quot;: &quot;&quot;, &quot;cipher_tls13&quot;:&quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;, &quot;prefer_server_cipher&quot;: true, &quot;alpn&quot;: [ &quot;http/1.1&quot; ], &quot;reuse_session&quot;: true, &quot;session_ticket&quot;: false, &quot;session_timeout&quot;: 600, &quot;plain_http_response&quot;: &quot;&quot;, &quot;curves&quot;: &quot;&quot;, &quot;dhparam&quot;: &quot;&quot; &#125;, &quot;tcp&quot;: &#123; &quot;no_delay&quot;: true, &quot;keep_alive&quot;: true, &quot;fast_open&quot;: false, &quot;fast_open_qlen&quot;: 20 &#125;, &quot;mysql&quot;: &#123; &quot;enabled&quot;: false, &quot;server_addr&quot;: &quot;127.0.0.1&quot;, &quot;server_port&quot;: 3306, &quot;database&quot;: &quot;trojan&quot;, &quot;username&quot;: &quot;trojan&quot;, &quot;password&quot;: &quot;&quot; &#125;&#125; 安全证书TSL配置手动的方式在证书配置网站按照指示完成申请之后，就可以下载证书，然后在配置文件中指向证书文件路径即可 下载并解压证书得到两个文件。一个是xxx.xxx.xxx_chain.crt 文件一个是xxx.xxx.xxx_key.key 文件把xxx.xxx.xxx_chain.crt改名为fullchain.cer备用把xxx.xxx.xxx_key.key改名为private.key备用 移动证书文件创建存放证书的文件夹trojan-cert 完整路径为 /usr/src/trojan-cert把刚才改名的2个文件（fullchain.cer和private.key）放到VPS /usr/src/trojan-cert目录下面 然后在配置文件的证书目录指向这两个文件 启动Trojan服务设置启动Trojan服务xxx是配置文件的文件名，按照配置文件开启不同的服务systemctl start &#116;&#114;&#x6f;&#x6a;&#97;&#110;&#64;&#x78;&#120;&#x78;&#46;&#x73;&#x65;&#114;&#x76;&#x69;&#99;&#101; #启动Trojansystemctl enable &#116;&#x72;&#111;&#x6a;&#97;&#x6e;&#x40;&#x78;&#120;&#120;&#x2e;&#x73;&#x65;&#x72;&#118;&#105;&#x63;&#x65; #设置Trojan服务开机自启 验证证书进入网址看是否有小锁 自动的方式下载：sudo pacman -S acme.sh acme.sh --help查看配置文档进行学习配置即可 TCP Fast OpenFor TCP Fast Open on servers to work, you’ll need to turn it on in your OS: echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen DisguiseTrojan servers can be disguised as other services over TLS to prevent active probing. This can be done by, for example, running a web server with nginx and pointing remote_addr and remote_port fields to the server address and port.","tags":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"}]},{"title":"VPN工作原理","date":"2021-02-25T17:01:32.054Z","path":"wiki/2021-03-03-VPN工作原理/","text":"vpn工作原理和搭建方法31条回复 之前为了翻墙，专门写过一篇《关于shadowsocks的一些思考》来说明它的工作原理，借助博客深入原理沉淀下来，对自己对他人都会有很大的帮助。 ss翻墙有一个必要的前提就是客户端本身必须支持socks5协议（比如浏览器一般都支持socks5配置），这样才能将和客户端本地的shadowsocks socks5代理进程互换数据，不过这也造成了很多软件是没法通过ss实现翻墙的，因此，我需要vpn来解决这个问题。 vpn的原理vpn：英文_全称_是“Virtual Private Network”，翻译过来就是“虚拟专用网络”。vpn通常拿来做2个事情，一个是可以让世界上任意2台机器进入一个虚拟的局域网中（当然这个局域网的数据通讯是加密的，很安全，用起来和一个家庭局域网没有区别），一个是可以用来翻墙。 vpn比ss更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发。这和任何一个代理的实现思路都差不多，应用层并不知道网卡是虚拟的，这样vpn虚拟网卡将以中间人的身份对数据进行加工，从而实现各种神奇的效果。具体来说，vpn是通过编写一套网卡驱动并注册到操作系统实现的虚拟网卡，这样数据只要经过网卡收发就可以进行拦截处理。 一句话，vpn在IP层工作，而ss在TCP层工作。 翻墙用途![[Pasted image 20210226010054.png]] 需要在vps上部署vpn server，客户端所有数据将经过虚拟网卡的加密封装后都转发给vps上的vpn server，由它来转发给目标服务器，这和ss server原理类似，由vpn协议加密从而绕过GFW实现访问墙外网站，下面将以pptp vpn协议为例说明。 假设要访问谷歌，那么客户端发出的数据包首先通过协议栈处理封装成IP包，其源地址是虚拟网卡的地址，例如：192.168.0.2，而目标地址是谷歌的IP。 原始IP包交给虚拟网卡发送时，PPTP网卡驱动会按PPP协议对这个IP包整体加密封装作为新的payload，用一层新的IP头封装这个payload发送出去，这个新IP头的目标地址是vpn server，源地址是客户端的外网IP。 vpn server的协议栈会剥离掉新IP头，将内部PPP协议的payload交给pptpd进程处理，pptpd进程会按PPP协议解包得到原始的IP包，我们知道这个IP包的源地址是192.168.0.2，目标地址google。因此，pptpd进程需要做的是将这个IP包的源IP地址改为vps的地址，然后将IP包发给谷歌，从而和谷歌进行数据交换。最终，pptpd理所应当将谷歌的应答IP包的目标IP地址换成192.168.0.2，然后经过PPP协议封装并添加新的IP头后发回给客户端既可。 不过要注意在pptpd的实现里，这个源地址修改是通过iptables实现的，也就是添加通过iptables添加一个NAT规则，实现来源地址的映射转换，这个在你配置pptp的过程中就会看到。 局域网用途![[Pasted image 20210226010117.png]] 大家知道，玩CS的时候都是局域网搜索房间的，要求大家坐在一个网吧里连着一台交换机。如果大家各自坐在家里玩CS想联机，通常要登录一个对战平台，其实对战平台做的事情就是VPN，也就是虚拟一个局域网，大家感受起来就和坐在一起一样。 虚拟网卡的驱动会尽力伪装成一个物理网卡的样子，我们知道DHCP协议是局域网动态分配客户端IP的协议，那么VPN的虚拟网卡其实也会和vpn server进行一些协商得到一个虚拟局域网的IP，比如192.168.0.2。得到虚拟IP后，后续数据将通过虚拟网卡发送至vpn server所在的IP，最终被pptpd进程处理。 既然各个客户端的虚拟网卡都是和同一个pptpd进程交互，那么这个pptpd进程自然知道这个虚拟的局域网内有哪些局域网用户，因此当2个虚拟局域网用户192.168.0.2和192.168.0.3之间想互相通讯的时候，pptpd会完成数据的中转。不过要注意，虚拟局域网用户间的通讯是不需要像访问谷歌那样修改数据包的源IP地址的，这个很容易想明白。 上面只是站在一个小白的角度理解这个过程，真实的pptp协议还用到了GRE协议，但并不是理解的重点。一个真实的pptpd进程包含一个在端口1723上tcp监听的父进程用来与各vpn client协商隧道信息，pptpd后续会给每个client创建一个子进程专门负责client的数据交互，而这个交互的协议就是GRE协议。 GRE直接在IP层之上实现，内核剥离IP透之后会解析GRE协议并根据GRE中的隧道ID将数据包分派给对应的pptpd子进程。子进程则通过raw socket对GRE包进行读写，利用raw socket可以方便的向任何隧道写出数据和读入数据，可以说pptpd的vpn隧道是直接依赖GRE协议的，有了GRE协议可以很方便的实现不同隧道间的数据交互，因为每个隧道的数据在GRE头中都有唯一ID标识（ID是1723端协商而来的），这就是虚拟局域网的大概实现原理。 当然，就像上面的图片描述的那样，VPN也常用于在家连接办公网，这是因为VPN server有另外一张网卡与办公网是局域网的关系，因此可以通过VPN server间接的访问到办公网，此时vpn server的帐号密码鉴权系统就显得尤为重要了。 最后由上可知，pptpd工作起来很像一个路由器，除了能访问谷歌，还能实现虚拟局域网。同时，由于其实现上是一张虚拟网卡，因此对所有应用都可以适用。","tags":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"}]},{"title":"DDNS与端口转发","date":"2021-02-25T16:57:40.681Z","path":"wiki/2021-03-03-DDNS与端口转发/","text":"DDNS与端口转发公网 IP怎样确定自己有没有公网 IP 当然，这里讲到的公网 IP 都是指的动态公网，重新拨号这个 IP 就会变化。 我们可以通过一些 IP 地址查询的网站查询到自己当前的 IP，Alliot 一般使用 IP.SB ，访问这个网站可以得到自己当前在公网的 IP，对比自家光猫或路由器（这取决于你使用哪个拨号）显示的外网 IP 或 WAN 口 IP，如果相同则为已有公网 IP，否则，需要向运营商申请。 怎样申请动态公网 IP 一般来说，即便你是电信或联通的宽带，运营商默认也是不会给你分配动态公网 IP 的，需要向运营商提出申请，根据地区不同，申请难易程度不同。 少数地区可以通过公众号或装维师父直接联系申请，大部分地区需要拨打人工客服（电信 10000，联通 10010）以“家中要安装家庭网络摄像头”为理由申请动态公网 IP（千万不能说是服务器或其他设备），少数地区可能一次无法申请成功（很多客服不清楚动态公网 IP，所以可以尝试多换几个客服），申请成功后重启光猫即可。 光猫改桥接 一般来说，运营商为了减少报障率，默认的宽带拨号都是在光猫里，且锁了光猫超级管理员，防止用户私自更改配置导致宽带故障。为了后面我们的 DDNS 与端口转发，我们最好将宽带拨号的任务交给我们的路由器。这一个步骤也有些麻烦，能不能改桥接得看你的光猫型号或是地区运营商的策略。如果你的光猫型号是较为老的光猫，网上有如何破解超级管理员密码的方案了，那么直接按照教程关闭 DHCP 改为桥接模式即可（记得记录光猫里的宽带账号信息，密码可以通过人工客服重置）。但是如果是较新的光猫，暂时没有破解的方案的，除了换光猫以外，最简单的方法就是直接拨打人工客服（电信 10000，联通 10010）让其将光猫改为桥接模式，这和申请公网 IP 一样，也看地区，看客服，部分地区很爽快直接就给改了，部分地区也需要软磨硬泡。成功改桥接后也需要重启光猫生效。 路由器拨号 Alliot 的路由器是前些日子 80 包邮淘的“友华 WR1200JS”，使用的是 hiboy（H 大）的 padavan 固件，所以以 padavan 为例（其他路由器基本都是打大同小异，甚至更简单）： 在“外部网络(WAN)”中填入家里的宽带拨号账户与密码，应用即可。 端口转发为什么需要端口转发 拥有公网 IP 后，我们还不能够直接访问到我们的群晖服务器，因为拥有公网 IP 的是我们的拨号设备，也就是路由器，路由器会通过 DHCP 分配内网 IP 给我们的设备，这样一来，在公网仅仅只是能够访问到路由器，我们需要在路由器与群晖服务器之间建立一个桥梁，让我们通过公网 IP 就能访问到内网的群晖等服务器，这就有了端口转发，端口转发简单来说就是将一个 IP 的端口与另外一个 IP 的端口对应起来（这个端口可以自定义），建立了从这个端口到那个端口之间的通道。 此外，端口转发也能够将一些常用服务的端口转发到不常用的端口，避免被机器批量扫描，起到一定的安全保护作用。 配置静态 ARP 绑定 静态 ARP 绑定的作用是将内网的机器 MAC 地址与对应的 IP 固定起来，方便我们做端口转发，依旧以 padavan 为例： 在 “内部网络(LAN)” 的 “DHCP服务器” 页，勾选底部如图中的“启动手动设置功能”，选择群晖的 MAC 地址、填入 IP 地址，点击 + 号（很重要），再“应用本页面设置”即可： 配置端口转发 在 “外部网络(WAN)” 的 “端口转发(UPnP)” 页，依图所示开启 UPnP 以及手动端口映射，添加需要映射的端口： 这里的外部端口可以自己定义，内部端口则应该对应群晖对应的服务所用的端口。 下面列举群晖常用的几个端口： 服务名 端口 DSM控制台（HTTP）（不建议转发） 5000 DSM控制台（HTTPS） 5001 Active-Backup 5510 Drive同步端口 6690 WebDAV 5006 ssh/sftp（不建议转发） 22 注： 在我们天朝，Web 等服务是收到严格管控的，因此，Web 服务用到的 80/8080/443 端口以及其他一些端口都是处于封锁状态（当然，部分地区可能没有，但是一旦被扫描到有架设 Web 服务，轻则封端口、收回公网 IP，重则断宽带、有关部门请喝茶），所以不要在公网转发使用这些敏感端口。 DDNS什么是 DDNS 这里首先我们要了解域名与域名解析的概念。什么是域名呢？现在你浏览器的顶栏显示的 www.iots.vip 就是 Alliot’s blog 的域名，通过 ping 域名，会发现返回信息的实际上是个 IP，域名与 IP 的关系，就好比你的姓名与身份证号码（可能用门牌号更贴切）的关系，目的是为了方便记忆（当然还有其他更多的作用，但是在我们这里最大的作用就是方便记忆），你想象一下如果这个世界用的都是身份证号码来叫人，那老师上课点名就会变成 “110101995XXXXXXX1” “到”，非常的不方便。 那什么是 DNS 呢？DNS 即域名系统，还是以姓名、身份证号码为例，DNS 就好比公安局的身份证信息数据库，利用这个数据库你能够通过某人的姓名找到他的身份证号码。 而 DDNS 动态域名解析就像是你的身份证号码变了，你要向公安局的这个数据库更新你的新身份证号码，我们所说的域名解析就是将 IP 提交给域名系统。 前面讲到我们的公网 IP 是动态的，每次重新拨号（运营商也会定期更改）都会变化，我们在外网通过这个 IP 来访问自己内网的服务器的时候，总不能每次都让家里人去路由器确认一下当前的 IP 再手动将 IP 做新的域名解析。 这时候就出现了一种叫 DDNS 的方法，DDNS(Dynamic Domain Name Server) 即动态域名解析服务，就是利用程序获取当前的 IP 并调用域名解析的接口来自动解析新 IP 到域名，有了 DDNS，不管家里的公网 IP 怎么变，我们都能够利用域名来访问到家里的群晖服务器。 域名注册 要做域名解析当然先得有域名，域名注册商很多，这里以阿里云万网为例。 登录 阿里云万网域名注册，挑选一个你所容易记忆的域名，后缀选择一个冷门便宜的即可，最便宜几块钱一年。 获取access key access key 是调用解析 API 的时候需要用到的，打开阿里云控制台的 RAM访问控制，如图处新建一个阿里云子用户，记得勾选编程访问： 创建完子用户后，点击子用户名，创建新的 AccessKey： 之后将得到的 AccessKey ID 与 secret 保存备用。 配置 DDNS DDNS 可以在内网的任意一个设备上做，因为我们的设备都处于同一个拨号环境下，得到的公网 IP 都是一样的。但是出于方便，Alliot 还是推荐在路由器上做 DDNS，因为只有路由器才是真正的 7*24 运行，而且 DDNS 配置完基本就不用动了，省去以后折腾过程中断网的风险，而且，在路由器上做 DDNS，可以实现在外网登录路由器唤醒我们的群晖。当然，部分朋友的路由器没有 DDNS 功能，后面 Docker 篇也会讲到如何使用群晖做 DDNS。 依旧以 H 大的 padavan 为例，在“拓展功能”的“花生壳内网版”的“Aliddns”页，按照指引填写前面获取的 Accesskey ID 与 secret，以及我们想要解析的域名，假设我要解析的是 synology.iots.vip ，则“顶级域名”第一个框填入 synology，第二个框填入 iots.vip： 保存应用配置后，我们还需要手动在阿里云解析 添加解析，DDNS 才能工作： 注： 域名解析设置完成后，由于 DNS 缓存等原因，需要等待5 - 10 分钟去刷新缓存。 然后重启我们的路由器，约两至三分钟后，可以通过 ping 我们的域名来确认域名是否成功解析为我们的公网 IP： \\ 1 2 3 # 按住 win 键 + R 输入 cmd ipconfig /flushdns # 刷新dns解析缓存 ping synology.iots.vip 结语 至此，我们已经了解了怎样配置端口转发，并利用 DDNS 完成了公网 IP 解析的问题，下一篇将介绍针对 DSM 的一些小优化。","tags":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"}]},{"title":"Git常用命令","date":"2021-02-25T16:53:01.238Z","path":"wiki/2021-03-03-Git常用命令/","text":"如果不了解具体命令的使用，可以使用--help选项查看使用帮助 实用命令配置命令：git config 123456git config --list # 列出所有的配置git config --global&#x2F;system&#x2F;local --list # 列出所有的全局&#x2F;系统&#x2F;本地配置git config --global user.name &quot;name&quot; # 添加用户名配置,添加配置就是类似的操作,只是对应的值和键名不同 .gitignore配置文件设置哪些文件不需要推送到服务器 123456# 配置文件示例# 每一行防止需要忽略传送到服务器的文件,支持通配符CNAME*.java 和仓库对接的命令git add file/当前路径添加文件到缓存区，选项有-i（交互式命令子系统） -u（交互式命令系统的update模式） -p（交互式命令子系统的patch模式） 文件的增删改查：在Linux命令的增删改查前面加上git，就可免去git add操作 git commit -m &quot;提交原因&quot;提交添加的文件到版本库中git commint --amend -m &quot;提交原因&quot;提交最新一条记录的更新原因git commit -C HEAD将当前文件改动提交到head或者当前分支的历史id git push rep_name [branch_name] 推送到远程仓库 git clone/fetch remote-rep-addr 获取git服务器的远程仓库到本地 git pull将远程仓库拉回到本地工作区 git checkout恢复正在工作的工作区tree file git status查看文件变动状态选项-s（简短记录查看） --ignored（包括被忽略的文件） git log查看本地的提交记录 git tag为项目标记里程碑 分支命令git branch -a查看本地和远程的分支列表git branch -r查看远程的分支列表，加-d参数可以删除远程版本库的分支 git branch [branch_name]新建分支git branch -m origin_name new_name用于更改分支名字git branch查看当前分支git branch -d [branch_name]删除分支git branch -D分支未提交到本地版本库前强行删除分支git branch -vv查看详细信息 合并分支这个命令是用来合并分支到当前分支默认的分支合并命令执行快进式合并，直接将master分支指向devel分支 git merge --no-ff使用了这个参数之后，在master分支上会生成一个新节点，保证版本演进更加清晰 git merge --no-edit在没有冲突的情况下合并，不想手动编辑提交原因，自动生成提交原因 切换分支 git checkout [branch_name用来切换到分支 git checkout -b [branch_name]创建分支并切换到这个分支 git checkout HEAD demo.html从本地版本库中的HEAD历史找出文件并覆盖当前工作的文件，没有HEAD就从暂存区寻找 git checkout --orphan new_branch创建出一个全新的完全没有历史记录的分支，但当前源分支上的最新文件都在，但是这个分支需要commit之后才正式成为分支 git checkout -p other_branch用来查看两个分支之间的差异 栈命令在git的栈中保存当前修改或者删除的工作进度，当你在一个分支里面做某项功能开发时，接到通知把昨天测试完没问题的代码提交发布到线上，但这时候，你已经在这个分支里面加入了其他未提交 的代码，这个时候，就可以把这些未提交的代码存到栈里面 git stash将未提交的文件提交到栈中git stash list查看栈中保存的内容git stash show stash@&#123;0&#125;显示栈中的一条记录git stash drop stash@&#123;0&#125;移除一条记录git stash pop检出最新的一条记录，并移除git stash apply stash@&#123;0&#125;检出一条记录不删除git stash branch new_branch 当前栈中最新一条记录检出，并创建一个新分支git stash clear清空git stash create创建一个自定义的栈，并且返回一个ID，此时并未真正存储到栈中git stash store ID真正的创建一条记录 操作历史显示历史提交记录 git log -p显示提交历史差异对比的记录git log file查看文件的历史记录git log --since=&quot;2 weeks ago&quot;2周前到现在的历史记录git log --before=&quot;2 weeks ago&quot;截止到2周前的历史记录git log -10查看10条记录git log --pretty=oneline一行中输出简短历史记录git log --pretty=format:&quot;%h&quot;指出自定义格式 重置分支将当前分支重设到指定的commit或者HEAD 撤销撤销某次操作，此次操作前后的记录都会保留，并且把这次撤销作为一次最新的提交 git revert -n HEAD撤销前一次的提交操作，n可以指定多次记录 diff命令查看工作区，暂存区，本地库和远程库之间的文件差异 git diff–stat参数可以用来查看变更统计数据 查看所有记录git reflog查看所有分支的所有操作记录 远程版本库连接如果在创建远程版本库之前，文件已经存在本地文件库中，可以使用git init本地初始化本地版本库，之后再将其与远程版本库连接具体流程： 1234567# 已有本地文件的初始化和远程库连接git inittouch README.mdgit add README.mdgit commit -m &quot;first commit&quot;git remote add rep_name https:&#x2F;&#x2F;gitee.com&#x2F;Jia_bao_Li&#x2F;repository_name.gitgit push -u origin_name master git init在本地目录内部生成.git文件夹git remote -v列出远程分支git remote add origin repo-addr添加一个新的远程仓库，指定名字为origin，以便引用后面的url远程仓库git fetch origin branch_name指定分支名时只取出这个分支的更新到本地，不指定分支，默认拉取所有分支更新到本地版本库 问题排查git blame查看文件每行代码块的历史信息 git bisect二分查找历史记录，排查bug后面加的参数：start开始查找，good没问题的点，bad有问题的点，reset回到原分支 其他操作git submodulegit子模块跟踪外部版本库，允许在一个版本库中存储例外的版本库，并且可以保持两个版本库完全独立，参考Youcompleteme的安装时，他的版本库 git gc 运行git的垃圾回收机制，清理冗余的历史快照 git archive将加了某个tag的某个版本进行打包git archive -v --fromat=zip v0.1 &gt; v0.1.zip","tags":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/tags/git%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/categories/git%E4%BD%BF%E7%94%A8/"}]},{"title":"git原理","date":"2021-02-25T16:00:51.864Z","path":"wiki/2021-03-03-git原理/","text":"几个区域分类 工作区，执行文件添加修改的区域，就是看得到的克隆下来的仓库目录文件，工作区添加到暂存区的命令，git add filename/directory反过来的一个命令：git checkout 暂存区：代码提交的暂时存放区域，暂存区到本地仓库的命令，git commit -m &quot;message&quot;，本地仓库到暂存区的命令git reset 本地仓库：存放需要和远程仓库进行交互的文件的地方，就是文件中的.git文件夹，本地仓库中有stage暂存区，还有git自动创建的第一个分支master，以及只想master的HEAD指针。本地仓库到远程仓库的命令git push origin master，远程仓库到本地仓库的命令git clone/fetch remoterep 远程仓库：存放文件与别人共享的地方，也就是git服务器上对应的仓库，远程仓库到工作区git pull branch分支介绍前面提到的master就是GitHub的主分支，也是git为我们创的第一个分支，其他分支开发完成后都会合并到这个主分支，合并分支到当前分支的命令git merge [branch_name] tag标签介绍标签是用来标记特定的点或提交的历史，通常会用来标记特定的点或者提交的历史，一般用来标记发布版本的名称或者版本号，标签是固定的不能随意改动 HEAD指针指向的是当前分支的最新提交 工作流程 克隆git资源作为本地工作目录 在克隆的资源上添加或者修改文件 如果其他人修改了，你可以更新资源 在提交前查看修改 提交修改 ![[Pasted image 20210223060940.png]]![[Pasted image 20210223062217.png]]![[Pasted image 20210223062505.png]] 本地仓库新建需要执行本地新建的操作的花，需要首先使用ssh key，这个需要你先生成你的sshkey密钥。 ssh-keygen -t rsa -C &quot;注册邮箱&quot;其中-t选项可选的密钥形式有多种，可以在官网查看，执行命令后一路回车即可 复制生成的密钥文件的公钥内容，然后粘贴到官网进行设置 验证是否成功ssh -T git@github.com 12345678mkdir test-repositorycd test-repositorygit inittouch README.mdgit add README.mdgit commit -m &quot;first commit&quot;git remote add rep_name https:&#x2F;&#x2F;gitee.com&#x2F;Jia_bao_Li&#x2F;repository_name.gitgit push -u origin_name master","tags":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/tags/git%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/categories/git%E4%BD%BF%E7%94%A8/"}]},{"title":"Github访问失败","date":"2021-02-25T09:39:22.352Z","path":"wiki/2021-03-03-Github访问失败/","text":"修改hostsping github.comping github.global.ssl.fastly.net 然后将这两个操作得到的IP地址复制到hosts文件中，与之对应映射 Windows的hosts文件在C:\\windows\\system32\\driver\\etc\\hostsLinux和Mac的文件在：/etc/hosts对该文件的修改需要系统管理员权限 1234# 格式： ip地址 域名&#x2F;别名ip地址 github.global.ssl.fastly.netip地址 github.com Windows修改完，之后需要刷新dns缓存信息：使用命令ipconfig/flushdnsLinux刷新：systemctl restart nscd","tags":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/tags/git%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/categories/git%E4%BD%BF%E7%94%A8/"}]},{"title":"内网穿透原理","date":"2021-02-24T16:55:33.119Z","path":"wiki/2021-03-03-内网穿透原理/","text":"需求场景: 基于微信平台开发服务号，本地移动端测试时，需要在微信平台注册测试号，然后填写接口配置信息，此信息需要你有自己的服务器资源，填写的URL需要正确响应微信发送的Token验证。如何能让外网访问到本地服务器呢，就需要用到内网穿透技术（NAT）。 注意：微信平台只支持80端口和443端口 内网穿透的目的：简单来说就是让外网能访问你本地的应用 几个概念： 1.OSI网络七层协议以及每层的作用 ![[Pasted image 20210225005138.png]] 1、物理层：该层包括物理连网媒介，如电缆连线连接器，物理层的协议产生并检测电压以便能够发送和接受携带数据的信号。如中继器、集线器、网线、HUB。 这一层的数据叫做比特。 2、数据链路层：控制网络层和物理层之间的通信，主要功能是如何在不可靠的物理线路上进行数据的可靠传递。如：网卡、网桥、交换机。 这一层是和包结构和字段打交道的和事佬。一方面接收来自网络层（第三层）的数据帧并为物理层封装这些帧；另一方面数据链路层把来自物理层的原始数据比特封装到网络层的帧中。起着重要的中介作用。 3、网络层：主要功能是将网络地址翻译成对应的无聊地址，并决定如何将数据从发送方路由到接收方。 如路由器、防火墙、多层交换机。 网络层确定把数据包传送到其目的地的路径。就是把逻辑网络地址转换为物理地址。如果数据包太大不能通过路径中的一条链路送到目的地，那么网络层的任务就是把这些包分成较小的包。 4、传输层：最重要的层，传输协议同时进行流量控制或者是基于对方可接受数据的快慢程度规定适当的发送速率。包括全双工半双工、流控制、错误恢复服务。同时按照网络能处理的最大尺寸将较长的数据包进行强行分割。进程和端口，TCP UDP协议 5、会话层：负责在网络中的两点之间建立和维护通信。如建立回话、断点续传 在分开的计算机上的两种应用程序之间建立一种虚拟链接，这种虚拟链接称为会话（session）。会话层通过在数据流中设置检查点而保持应用程序之间的同步。允许应用程序进行通信的名称识别和安全性的工作就由会话层完成。 6、表示层：应该程序和网络之间的翻译官，管理数据的加密和解密。如编码方式，图像编解码、交换机 定义由应用程序用来交换数据的格式。在这种意义上，表示层也称为转换器（translator）。该层负责协议转换、数据编码和数据压缩。转发程序在该层进行服务操作。 7、应用层：负责对软件提供接口使能网络服务。如应用程序，如FTP、SMTP、HTTP 2.IP地址 网络中唯一定位一台设备的逻辑地址，类似我们的电话号码。 在互联网中我们访问一个网站或使用一个网络服务最终都需要通过IP定位到每一台主机，如访问baidu网站：其中220.181.112.244就是一个公网的IP地址，他最终指向了一台服务器。 IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。 内网IP可以同时出现在多个不同的局域网络中，如A公司的U1用户获得了192.168.0.5，B公司的U3用户也可以获得192.168.0.5；但公网IP是唯一的，因为我们只有一个Internet。 3.域名 域名是IP的别名，便于记忆，域名最终通过DNS解析成IP地址。nslookup baidu.com可以查看域名 IPv4是一个32位的数字，IPv6有128位，要记住一串毫无意义的数字非常困难，域名解决了这个问题。 DNS查询过程如下，最终将域名变成IP地址 ![[Pasted image 20210225005322.png]] 4.NAT NAT（Network Address Translation）即网络地址转换，NAT能将其本地地址转换成全球IP地址。 内网的一些主机本来已经分配到了本地IP地址（如局域网DHCP分配的IP），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。 通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。 NAT不仅能解决了lP地址不足与共享上网的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 多路由器可完成NAT功能。 NAT的实现方式： 静态转换是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一。 动态转换是指将内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的。 端口多路复用（Port address Translation,PAT)，内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。 应用程序级网关技术（Application Level Gateway）ALG：传统的NAT技术只对IP层和传输层头部进行转换处理，ALG它能对这些应用程序在通信时所包含的地址信息也进行相应的NAT转换 ![[Pasted image 20210225005531.png]]![[Pasted image 20210225005520.png]] 5. Proxy Proxy即代理，被广泛应用于计算机领域，主要分为正向代理与反向代理： 正向代理 比如X花店代A,B,C,D,E五位男生向Candy女生送匿名的生日鲜花，这里的X花店就是5位顾客的代理，花店代理的是客户，隐藏的是客户。这就是我们常说的代理。 正向代理隐藏了真实的请求客户端。服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问http://www.google.com时被墙了，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。 当多个客户端访问服务器时服务器不知道真正访问自己的客户端是那一台。正向代理中,proxy和client同属一个LAN,对server透明;![[Pasted image 20210225005359.png]] 反向代理 拨打10086客服电话，接线员可能有很多个，调度器会智能的分配一个接线员与你通话。这里的调度器就是一个代理，只不过他代理的是接线员，客户端不能确定真正与自己通话的人，隐藏与保护的是目标对象。 反向代理隐藏了真实的服务端，当我们请求 ww.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，ww.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。![[Pasted image 20210225005414.png]] 反向代理中,proxy和server同属一个LAN,对client透明。 6. DDNS DDNS即动态域名解析，是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候，客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务程序负责提供DNS服务并实现动态域名解析。就是说DDNS捕获用户每次变化的IP地址，然后将其与域名相对应，这样域名就可以始终解析到非固定IP的服务器上，互联网用户通过本地的域名服务器获得网站域名的IP地址，从而可以访问网站的服务。 7. 为什么需要内网穿透 当内网中的主机没有静态IP地址要被外网稳定访问时可以使用内网穿透 在互联网中唯一定位一台主机的方法是通过公网的IP地址，但固定IP是一种非常稀缺的资源，不可能给每个公司都分配一个，且许多中小公司不愿意为高昂的费用买单，多数公司直接或间接的拨号上网，电信部门会给接入网络的用户分配IP地址，以前上网用户少的时候基本分配的都是临时的静态IP地址，租约过了之后可能会更换成另一个IP地址，这样外网访问就不稳定，因为内网的静态IP地址一直变化，为了解决这个问题可以使用动态域名解析的办法变换域名指向的静态IP地址。但是现在越来越多的上网用户使得临时分配的静态IP地址也不够用了，电信部门开始分配一些虚拟的静态IP地址，这些IP是公网不能直接访问的，如以125开头的一些IP地址，以前单纯的动态域名解析就不好用了。 8. 内网穿透的定义与障碍 简单来说实现不同局域网内的主机之间通过互联网进行通信的技术叫内网穿透。 障碍一：位于局域网内的主机有两套 IP 地址，一套是局域网内的 IP 地址，通常是动态分配的，仅供局域网内的主机间通信使用；一套是经过网关转换后的外网 IP 地址，用于与外网程序进行通信。![[Pasted image 20210225005444.png]] 障碍二：位于不同局域网内的两台主机，即使是知道了对方的 IP 地址和端口号，“一厢情愿”地将数据包发送过去，对方也是接收不到的。 因为出于安全起见，除非是主机主动向对方发出了连接请求（这时会在该主机的数据结构中留下一条记录），否则，当主机接收到数据包时，如果在其数据结构中查询不到对应的记录，那些不请自来的数据包将会被丢弃。![[Pasted image 20210225005456.png]] 解决办法：要想解决以上两大障碍，我们需要借助一台具有公网 IP 的服务器进行桥接。","tags":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"}]},{"title":"内网穿透","date":"2021-02-24T16:49:41.335Z","path":"wiki/2021-03-03-内网穿透/","text":"ngrok是一个可以用来免费内网IP转换为可供外网访问的一种方法，这个可以利用CNAME的域名映射到作者的服务器上，从未再创建一个隧道提供一个方便的途径给我们用与创建本地简易不稳定的服务器 该软件服务器的作者创作不易，有条件的小伙伴，可以购买便宜一点的10元服务器，支持一下作者，也方便我们自己 除了ngrok，还有需收费的花生壳，这个是内网穿透做的比较好的 内网穿透的原理内网穿透是我们在进行网络连接时的一种术语，也叫做NAT穿透，即在计算机是局域网内的时候，外网与内网的计算机的节点进行连接时所需要的连接通信，有时候就会出现内网穿透不支的情况。内网穿透的功能就是，当我们在端口映射时设置时，内网穿透起到了地址转换的功能，也就是把公网的地址进行翻译，转成为一种私有的地址，然后再采用路由的方式ADSL的宽带路由器，具有一个动态或者是固定的公网IP，最后ADSL直接在交换机上，这样所有的电脑都可以共享上网。内网穿透除了可以实现内网之间机器的网络通信功通之外，还可以解决UDP中出现的数据传输不稳定问题。 内网IP解析成外网可访问的域名首先进入ngrok.cc官网进行注册，显示会员注册，其实只要你注册了就是会员，里面会有一个免费的服务器使用，当然，如果有条件的话，可以购买一个服务器，便宜的也只要10块钱，真的是十分的良心的了。 注册好了之后请一定先看教程，作者也在里面是强烈建议看完教程之后再去进行操作 教程网址 看完教程学会了之后就可以进行客户端下载 大致的流程 1. 注册 2. 观看教程 3. 开通隧道 进入到隧道设置界面，选择http或者https，然后设置前置域名（如bao之类的，不需要.号）之后端口就设置你自己的内网ip和端口 4. 自定义域名需在隧洞建立好后，去到编辑页面进行设置，这个自定义域名需是你自己注册好的域名，如果想要使用https，你还需要为你的域名配置证书，详情看下方的ssl证书配置 5. 如果你的网站需要授权访问的话，就可以设置验证用户名和密码，保存修改 6. 然后进入到你的域名管理网站，进行域名记录的配置，添加一条记录CNAME的配置，将其记录指向服务器：`free.idcfengye.com`，保存记录修改即可。 7. 进入到隧道列表，找到隧洞id，然后复制下来，之后在客户端的配置使用这个id来启动隧洞。详细的启动流程依照教程的来使用就可以了 详细的免费证书配置流程看：-&gt;[[ssl证书]] 教程内容ngrock启动mac、linux启动下载对应的客户端，修改该脚本的的权限，给该脚本加上可执行权限 使用方法./script_name clientid 隧道id多个隧道id启动./script_name clientid 隧道id1,隧道id2 后台运行可以使用：setsid ./script_name clientid 隧道id &amp; windows启动和linux类似，也是在命令行中运行sunny.exe clientid 隧道id 还有一个bat脚本文件，只要运行之后把隧道id输入即可 python版本下载好了python脚本之后，直接执行脚本python script --client=隧道id,隧道id php版本和python脚本类似 安卓端也有ngrokc客户端可以在路由器中使用，教程 Frp启动和ngrokc是一样的，只是少了python php脚本和安卓端 ngrokc常见错误错误1: Tunnel ** not found隧道没有启动的时候会提示：Tunnel sphynx.free.idcfengye.com not found 这时候应该检查隧道是否已经启动，如果没有启动则启动。 错误2: 隧道 ** 不可用如果隧道启动了，而web服务没有启动会提示 这个并不是错误，而是要映射的服务不没有启动，不是服务器出问题了，也不是隧道出问题了。 错误3: bind: address already in use服务器无法分配隧道: [ctl:d66a0e1] [54710df44b9784aa60692e8b8e7bda79] 绑定TCP监听器错误: listen tcp **: bind: address already in use 这个错误是因为TCP隧道已经启动了，所以会出现这个错误。 错误4：服务器无法分配隧道: ** 已注册.服务器无法分配隧道: 隧道 http://sphynx.free.idcfengye.com 已注册. 这个错误是因为HTTP隧道已经启动了，所以会出现这个错误。 解决办法 1、登陆管理平台到隧道管理 2、点击查看状态，检查隧道是否在线 3、如果在线点击踢下线 错误5: reconnecting出现这个错误要检查两个问题 这个问题一般都是香港的问题比较多，因为香港由于国策原因有可能被墙也会抽风。因此如果有在tcp和udp的用户尽可能的选择内地的服务器。出现这个问题的时候先选择ping一下服务器看看能否通 检查隧道是否已经启动，http的隧道可以通过浏览器访问如果没有启动的隧道提示是 not found 如果已经启动那么浏览器会一直转圈。对于tcp隧道可以采用telnet的方式连接查看隧道是否启动，按照错误4的解决办法操作 解决问题步骤： 1、ping 隧道服务器（隧道管理单机隧道ID可以展开查看服务器地址），检查是否可以ping通 2、通过 http://ping.chinaz.com/服务器地址 ping 隧道服务器地址（隧道管理单机隧道ID可以展开查看服务器地址） 查看得出来的ip是否和自己电脑ping的ip一致，检查dns是否污染 3、检查隧道是否启动，可以在隧道管理平台隧道管理检查 4、telnet 隧道服务器的 4443端口 FRP常见错误错误1: start error: listen tcp **: bind: address already in use这个错误是因为TCP隧道已经启动了，所以会出现这个错误 部署https协议隧道方法一：本地部署HTTPS环境如果在本地部署环境，我们以Nginx为例。 步骤： 1、先去下载证书 2、部署证书到nginx服务器上 3、修改平台隧道协议 4、启动隧道 1、先去下载证书登陆申请证书的页面，这里以阿里云为例 我使用的上nginx服务器，所以我下载nginx的 2、部署证书到nginx服务器上1234567891011121314151617server &#123; listen 443 ssl; server_name test.sunnyos.com; ssl_certificate &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;ssl&#x2F;test.sunnyos.com.pem; ssl_certificate_key &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;ssl&#x2F;test.sunnyos.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; location &#x2F; &#123; root html; index index.html index.htm; &#125;&#125; 证书配置文件参考阿里云的配置，每家服务商的不一定一样，具体参考ssl证书服务商的教程。 3、修改平台隧道协议 因为我的nginx在虚拟机里面，隧道在物理机里面启动的，所以修改内网地址和端口为虚拟机的实际地址和端口。 4、启动隧道 启动隧道，访问隧道。 浏览器访问隧道可以看到证书了。 方法二：CDN服务商和HTTPS证书在同一个服务商部署如果使用阿里云的CDN并且在阿里云申请的https证书，直接在证书页面部署 步骤： 1、进入https证书页面找到对应的证书-&gt;点击部署-&gt;点击CDN 2、在弹出来的页面选择在CDN里面要部署的域名 3、设置CDN回源协议 4、查看是否部署成功 5、启动隧道 1、进入https证书页面找到对应的证书-&gt;点击部署-&gt;点击CDN 2、在弹出来的页面选择在CDN里面要部署的域名 3、设置CDN回源协议 因为在CDN部署的https所以在 Sunny-Ngrok 平台不需要使用 https 协议，因此在cdn这里的回源协议要使用http。 4、查看是否部署成功 到这里看到我们刚刚部署的证书就是成功了。 5、启动隧道 启动隧道注意这里协议还是http，所以一定要在cdn回源设置http协议回源。 方法三：CDN和HTTPS证书分别在不同服务商部署例如我们使用阿里云的CDN但是证书是在别的地方申请的，例如我在腾讯申请的证书。 步骤： 1、进入腾讯云下载证书 2、进入阿里云的CDN配置页面上传证书 3、启动隧道 1、进入腾讯云下载证书 2、进入阿里云的CDN配置页面上传证书 把下载的证书上传到阿里云到CDN里面 3、启动隧道","tags":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"}]},{"title":"内网和外网","date":"2021-02-24T15:14:46.172Z","path":"wiki/2021-03-03-内网和外网/","text":"内外网区别原文：[https://blog.csdn.net/Alexwym/article/details/81772446](https://blog.csdn.net/Alexwym/article/details/81772446) 我们每天都会访问各种各样的网站，比如淘宝，百度等等。不免会思考，我们的设备是如何连接上这些网址的呢？要想搞清楚这个问题，首先就得先搞清楚内网ip和外网ip的联系。 ![[Pasted image 20210224223019.png]] 如图，假设我们的计算机现在就是设备一，我们想要访问百度。如果我们正使用着校园网，那么首先我们需要先通过校园网的路由器把我们的内网ip转为校园网的外网ip。然后通过这个外网ip先连接上湖南电信的网关，最后在连接上百度的网关。百度把你请求的信息回传到你的校园网网关，校园网网关再把信息传给你（整个网络呈网状结构，它会自动找到一条通往百度的路径——基于深度优先搜索或者广度优先搜索）。 这个过程就跟网购差不多。比如你现在在学校里订购了一本书，淘宝那边接收到你的订单准备好物品就开始给你发货了。他发现你的收货地址在湖南，于是它可能从杭州出发，先去了福建的中转站，然后再到江西的中转站，突然发现江西到湖南的中转站不通，于是它只能再绕到广东的中转站，最后再到湖南中转站。这些中转站就相当于公网上的各个网关。到了湖南中转站，快递小哥再把包裹送到你的校门（这就是最后一级网关）。这时快递小哥就走了，校门处的管理人员在根据的你的宿舍信息把包裹拿给你。（局域网内部的信息交流由校园网这个网关来处理） 注意点1. 公网ip具有世界范围的唯一性，而内网ip只在局域网内部具有唯一性。并且，一个局域网里所有电脑的内网IP是互不相同的,但共用一个外网IP。就像我们前面所说的你所在学校的校名在整个世界上只有一个，但是你学校里面的A栋大楼3层3号教室只有在你的校园内部才具有唯一性。别的学校也有A栋大楼3层3号教室。你只能跟快递小哥说请帮我把包裹送到xx大学，而不能说请帮我把包裹送到A栋大楼3层3号教室。 2. 在局域网中，每台电脑都可以自己分配自己的IP，但是这个IP只在局域网中有效。而如果你将电脑连接到互联网，你的网络提供商的服务器会为你分配一个IP地址，这个IP地址才是你在外网的IP。两个IP同时存在，一个对内，一个对外。 3. 互联网上的IP（即外网IP）地址统一由一个叫“IANA”(InternetAssigned NumbersAuthority，互联网网络号分配机构)的组织来管理。由于分配不合理以及IPv4协议本身存在的局限，现在互联网的IP地址资源越来越紧张。IANA将A、B、C类IP地址的一部分保留下来，留作局域网使用。具体如下 IP地址空间： - a类网 10.0.0.0~10.255.255.255 - b类网 172.16.0.0~172.31.255.255 - c类网 192.168.0.0~192.168.255.255 也就是说，如果你查到的ip地址在以上A、B、C类IP地址的范围内，它一定就是局域网的ip地址，否则就是公网的地址。 4.实际生活中不仅有一级NET技术，还有二级NET技术。也就是可能你的校园网关也只是个局域网。通过多级转换可以得到更多的地址。 ==内网IP局域网，网线都是连接在同一个交换机上面的== 也就是说它们的IP地址是由交换机或者路由器进行分配的。而且每一个IP也是有所不同的，并且这些连接在同一个路由器上的电脑都可以通过internet连接共享的，也就是说网吧里面的电脑是可以访问网吧内另外一部电脑的。 ==外网IP是全世界唯一的IP地址，仅分配给一个网络设备。== 而内网IP是由路由器分配给每一部内部使用的IP地址，而内网的所有用户都是通过同一个外网IP地址进行上网的。 区别是内网的IP地址每个人的都不一样，Internet上的用户也无法直接访问到内网用户。简单来说呢，外网IP就是标示了您在整个互联网上的地址，就相当于小区的地址，而内网IP呢，就是标识着您在局域网里面的地址，也就是小区内的几栋几楼几号房子。 ![[Pasted image 20210224231333.png]] 在局域网中，每台电脑都可以自己分配自己的IP，这个IP只在局域网中有效。而如果你将电脑连接到互联网，你的网络提供商（ISP）的服务器会为你分配一个IP地址，这个IP地址才是你在外网的IP。两个IP同时存在，一个对内，一个对外。 IP分类- A类：1.0.0.0-127.255.255.255 - B类：128.0.0.0-191.255.255.255 - C类：192.0.0.0-223.255.255.255 - D类和E类被保留，不能使用。 - D 类地址用于在IP网络中的 组播( multicasting ，又称为 多目广播)。D类地址的前4位恒为1110 ，预置前3位为1意味着D类地址开始于128+64+32等于224。第4位为0意味着D类地址的最大值为128+64+32+8+4+2+1为239，因此D类 地址空间的范围从224.0.0.0到239. 255. 255.254。 - E 类地址保留作研究之用。因此Internet上没有可用的E类地址。E类地址的前4位恒为1，因此有效的地址范围从240.0.0.0 至255.255.255.255。 IP地址分类由第一个八位组的值来确定。任何一个0到127 间的 网络地址均是一个A类地址。任何一个128到191间的 网络地址是一个B类地址。任何一个192到223 间的 网络地址是一个C类地址。任何一个第一个八位组在224到239 间的网络地址是一个 组播地址即D类地址，E类保留。 内外网IP定义内网IP地址就是私有IP地址，不允许在公网上面传递，只能供内部使用。内网使用了私有地址无法访问internet 会用到NAT-地址转换技术，将内部的私有地址转换为可以访问internet的外网地址让内部可以上网。外网IP地址就是除了私有地址和被保留的地址外的所有地址，需要申请才能使用。 ABC三类地址中划分出了三类私有地址： - A类10.0.0.0～10.255.255.255 - B类172.16.0.0～172.31.255.255 - C类192.168.0.0～192.168.255.255 内网概念 即所说的局域网，比如学校的局域网，局域网内每台计算机的IP地址在本局域网内具有互异性，是不可重复的。但两个局域网内的内网IP可以有相同的。 外网概念 即互联网，局域网通过一台服务器或是一个路由器对外连接的网络，这个IP地址是惟一的。也就是说内网里所有的计算机都是连接到这一个外网IP上，通过这一个外网IP对外进行交换数据的。也就是说，一个局域网里所有电脑的内网IP是互不相同的,但共用一个外网IP。（用ipconfig/all查到的IP是你本机的内网IP；在网页上看到的是你连接互联网所使用的IP，即外网） 内外网联系及区别在局域网中，每台电脑都可以自己分配自己的IP，这个IP只在局域网中有效。而如果你将电脑连接到互联网，你的网络提供商（ISP）的服务器会为你分配一个IP地址，这个IP地址才是你在外网的IP。两个IP同时存在，一个对内，一个对外。 当你家里买了两台电脑，你想组建一个局域网，你除了要用网线和路由器等设备将两台电脑相连，你还要将两台电脑设置固定IP，比如电脑A设为192.168.1.2，电脑B设为192.168.1.3，这样你就可以用这两个IP地址互相访问两台电脑，但这两个IP地址只在这两台电脑间有效，对外网无效。所以局域网中分配的IP与广域网中的IP完全没有对应关系。 你在内网的机子在上网时，都是在向网关发出请求，再由网关（一般为路由器）用外网IP转到INT网上，接受数据后，再分发到你的内网IP上。 文章三：关于内网和外网 简单的说，自己的单位或者家庭、小区内部有局域网；单位、家庭之外有覆盖范围极大的网络，比如internet，这个大网络延伸到了我们的单位、家庭（通过光纤、网线、电话线等）。我们把自己的局域网连接到internet上，那么我们的访问范围就从局域网扩展到了整个internet。这时候，就说局域网是内网，internet是外网。 同理，如果你们单位的局域网很庞大，而你的办公室里面的几台电脑组成的小局域网又连接到单位的整个大局域网，那么也可以说单位的大局域网是外网，办公室内的小局域网是内网。同时，如果单位的大局域网连接了Internet，那么相对于Internet，也可以说单位的大局域网是内网。 内网可能是一个独立的局域网，通过其中的网关（网关就是连接两个网络的节点，说白了，就是有双重身份的电脑，既有局域网的IP地址，又有Internet的IP地址，两个IP地址分别捆绑在不同的网卡上）的代理访问外部网络，比如网吧都是这样实现的，其特征是：网吧内的电脑的ip都是局域网专用ip，比如192.168.xxx.xxx或者10.xxx.xxx.xxx，而这种ip在internet上面是不会出现的。 （注：所谓代理，就是你提要求，他来办事，类似于代购火车票。局域网的电脑想和外面联络，就把对方地址告诉服务器，也就是网关，网关以自己的身份和对方联络，同时把对方发回来的消息转送给局域网内的电脑。因此，对方看不见局域网内电脑的IP，只会以为是网关那台电脑在与自己交流。网吧内的所有QQ都显示同样的IP，现在你能理解为什么了吗？） 内网也可能是外网的一个部分，比如校园网，或者相对于单位局域网的办公室内部局域网。其特征是：内网电脑的ip就是整个外网ip范围的一部分，内网的电脑通过网关（路由器）连接到外网，网关不需要进行代理服务，直接路由就行了。 （注：所谓路由，就是路径选择。路由器连接多个网络，因此一定是各个网络的网关，其作用类似于邮局。你想联系局域网外的电脑，就把邮包发送给路由器，路由器会帮你投递到邮包上标明的地址。这样，收到邮包的人可以知道是谁把邮包发过来的，但是，他无法知道发邮包的人是不是帮别人代理发邮包的。或者说，收到数据的电脑可以知道是哪台电脑在与它联络，但它无法知道与它联络的这台电脑是否是某个局域网的代理服务器。） adsl比较特殊，它有两种工作方式。第一种，adsl的modem打开代理功能，这时候，modem实际上就可以看作一台电脑，它是internet（外网）的一个节点，同时，它与你的电脑连接成为局域网，也就是内网，内网网关就是modem。第二种，通过电脑进行拨号上网，这种情况下，modem就是电脑的一个外部设备，而你的电脑通过电话线直接连接在internet上，不存在其它网络，因此也就无所谓内网外网。 广域网和局域网什么是广域网（WAN、公网、外网），什么是局域网（LAN、私网、内网）？ 广域网（WAN），就是我们通常所说的Internet，它是一个遍及全世界的网络。 局域网（LAN），相对于广域网（WAN）而言，主要是指在小范围内的计算机互联网络。这个“小范围”可以是一个家庭，一所学校，一家公司，或者是一个政府部门。 BT中常常提到的公网、外网，即广域网（WAN）；BT中常常提到私网、内网，即局域网（LAN）。 广域网上的每一台电脑（或其他网络设备）都有一个或多个广域网IP地址（或者说公网、外网IP地址），广域网IP地址一般要到ISP处交费之后才能申请到，广域网IP地址不能重复；局域网（LAN）上的每一台电脑（或其他网络设备）都有一个或多个局域网IP地址（或者说私网、内网IP地址），局域网IP地址是局域网内部分配的，不同局域网的IP地址可以重复，不会相互影响。 广域网（WAN、公网、外网）与局域网（LAN、私网、内网）电脑交换数据要通过路由器或网关的NAT（网络地址转换）进行。一般说来，局域网（LAN、私网、内网）内电脑发起的对外连接请求，路由器或网关都不会加以阻拦，但来自广域网对局域网内电脑电脑连接的请求，路由器或网关在绝大多数情况下都会进行拦截。 通常情况下，网关或路由器对内部向外发出的信息不会进行拦截，但对来自外部想进入内部网络的信息则会进行识别、筛选，认为是安全的、有效的，才会转发给内网电脑。正是这种情况的存在，才导致了很多内网用户没有“远程”，速度也不尽如人意。","tags":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"}]},{"title":"域名和ip","date":"2021-02-24T15:11:48.516Z","path":"wiki/2021-03-03-域名和ip/","text":"[[免费域名申请]]IP公网ip==公网ip具有世界范围的唯一性== 这个ip地址才是可以绑定域名的，而且现在绑定域名制作网站是需要备案的 内网ip==内网ip只在局域网内部具有唯一性== 这种ip需要借助花生壳这样的工作来绑定域名 内网ip只能是同一局域网下的用户相互连通 如果想要不在同一局域网的用户连接到你，你需要的是一个外网ip 还有一种方式就是使用自己的路由器设置虚拟服务器来是得外网可以访问，原理就是设置好这个服务器之后获得了一个外网ip，然后再利用这个外网ip来访问本地电脑 云服务器购买也就是购买一个拥有公网IP的服务器","tags":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"}]},{"title":"免费域名申请","date":"2021-02-24T08:17:13.760Z","path":"wiki/2021-03-03-免费域名申请/","text":"永久免费域名申请freenom.com是一个提供免费域名申请的网 注意： 1、打不开网站或者打开慢的请使用那个啥。 2、长期闲置没有使用的域名会被回收，访问量太大的域名也会被回收（至于多大我也不知道），博主的freefrp.tk和freefrp.ml就被suspend了。 3、最长可以选择免费一年，到期前2个星期会提醒是否续费，到时直接可以免费续费再用一年，相当于永久免费。 一、申请域名 1、进入网站，查询自己想要的域名是否可用。 可以看到有tk、ml、ga、cf、gq等域名后缀可选，都是免费的 freenom申请永久免费域名 freenom申请永久免费域名 2、选择域名 点击现在获取–完成 freenom申请永久免费域名 3、修改域名时间 默认是3个月，最长可以修改到12个月都是免费的，修改完以后点击“继续” freenom申请永久免费域名 4、结账确认（注册账号） 可以看到是免费的，如果有账号了直接登录就行。如果没有注册，输入邮箱验证点击验证（有时会报错，刷新一下吧） 这时候会跳出谷歌验证码 （其实博主已经有账号了，哦豁！）。 freenom申请永久免费域名 5、验证邮箱 这时候会向邮箱发送验证链接，点击验证即可。 freenom申请永久免费域名 6、输入注册信息 点击验证邮箱链接后会跳转，让填一些信息，参考例子填即可 然后点击完成订单 7、完成进入管理域名 二、修改nameserver解析 freenom上面的解析不太好用，这里修改为dnspod的解析（首先注册dnspod账号，不再赘述。） 1、登录dnspod，添加刚刚注册的域名 2、点击域名进入管理详情 会自动扫描DNS记录，不用管 3、记下nameserver下一步有用。 4、在freenom点击管理域名进入修改nameserver 5、添加在dnspod记下的nameserver 6、完成然后等待NS生效，添加解析 生效后就可以在dnspod添加解析了（最慢48小时，一般几分钟就好了），然后freenom上的域名就不用管了，到期前去免费续期即可，其他的都在dnspod管理。 免费花生壳域名：37746zt717.qicp.vip 域名的管理使用腾讯云的dnspod进行域名的管理，域名记录的添加管理 域名访问指向哪个服务器或者ip地址就可以在这个控制台新建管理 域名记录新建之后需要一定的生效时间","tags":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"}]},{"title":"ssl证书","date":"2021-02-24T04:59:13.368Z","path":"wiki/2021-03-03-ssl证书/","text":"证书密钥：4C28-93A4-F84D-4E67 9E38-31B2-1D51-E870 F711-83A7-FF2C-C528 5227-C342-77A2-70E1 免费证书申请 首先注册账号，然后登陆 输入域名进行申请 证书生成设置 选择验证方式 选择证书类型 选择申请方式：一般选择离线生成，这个时候需要keymanager软件，这时候需要下载，然后按照提示操作即可，当然如果自己有csr的也可以选择我有csr进行申请。选择浏览器生成的话不用下载软件，其他操作和离线生成一样 域名记录配置：按照提供的记录和记录值将其配置到域名记录里面。再进行验证可以在dnspod中进行域名记录的添加，按照要求选取txt记录然后把浏览器中提供的记录值添加进去就可以了 配置好之后就成功生成了证书，然后就可以利用https访问你的域名了 如果需要配置到服务器，就需要下载证书，导出需要配置的服务器证书就可以了，然后放在服务器的指定目录并在服务器设置中添加证书路径","tags":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"}]},{"title":"系统vim插件安装","date":"2021-02-23T00:50:05.793Z","path":"wiki/2021-03-03-系统vim插件安装/","text":"全局加载插件/usr/share/vim/vim82/autoload/将你需要全局加载的插件文件夹下的autoload文件夹下的vim文件放到上面目录中 配置当配置文件内容较多，可以将其分解成多个文件，然后在配置文件中source这些文件即可source /home/jiabao/.config/vim/*.vim","tags":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/tags/vim%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/categories/vim%E4%BD%BF%E7%94%A8/"}]},{"title":"git配置","date":"2021-02-22T23:20:12.326Z","path":"wiki/2021-03-03-git配置/","text":"配置命令git config --system/global/local user.name &quot;name&quot;类似的添加配置方法git config -l/--list列出所有配置，–system/global/local，分别列出系统全局和本地配置配置文件：/etc/gitconfig，~/.gitconfig 一些常用配置git config --global user.name &quot;li-jiabao&quot;git config --global user.email &quot;905001136@qq.com&quot; git config \\--global core.editor &quot;vim&quot;修改编辑器修改了配置器之后就可以在git 提交时，就可以不用git commit -m 而是git commit","tags":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/tags/git%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/categories/git%E4%BD%BF%E7%94%A8/"}]},{"title":"服务器搭建","date":"2021-02-22T23:11:26.053Z","path":"wiki/2021-03-03-服务器搭建/","text":"安装gitsudo pacman -S base-devel openssh git 创建git用户组和用户用来运行git服务器groupadd git useradd -m git -G git 创建证书登陆收集所有需要登陆的用户的公钥，公钥位于id_rsa.pub文件夹中把公钥导入到/home/git/.ssh/authorized_keys文件夹中 12345cd &#x2F;home&#x2F;gitmkdir .sshchmod 755 .sshtouch .ssh&#x2F;sutorized_keyschmod 644 .ssh&#x2F;authorized_keys 初始化git仓库选定一个目录为git仓库，执行下述步骤即可 123456mkdir &#x2F;home&#x2F;repchown git:git rep&#x2F;cd repgit init --bare my-gitrep.gitchown -R git:git my--gitrep.git把仓库所属用户改为git 克隆仓库server-ip是指服务的ipgit clone git@server-ip:/home/rep/my-gitrep.git","tags":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/tags/git%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/categories/git%E4%BD%BF%E7%94%A8/"}]},{"title":"查看提交历史","date":"2021-02-22T22:37:59.379Z","path":"wiki/2021-03-03-查看提交历史/","text":"主要有两个命令 git log查看历史提交记录，这个命令有许多的参数可以使用，可以使用帮助文档查看git blame &lt;file&gt;查看指定文件的历史修改记录","tags":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/tags/git%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/categories/git%E4%BD%BF%E7%94%A8/"}]},{"title":"重置登陆信息","date":"2021-02-22T18:34:26.179Z","path":"wiki/2021-03-03-重置登陆信息/","text":"git config --system --unset credential.helper","tags":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/tags/git%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/categories/git%E4%BD%BF%E7%94%A8/"}]},{"title":"Exception Advantages","date":"2021-02-21T09:20:13.600Z","path":"wiki/2021-03-03-Exception Advantages/","text":"异常的优点Advantage 1：将异常处理代码和正常的代码分离开来如果没有该异常处理机制，可能需要在每个位置进行判断detection从而确定是否可以往下继续进行，但是异常处理机制的出现，使得可以将一连串操作放在try代码块中，从而根据可能出现的异常利用不同的catch代码块去进行分别的处理，这样就让代码逻辑性更好，可读性更好，同时也使得程序更加的robust Advanage 2：将异常错误推送到stack trace传统的异常会让整个调用链的函数都要去推送异常知道最后异常到达处理的位置。而JVM运行环境会往后搜索调用堆栈去找寻处理特定异常。方法可以将异常推送到调用堆栈中，因此就可以让其他方法进入到调用堆栈去捕捉它，只有要处理异常的方法才关心探测异常。但是推送异常到堆栈需要middleman method的参与帮助，因此任何可以在方法中被抛出的异常必须指定在throws语句中 Advantage 3：将错误类型分组并区分错误类型 异常就是对象，因此，异常的分组分类本质上就是区分异常类的等级制度。例子：java.io.IOException，这是在处理IO操作时发生的最一般的异常，而它的子类则代表了更加明确的异常FileNotFoundException。异常处理器可以选择写更加明确的异常，也可以写更宽泛的异常。异常的等级制度的最接近顶端就是Exception最高的是==Throwable==。exception.printStackTrace(); // output goes to System.errexception.printStackTrace(System.out; // sent trace to stdout可以选择指定更加详细的异常处理器，这样，代码的robust和处理异常的能力更强。当然如果不用捕获明确的异常，可以使用更为宽泛的异常类Exception之类。","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"异常使用技巧","date":"2021-02-21T09:19:07.783Z","path":"wiki/2021-03-03-异常使用技巧/","text":"使用技巧 只在异常情况下使用异常，异常处理不能代替简单的测试 不要过于细化异常 如果你将代码过于细化，会导致代码量的急剧增加，而且代码的逻辑可能也会不清晰 需要异常处理的代码可以放在一个try代码块中 对于需要捕获的异常创建对应的异常处理 充分利用异常层次结构 不要只抛出RuntimeException,寻找适合的子类创建合适的异常类 不要只捕获THrowable异常，否则使代码难读难懂 考虑检查性异常和非检查型异常的区别，不要为逻辑错误抛出检查型异常 不要压制异常有些时候异常的出现远比你压制异常的出现要更好，比如在寻找错误的时候，比如在你debug的时候 早抛出对于出错的地方，早点抛出会更好，会比以后抛出NullPointException更好 晚捕获不一定非要捕获异常，有时候将异常传递可能会更好","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"catch and handle exception","date":"2021-02-21T07:54:32.836Z","path":"wiki/2021-03-03-catch and handle exception/","text":"对于异常处理的最佳方案对于抛出检查型异常的方法，必须对这个异常进行处理或者是继续传递这个异常（也就是继续抛出，不处理）哪种方法更好呢？ 对于知道如何去处理的异常，就进行捕获 对于不清楚如何处理的，传递这个异常不处理（方法定义时加入throws语句抛出） 捕获异常有三种主要的异常处理组件和一个stream有关的异常捕获语句：try语句应该包含至少一个catch或者finally语句，可以拥有多个catch语句。try-catch-finall这三个来组成的 1234try&#123; code; // 合法的语句，需要含有可抛出异常的语句&#125;catch and finally blocks... 12345678try&#123; code; // 和第一种一样&#125;catch (ExceptionType name) &#123; handler block; // 此处放置捕获相应的异常之后的处理语句&#125; catch (ExceptionType1| ExceptionType2 name)&#123; handler block;&#125; 1234567try&#123; code;&#125;catch (ExceptionType name) &#123; handler block;&#125;finally&#123;&#125; 特殊的主要用于资源处理的异常语句，implements Closeable的类就可以被用做资源。（和python中的上下文语句，with一样，语句执行结束后自动关闭资源对象） 1234try (在这里声明需要关闭放置资源丢失的一些操作（如文件读取器和写入器这一类）)&#123; &#125;// 其他的和正常的异常捕获一致，可以有catch和finally语句 捕获多个异常123456789101112131415161718public void exceptionTest()&#123; try&#123; code block &#125; catch (Exception e)&#123; exceptionhandler &#125; catxh (IOException e)&#123; exception handler &#125; ... catch (EOFException | FileNotFoundException e)&#123; // 也可以是这样的对于多个异常采用相同的处理代码块 &#125; finally&#123; &#125;&#125; 再次抛出异常与异常链123456789101112131415161718192021222324try&#123; code block&#125;catch (Exception e)&#123; if ()&#123; throw new newExeption(); &#125; // 抛出新的异常&#125;catch (Exception original)&#123; if ()&#123; var e = new newException(); e.initCause(original); throw e; // 也可以是这样的异常链的抛出，把原始的异常设置为新异常的起因 // THrowable cause = causeException.getCause(); // 这一句使用来查询捕获异常的起因 &#125;&#125;catch (Exception e)&#123; logger.log(level, message, e); throw e; // 这是一种只用来记录异常而不处理的用法&#125; 当代码抛出异常时，其代码块后面的语句就会停止运行，并退出当前的这个方法但有些时候，对于资源的处理是需要清理的，不然会出现问题，因此，就出现了finally语句 异常逻辑结束后，还会进行finally语句块的执行再退出方法 分析堆栈轨迹元素12345&#x2F;&#x2F; 调用throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息var t &#x3D; new Throwable();var out &#x3D; new StringWriter();t.printStackTrace(new PrintWriter(out));String description &#x3D; out.toString(); 还有另外一种更加灵活的方式，使用StackWalker类，会生成一个StackWalker.StackFrame流，其中的每个实例分别描述一个栈针，用下面的方法去处理这些栈针。 1234StackWalker walker = StackWalker.getInstance();walker.forEach(frame -&gt; analyze frame);// 或者懒人方法walker.walk(stream -&gt; process stream);","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"create a exception class","date":"2021-02-21T07:22:13.178Z","path":"wiki/2021-03-03-create a exception class/","text":"创建合适的异常类习惯的做法：自定义的异常类中包含两个构造器，一个是默认的构造器，，一个是包含详细错误描述信息的构造器（在超类throwable中toString()方法会返回一个字符串，其中包含这个详细信息，对于调试很有用） 1234567class FileFormatException extends IOException&#123; public FileFOrmatException&#123;&#125; publix FileFormatException(String gripe)&#123; super(gripe); &#125;&#125;// 创建好自己的异常之后，就可以按照标准的异常抛出方法进行抛出 对于异常的处理，有两种： 抛出，抛出就是不管这个异常 捕获：对可能出现的异常进行捕获，并选择相对应的处理方案","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"throw a exception","date":"2021-02-21T07:12:22.365Z","path":"wiki/2021-03-03-throw a exception/","text":"如何指定可被方法抛出的异常：使用throw关键字throw throwableException; throw关键字后面跟着的对象需要是Throwable的子类（直接子类或者间接子类） 直接子类：Throwable的直接子类有两个，Error，Exception 间接子类：Exception的子类，RuntimeException。 123456789// 如何抛出一个异常public String readDate(Scanner in) throws EOFException&#123; while (..)&#123; if (encount a error)&#123; throw new EOFException(); &#125; &#125;&#125; 抛出异常的步骤是找到一个合适的异常类，在方法中指出可能遇到的异常，然后创建这个异常类的对象，然后将对象抛出 find a appropriate exception class create a object of the exception throw it chained exceptions有些应用通常在响应处理某个异常的时候，会抛出另外一个异常。实际上是第一个异常造成第二个异常的出现。所以知道什么时候一个异常造成另外一个异常是很有帮助的。==chained exception==可以做到，下面是几个在Throwable中支持chained exceptions的方法和构造器：传入构造器和initCause方法的Throwable是造成当前异常的异常 Throwable(String, Throwable): Throwable(Throwable) Throwable getCause()：返回的是造成当前错误的异常 Throwable initCause(Throwable)：设置造成当前异常的异常 获取Stack Trace信息statck trace：提供的提供当前线程的执行历史并且列出当异常发生的时候调用的类和方法名字。当异常发生的时候，stack trace是很有用的debug工具 1234567catch(Exception cause)&#123; StackTraceElement[] elements = cause.getStackTrace(); for(int i = 0, n = elements.length;i &lt; n; i++)&#123; System.err.println(elements[i].getFileName() + &quot;:&quot; +elements[i].getLineNumber()+ &quot;:&quot;+elements[i].getMethodName());&#125;&#125; logging API使用logging API除了可以将错误异常信息打印，其可以将异常信息导出到文件中。使用：java.util.logging 1234567891011try&#123; Handler handler = new FileHandler(&quot;output.log&quot;) Logger.getLogger(&quot;&quot;).addHandler(handler);&#125;catch (IOException e)&#123; Logger logger = Logger.getLogger(package.name); StackTraceElement[] elements = e.getStackTrace(); for (StackTraceElement element:elements)&#123; logger.log(Level.WARNING, element.getMethodName()); &#125;&#125; 需要自己写异常类的情况 需要写一个在Java平台中没有提供的异常的时候 如果用户可以区分你写的异常类和其他vendor写的类的时候 你的代码是否抛出好几个相关的异常 如果使用了别人的异常，是否用户有那些异常的访问权限，也就是说你的包是否是独立且self-contained ==选择超类==：创建自己异常的时候应该考虑使用哪个作为父类更合适，Error通常用作严重的硬件错误时使用（如那些使得JVM停止运行的错误），大部分时候都选择Exception作为父类（为了可读性考虑，最好将继承Exception的类后面都加上Exception）","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"日志logger","date":"2021-02-21T06:28:34.111Z","path":"wiki/2021-03-03-日志logger/","text":"日志","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Exception","date":"2021-02-21T06:28:25.497Z","path":"wiki/2021-03-03-Exception/","text":"[[Exception Advantages]]Advantage 1：将异常处理代码和正常的代码分离开来 Advanage 2：将异常错误推送到stack trace Advantage 3：将错误类型分组并区分错误类型 异常类，抛出异常，查找调用堆栈，分配异常处理器（捕获异常）==正常的异常机制的整过程==：创建异常类-&gt;在有需求的方法中抛出异常-&gt;异常发生的时候通过查看调用堆栈确定异常位置-&gt;创建异常类推送给编译器-&gt;根据找到的异常类去和异常处理器进行匹配-&gt;匹配到的异常处理器对异常进行处理-&gt;如果继续出现错误，抛出chained异常-&gt;可用getStackTrace方法去获取StatckTraceElement对象-&gt;利用这个对象去获取具体的错误信息，可以很好进行debug工作 异常是发生再程序运行期间发生的事件，这些事件会阻碍程序的正常运行。当一个程序执行时发生错误，这个方法会创建一个对象并将其呈递给运行系统。这个对象就是Exception，他包含了错误的信息，包含有错误的类型和错误发生时程序的状态。创建一个异常对象并将其送到运行系统，这个过程叫做抛出异常。在方法抛出异常之后，运行系统就会尝试去发现一些步骤去处理，这些步骤是一个方法有序列表，这些方法被用来到达发生错误的方法处，这个方法列表叫做==call stack==运行系统搜寻调用堆栈来找到包含可以解决这个异常的代码块。这个搜寻从发生错误的方法开始，然后以调用堆栈的反序去找寻。当找到合适的异常处理器==exception handler==时，运行系统将异常对象传递给该处理器，处理器判断是否可以处理该异常是通过判断异常类型是否和处理器的类型一致。选择处理器处理异常的过程叫做catch exception（捕获异常），如果没有找到合适的处理器处理异常，程序会终止 异常处理的基本要求合理的Java程序必须重视Catch or Specify requirement。可以抛出异常的代码需要有： Try声明（可以捕获异常），try语句必须提供异常处理器。 方法必须定义他是否可以抛出异常，方法必须提供throws语句（带有异常列表） 三个大的异常类不是所有的异常都满足上面的两个条件下面介绍以下异常中重要的三个类： [[checked exception]]：这一类异常都是设计良好的应用应该考虑到的并且可以从中修复的一类异常情况，例如访问文件的时候，如果传入一个没有的文件，就会出现java.io.FileNotFoundException。编写良好的程序可以捕获这类异常兵并且提示犯错给出改进。checked异常满足两个基本要求，所有的异常都是checked异常，除了Error和RuntimeException和他们的子类 error exception：这是程序外部的往往难以预料和处理的异常，例如成功打开了一个文件，但是由于硬件或者系统故障，不能正常读取，这将会抛出java.io.IOError。为了提示异常问题所在会捕获异常，并且打印堆栈trace并退出也是有意义的。Error不遵从两个基本条件。error指的是Error类和他的子类 runtime exception：指的是程序内部的，但是往往是那些无法预料和处理的异常，这些通常就指向程序的bug所在（比如逻辑错误、不适当的API运用）比如传递文件名时，发生逻辑错误而导致传入null给构造器，就会出现NullPointerException。应用可捕获这类异常，消除这个Bug是很有意义的。Runtime异常不满足两个基本条件，runtime异常是那些RuntimeException和它的子类 ==runtime异常和error合称[[unchecked exception]]== 绕过Catch or Specify有些人认为Catch or Specify要求是一个严重的缺陷，并并且绕过它用一些unchecked异常来取代checked异常。一般来说，这是不建议的。 [[catch and handle exception]][[Specify Exception thrown by method]][[throw a exception]][[create a exception class]][[异常使用技巧]][[断言]][[日志logger]]","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"断言","date":"2021-02-21T06:27:25.927Z","path":"wiki/2021-03-03-断言/","text":"断言在一个拥有良好自我保护能力的程序中很常用 断言的概念假设确信某个属性符合要求，且代码的执行依赖于这个属性 java中对于断言引入了assert关键字assert condition;assert condition : exprression; 上述的两个语句都会计算条件，如果结果为fasle，抛出一个AssertionError异常，第二个语句中，表达式将会传入SeertionError对象的构造器，并转换成一个消息字符串表达式部分的唯一目的是产生一个消息字符串，AeertionError并不会存储具体表达式值 断言的启用和禁用默认情况下，断言是被禁用的。可以在运行程序时用-enableassertions or -ea选项来启用 java -ea:MyClass -ea:com.mycompany.mylib Myapp为MyClass和mylib下的包打开断言，关闭断言并不会降低程序的运行速度，禁用断言是，类加载器为自动去除断言代码 disableassertions -da禁用断言 使用断言完成参数检查Java中处理错误的三种机制 异常 日志 断言 使用断言的情况： 断言失败是致命的不可恢复的错误 断言检查只是在开发阶段和测试阶段打开（靠近海岸时穿上救生衣，但到了海里就脱下了救生衣） 因此，不应该使用断言向程序的其他部分通知发生了可恢复性的错误，或者说不应该使用断言和程序用户沟通问题assert a != null;参数检查 使用断言来提供假设性文档","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"版本控制","date":"2021-02-21T05:06:12.438Z","path":"wiki/2021-03-03-版本控制/","text":"什么是版本控制版本控制就是在开发过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改的历史记录，备份以便恢复以前版本的一种软件工程技术 实现多人协同开发 追踪和记录一个或者多个文件而历史记录 组织和保护你的源代码和文档 统计工作量 并行开发，提高工作效率 跟踪记录软件的整个开发过程 减轻开发人员的负担，节省时间，同时降低人为的错误 用于管理多人协同开发的一种技术","tags":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/tags/git%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"git使用","slug":"git使用","permalink":"http://example.com/categories/git%E4%BD%BF%E7%94%A8/"}]},{"title":"vim快捷键","date":"2021-02-20T16:20:31.096Z","path":"wiki/2021-03-03-vim快捷键/","text":"前缀前缀键。各类 vim 插件帮助文档中经常出现 &lt;leader&gt;，即，前缀键。vim 自带有很多快捷键，再加上各类插件的快捷键，大量快捷键出现在单层空间中难免引起冲突，为缓解该问题，引入了前缀键 &lt;leader&gt;，这样，键 r 可以配置成 r、&lt;leader&gt;r、&lt;leader&gt;&lt;leader&gt;r 等等多个快捷键。前缀键是 vim 使用率较高的一个键（最高的当属 Esc），选一个最方便输入的键作为前缀键，将有助于提高编辑效率。找个无须眼睛查找、无须移动手指的键 —— 分号键，挺方便的，就在你右手小指处： 前缀键的出现，让vim的键盘映射更加丰富，而且也能避免让某些键盘失去原来的功效，只需呀i添加一个前缀，就可以解决掉一些冲突，很方便 123&quot;定义快捷键的前缀，即&lt;Leader&gt;let mapleader&#x3D;&quot;;&quot;&quot; 定义好了前缀符号，就可以使用前缀符来引导映射了:noremap &lt;leader&gt;&lt;c-d&gt; dd类似的操作 vim当中还有一种localleader，这种使用于特定类型文件的键盘映射:let maplocalleader=&#39;\\\\&#39; vim中的&lt;cr&gt;代表的是换行回车符，执行的是enter的操作，在很对的键盘映射中可看到 normal模式下的键盘映射：map - x符号-代表的是绑定的键盘x代表的是按下按键后执行的命令键盘绑定可以是：&lt;keyname&gt;，也可以是字符其中keyname可以是一个特殊按键，也可是一组按键命令如&lt;space&gt;，&lt;c-d&gt;#ctrl+d&gt; 不同模式下的键盘映射 :nmap：normal模式 :vmap：visual模式 :imap：insert模式 insert模式下默认不能使用normal下的命令因此:imap &lt;c-d&gt; dd只是插入两个d字符:imap &lt;c-d&gt; &lt;ESC&gt;ddi这样绑定是先esc推出到normal模式，再执行dd,再按i进入插入模式 精确映射123456:map x dd:map \\ x&quot; 对于上述的命令绑定，由于是递归的映射，因此在你执行\\命令时，会调用到dd,产生自己想不到的结果，因此需要使用非递归的:noremap \\ x&quot; 这种绑定在执行的时候不会在调用到dd上&quot; 映射的时候尽量避免映射冲突，因此设置的时候最好进行仔细的检查 由于上述的命令可能存在递归调用的情况，可能会造成不小的问题，因此任何时候，都不要过于随便的使用上述的键盘映射命令，而需要使用非递归的映射命令：*map都有一个对应的非递归映射命令：*noremap这个非递归的映射命令会忽略掉现有命令的映射，而只执行当前命令的默认映射 对于某一时刻的灵感突发，想要修改vimrc配置文件，但是又不想推出当前的vim窗口，那么可以绑定一个快捷键来打开vimrc：:noremap &lt;leader&gt;ev :vsplit $MYVIMRC &lt;CR&gt;:noremap &lt;leader&gt;rd source $MYVIMRC &lt;CR&gt;执行配置文件的重新读取这样可以减少很多没必要的时间浪费和灵感的消失","tags":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/tags/vim%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/categories/vim%E4%BD%BF%E7%94%A8/"}]},{"title":"VIMSCRIPT","date":"2021-02-20T15:41:58.494Z","path":"wiki/2021-03-03-VIMSCRIPT/","text":"VIMSCRIPT其实VIM也有着自己的一个脚本语言，而VIM的配置文件其实就是一个脚本，VIM打开之后自动读取这个脚本并执行因此，如果想要自己配置一个自己想要的编辑器，需要对VIM的脚本语言有一定的了解认识","tags":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/tags/vim%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/categories/vim%E4%BD%BF%E7%94%A8/"}]},{"title":"vim配置文件","date":"2021-02-20T15:25:50.525Z","path":"wiki/2021-03-03-vim配置文件/","text":"配置方案1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809&quot;VIM配置件&quot;2016-07-11&quot;是否兼容VI，compatible为兼容，nocompatible为不完全兼容&quot;如果设置为compatible，则tab将不会变成空格set nocompatible&quot;设置鼠标运行模式为WINDOWS模式behave mswin&quot;设置菜单语言set encoding&#x3D;chinese set langmenu&#x3D;zh_CN.UTF-8 &quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; 功能函数&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; 获取当前目录func GetPWD() return substitute(getcwd(), &quot;&quot;, &quot;&quot;, &quot;g&quot;)endf&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; 多语言环境&quot; 默认为 UTF-8 编码&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;if has(&quot;multi_byte&quot;) set encoding&#x3D;utf-8 &quot; English messages only &quot;language messages zh_CN.utf-8 if has(&#39;win32&#39;) language english let &amp;termencoding&#x3D;&amp;encoding endif set fencs&#x3D;utf-8,gbk,chinese,latin1 set formatoptions+&#x3D;mM set nobomb &quot; 不使用 Unicode 签名 if v:lang &#x3D;~? &#39;^\\(zh\\)\\|\\(ja\\)\\|\\(ko\\)&#39; set ambiwidth&#x3D;double endifelse echoerr &quot;Sorry, this version of (g)vim was not compiled with +multi_byte&quot;endif&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; 环境配置&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; 保留历史记录set history&#x3D;400&quot; 命令行于状态行set ch&#x3D;1set stl&#x3D;\\ [File]\\ %F%m%r%h%y[%&#123;&amp;fileformat&#125;,%&#123;&amp;fileencoding&#125;]\\ %w\\ \\ [PWD]\\ %r%&#123;GetPWD()&#125;%h\\ %&#x3D;\\ [Line]\\ %l,%c\\ %&#x3D;\\ %P set ls&#x3D;2 &quot; 始终显示状态行&quot; 制表符set tabstop&#x3D;4&quot;把tab转成空格&quot;set expandtabset smarttabset shiftwidth&#x3D;4set softtabstop&#x3D;4&quot; 状态栏显示目前所执行的指令set showcmd &quot; 行控制set linebreakset nocompatibleset textwidth&#x3D;80set wrap&quot; 行号和标尺set numberset rulerset rulerformat&#x3D;%15(%c%V\\ %p%%%)&quot; 控制台响铃:set noerrorbells:set novisualbell:set t_vb&#x3D; &quot;close visual bell&quot; 插入模式下使用 &lt;BS&gt;、&lt;Del&gt; &lt;C-W&gt; &lt;C-U&gt;set backspace&#x3D;indent,eol,start&quot; 标签页set tabpagemax&#x3D;20set showtabline&#x3D;2&quot; 缩进 智能对齐方式set autoindentset smartindent&quot; 自动重新读入set autoread&quot;代码折叠&quot;设置折叠模式set foldcolumn&#x3D;4&quot;光标遇到折叠，折叠就打开&quot;set foldopen&#x3D;all&quot;移开折叠时自动关闭折叠&quot;set foldclose&#x3D;all&quot;zf zo zc zd zr zm zR zM zn zi zN&quot;依缩进折叠&quot; manual 手工定义折叠&quot; indent 更多的缩进表示更高级别的折叠&quot; expr 用表达式来定义折叠&quot; syntax 用语法高亮来定义折叠&quot; diff 对没有更改的文本进行折叠&quot; marker 对文中的标志折叠set foldmethod&#x3D;syntax&quot;启动时不要自动折叠代码set foldlevel&#x3D;100&quot;依标记折叠set foldmethod&#x3D;marker&quot;语法高亮syntax enablesyntax on&quot;设置配色set guifont&#x3D;Courier\\ New:h12colorscheme desert&quot;设定文件浏览器目录为当前目录set bsdir&#x3D;buffer&quot; 自动切换到文件当前目录set autochdir&quot;在查找时忽略大小写set ignorecaseset incsearchset hlsearch &quot;设置命令行的高度set cmdheight&#x3D;2&quot;显示匹配的括号set showmatch&quot;增强模式中的命令行自动完成操作set wildmenu&quot;使PHP识别EOT字符串hi link phpheredoc string&quot;php语法折叠let php_folding &#x3D; 1&quot;允许在有未保存的修改时切换缓冲区set hidden&quot;实现全能补全功能，需要打开文件类型检测&quot;filetype plugin indent on&quot;打开vim的文件类型自动检测功能&quot;filetype on&quot;保存文件的格式顺序set fileformats&#x3D;dos,unix&quot;置粘贴模式，这样粘贴过来的程序代码就不会错位了。set paste&quot;在所有模式下都允许使用鼠标，还可以是n,v,i,c等set mouse&#x3D;a&quot; 恢复上次文件打开位置set viminfo&#x3D;&#39;10,\\&quot;100,:20,%,n~&#x2F;.viminfoau BufReadPost * if line(&quot;&#39;\\&quot;&quot;) &gt; 0|if line(&quot;&#39;\\&quot;&quot;) &lt;&#x3D; line(&quot;$&quot;)|exe(&quot;norm &#39;\\&quot;&quot;)|else|exe &quot;norm $&quot;|endif|endif&quot;取得光标处的匹配function! GetPatternAtCursor(pat) let col &#x3D; col(&#39;.&#39;) - 1 let line &#x3D; getline(&#39;.&#39;) let ebeg &#x3D; -1 let cont &#x3D; match(line, a:pat, 0) while (ebeg &gt;&#x3D; 0 || (0 &lt;&#x3D; cont) &amp;&amp; (cont &lt;&#x3D; col)) let contn &#x3D; matchend(line, a:pat, cont) if (cont &lt;&#x3D; col) &amp;&amp; (col &lt; contn) let ebeg &#x3D; match(line, a:pat, cont) let elen &#x3D; contn - ebeg break else let cont &#x3D; match(line, a:pat, contn) endif endwh if ebeg &gt;&#x3D; 0 return strpart(line, ebeg, elen) else return &quot;&quot; endifendfunction&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; 图形界面&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;if has(&#39;gui_running&#39;) &quot; 只显示菜单 set guioptions&#x3D;mcr &quot; 高亮光标所在的行 set cursorline &quot; 编辑器配色 colorscheme desert &quot;colorscheme zenburn &quot;colorscheme dusk if has(&quot;win32&quot;) &quot; Windows 兼容配置 source $VIMRUNTIME&#x2F;vimrc_example.vim source $VIMRUNTIME&#x2F;mswin.vim &quot;设置鼠标运行模式为WINDOWS模式 behave mswin &quot; f11 最大化 map &lt;f11&gt; :call libcallnr(&#39;fullscreen.dll&#39;, &#39;ToggleFullScreen&#39;, 0)&lt;cr&gt; &quot; 字体配置 exec &#39;set guifont&#x3D;&#39;.iconv(&#39;Courier_New&#39;, &amp;enc, &#39;gbk&#39;).&#39;:h12:cANSI&#39; &quot;exec &#39;set guifontwide&#x3D;&#39;.iconv(&#39;微软雅黑&#39;, &amp;enc, &#39;gbk&#39;).&#39;:h12&#39; endif if has(&quot;unix&quot;) &amp;&amp; !has(&#39;gui_macvim&#39;) set guifont&#x3D;Courier\\ 10\\ Pitch\\ 11 set guifontwide&#x3D;YaHei\\ Consolas\\ Hybrid\\ 11 endif if has(&quot;mac&quot;) || has(&quot;gui_macvim&quot;) set guifont&#x3D;Courier\\ New:h16.00 &quot;set guifontwide&#x3D;YaHei\\ Consolas\\ Hybrid:h16.00 &quot;set guifont&#x3D;Monaco:h16 &quot;set guifont&#x3D;Droid\\ Sans\\ Mono:h14 set guifontwide&#x3D;YouYuan:h14 if has(&quot;gui_macvim&quot;) &quot;set transparency&#x3D;4 set lines&#x3D;200 columns&#x3D;142 let s:lines&#x3D;&amp;lines let s:columns&#x3D;&amp;columns func! FullScreenEnter() set lines&#x3D;999 columns&#x3D;999 set fu endf func! FullScreenLeave() let &amp;lines&#x3D;s:lines let &amp;columns&#x3D;s:columns set nofu endf func! FullScreenToggle() if &amp;fullscreen call FullScreenLeave() else call FullScreenEnter() endif endf endif endifendif&quot; Under the Mac(MacVim)if has(&quot;gui_macvim&quot;) &quot; Mac 下，按 \\ff 切换全屏 map &lt;Leader&gt;&lt;Leader&gt; :call FullScreenToggle()&lt;cr&gt; &quot; Set input method off set imdisable &quot; Set QuickTemplatePath let g:QuickTemplatePath &#x3D; $HOME.&#39;&#x2F;.vim&#x2F;templates&#x2F;&#39; lcd ~&#x2F;Desktop&#x2F; &quot; 自动切换到文件当前目录 set autochdir &quot; Set QuickTemplatePath let g:QuickTemplatePath &#x3D; $HOME.&#39;&#x2F;.vim&#x2F;templates&#x2F;&#39;endif&quot;设置VIM状态栏set laststatus&#x3D;2 &quot;显示状态栏(默认值为1, 无法显示状态栏)set statusline&#x3D; &quot;[%F]%y%r%m%*%&#x3D;[Line:%l&#x2F;%L,Column:%c][%p%%]set statusline+&#x3D;%2*%-3.3n%0*\\ &quot; buffer numberset statusline+&#x3D;%f\\ &quot; file nameset statusline+&#x3D;%h%1*%m%r%w%0* &quot; flagset statusline+&#x3D;[if v:version &gt;&#x3D; 600 set statusline+&#x3D;%&#123;strlen(&amp;ft)?&amp;ft:&#39;none&#39;&#125;, &quot; filetype set statusline+&#x3D;%&#123;&amp;fileencoding&#125;, &quot; encodingendifset statusline+&#x3D;%&#123;&amp;fileformat&#125;] &quot; file formatset statusline+&#x3D;%&#x3D; &quot; right align&quot;set statusline+&#x3D;%2*0x%-8B\\ &quot; current charset statusline+&#x3D;0x%-8B\\ &quot; current charset statusline+&#x3D;%-14.(%l,%c%V%)\\ %&lt;%P &quot; offsetif filereadable(expand(&quot;~&#x2F;vimfiles&#x2F;plugin&#x2F;vimbuddy.vim&quot;)) set statusline+&#x3D;\\ %&#123;VimBuddy()&#125; &quot; vim buddyendif&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; 插件&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;filetype plugin indent on&quot;html自动输入匹配标签，输入&gt;之后自动完成匹配标签au FileType xhtml,xml so ~&#x2F;.vim&#x2F;plugin&#x2F;html_autoclosetag.vim&quot;Auto completion using the TAB key &quot; 自动补全括号，引号&quot;This function determines, wether we are on &quot;the start of the line text(then tab indents) &quot;or if we want to try auto completion function! InsertTabWrapper() let col&#x3D;col(&#39;.&#39;)-1 if !col || getline(&#39;.&#39;)[col-1] !~ &#39;\\k&#39; return &quot;\\&lt;TAB&gt;&quot; else return &quot;\\&lt;C-N&gt;&quot; endif endfunction &quot;Remap the tab key to select action with InsertTabWrapper inoremap &lt;TAB&gt; &lt;C-R&gt;&#x3D;InsertTabWrapper()&lt;CR&gt;:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;&#x3D;ClosePair(&#39;)&#39;)&lt;CR&gt;:inoremap &#123; &#123;&#125;&lt;ESC&gt;i:inoremap &#125; &lt;c-r&gt;&#x3D;ClosePair(&#39;&#125;&#39;)&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;&#x3D;ClosePair(&#39;]&#39;)&lt;CR&gt;:inoremap &lt; &lt;&gt;&lt;ESC&gt;i:inoremap &gt; &lt;c-r&gt;&#x3D;ClosePair(&#39;&gt;&#39;)&lt;CR&gt;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i:inoremap &#39; &#39;&#39;&lt;ESC&gt;ifunction! ClosePair(char) if getline(&#39;.&#39;)[col(&#39;.&#39;) - 1] &#x3D;&#x3D; a:char return &quot;\\&lt;Right&gt;&quot; else return a:char endifendf&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; AutoCmd&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;if has(&quot;autocmd&quot;) filetype plugin indent on &quot; 括号自动补全 func! AutoClose() :inoremap ( ()&lt;ESC&gt;i &quot;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i &quot;:inoremap &#39; &#39;&#39;&lt;ESC&gt;i :inoremap &#123; &#123;&#125;&lt;ESC&gt;i :inoremap [ []&lt;ESC&gt;i :inoremap ) &lt;c-r&gt;&#x3D;ClosePair(&#39;)&#39;)&lt;CR&gt; :inoremap &#125; &lt;c-r&gt;&#x3D;ClosePair(&#39;&#125;&#39;)&lt;CR&gt; :inoremap ] &lt;c-r&gt;&#x3D;ClosePair(&#39;]&#39;)&lt;CR&gt; endf func! ClosePair(char) if getline(&#39;.&#39;)[col(&#39;.&#39;) - 1] &#x3D;&#x3D; a:char return &quot;\\&lt;Right&gt;&quot; else return a:char endif endf augroup vimrcEx au! autocmd FileType text setlocal textwidth&#x3D;80 autocmd BufReadPost * \\ if line(&quot;&#39;\\&quot;&quot;) &gt; 0 &amp;&amp; line(&quot;&#39;\\&quot;&quot;) &lt;&#x3D; line(&quot;$&quot;) | \\ exe &quot;normal g&#96;\\&quot;&quot; | \\ endif augroup END &quot;auto close quotation marks for PHP, Javascript, etc, file au FileType php,c,python,javascript exe AutoClose() &quot; Auto Check Syntax au BufWritePost,FileWritePost *.js,*.php call CheckSyntax(1) &quot; JavaScript 语法高亮 au FileType html,javascript let g:javascript_enable_domhtmlcss &#x3D; 1 &quot; 给 Javascript 文件添加 Dict if has(&#39;gui_macvim&#39;) || has(&#39;unix&#39;) au FileType javascript setlocal dict+&#x3D;~&#x2F;.vim&#x2F;dict&#x2F;javascript.dict else au FileType javascript setlocal dict+&#x3D;$VIM&#x2F;vimfiles&#x2F;dict&#x2F;javascript.dict endif &quot; 格式化 JavaScript 文件 &quot;au FileType javascript map &lt;f12&gt; :call g:Jsbeautify()&lt;cr&gt; au FileType javascript set omnifunc&#x3D;javascriptcomplete#CompleteJS &quot; 给 CSS 文件添加 Dict if has(&#39;gui_macvim&#39;) || has(&#39;unix&#39;) au FileType css setlocal dict+&#x3D;~&#x2F;.vim&#x2F;dict&#x2F;css.dict else au FileType css setlocal dict+&#x3D;$VIM&#x2F;vimfiles&#x2F;dict&#x2F;css.dict endif &quot; 增加 ActionScript 语法支持 au BufNewFile,BufRead *.as setf actionscript &quot; 自动最大化窗口 if has(&#39;gui_running&#39;) if has(&quot;win32&quot;) au GUIEnter * simalt ~x &quot;elseif has(&quot;unix&quot;) &quot;au GUIEnter * winpos 0 0 &quot;set lines&#x3D;999 columns&#x3D;999 endif endifendiflet g:SuperTabDefaultCompletionType &#x3D; &#39;&lt;c-x&gt;&lt;c-u&gt;&#39;let g:SuperTabDefaultCompletionType &#x3D; &quot;context&quot;let g:SuperTabRetainCompletionType&#x3D;2 &quot; Disable AutoComplPop.let g:acp_enableAtStartup &#x3D; 0&quot; Use neocomplcache.let g:neocomplcache_enable_at_startup &#x3D; 1&quot; Use smartcase.let g:neocomplcache_enable_smart_case &#x3D; 1&quot; Use camel case completion.let g:neocomplcache_enable_camel_case_completion &#x3D; 1&quot; Use underbar completion.let g:neocomplcache_enable_underbar_completion &#x3D; 1&quot; Set minimum syntax keyword length.let g:neocomplcache_min_syntax_length &#x3D; 3let g:neocomplcache_lock_buffer_name_pattern &#x3D; &#39;\\*ku\\*&#39;&quot; Define dictionary.let g:neocomplcache_dictionary_filetype_lists &#x3D; &#123; \\ &#39;default&#39; : &#39;&#39;, \\ &#39;css&#39; : &#39;~&#x2F;.vim&#x2F;dist&#x2F;css.dic&#39;, \\ &#39;php&#39; : &#39;~&#x2F;.vim&#x2F;dict&#x2F;php.dic&#39;, \\ &#39;javascript&#39; : &#39;~&#x2F;.vim&#x2F;dict&#x2F;javascript.dic&#39;, \\ &#39;vimshell&#39; : $HOME.&#39;&#x2F;.vimshell_hist&#39;, \\ &#39;scheme&#39; : $HOME.&#39;&#x2F;.gosh_completions&#39; \\ &#125;let g:neocomplcache_snippets_dir&#x3D;&quot;~&#x2F;.vim&#x2F;snippets&quot;inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : &quot;\\&lt;TAB&gt;&quot;inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\\&lt;C-p&gt;&quot; : &quot;\\&lt;TAB&gt;&quot;&quot; Define keyword.if !exists(&#39;g:neocomplcache_keyword_patterns&#39;) let g:neocomplcache_keyword_patterns &#x3D; &#123;&#125;endiflet g:neocomplcache_keyword_patterns[&#39;default&#39;] &#x3D; &#39;\\h\\w*&#39;&quot; Plugin key-mappings.imap &lt;C-k&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)smap &lt;C-k&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)inoremap &lt;expr&gt;&lt;C-g&gt; neocomplcache#undo_completion()inoremap &lt;expr&gt;&lt;C-l&gt; neocomplcache#complete_common_string()&quot; Recommended key-mappings.&quot; &lt;CR&gt;: close popup and save indent.inoremap &lt;expr&gt;&lt;CR&gt; neocomplcache#smart_close_popup() . &quot;\\&lt;CR&gt;&quot;&quot; &lt;TAB&gt;: completion.inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : &quot;\\&lt;TAB&gt;&quot;&quot; &lt;C-h&gt;, &lt;BS&gt;: close popup and delete backword char.inoremap &lt;expr&gt;&lt;C-h&gt; neocomplcache#smart_close_popup().&quot;\\&lt;C-h&gt;&quot;inoremap &lt;expr&gt;&lt;BS&gt; neocomplcache#smart_close_popup().&quot;\\&lt;C-h&gt;&quot;inoremap &lt;expr&gt;&lt;C-y&gt; neocomplcache#close_popup()inoremap &lt;expr&gt;&lt;C-e&gt; neocomplcache#cancel_popup()&quot; AutoComplPop like behavior.&quot;let g:neocomplcache_enable_auto_select &#x3D; 1&quot; Shell like behavior(not recommended).&quot;set completeopt+&#x3D;longestlet g:neocomplcache_enable_auto_select &#x3D; 1let g:neocomplcache_disable_auto_complete &#x3D; 1inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? &quot;\\&lt;Down&gt;&quot; : &quot;\\&lt;TAB&gt;&quot;inoremap &lt;expr&gt;&lt;CR&gt; neocomplcache#smart_close_popup() . &quot;\\&lt;CR&gt;&quot;&quot; Enable omni completion.autocmd FileType css setlocal omnifunc&#x3D;csscomplete#CompleteCSSautocmd FileType html,markdown setlocal omnifunc&#x3D;htmlcomplete#CompleteTagsautocmd FileType javascript setlocal omnifunc&#x3D;javascriptcomplete#CompleteJSautocmd FileType python setlocal omnifunc&#x3D;pythoncomplete#Completeautocmd FileType xml setlocal omnifunc&#x3D;xmlcomplete#CompleteTags&quot; Enable heavy omni completion.if !exists(&#39;g:neocomplcache_omni_patterns&#39;) let g:neocomplcache_omni_patterns &#x3D; &#123;&#125;endiflet g:neocomplcache_omni_patterns.ruby &#x3D; &#39;[^. *\\t]\\.\\w*\\|\\h\\w*::&#39;&quot;autocmd FileType ruby setlocal omnifunc&#x3D;rubycomplete#Completelet g:neocomplcache_omni_patterns.php &#x3D; &#39;[^. \\t]-&gt;\\h\\w*\\|\\h\\w*::&#39;let g:neocomplcache_omni_patterns.c &#x3D; &#39;\\%(\\.\\|-&gt;\\)\\h\\w*&#39;let g:neocomplcache_omni_patterns.cpp &#x3D; &#39;\\h\\w*\\%(\\.\\|-&gt;\\)\\h\\w*\\|\\h\\w*::&#39;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Tag list (ctags)&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;if has(&quot;win32&quot;) &quot;设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd &#x3D; &#39;ctags&#39;elseif has(&quot;linux&quot;) &quot;设定linux系统中ctags程序的位置let Tlist_Ctags_Cmd &#x3D; &#39;&#x2F;usr&#x2F;bin&#x2F;ctags&#39;endiflet Tlist_Show_One_File &#x3D; 1 &quot;不同时显示多个文件的tag，只显示当前文件的let Tlist_Exit_OnlyWindow &#x3D; 1 &quot;如果taglist窗口是最后一个窗口，则退出vimlet Tlist_Use_Right_Window &#x3D; 1 &quot;在右侧窗口中显示taglist窗口 &quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; 快捷键&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;map cal :Calendar&lt;cr&gt;map cse :ColorSchemeExplorer&quot;&#x3D;&#x3D;&#x3D;&#x3D; F3 NERDTree 切换 &#x3D;&#x3D;&#x3D;&#x3D;let NERDTreeWinSize&#x3D;22&quot;map ntree :NERDTree &lt;cr&gt;&quot;map nk :NERDTreeClose &lt;cr&gt;&quot;map &lt;leader&gt;n :NERDTreeToggle&lt;cr&gt;map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;&quot;&#x3D;&#x3D;&#x3D;&#x3D; F4 Tag list 切换 &#x3D;&#x3D;&#x3D;&#x3D;map &lt;silent&gt; &lt;F4&gt; :TlistToggle&lt;cr&gt; &quot; 标签相关的快捷键 Ctrlmap tn :tabnext&lt;cr&gt;map tp :tabprevious&lt;cr&gt;map tc :tabclose&lt;cr&gt;map &lt;C-t&gt; :tabnew&lt;cr&gt;map &lt;C-p&gt; :tabprevious&lt;cr&gt;map &lt;C-n&gt; :tabnext&lt;cr&gt;map &lt;C-k&gt; :tabclose&lt;cr&gt;map &lt;C-Tab&gt; :tabnext&lt;cr&gt;&quot; 新建 XHTML 、PHP、Javascript 文件的快捷键nmap &lt;C-c&gt;&lt;C-h&gt; :NewQuickTemplateTab xhtml&lt;cr&gt;nmap &lt;C-c&gt;&lt;C-p&gt; :NewQuickTemplateTab php&lt;cr&gt;nmap &lt;C-c&gt;&lt;C-j&gt; :NewQuickTemplateTab javascript&lt;cr&gt;nmap &lt;C-c&gt;&lt;C-c&gt; :NewQuickTemplateTab css&lt;cr&gt;&quot; 在文件名上按gf时，在新的tab中打开map gf :tabnew &lt;cfile&gt;&lt;cr&gt;&quot;jquery 配色au BufRead,BufNewFile *.js set syntax&#x3D;jquery&quot; jsLint for Vimlet g:jslint_highlight_color &#x3D; &#39;#996600&#39;&quot; 指定 jsLint 调用路径，通常不用更改let g:jslint_command &#x3D; $HOME . &#39;\\&#x2F;.vim\\&#x2F;jsl\\&#x2F;jsl&#39;&quot; 指定 jsLint 的启动参数，可以指定相应的配置文件let g:jslint_command_options &#x3D; &#39;-nofilelisting -nocontext -nosummary -nologo -process&#39;&quot; 返回当前时间func! GetTimeInfo() &quot;return strftime(&#39;%Y-%m-%d %A %H:%M:%S&#39;) return strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)endfunction&quot; 插入模式按 Ctrl + D(ate) 插入当前时间imap &lt;C-d&gt; &lt;C-r&gt;&#x3D;GetTimeInfo()&lt;cr&gt;&quot;缺省不产生备份文件set nobackupset nowritebackup&quot; autoload _vimrcautocmd! bufwritepost _vimrc source %&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; plugin list&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;Color Scheme Explorer&quot;jsbeauty \\ff&quot;NERDTree&quot;Calendar&quot;conquer_term&quot;nerd_commenter&quot;&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*\\&quot; 常用指令收集&quot;\\*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;&quot; 系统时间&quot; :map &lt;F7&gt; a&lt;C-R&gt;&#x3D;strftime(&quot;%c&quot;)&lt;CR&gt;&lt;esc&gt;&quot; :s&#x2F;__date__&#x2F;\\&#x3D;strftime(&quot;%c&quot;)&#x2F;&quot;&#x2F;*---------------------------------------*\\&quot; 基础命令&quot;&#x2F;*---------------------------------------*\\&quot; ctrl+q 可以联合复制，粘贴，替换用 行操作&quot; ctrl+w+j ctrl+w+k (:bn :bp :bd)&quot; &#39;. 它移动光标到上一次的修改行&quot; &#96;. 它移动光标到上一次的修改点&quot; . 重复上次命令&quot; &lt;C-O&gt; : 依次沿着你的跳转记录向回跳 (从最近的一次开始)&quot; &lt;C-I&gt; : 依次沿着你的跳转记录向前跳&quot; ju(mps) : 列出你跳转的足迹&quot; :history : 列出历史命令记录&quot; :his c : 命令行命令历史&quot; :his s : 搜索命令历史&quot; q&#x2F; : 搜索命令历史的窗口&quot; q: : 命令行命令历史的窗口&quot; g ctrl+g 计算文件字符&quot; &#123;,&#125; 前进至上一段落前进至后一段落&quot; gg,G(2G) 文件首&quot; gd dw gf ga(进制转化)&quot; gg&#x3D;G 全篇自动缩进 , &#x3D;G 单行缩进&quot;* ci[ 删除一对 [] 中的所有字符并进入插入模式&quot;* ci( 删除一对 () 中的所有字符并进入插入模式&quot;* ci&lt; 删除一对 &lt;&gt; 中的所有字符并进入插入模式&quot;* ci&#123; 删除一对 &#123;&#125; 中的所有字符并进入插入模式&quot;* cit 删除一对 HTML&#x2F;XML 的标签内部的所有字符并进入插入模式&quot;* ci” ci’ ci&#96; 删除一对引号字符 (” 或 ‘ 或 &#96;) 中所有字符并进入插入模式&quot;&quot;* vi[ 选择一对 [] 中的所有字符&quot;* vi( 选择一对 () 中的所有字符&quot;* vi&lt; 选择一对 &lt;&gt; 中的所有字符&quot;* vi&#123; 选择一对 &#123;&#125; 中的所有字符&quot;* vit 选择一对 HTML&#x2F;XML 的标签内部的所有字符&quot;* vi” vi’ vi&#96; 选择一对引号字符 (” 或 ‘ 或 &#96;) 中所有字符&quot; crl+] 函数原型处 crl+t 回 ( ctags )&quot; ctl+p 自动补全( 编辑状态 )&quot; :X 加密保存( 要输入密码 )&quot; ? &#x2F; (N n)&quot; f(F,t) 查找字符&quot; w(e) 移动光标到下一个单词.&quot; 5fx 表示查找光标后第 5 个 x 字符.&quot; 5w(e) 移动光标到下五个单词.&quot; b 移动光标到上一个单词.&quot; 0 移动光标到本行最开头.&quot; ^ 移动光标到本行最开头的字符处.&quot; $ 移动光标到本行结尾处.&quot; H 移动光标到屏幕的首行.&quot; M 移动光标到屏幕的中间一行.&quot; L 移动光标到屏幕的尾行.&quot; c-f (即 ctrl 键与 f 键一同按下)&quot; c-b (即 ctrl 键与 b 键一同按下) 翻页&quot; c-d (下半页) c-u(上半页) c-e (一行滚动)&quot; zz 让光标所在的行居屏幕中央&quot; zt 让光标所在的行居屏幕最上一行&quot; zb 让光标所在的行居屏幕最下一行&quot; 在 vi 中 y 表示拷贝, d 表示删除, p 表示粘贴. 其中拷贝与删除是与光标移动命令&quot; yw 表示拷贝从当前光标到光标所在单词结尾的内容.&quot; dw 表示删除从当前光标到光标所在单词结尾的内容.&quot; y0 表示拷贝从当前光标到光标所在行首的内容.&quot; d0 表示删除从当前光标到光标所在行首的内容.&quot; y$(Y) 表示拷贝从当前光标到光标所在行尾的内容.&quot; d$(D) 表示删除从当前光标到光标所在行尾的内容.&quot; yfa 表示拷贝从当前光标到光标后面的第一个a字符之间的内容.&quot; dfa 表示删除从当前光标到光标后面的第一个a字符之间的内容.&quot; s(S),a(A),x(X),D&quot; yy 表示拷贝光标所在行.&quot; dd 表示删除光标所在行.&quot; 5yy 表示拷贝光标以下 5 行.&quot; 5dd 表示删除光标以下 5 行.&quot; y2fa 表示拷贝从当前光标到光标后面的第二个a字符之间的内容.&quot; :12,24y 表示拷贝第12行到第24行之间的内容.&quot; :12,y 表示拷贝第12行到光标所在行之间的内容.&quot; :,24y 表示拷贝光标所在行到第24行之间的内容. 删除类似.&quot; TAB 就是制表符, 单独拿出来做一节是因为这个东西确实很有用.&quot; &lt;&lt; 输入此命令则光标所在行向左移动一个 tab.&quot; &gt;&gt; 输入此命令则光标所在行向右移动一个 tab.&quot; 5&gt;&gt; 输入此命令则光标后 5 行向右移动一个 tab.&quot; :5&gt;&gt;(&gt;&gt;&gt;) :&gt;&gt;(&gt;&gt;&gt;)5&quot; :12,24&gt; 此命令将12行到14行的数据都向右移动一个 tab.&quot; :12,24&gt;&gt; 此命令将12行到14行的数据都向右移动两个 tab.&quot; :set shiftwidth&#x3D;4 设置自动缩进 4 个空格, 当然要设自动缩进先.&quot; :set sts&#x3D;4 即设置 softtabstop 为 4. 输入 tab 后就跳了 4 格.&quot; :set tabstop&#x3D;4 实际的 tab 即为 4 个空格, 而不是缺省的 8 个.&quot; :set expandtab 在输入 tab 后, vim 用恰当的空格来填充这个 tab.&quot; :g&#x2F;^&#x2F;exec &#39;s&#x2F;^&#x2F;&#39;.strpart(line(&#39;.&#39;).&#39; &#39;, 0, 4) 在行首插入行号&quot; set ai 设置自动缩进&quot; 5ia&lt;esc&gt; 重复插入5个a字符&quot;&#x2F;*---------------------------------------*\\&quot; 替换命令&quot;&#x2F;*---------------------------------------*\\&quot; 替换文字 2009-02-34 ----&gt; 2009-02-34 00:00:00&quot; :%s&#x2F;\\(\\d\\&#123;4\\&#125;-\\d\\&#123;2\\&#125;-\\d\\&#123;2\\&#125;\\)&#x2F;\\1 00:00:00&#x2F;g&quot; :s&#x2F;aa&#x2F;bb&#x2F;g 将光标所在行出现的所有包含 aa 的字符串中的 aa 替换为 bb&quot; :s&#x2F;\\&#x2F;bb&#x2F;g 将光标所在行出现的所有 aa 替换为 bb, 仅替换 aa 这个单词&quot; :%s&#x2F;aa&#x2F;bb&#x2F;g 将文档中出现的所有包含 aa 的字符串中的 aa 替换为 bb&quot; :12,23s&#x2F;aa&#x2F;bb&#x2F;g 将从12行到23行中出现的所有包含 aa 的字符串中的 aa 替换为 bb&quot; :12,23s&#x2F;^&#x2F;#&#x2F; 将从12行到23行的行首加入 # 字符&quot; :%s&#x2F;fred&#x2F;joe&#x2F;igc 一个常见的替换命令，修饰符igc和perl中一样意思&quot; s&#x2F;dick&#x2F;joe&#x2F;igc则 对于这些满足条件的行进行替换&quot; :g&#x2F;^\\s*$&#x2F;d 空行(空格也不包含)删除.&quot; :%s&#x2F;\\r&#x2F;&#x2F;g 删除DOS方式的回车^M&quot; :%s&#x2F; *$&#x2F;&#x2F; 删除行尾空白(%s&#x2F;\\s*$&#x2F;&#x2F;g)&quot; :g!&#x2F;^dd&#x2F;d 删除不含字符串&#39;dd&#39;开头的行&quot; :v&#x2F;^dd&#x2F;d 同上,译释：v &#x3D;&#x3D; g!，就是不匹配！&quot; :v&#x2F;.&#x2F;.,&#x2F;.&#x2F;-1join 压缩空行(多行空行合并为一行)&quot; :g&#x2F;^$&#x2F;,&#x2F;.&#x2F;-j 压缩空行(多行空行合并为一行)&quot; :g&#x2F;^&#x2F;pu _ 把文中空行扩增一倍 (pu &#x3D; put),原来两行间有一个空行，现在变成2个&quot; :g&#x2F;^&#x2F;m0 按行翻转文章 (m &#x3D; move)&quot; :g&#x2F;fred&#x2F;,&#x2F;joe&#x2F;d not line based (very powerfull)&quot; :g&#x2F;&lt;input\\|&lt;form&#x2F;p 或者 要用\\|&quot; :g&#x2F;fred&#x2F;t$ 拷贝行，从fred到文件末尾(EOF)&quot; :%norm jdd 隔行删除,译释：%指明是对所有行进行操作,norm指出后面是normal模式的指令,j是下移一行，dd是删除行&quot; :&#39;a,&#39;bg&#x2F;fred&#x2F;s&#x2F;dick&#x2F;joe&#x2F;igc (&#39;a,&#39;b指定一个范围：mark a ~ mark b)&quot; g&#x2F;&#x2F;用一个正则表达式指出了进行操作的行必须可以被fred匹配,g&#x2F;&#x2F;是一个全局显示命令&quot; &#x2F;joe&#x2F;e 光标停留在匹配单词最后一个字母处&quot; &#x2F;joe&#x2F;e+1 光标停留在匹配单词最后一个字母的下一个字母处&quot; &#x2F;joe&#x2F;s 光标停留在匹配单词第一个字母处&quot; &#x2F;^joe.*fred.*bill&#x2F; 标准正则表达式&quot; &#x2F;^[A-J]\\+&#x2F; 找一个以A~J中一个字母重复两次或以上开头的行&quot; &#x2F;forum\\(\\_.\\)*pent 多行匹配&quot; &#x2F;fred\\_s*joe&#x2F;i 中间可以有任何空白，包括换行符\\n&quot; &#x2F;fred\\|joe 匹配FRED或JOE&quot; &#x2F;\\&lt;fred\\&gt;&#x2F;i 匹配fred,fred必须是一个独立的单词，而不是子串&quot; &#x2F;\\&lt;\\d\\d\\d\\d\\&gt; 匹配4个数字 \\&lt;\\d\\&#123;4&#125;\\&gt;&quot; 列，替换所有在第三列中的str1&quot; :%s:\\(\\(\\w\\+\\s\\+\\)\\&#123;2&#125;\\)str1:\\1str2:&quot; 交换第一列和最后一列 (共4列)&quot; :%s:\\(\\w\\+\\)\\(.*\\s\\+\\)\\(\\w\\+\\)$:\\3\\2\\1:&quot; 全局(global)显示命令，就是用 :g＋正则表达式&quot; 译释： :g&#x2F;&#123;pattern&#125;&#x2F;&#123;cmd&#125; 就是全局找到匹配的,然后对这些行执行命令&#123;cmd&#125;&quot; :g&#x2F;\\&lt;fred\\&gt;&#x2F; 显示所有能够为单词fred所匹配的行&quot; :g&#x2F;&lt;pattern&gt;&#x2F;z#.5 显示内容，还有行号&quot; :g&#x2F;&lt;pattern&gt;&#x2F;z#.5|echo &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39; 漂亮的显示&quot;&#x2F;*---------------------------------------*\\&quot; 多文档操作 (基础)&quot;&#x2F;*---------------------------------------*\\&quot; 用 :ls! 可以显示出当前所有的buffer&quot; :bn 跳转到下一个buffer&quot; :bp 跳转到上一个buffer&quot; :wn 存盘当前文件并跳转到下一个&quot; :wp 存盘当前文件并跳转到上一个&quot; :bd 把这个文件从buffer列表中做掉&quot; :b 3 跳到第3个buffer&quot; :b main 跳到一个名字中包含main的buffer&quot;&#x2F;*---------------------------------------*\\&quot; 列复制&quot;&#x2F;*---------------------------------------*\\&quot; 译注：@#%&amp;^#*^%#$!&quot; :%s&#x3D; [^ ]\\+$&#x3D;&amp;&amp;&#x3D; : 复制最后一列&quot; :%s&#x3D; \\f\\+$&#x3D;&amp;&amp;&#x3D; : 一样的功能&quot; :%s&#x3D; \\S\\+$&#x3D;&amp;&amp; : ft,还是一样&quot; 反向引用，或称记忆&quot; :s&#x2F;\\(.*\\):\\(.*\\)&#x2F;\\2 : \\1&#x2F; : 颠倒用:分割的两个字段&quot; :%s&#x2F;^\\(.*\\)\\n\\1&#x2F;\\1$&#x2F; : 删除重复行&quot; 非贪婪匹配，\\&#123;-&#125;&quot; :%s&#x2F;^.\\&#123;-&#125;pdf&#x2F;new.pdf&#x2F; : 只是删除第一个pdf&quot; 跨越可能的多行&quot; :%s&#x2F;&lt;!--\\_.\\&#123;-&#125;--&gt;&#x2F;&#x2F; : 又是删除多行注释（咦？为什么要说「又」呢？）&quot; :help &#x2F;\\&#123;-&#125; : 看看关于 非贪婪数量符 的帮助&quot; :s&#x2F;fred&#x2F;&lt;c-r&gt;a&#x2F;g : 替换fred成register a中的内容，呵呵&quot; 写在一行里的复杂命令&quot; :%s&#x2F;\\f\\+\\.gif\\&gt;&#x2F;\\r&amp;\\r&#x2F;g | v&#x2F;\\.gif$&#x2F;d | %s&#x2F;gif&#x2F;jpg&#x2F;&quot; 译注：就是用 | 管道啦&quot;&#x2F;*---------------------------------------*\\&quot; 大小写转换&quot;&#x2F;*---------------------------------------*\\&quot; g~~ : 行翻转&quot; vEU : 字大写(广义字)&quot; vE~ : 字翻转(广义字)&quot; ~ 将光标下的字母改变大小写&quot; 3~ 将下3个字母改变其大小写&quot; g~w 字翻转&quot; U 将可视模式下的字母全改成大写字母&quot; gUU 将当前行的字母改成大写&quot; u 将可视模式下的字母全改成小写&quot; guu 将当前行的字母全改成小写&quot; gUw 将光标下的单词改成大写。&quot; guw 将光标下的单词改成小写。&quot; 文件浏览&quot; :Ex : 开启目录浏览器，注意首字母E是大写的&quot; :Sex : 在一个分割的窗口中开启目录浏览器&quot; :ls : 显示当前buffer的情况&quot; :cd .. : 进入父目录&quot; :pwd&quot; :args : 显示目前打开的文件&quot; :lcd %:p:h : 更改到当前文件所在的目录&quot; 译释：lcd是紧紧改变当前窗口的工作路径，% 是代表当前文件的文件名,&quot; 加上 :p扩展成全名（就是带了路径），加上 :h析取出路径&quot;&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*\\&quot; END&quot;\\*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F; 配置方案2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210Skip to contentThis repositorySearchPull requestsIssuesGist @shuter Watch 154 Star 1,351 Fork 520 humiaozuzu&#x2F;dot-vimrc Code Issues 5 Pull requests 1 Wiki Pulse GraphsBranch: master Find file Copy pathdot-vimrc&#x2F;vimrc9f843b9 on 9 Sep 2013@humiaozuzu humiaozuzu Fix snipmate error2 contributors @humiaozuzu @graceceRawBlameHistory 269 lines (235 sloc) 8.19 KBsource ~&#x2F;.vim&#x2F;bundles.vim&quot; encoding dectectionset fileencodings&#x3D;utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1&quot; enable filetype dectection and ft specific plugin&#x2F;indentfiletype plugin indent on&quot; enable syntax hightlight and completionsyntax on&quot;--------&quot; Vim UI&quot;--------&quot; color schemeset background&#x3D;darkcolor solarized&quot; highlight current lineau WinLeave * set nocursorline nocursorcolumnau WinEnter * set cursorline cursorcolumnset cursorline cursorcolumn&quot; searchset incsearch&quot;set highlight &quot; conflict with highlight current lineset ignorecaseset smartcase&quot; editor settingsset history&#x3D;1000set nocompatibleset nofoldenable &quot; disable folding&quot;set confirm &quot; prompt when existing from an unsaved fileset backspace&#x3D;indent,eol,start &quot; More powerful backspacingset t_Co&#x3D;256 &quot; Explicitly tell vim that the terminal has 256 colors &quot;set mouse&#x3D;a &quot; use mouse in all modesset report&#x3D;0 &quot; always report number of lines changed &quot;set nowrap &quot; dont wrap linesset scrolloff&#x3D;5 &quot; 5 lines above&#x2F;below cursor when scrollingset number &quot; show line numbersset showmatch &quot; show matching bracket (briefly jump)set showcmd &quot; show typed command in status barset title &quot; show file in titlebarset laststatus&#x3D;2 &quot; use 2 lines for the status barset matchtime&#x3D;2 &quot; show matching bracket for 0.2 secondsset matchpairs+&#x3D;&lt;span class&#x3D;&quot;hljs-tag&quot;&gt;&lt;span class&#x3D;&quot;hljs-tag&quot;&gt;&lt;&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;hljs-name&quot;&gt;&lt;span class&#x3D;&quot;hljs-tag&quot;&gt;&lt;span class&#x3D;&quot;hljs-name&quot;&gt;:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;hljs-tag&quot;&gt;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &quot; specially for html&quot; set relativenumber&quot; Default Indentationset autoindentset smartindent &quot; indent whenset tabstop&#x3D;4 &quot; tab widthset softtabstop&#x3D;4 &quot; backspaceset shiftwidth&#x3D;4 &quot; indent width&quot; set textwidth&#x3D;79&quot; set smarttabset expandtab &quot; expand tab to spaceautocmd FileType php setlocal tabstop&#x3D;2 shiftwidth&#x3D;2 softtabstop&#x3D;2 textwidth&#x3D;120autocmd FileType ruby setlocal tabstop&#x3D;2 shiftwidth&#x3D;2 softtabstop&#x3D;2 textwidth&#x3D;120autocmd FileType php setlocal tabstop&#x3D;4 shiftwidth&#x3D;4 softtabstop&#x3D;4 textwidth&#x3D;120autocmd FileType coffee,javascript setlocal tabstop&#x3D;2 shiftwidth&#x3D;2 softtabstop&#x3D;2 textwidth&#x3D;120autocmd FileType python setlocal tabstop&#x3D;4 shiftwidth&#x3D;4 softtabstop&#x3D;4 textwidth&#x3D;120autocmd FileType html,htmldjango,xhtml,haml setlocal tabstop&#x3D;2 shiftwidth&#x3D;2 softtabstop&#x3D;2 textwidth&#x3D;0autocmd FileType sass,scss,css setlocal tabstop&#x3D;2 shiftwidth&#x3D;2 softtabstop&#x3D;2 textwidth&#x3D;120&quot; syntax supportautocmd Syntax javascript set syntax&#x3D;jquery &quot; JQuery syntax support&quot; jslet g:html_indent_inctags &#x3D; &quot;html,body,head,tbody&quot;let g:html_indent_script1 &#x3D; &quot;inc&quot;let g:html_indent_style1 &#x3D; &quot;inc&quot;&quot;-----------------&quot; Plugin settings&quot;-----------------&quot; Rainbow parentheses for Lisp and variantslet g:rbpt_colorpairs &#x3D; [ \\ [&#39;brown&#39;, &#39;RoyalBlue3&#39;], \\ [&#39;Darkblue&#39;, &#39;SeaGreen3&#39;], \\ [&#39;darkgray&#39;, &#39;DarkOrchid3&#39;], \\ [&#39;darkgreen&#39;, &#39;firebrick3&#39;], \\ [&#39;darkcyan&#39;, &#39;RoyalBlue3&#39;], \\ [&#39;darkred&#39;, &#39;SeaGreen3&#39;], \\ [&#39;darkmagenta&#39;, &#39;DarkOrchid3&#39;], \\ [&#39;brown&#39;, &#39;firebrick3&#39;], \\ [&#39;gray&#39;, &#39;RoyalBlue3&#39;], \\ [&#39;black&#39;, &#39;SeaGreen3&#39;], \\ [&#39;darkmagenta&#39;, &#39;DarkOrchid3&#39;], \\ [&#39;Darkblue&#39;, &#39;firebrick3&#39;], \\ [&#39;darkgreen&#39;, &#39;RoyalBlue3&#39;], \\ [&#39;darkcyan&#39;, &#39;SeaGreen3&#39;], \\ [&#39;darkred&#39;, &#39;DarkOrchid3&#39;], \\ [&#39;red&#39;, &#39;firebrick3&#39;], \\ ]let g:rbpt_max &#x3D; 16autocmd Syntax lisp,scheme,clojure,racket RainbowParenthesesToggle&quot; tabbarlet g:Tb_MaxSize &#x3D; 2let g:Tb_TabWrap &#x3D; 1hi Tb_Normal guifg&#x3D;white ctermfg&#x3D;whitehi Tb_Changed guifg&#x3D;green ctermfg&#x3D;greenhi Tb_VisibleNormal ctermbg&#x3D;252 ctermfg&#x3D;235hi Tb_VisibleChanged guifg&#x3D;green ctermbg&#x3D;252 ctermfg&#x3D;white&quot; easy-motionlet g:EasyMotion_leader_key &#x3D; &#39;&lt;span class&#x3D;&quot;hljs-tag&quot;&gt;&lt;span class&#x3D;&quot;hljs-tag&quot;&gt;&lt;&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;hljs-name&quot;&gt;&lt;span class&#x3D;&quot;hljs-tag&quot;&gt;&lt;span class&#x3D;&quot;hljs-name&quot;&gt;Leader&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;hljs-tag&quot;&gt;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&#39;&quot; Tagbarlet g:tagbar_left&#x3D;1let g:tagbar_width&#x3D;30let g:tagbar_autofocus &#x3D; 1let g:tagbar_sort &#x3D; 0let g:tagbar_compact &#x3D; 1&quot; tag for coffeeif executable(&#39;coffeetags&#39;) let g:tagbar_type_coffee &#x3D; &#123; \\ &#39;ctagsbin&#39; : &#39;coffeetags&#39;, \\ &#39;ctagsargs&#39; : &#39;&#39;, \\ &#39;kinds&#39; : [ \\ &#39;f:functions&#39;, \\ &#39;o:object&#39;, \\ ], \\ &#39;sro&#39; : &quot;.&quot;, \\ &#39;kind2scope&#39; : &#123; \\ &#39;f&#39; : &#39;object&#39;, \\ &#39;o&#39; : &#39;object&#39;, \\ &#125; \\ &#125; let g:tagbar_type_markdown &#x3D; &#123; \\ &#39;ctagstype&#39; : &#39;markdown&#39;, \\ &#39;sort&#39; : 0, \\ &#39;kinds&#39; : [ \\ &#39;h:sections&#39; \\ ] \\ &#125;endif&quot; Nerd Treelet NERDChristmasTree&#x3D;0let NERDTreeWinSize&#x3D;30let NERDTreeChDirMode&#x3D;2let NERDTreeIgnore&#x3D;[&#39;\\~$&#39;, &#39;\\.pyc$&#39;, &#39;\\.swp$&#39;]&quot; let NERDTreeSortOrder&#x3D;[&#39;^__\\.py$&#39;, &#39;\\&#x2F;$&#39;, &#39;*&#39;, &#39;\\.swp$&#39;, &#39;\\~$&#39;]let NERDTreeShowBookmarks&#x3D;1let NERDTreeWinPos &#x3D; &quot;right&quot;&quot; nerdcommenterlet NERDSpaceDelims&#x3D;1&quot; Quickly edit&#x2F;reload the vimrc filenmap &lt;silent&gt; &lt;leader&gt;ev :e $MYVIMRC&lt;CR&gt; nmap &lt;silent&gt; &lt;leader&gt;sv :so $MYVIMRC&lt;CR&gt;&quot; sublime key bindingsnmap &lt;D-]&gt; &gt;&gt; nmap &lt;D-[&gt; &lt;&lt; vmap &lt;D-[&gt; &lt;gv vmap &lt;D-]&gt; &gt;gv&quot; eggcache vimnnoremap ; ::command W w:command WQ wq:command Wq wq:command Q q:command Qa qa:command QA qa&quot; for macvimif has(&quot;gui_running&quot;) set go&#x3D;aAce &quot; remove toolbar &quot;set transparency&#x3D;30 set guifont&#x3D;Monaco:h13 set showtabline&#x3D;2 set columns&#x3D;140 set lines&#x3D;40 noremap &lt;D-M-Left&gt; :tabprevious&lt;cr&gt; noremap &lt;D-M-Right&gt; :tabnext&lt;cr&gt; map &lt;D-1&gt; 1gt map &lt;D-2&gt; 2gt map &lt;D-3&gt; 3gt map &lt;D-4&gt; 4gt map &lt;D-5&gt; 5gt map &lt;D-6&gt; 6gt map &lt;D-7&gt; 7gt map &lt;D-8&gt; 8gt map &lt;D-9&gt; 9gt map &lt;D-0&gt; :tablast&lt;cr&gt;endif 配置文件312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253&quot; Modeline and Notes &#123;&quot; vim: set sw&#x3D;4 ts&#x3D;4 sts&#x3D;4 et tw&#x3D;78 foldmarker&#x3D;&#123;,&#125; foldlevel&#x3D;0 foldmethod&#x3D;marker spell:&quot;&quot; __ _ _____ _&quot; ___ _ __ &#x2F; _&#x2F; |___ &#x2F; __ __(_)_ __ ___&quot; &#x2F; __| &#39;_ \\| |_| | |_ \\ _____\\ \\ &#x2F; &#x2F;| | &#39;_ &#96; _ \\&quot; \\__ \\ |_) | _| |___) |_____|\\ V &#x2F; | | | | | | |&quot; |___&#x2F; .__&#x2F;|_| |_|____&#x2F; \\_&#x2F; |_|_| |_| |_|&quot; |_|&quot;&quot; This is the personal .vimrc file of Steve Francia.&quot; While much of it is beneficial for general use, I would&quot; recommend picking out the parts you want and understand.&quot;&quot; You can find me at http:&#x2F;&#x2F;spf13.com&quot;&quot; Copyright 2014 Steve Francia&quot;&quot; Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&quot; you may not use this file except in compliance with the License.&quot; You may obtain a copy of the License at&quot;&quot; http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0&quot;&quot; Unless required by applicable law or agreed to in writing, software&quot; distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&quot; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot; See the License for the specific language governing permissions and&quot; limitations under the License.&quot; &#125;&quot; Environment &#123; &quot; Identify platform &#123; silent function! OSX() return has(&#39;macunix&#39;) endfunction silent function! LINUX() return has(&#39;unix&#39;) &amp;&amp; !has(&#39;macunix&#39;) &amp;&amp; !has(&#39;win32unix&#39;) endfunction silent function! WINDOWS() return (has(&#39;win32&#39;) || has(&#39;win64&#39;)) endfunction &quot; &#125; &quot; Basics &#123; set nocompatible &quot; Must be first line if !WINDOWS() set shell&#x3D;&#x2F;bin&#x2F;sh endif &quot; &#125; &quot; Windows Compatible &#123; &quot; On Windows, also use &#39;.vim&#39; instead of &#39;vimfiles&#39;; this makes synchronization &quot; across (heterogeneous) systems easier. if WINDOWS() set runtimepath&#x3D;$HOME&#x2F;.vim,$VIM&#x2F;vimfiles,$VIMRUNTIME,$VIM&#x2F;vimfiles&#x2F;after,$HOME&#x2F;.vim&#x2F;after endif &quot; &#125; &quot; Arrow Key Fix &#123; &quot; https:&#x2F;&#x2F;github.com&#x2F;spf13&#x2F;spf13-vim&#x2F;issues&#x2F;780 if &amp;term[:4] &#x3D;&#x3D; &quot;xterm&quot; || &amp;term[:5] &#x3D;&#x3D; &#39;screen&#39; || &amp;term[:3] &#x3D;&#x3D; &#39;rxvt&#39; inoremap &lt;silent&gt; &lt;C-[&gt;OC &lt;RIGHT&gt; endif &quot; &#125;&quot; &#125;&quot; Use before config if available &#123; if filereadable(expand(&quot;~&#x2F;.vimrc.before&quot;)) source ~&#x2F;.vimrc.before endif&quot; &#125;&quot; Use bundles config &#123; if filereadable(expand(&quot;~&#x2F;.vimrc.bundles&quot;)) source ~&#x2F;.vimrc.bundles endif&quot; &#125;&quot; General &#123; set background&#x3D;dark &quot; Assume a dark background &quot; Allow to trigger background function! ToggleBG() let s:tbg &#x3D; &amp;background &quot; Inversion if s:tbg &#x3D;&#x3D; &quot;dark&quot; set background&#x3D;light else set background&#x3D;dark endif endfunction noremap &lt;leader&gt;bg :call ToggleBG()&lt;CR&gt; &quot; if !has(&#39;gui&#39;) &quot;set term&#x3D;$TERM &quot; Make arrow and other keys work &quot; endif filetype plugin indent on &quot; Automatically detect file types. syntax on &quot; Syntax highlighting set mouse&#x3D;a &quot; Automatically enable mouse usage set mousehide &quot; Hide the mouse cursor while typing scriptencoding utf-8 if has(&#39;clipboard&#39;) if has(&#39;unnamedplus&#39;) &quot; When possible use + register for copy-paste set clipboard&#x3D;unnamed,unnamedplus else &quot; On mac and Windows, use * register for copy-paste set clipboard&#x3D;unnamed endif endif &quot; Most prefer to automatically switch to the current file directory when &quot; a new buffer is opened; to prevent this behavior, add the following to &quot; your .vimrc.before.local file: &quot; let g:spf13_no_autochdir &#x3D; 1 if !exists(&#39;g:spf13_no_autochdir&#39;) autocmd BufEnter * if bufname(&quot;&quot;) !~ &quot;^\\[A-Za-z0-9\\]*:&#x2F;&#x2F;&quot; | lcd %:p:h | endif &quot; Always switch to the current file directory endif &quot;set autowrite &quot; Automatically write a file when leaving a modified buffer set shortmess+&#x3D;filmnrxoOtT &quot; Abbrev. of messages (avoids &#39;hit enter&#39;) set viewoptions&#x3D;folds,options,cursor,unix,slash &quot; Better Unix &#x2F; Windows compatibility set virtualedit&#x3D;onemore &quot; Allow for cursor beyond last character set history&#x3D;1000 &quot; Store a ton of history (default is 20) set spell &quot; Spell checking on set hidden &quot; Allow buffer switching without saving set iskeyword-&#x3D;. &quot; &#39;.&#39; is an end of word designator set iskeyword-&#x3D;# &quot; &#39;#&#39; is an end of word designator set iskeyword-&#x3D;- &quot; &#39;-&#39; is an end of word designator &quot; Instead of reverting the cursor to the last position in the buffer, we &quot; set it to the first line when editing a git commit message au FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos(&#39;.&#39;, [0, 1, 1, 0]) &quot; http:&#x2F;&#x2F;vim.wikia.com&#x2F;wiki&#x2F;Restore_cursor_to_file_position_in_previous_editing_session &quot; Restore cursor to file position in previous editing session &quot; To disable this, add the following to your .vimrc.before.local file: &quot; let g:spf13_no_restore_cursor &#x3D; 1 if !exists(&#39;g:spf13_no_restore_cursor&#39;) function! ResCur() if line(&quot;&#39;\\&quot;&quot;) &lt;&#x3D; line(&quot;$&quot;) silent! normal! g&#96;&quot; return 1 endif endfunction augroup resCur autocmd! autocmd BufWinEnter * call ResCur() augroup END endif &quot; Setting up the directories &#123; set backup &quot; Backups are nice ... if has(&#39;persistent_undo&#39;) set undofile &quot; So is persistent undo ... set undolevels&#x3D;1000 &quot; Maximum number of changes that can be undone set undoreload&#x3D;10000 &quot; Maximum number lines to save for undo on a buffer reload endif &quot; To disable views add the following to your .vimrc.before.local file: &quot; let g:spf13_no_views &#x3D; 1 if !exists(&#39;g:spf13_no_views&#39;) &quot; Add exclusions to mkview and loadview &quot; eg: *.*, svn-commit.tmp let g:skipview_files &#x3D; [ \\ &#39;\\[example pattern\\]&#39; \\ ] endif &quot; &#125;&quot; &#125;&quot; Vim UI &#123; if !exists(&#39;g:override_spf13_bundles&#39;) &amp;&amp; filereadable(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;vim-colors-solarized&#x2F;colors&#x2F;solarized.vim&quot;)) let g:solarized_termcolors&#x3D;256 let g:solarized_termtrans&#x3D;1 let g:solarized_contrast&#x3D;&quot;normal&quot; let g:solarized_visibility&#x3D;&quot;normal&quot; color solarized &quot; Load a colorscheme endif set tabpagemax&#x3D;15 &quot; Only show 15 tabs set showmode &quot; Display the current mode set cursorline &quot; Highlight current line highlight clear SignColumn &quot; SignColumn should match background highlight clear LineNr &quot; Current line number row will have same background color in relative mode &quot;highlight clear CursorLineNr &quot; Remove highlight color from current line number if has(&#39;cmdline_info&#39;) set ruler &quot; Show the ruler set rulerformat&#x3D;%30(%&#x3D;\\:b%n%y%m%r%w\\ %l,%c%V\\ %P%) &quot; A ruler on steroids set showcmd &quot; Show partial commands in status line and &quot; Selected characters&#x2F;lines in visual mode endif if has(&#39;statusline&#39;) set laststatus&#x3D;2 &quot; Broken down into easily includeable segments set statusline&#x3D;%&lt;%f\\ &quot; Filename set statusline+&#x3D;%w%h%m%r &quot; Options if !exists(&#39;g:override_spf13_bundles&#39;) set statusline+&#x3D;%&#123;fugitive#statusline()&#125; &quot; Git Hotness endif set statusline+&#x3D;\\ [%&#123;&amp;ff&#125;&#x2F;%Y] &quot; Filetype set statusline+&#x3D;\\ [%&#123;getcwd()&#125;] &quot; Current dir set statusline+&#x3D;%&#x3D;%-14.(%l,%c%V%)\\ %p%% &quot; Right aligned file nav info endif set backspace&#x3D;indent,eol,start &quot; Backspace for dummies set linespace&#x3D;0 &quot; No extra spaces between rows set number &quot; Line numbers on set showmatch &quot; Show matching brackets&#x2F;parenthesis set incsearch &quot; Find as you type search set hlsearch &quot; Highlight search terms set winminheight&#x3D;0 &quot; Windows can be 0 line high set ignorecase &quot; Case insensitive search set smartcase &quot; Case sensitive when uc present set wildmenu &quot; Show list instead of just completing set wildmode&#x3D;list:longest,full &quot; Command &lt;Tab&gt; completion, list matches, then longest common part, then all. set whichwrap&#x3D;b,s,h,l,&lt;,&gt;,[,] &quot; Backspace and cursor keys wrap too set scrolljump&#x3D;5 &quot; Lines to scroll when cursor leaves screen set scrolloff&#x3D;3 &quot; Minimum lines to keep above and below cursor set foldenable &quot; Auto fold code set list set listchars&#x3D;tab:›\\ ,trail:•,extends:#,nbsp:. &quot; Highlight problematic whitespace&quot; &#125;&quot; Formatting &#123; set nowrap &quot; Do not wrap long lines set autoindent &quot; Indent at the same level of the previous line set shiftwidth&#x3D;4 &quot; Use indents of 4 spaces set expandtab &quot; Tabs are spaces, not tabs set tabstop&#x3D;4 &quot; An indentation every four columns set softtabstop&#x3D;4 &quot; Let backspace delete indent set nojoinspaces &quot; Prevents inserting two spaces after punctuation on a join (J) set splitright &quot; Puts new vsplit windows to the right of the current set splitbelow &quot; Puts new split windows to the bottom of the current &quot;set matchpairs+&#x3D;&lt;:&gt; &quot; Match, to be used with % set pastetoggle&#x3D;&lt;F12&gt; &quot; pastetoggle (sane indentation on pastes) &quot;set comments&#x3D;sl:&#x2F;*,mb:*,elx:*&#x2F; &quot; auto format comment blocks &quot; Remove trailing whitespaces and ^M chars &quot; To disable the stripping of whitespace, add the following to your &quot; .vimrc.before.local file: &quot; let g:spf13_keep_trailing_whitespace &#x3D; 1 autocmd FileType c,cpp,java,go,php,javascript,puppet,python,rust,twig,xml,yml,perl,sql autocmd BufWritePre &lt;buffer&gt; if !exists(&#39;g:spf13_keep_trailing_whitespace&#39;) | call StripTrailingWhitespace() | endif &quot;autocmd FileType go autocmd BufWritePre &lt;buffer&gt; Fmt autocmd BufNewFile,BufRead *.html.twig set filetype&#x3D;html.twig autocmd FileType haskell,puppet,ruby,yml setlocal expandtab shiftwidth&#x3D;2 softtabstop&#x3D;2 &quot; preceding line best in a plugin but here for now. autocmd BufNewFile,BufRead *.coffee set filetype&#x3D;coffee &quot; Workaround vim-commentary for Haskell autocmd FileType haskell setlocal commentstring&#x3D;--\\ %s &quot; Workaround broken colour highlighting in Haskell autocmd FileType haskell,rust setlocal nospell&quot; &#125;&quot; Key (re)Mappings &#123; &quot; The default leader is &#39;\\&#39;, but many people prefer &#39;,&#39; as it&#39;s in a standard &quot; location. To override this behavior and set it back to &#39;\\&#39; (or any other &quot; character) add the following to your .vimrc.before.local file: &quot; let g:spf13_leader&#x3D;&#39;\\&#39; if !exists(&#39;g:spf13_leader&#39;) let mapleader &#x3D; &#39;,&#39; else let mapleader&#x3D;g:spf13_leader endif if !exists(&#39;g:spf13_localleader&#39;) let maplocalleader &#x3D; &#39;_&#39; else let maplocalleader&#x3D;g:spf13_localleader endif &quot; The default mappings for editing and applying the spf13 configuration &quot; are &lt;leader&gt;ev and &lt;leader&gt;sv respectively. Change them to your preference &quot; by adding the following to your .vimrc.before.local file: &quot; let g:spf13_edit_config_mapping&#x3D;&#39;&lt;leader&gt;ec&#39; &quot; let g:spf13_apply_config_mapping&#x3D;&#39;&lt;leader&gt;sc&#39; if !exists(&#39;g:spf13_edit_config_mapping&#39;) let s:spf13_edit_config_mapping &#x3D; &#39;&lt;leader&gt;ev&#39; else let s:spf13_edit_config_mapping &#x3D; g:spf13_edit_config_mapping endif if !exists(&#39;g:spf13_apply_config_mapping&#39;) let s:spf13_apply_config_mapping &#x3D; &#39;&lt;leader&gt;sv&#39; else let s:spf13_apply_config_mapping &#x3D; g:spf13_apply_config_mapping endif &quot; Easier moving in tabs and windows &quot; The lines conflict with the default digraph mapping of &lt;C-K&gt; &quot; If you prefer that functionality, add the following to your &quot; .vimrc.before.local file: &quot; let g:spf13_no_easyWindows &#x3D; 1 if !exists(&#39;g:spf13_no_easyWindows&#39;) map &lt;C-J&gt; &lt;C-W&gt;j&lt;C-W&gt;_ map &lt;C-K&gt; &lt;C-W&gt;k&lt;C-W&gt;_ map &lt;C-L&gt; &lt;C-W&gt;l&lt;C-W&gt;_ map &lt;C-H&gt; &lt;C-W&gt;h&lt;C-W&gt;_ endif &quot; Wrapped lines goes down&#x2F;up to next row, rather than next line in file. noremap j gj noremap k gk &quot; End&#x2F;Start of line motion keys act relative to row&#x2F;wrap width in the &quot; presence of &#96;:set wrap&#96;, and relative to line for &#96;:set nowrap&#96;. &quot; Default vim behaviour is to act relative to text line in both cases &quot; If you prefer the default behaviour, add the following to your &quot; .vimrc.before.local file: &quot; let g:spf13_no_wrapRelMotion &#x3D; 1 if !exists(&#39;g:spf13_no_wrapRelMotion&#39;) &quot; Same for 0, home, end, etc function! WrapRelativeMotion(key, ...) let vis_sel&#x3D;&quot;&quot; if a:0 let vis_sel&#x3D;&quot;gv&quot; endif if &amp;wrap execute &quot;normal!&quot; vis_sel . &quot;g&quot; . a:key else execute &quot;normal!&quot; vis_sel . a:key endif endfunction &quot; Map g* keys in Normal, Operator-pending, and Visual+select noremap $ :call WrapRelativeMotion(&quot;$&quot;)&lt;CR&gt; noremap &lt;End&gt; :call WrapRelativeMotion(&quot;$&quot;)&lt;CR&gt; noremap 0 :call WrapRelativeMotion(&quot;0&quot;)&lt;CR&gt; noremap &lt;Home&gt; :call WrapRelativeMotion(&quot;0&quot;)&lt;CR&gt; noremap ^ :call WrapRelativeMotion(&quot;^&quot;)&lt;CR&gt; &quot; Overwrite the operator pending $&#x2F;&lt;End&gt; mappings from above &quot; to force inclusive motion with :execute normal! onoremap $ v:call WrapRelativeMotion(&quot;$&quot;)&lt;CR&gt; onoremap &lt;End&gt; v:call WrapRelativeMotion(&quot;$&quot;)&lt;CR&gt; &quot; Overwrite the Visual+select mode mappings from above &quot; to ensure the correct vis_sel flag is passed to function vnoremap $ :&lt;C-U&gt;call WrapRelativeMotion(&quot;$&quot;, 1)&lt;CR&gt; vnoremap &lt;End&gt; :&lt;C-U&gt;call WrapRelativeMotion(&quot;$&quot;, 1)&lt;CR&gt; vnoremap 0 :&lt;C-U&gt;call WrapRelativeMotion(&quot;0&quot;, 1)&lt;CR&gt; vnoremap &lt;Home&gt; :&lt;C-U&gt;call WrapRelativeMotion(&quot;0&quot;, 1)&lt;CR&gt; vnoremap ^ :&lt;C-U&gt;call WrapRelativeMotion(&quot;^&quot;, 1)&lt;CR&gt; endif &quot; The following two lines conflict with moving to top and &quot; bottom of the screen &quot; If you prefer that functionality, add the following to your &quot; .vimrc.before.local file: &quot; let g:spf13_no_fastTabs &#x3D; 1 if !exists(&#39;g:spf13_no_fastTabs&#39;) map &lt;S-H&gt; gT map &lt;S-L&gt; gt endif &quot; Stupid shift key fixes if !exists(&#39;g:spf13_no_keyfixes&#39;) if has(&quot;user_commands&quot;) command! -bang -nargs&#x3D;* -complete&#x3D;file E e&lt;bang&gt; &lt;args&gt; command! -bang -nargs&#x3D;* -complete&#x3D;file W w&lt;bang&gt; &lt;args&gt; command! -bang -nargs&#x3D;* -complete&#x3D;file Wq wq&lt;bang&gt; &lt;args&gt; command! -bang -nargs&#x3D;* -complete&#x3D;file WQ wq&lt;bang&gt; &lt;args&gt; command! -bang Wa wa&lt;bang&gt; command! -bang WA wa&lt;bang&gt; command! -bang Q q&lt;bang&gt; command! -bang QA qa&lt;bang&gt; command! -bang Qa qa&lt;bang&gt; endif cmap Tabe tabe endif &quot; Yank from the cursor to the end of the line, to be consistent with C and D. nnoremap Y y$ &quot; Code folding options nmap &lt;leader&gt;f0 :set foldlevel&#x3D;0&lt;CR&gt; nmap &lt;leader&gt;f1 :set foldlevel&#x3D;1&lt;CR&gt; nmap &lt;leader&gt;f2 :set foldlevel&#x3D;2&lt;CR&gt; nmap &lt;leader&gt;f3 :set foldlevel&#x3D;3&lt;CR&gt; nmap &lt;leader&gt;f4 :set foldlevel&#x3D;4&lt;CR&gt; nmap &lt;leader&gt;f5 :set foldlevel&#x3D;5&lt;CR&gt; nmap &lt;leader&gt;f6 :set foldlevel&#x3D;6&lt;CR&gt; nmap &lt;leader&gt;f7 :set foldlevel&#x3D;7&lt;CR&gt; nmap &lt;leader&gt;f8 :set foldlevel&#x3D;8&lt;CR&gt; nmap &lt;leader&gt;f9 :set foldlevel&#x3D;9&lt;CR&gt; &quot; Most prefer to toggle search highlighting rather than clear the current &quot; search results. To clear search highlighting rather than toggle it on &quot; and off, add the following to your .vimrc.before.local file: &quot; let g:spf13_clear_search_highlight &#x3D; 1 if exists(&#39;g:spf13_clear_search_highlight&#39;) nmap &lt;silent&gt; &lt;leader&gt;&#x2F; :nohlsearch&lt;CR&gt; else nmap &lt;silent&gt; &lt;leader&gt;&#x2F; :set invhlsearch&lt;CR&gt; endif &quot; Find merge conflict markers map &lt;leader&gt;fc &#x2F;\\v^[&lt;\\|&#x3D;&gt;]&#123;7&#125;( .*\\|$)&lt;CR&gt; &quot; Shortcuts &quot; Change Working Directory to that of the current file cmap cwd lcd %:p:h cmap cd. lcd %:p:h &quot; Visual shifting (does not exit Visual mode) vnoremap &lt; &lt;gv vnoremap &gt; &gt;gv &quot; Allow using the repeat operator with a visual selection (!) &quot; http:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;8064607&#x2F;127816 vnoremap . :normal .&lt;CR&gt; &quot; For when you forget to sudo.. Really Write the file. cmap w!! w !sudo tee % &gt;&#x2F;dev&#x2F;null &quot; Some helpers to edit mode &quot; http:&#x2F;&#x2F;vimcasts.org&#x2F;e&#x2F;14 cnoremap %% &lt;C-R&gt;&#x3D;fnameescape(expand(&#39;%:h&#39;)).&#39;&#x2F;&#39;&lt;cr&gt; map &lt;leader&gt;ew :e %% map &lt;leader&gt;es :sp %% map &lt;leader&gt;ev :vsp %% map &lt;leader&gt;et :tabe %% &quot; Adjust viewports to the same size map &lt;Leader&gt;&#x3D; &lt;C-w&gt;&#x3D; &quot; Map &lt;Leader&gt;ff to display all lines with keyword under cursor &quot; and ask which one to jump to nmap &lt;Leader&gt;ff [I:let nr &#x3D; input(&quot;Which one: &quot;)&lt;Bar&gt;exe &quot;normal &quot; . nr .&quot;[\\t&quot;&lt;CR&gt; &quot; Easier horizontal scrolling map zl zL map zh zH &quot; Easier formatting nnoremap &lt;silent&gt; &lt;leader&gt;q gwip &quot; FIXME: Revert this f70be548 &quot; fullscreen mode for GVIM and Terminal, need &#39;wmctrl&#39; in you PATH map &lt;silent&gt; &lt;F11&gt; :call system(&quot;wmctrl -ir &quot; . v:windowid . &quot; -b toggle,fullscreen&quot;)&lt;CR&gt;&quot; &#125;&quot; Plugins &#123; &quot; GoLang &#123; if count(g:spf13_bundle_groups, &#39;go&#39;) let g:go_highlight_functions &#x3D; 1 let g:go_highlight_methods &#x3D; 1 let g:go_highlight_structs &#x3D; 1 let g:go_highlight_operators &#x3D; 1 let g:go_highlight_build_constraints &#x3D; 1 let g:go_fmt_command &#x3D; &quot;goimports&quot; let g:syntastic_go_checkers &#x3D; [&#39;golint&#39;, &#39;govet&#39;, &#39;errcheck&#39;] let g:syntastic_mode_map &#x3D; &#123; &#39;mode&#39;: &#39;active&#39;, &#39;passive_filetypes&#39;: [&#39;go&#39;] &#125; au FileType go nmap &lt;Leader&gt;s &lt;Plug&gt;(go-implements) au FileType go nmap &lt;Leader&gt;i &lt;Plug&gt;(go-info) au FileType go nmap &lt;Leader&gt;e &lt;Plug&gt;(go-rename) au FileType go nmap &lt;leader&gt;r &lt;Plug&gt;(go-run) au FileType go nmap &lt;leader&gt;b &lt;Plug&gt;(go-build) au FileType go nmap &lt;leader&gt;t &lt;Plug&gt;(go-test) au FileType go nmap &lt;Leader&gt;gd &lt;Plug&gt;(go-doc) au FileType go nmap &lt;Leader&gt;gv &lt;Plug&gt;(go-doc-vertical) au FileType go nmap &lt;leader&gt;co &lt;Plug&gt;(go-coverage) endif &quot; &#125; &quot; TextObj Sentence &#123; if count(g:spf13_bundle_groups, &#39;writing&#39;) augroup textobj_sentence autocmd! autocmd FileType markdown call textobj#sentence#init() autocmd FileType textile call textobj#sentence#init() autocmd FileType text call textobj#sentence#init() augroup END endif &quot; &#125; &quot; TextObj Quote &#123; if count(g:spf13_bundle_groups, &#39;writing&#39;) augroup textobj_quote autocmd! autocmd FileType markdown call textobj#quote#init() autocmd FileType textile call textobj#quote#init() autocmd FileType text call textobj#quote#init(&#123;&#39;educate&#39;: 0&#125;) augroup END endif &quot; &#125; &quot; PIV &#123; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;PIV&quot;)) let g:DisableAutoPHPFolding &#x3D; 0 let g:PIVAutoClose &#x3D; 0 endif &quot; &#125; &quot; Misc &#123; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;nerdtree&quot;)) let g:NERDShutUp&#x3D;1 endif if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;matchit.zip&quot;)) let b:match_ignorecase &#x3D; 1 endif &quot; &#125; &quot; OmniComplete &#123; &quot; To disable omni complete, add the following to your .vimrc.before.local file: &quot; let g:spf13_no_omni_complete &#x3D; 1 if !exists(&#39;g:spf13_no_omni_complete&#39;) if has(&quot;autocmd&quot;) &amp;&amp; exists(&quot;+omnifunc&quot;) autocmd Filetype * \\if &amp;omnifunc &#x3D;&#x3D; &quot;&quot; | \\setlocal omnifunc&#x3D;syntaxcomplete#Complete | \\endif endif hi Pmenu guifg&#x3D;#000000 guibg&#x3D;#F8F8F8 ctermfg&#x3D;black ctermbg&#x3D;Lightgray hi PmenuSbar guifg&#x3D;#8A95A7 guibg&#x3D;#F8F8F8 gui&#x3D;NONE ctermfg&#x3D;darkcyan ctermbg&#x3D;lightgray cterm&#x3D;NONE hi PmenuThumb guifg&#x3D;#F8F8F8 guibg&#x3D;#8A95A7 gui&#x3D;NONE ctermfg&#x3D;lightgray ctermbg&#x3D;darkcyan cterm&#x3D;NONE &quot; Some convenient mappings &quot;inoremap &lt;expr&gt; &lt;Esc&gt; pumvisible() ? &quot;\\&lt;C-e&gt;&quot; : &quot;\\&lt;Esc&gt;&quot; if exists(&#39;g:spf13_map_cr_omni_complete&#39;) inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\\&lt;C-y&gt;&quot; : &quot;\\&lt;CR&gt;&quot; endif inoremap &lt;expr&gt; &lt;Down&gt; pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : &quot;\\&lt;Down&gt;&quot; inoremap &lt;expr&gt; &lt;Up&gt; pumvisible() ? &quot;\\&lt;C-p&gt;&quot; : &quot;\\&lt;Up&gt;&quot; inoremap &lt;expr&gt; &lt;C-d&gt; pumvisible() ? &quot;\\&lt;PageDown&gt;\\&lt;C-p&gt;\\&lt;C-n&gt;&quot; : &quot;\\&lt;C-d&gt;&quot; inoremap &lt;expr&gt; &lt;C-u&gt; pumvisible() ? &quot;\\&lt;PageUp&gt;\\&lt;C-p&gt;\\&lt;C-n&gt;&quot; : &quot;\\&lt;C-u&gt;&quot; &quot; Automatically open and close the popup menu &#x2F; preview window au CursorMovedI,InsertLeave * if pumvisible() &#x3D;&#x3D; 0|silent! pclose|endif set completeopt&#x3D;menu,preview,longest endif &quot; &#125; &quot; Ctags &#123; set tags&#x3D;.&#x2F;tags;&#x2F;,~&#x2F;.vimtags &quot; Make tags placed in .git&#x2F;tags file available in all levels of a repository let gitroot &#x3D; substitute(system(&#39;git rev-parse --show-toplevel&#39;), &#39;[\\n\\r]&#39;, &#39;&#39;, &#39;g&#39;) if gitroot !&#x3D; &#39;&#39; let &amp;tags &#x3D; &amp;tags . &#39;,&#39; . gitroot . &#39;&#x2F;.git&#x2F;tags&#39; endif &quot; &#125; &quot; AutoCloseTag &#123; &quot; Make it so AutoCloseTag works for xml and xhtml files as well au FileType xhtml,xml ru ftplugin&#x2F;html&#x2F;autoclosetag.vim nmap &lt;Leader&gt;ac &lt;Plug&gt;ToggleAutoCloseMappings &quot; &#125; &quot; SnipMate &#123; &quot; Setting the author var &quot; If forking, please overwrite in your .vimrc.local file let g:snips_author &#x3D; &#39;Steve Francia &lt;steve.francia@gmail.com&gt;&#39; &quot; &#125; &quot; NerdTree &#123; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;nerdtree&quot;)) map &lt;C-e&gt; &lt;plug&gt;NERDTreeTabsToggle&lt;CR&gt; map &lt;leader&gt;e :NERDTreeFind&lt;CR&gt; nmap &lt;leader&gt;nt :NERDTreeFind&lt;CR&gt; let NERDTreeShowBookmarks&#x3D;1 let NERDTreeIgnore&#x3D;[&#39;\\.py[cd]$&#39;, &#39;\\~$&#39;, &#39;\\.swo$&#39;, &#39;\\.swp$&#39;, &#39;^\\.git$&#39;, &#39;^\\.hg$&#39;, &#39;^\\.svn$&#39;, &#39;\\.bzr$&#39;] let NERDTreeChDirMode&#x3D;0 let NERDTreeQuitOnOpen&#x3D;1 let NERDTreeMouseMode&#x3D;2 let NERDTreeShowHidden&#x3D;1 let NERDTreeKeepTreeInNewTab&#x3D;1 let g:nerdtree_tabs_open_on_gui_startup&#x3D;0 endif &quot; &#125; &quot; Tabularize &#123; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;tabular&quot;)) nmap &lt;Leader&gt;a&amp; :Tabularize &#x2F;&amp;&lt;CR&gt; vmap &lt;Leader&gt;a&amp; :Tabularize &#x2F;&amp;&lt;CR&gt; nmap &lt;Leader&gt;a&#x3D; :Tabularize &#x2F;^[^&#x3D;]*\\zs&#x3D;&lt;CR&gt; vmap &lt;Leader&gt;a&#x3D; :Tabularize &#x2F;^[^&#x3D;]*\\zs&#x3D;&lt;CR&gt; nmap &lt;Leader&gt;a&#x3D;&gt; :Tabularize &#x2F;&#x3D;&gt;&lt;CR&gt; vmap &lt;Leader&gt;a&#x3D;&gt; :Tabularize &#x2F;&#x3D;&gt;&lt;CR&gt; nmap &lt;Leader&gt;a: :Tabularize &#x2F;:&lt;CR&gt; vmap &lt;Leader&gt;a: :Tabularize &#x2F;:&lt;CR&gt; nmap &lt;Leader&gt;a:: :Tabularize &#x2F;:\\zs&lt;CR&gt; vmap &lt;Leader&gt;a:: :Tabularize &#x2F;:\\zs&lt;CR&gt; nmap &lt;Leader&gt;a, :Tabularize &#x2F;,&lt;CR&gt; vmap &lt;Leader&gt;a, :Tabularize &#x2F;,&lt;CR&gt; nmap &lt;Leader&gt;a,, :Tabularize &#x2F;,\\zs&lt;CR&gt; vmap &lt;Leader&gt;a,, :Tabularize &#x2F;,\\zs&lt;CR&gt; nmap &lt;Leader&gt;a&lt;Bar&gt; :Tabularize &#x2F;&lt;Bar&gt;&lt;CR&gt; vmap &lt;Leader&gt;a&lt;Bar&gt; :Tabularize &#x2F;&lt;Bar&gt;&lt;CR&gt; endif &quot; &#125; &quot; Session List &#123; set sessionoptions&#x3D;blank,buffers,curdir,folds,tabpages,winsize if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;sessionman.vim&#x2F;&quot;)) nmap &lt;leader&gt;sl :SessionList&lt;CR&gt; nmap &lt;leader&gt;ss :SessionSave&lt;CR&gt; nmap &lt;leader&gt;sc :SessionClose&lt;CR&gt; endif &quot; &#125; &quot; JSON &#123; nmap &lt;leader&gt;jt &lt;Esc&gt;:%!python -m json.tool&lt;CR&gt;&lt;Esc&gt;:set filetype&#x3D;json&lt;CR&gt; let g:vim_json_syntax_conceal &#x3D; 0 &quot; &#125; &quot; PyMode &#123; &quot; Disable if python support not present if !has(&#39;python&#39;) &amp;&amp; !has(&#39;python3&#39;) let g:pymode &#x3D; 0 endif if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;python-mode&quot;)) let g:pymode_lint_checkers &#x3D; [&#39;pyflakes&#39;] let g:pymode_trim_whitespaces &#x3D; 0 let g:pymode_options &#x3D; 0 let g:pymode_rope &#x3D; 0 endif &quot; &#125; &quot; ctrlp &#123; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;ctrlp.vim&#x2F;&quot;)) let g:ctrlp_working_path_mode &#x3D; &#39;ra&#39; nnoremap &lt;silent&gt; &lt;D-t&gt; :CtrlP&lt;CR&gt; nnoremap &lt;silent&gt; &lt;D-r&gt; :CtrlPMRU&lt;CR&gt; let g:ctrlp_custom_ignore &#x3D; &#123; \\ &#39;dir&#39;: &#39;\\.git$\\|\\.hg$\\|\\.svn$&#39;, \\ &#39;file&#39;: &#39;\\.exe$\\|\\.so$\\|\\.dll$\\|\\.pyc$&#39; &#125; if executable(&#39;ag&#39;) let s:ctrlp_fallback &#x3D; &#39;ag %s --nocolor -l -g &quot;&quot;&#39; elseif executable(&#39;ack-grep&#39;) let s:ctrlp_fallback &#x3D; &#39;ack-grep %s --nocolor -f&#39; elseif executable(&#39;ack&#39;) let s:ctrlp_fallback &#x3D; &#39;ack %s --nocolor -f&#39; &quot; On Windows use &quot;dir&quot; as fallback command. elseif WINDOWS() let s:ctrlp_fallback &#x3D; &#39;dir %s &#x2F;-n &#x2F;b &#x2F;s &#x2F;a-d&#39; else let s:ctrlp_fallback &#x3D; &#39;find %s -type f&#39; endif if exists(&quot;g:ctrlp_user_command&quot;) unlet g:ctrlp_user_command endif let g:ctrlp_user_command &#x3D; &#123; \\ &#39;types&#39;: &#123; \\ 1: [&#39;.git&#39;, &#39;cd %s &amp;&amp; git ls-files . --cached --exclude-standard --others&#39;], \\ 2: [&#39;.hg&#39;, &#39;hg --cwd %s locate -I .&#39;], \\ &#125;, \\ &#39;fallback&#39;: s:ctrlp_fallback \\ &#125; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;ctrlp-funky&#x2F;&quot;)) &quot; CtrlP extensions let g:ctrlp_extensions &#x3D; [&#39;funky&#39;] &quot;funky nnoremap &lt;Leader&gt;fu :CtrlPFunky&lt;Cr&gt; endif endif &quot;&#125; &quot; TagBar &#123; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;tagbar&#x2F;&quot;)) nnoremap &lt;silent&gt; &lt;leader&gt;tt :TagbarToggle&lt;CR&gt; endif &quot;&#125; &quot; Rainbow &#123; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;rainbow&#x2F;&quot;)) let g:rainbow_active &#x3D; 1 &quot;0 if you want to enable it later via :RainbowToggle endif &quot;&#125; &quot; Fugitive &#123; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;vim-fugitive&#x2F;&quot;)) nnoremap &lt;silent&gt; &lt;leader&gt;gs :Gstatus&lt;CR&gt; nnoremap &lt;silent&gt; &lt;leader&gt;gd :Gdiff&lt;CR&gt; nnoremap &lt;silent&gt; &lt;leader&gt;gc :Gcommit&lt;CR&gt; nnoremap &lt;silent&gt; &lt;leader&gt;gb :Gblame&lt;CR&gt; nnoremap &lt;silent&gt; &lt;leader&gt;gl :Glog&lt;CR&gt; nnoremap &lt;silent&gt; &lt;leader&gt;gp :Git push&lt;CR&gt; nnoremap &lt;silent&gt; &lt;leader&gt;gr :Gread&lt;CR&gt; nnoremap &lt;silent&gt; &lt;leader&gt;gw :Gwrite&lt;CR&gt; nnoremap &lt;silent&gt; &lt;leader&gt;ge :Gedit&lt;CR&gt; &quot; Mnemonic _i_nteractive nnoremap &lt;silent&gt; &lt;leader&gt;gi :Git add -p %&lt;CR&gt; nnoremap &lt;silent&gt; &lt;leader&gt;gg :SignifyToggle&lt;CR&gt; endif &quot;&#125; &quot; YouCompleteMe &#123; if count(g:spf13_bundle_groups, &#39;youcompleteme&#39;) let g:acp_enableAtStartup &#x3D; 0 &quot; enable completion from tags let g:ycm_collect_identifiers_from_tags_files &#x3D; 1 &quot; remap Ultisnips for compatibility for YCM let g:UltiSnipsExpandTrigger &#x3D; &#39;&lt;C-j&gt;&#39; let g:UltiSnipsJumpForwardTrigger &#x3D; &#39;&lt;C-j&gt;&#39; let g:UltiSnipsJumpBackwardTrigger &#x3D; &#39;&lt;C-k&gt;&#39; &quot; Enable omni completion. autocmd FileType css setlocal omnifunc&#x3D;csscomplete#CompleteCSS autocmd FileType html,markdown setlocal omnifunc&#x3D;htmlcomplete#CompleteTags autocmd FileType javascript setlocal omnifunc&#x3D;javascriptcomplete#CompleteJS autocmd FileType python setlocal omnifunc&#x3D;pythoncomplete#Complete autocmd FileType xml setlocal omnifunc&#x3D;xmlcomplete#CompleteTags autocmd FileType ruby setlocal omnifunc&#x3D;rubycomplete#Complete autocmd FileType haskell setlocal omnifunc&#x3D;necoghc#omnifunc &quot; Haskell post write lint and check with ghcmod &quot; $ &#96;cabal install ghcmod&#96; if missing and ensure &quot; ~&#x2F;.cabal&#x2F;bin is in your $PATH. if !executable(&quot;ghcmod&quot;) autocmd BufWritePost *.hs GhcModCheckAndLintAsync endif &quot; For snippet_complete marker. if !exists(&quot;g:spf13_no_conceal&quot;) if has(&#39;conceal&#39;) set conceallevel&#x3D;2 concealcursor&#x3D;i endif endif &quot; Disable the neosnippet preview candidate window &quot; When enabled, there can be too much visual noise &quot; especially when splits are used. set completeopt-&#x3D;preview endif &quot; &#125; &quot; neocomplete &#123; if count(g:spf13_bundle_groups, &#39;neocomplete&#39;) let g:acp_enableAtStartup &#x3D; 0 let g:neocomplete#enable_at_startup &#x3D; 1 let g:neocomplete#enable_smart_case &#x3D; 1 let g:neocomplete#enable_auto_delimiter &#x3D; 1 let g:neocomplete#max_list &#x3D; 15 let g:neocomplete#force_overwrite_completefunc &#x3D; 1 &quot; Define dictionary. let g:neocomplete#sources#dictionary#dictionaries &#x3D; &#123; \\ &#39;default&#39; : &#39;&#39;, \\ &#39;vimshell&#39; : $HOME.&#39;&#x2F;.vimshell_hist&#39;, \\ &#39;scheme&#39; : $HOME.&#39;&#x2F;.gosh_completions&#39; \\ &#125; &quot; Define keyword. if !exists(&#39;g:neocomplete#keyword_patterns&#39;) let g:neocomplete#keyword_patterns &#x3D; &#123;&#125; endif let g:neocomplete#keyword_patterns[&#39;default&#39;] &#x3D; &#39;\\h\\w*&#39; &quot; Plugin key-mappings &#123; &quot; These two lines conflict with the default digraph mapping of &lt;C-K&gt; if !exists(&#39;g:spf13_no_neosnippet_expand&#39;) imap &lt;C-k&gt; &lt;Plug&gt;(neosnippet_expand_or_jump) smap &lt;C-k&gt; &lt;Plug&gt;(neosnippet_expand_or_jump) endif if exists(&#39;g:spf13_noninvasive_completion&#39;) inoremap &lt;CR&gt; &lt;CR&gt; &quot; &lt;ESC&gt; takes you out of insert mode inoremap &lt;expr&gt; &lt;Esc&gt; pumvisible() ? &quot;\\&lt;C-y&gt;\\&lt;Esc&gt;&quot; : &quot;\\&lt;Esc&gt;&quot; &quot; &lt;CR&gt; accepts first, then sends the &lt;CR&gt; inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\\&lt;C-y&gt;\\&lt;CR&gt;&quot; : &quot;\\&lt;CR&gt;&quot; &quot; &lt;Down&gt; and &lt;Up&gt; cycle like &lt;Tab&gt; and &lt;S-Tab&gt; inoremap &lt;expr&gt; &lt;Down&gt; pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : &quot;\\&lt;Down&gt;&quot; inoremap &lt;expr&gt; &lt;Up&gt; pumvisible() ? &quot;\\&lt;C-p&gt;&quot; : &quot;\\&lt;Up&gt;&quot; &quot; Jump up and down the list inoremap &lt;expr&gt; &lt;C-d&gt; pumvisible() ? &quot;\\&lt;PageDown&gt;\\&lt;C-p&gt;\\&lt;C-n&gt;&quot; : &quot;\\&lt;C-d&gt;&quot; inoremap &lt;expr&gt; &lt;C-u&gt; pumvisible() ? &quot;\\&lt;PageUp&gt;\\&lt;C-p&gt;\\&lt;C-n&gt;&quot; : &quot;\\&lt;C-u&gt;&quot; else &quot; &lt;C-k&gt; Complete Snippet &quot; &lt;C-k&gt; Jump to next snippet point imap &lt;silent&gt;&lt;expr&gt;&lt;C-k&gt; neosnippet#expandable() ? \\ &quot;\\&lt;Plug&gt;(neosnippet_expand_or_jump)&quot; : (pumvisible() ? \\ &quot;\\&lt;C-e&gt;&quot; : &quot;\\&lt;Plug&gt;(neosnippet_expand_or_jump)&quot;) smap &lt;TAB&gt; &lt;Right&gt;&lt;Plug&gt;(neosnippet_jump_or_expand) inoremap &lt;expr&gt;&lt;C-g&gt; neocomplete#undo_completion() inoremap &lt;expr&gt;&lt;C-l&gt; neocomplete#complete_common_string() &quot;inoremap &lt;expr&gt;&lt;CR&gt; neocomplete#complete_common_string() &quot; &lt;CR&gt;: close popup &quot; &lt;s-CR&gt;: close popup and save indent. inoremap &lt;expr&gt;&lt;s-CR&gt; pumvisible() ? neocomplete#smart_close_popup().&quot;\\&lt;CR&gt;&quot; : &quot;\\&lt;CR&gt;&quot; function! CleverCr() if pumvisible() if neosnippet#expandable() let exp &#x3D; &quot;\\&lt;Plug&gt;(neosnippet_expand)&quot; return exp . neocomplete#smart_close_popup() else return neocomplete#smart_close_popup() endif else return &quot;\\&lt;CR&gt;&quot; endif endfunction &quot; &lt;CR&gt; close popup and save indent or expand snippet imap &lt;expr&gt; &lt;CR&gt; CleverCr() &quot; &lt;C-h&gt;, &lt;BS&gt;: close popup and delete backword char. inoremap &lt;expr&gt;&lt;BS&gt; neocomplete#smart_close_popup().&quot;\\&lt;C-h&gt;&quot; inoremap &lt;expr&gt;&lt;C-y&gt; neocomplete#smart_close_popup() endif &quot; &lt;TAB&gt;: completion. inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : &quot;\\&lt;TAB&gt;&quot; inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\\&lt;C-p&gt;&quot; : &quot;\\&lt;TAB&gt;&quot; &quot; Courtesy of Matteo Cavalleri function! CleverTab() if pumvisible() return &quot;\\&lt;C-n&gt;&quot; endif let substr &#x3D; strpart(getline(&#39;.&#39;), 0, col(&#39;.&#39;) - 1) let substr &#x3D; matchstr(substr, &#39;[^ \\t]*$&#39;) if strlen(substr) &#x3D;&#x3D; 0 &quot; nothing to match on empty string return &quot;\\&lt;Tab&gt;&quot; else &quot; existing text matching if neosnippet#expandable_or_jumpable() return &quot;\\&lt;Plug&gt;(neosnippet_expand_or_jump)&quot; else return neocomplete#start_manual_complete() endif endif endfunction imap &lt;expr&gt; &lt;Tab&gt; CleverTab() &quot; &#125; &quot; Enable heavy omni completion. if !exists(&#39;g:neocomplete#sources#omni#input_patterns&#39;) let g:neocomplete#sources#omni#input_patterns &#x3D; &#123;&#125; endif let g:neocomplete#sources#omni#input_patterns.php &#x3D; &#39;[^. \\t]-&gt;\\h\\w*\\|\\h\\w*::&#39; let g:neocomplete#sources#omni#input_patterns.perl &#x3D; &#39;\\h\\w*-&gt;\\h\\w*\\|\\h\\w*::&#39; let g:neocomplete#sources#omni#input_patterns.c &#x3D; &#39;[^.[:digit:] *\\t]\\%(\\.\\|-&gt;\\)&#39; let g:neocomplete#sources#omni#input_patterns.cpp &#x3D; &#39;[^.[:digit:] *\\t]\\%(\\.\\|-&gt;\\)\\|\\h\\w*::&#39; let g:neocomplete#sources#omni#input_patterns.ruby &#x3D; &#39;[^. *\\t]\\.\\h\\w*\\|\\h\\w*::&#39; &quot; &#125; &quot; neocomplcache &#123; elseif count(g:spf13_bundle_groups, &#39;neocomplcache&#39;) let g:acp_enableAtStartup &#x3D; 0 let g:neocomplcache_enable_at_startup &#x3D; 1 let g:neocomplcache_enable_camel_case_completion &#x3D; 1 let g:neocomplcache_enable_smart_case &#x3D; 1 let g:neocomplcache_enable_underbar_completion &#x3D; 1 let g:neocomplcache_enable_auto_delimiter &#x3D; 1 let g:neocomplcache_max_list &#x3D; 15 let g:neocomplcache_force_overwrite_completefunc &#x3D; 1 &quot; Define dictionary. let g:neocomplcache_dictionary_filetype_lists &#x3D; &#123; \\ &#39;default&#39; : &#39;&#39;, \\ &#39;vimshell&#39; : $HOME.&#39;&#x2F;.vimshell_hist&#39;, \\ &#39;scheme&#39; : $HOME.&#39;&#x2F;.gosh_completions&#39; \\ &#125; &quot; Define keyword. if !exists(&#39;g:neocomplcache_keyword_patterns&#39;) let g:neocomplcache_keyword_patterns &#x3D; &#123;&#125; endif let g:neocomplcache_keyword_patterns._ &#x3D; &#39;\\h\\w*&#39; &quot; Plugin key-mappings &#123; &quot; These two lines conflict with the default digraph mapping of &lt;C-K&gt; imap &lt;C-k&gt; &lt;Plug&gt;(neosnippet_expand_or_jump) smap &lt;C-k&gt; &lt;Plug&gt;(neosnippet_expand_or_jump) if exists(&#39;g:spf13_noninvasive_completion&#39;) inoremap &lt;CR&gt; &lt;CR&gt; &quot; &lt;ESC&gt; takes you out of insert mode inoremap &lt;expr&gt; &lt;Esc&gt; pumvisible() ? &quot;\\&lt;C-y&gt;\\&lt;Esc&gt;&quot; : &quot;\\&lt;Esc&gt;&quot; &quot; &lt;CR&gt; accepts first, then sends the &lt;CR&gt; inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\\&lt;C-y&gt;\\&lt;CR&gt;&quot; : &quot;\\&lt;CR&gt;&quot; &quot; &lt;Down&gt; and &lt;Up&gt; cycle like &lt;Tab&gt; and &lt;S-Tab&gt; inoremap &lt;expr&gt; &lt;Down&gt; pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : &quot;\\&lt;Down&gt;&quot; inoremap &lt;expr&gt; &lt;Up&gt; pumvisible() ? &quot;\\&lt;C-p&gt;&quot; : &quot;\\&lt;Up&gt;&quot; &quot; Jump up and down the list inoremap &lt;expr&gt; &lt;C-d&gt; pumvisible() ? &quot;\\&lt;PageDown&gt;\\&lt;C-p&gt;\\&lt;C-n&gt;&quot; : &quot;\\&lt;C-d&gt;&quot; inoremap &lt;expr&gt; &lt;C-u&gt; pumvisible() ? &quot;\\&lt;PageUp&gt;\\&lt;C-p&gt;\\&lt;C-n&gt;&quot; : &quot;\\&lt;C-u&gt;&quot; else imap &lt;silent&gt;&lt;expr&gt;&lt;C-k&gt; neosnippet#expandable() ? \\ &quot;\\&lt;Plug&gt;(neosnippet_expand_or_jump)&quot; : (pumvisible() ? \\ &quot;\\&lt;C-e&gt;&quot; : &quot;\\&lt;Plug&gt;(neosnippet_expand_or_jump)&quot;) smap &lt;TAB&gt; &lt;Right&gt;&lt;Plug&gt;(neosnippet_jump_or_expand) inoremap &lt;expr&gt;&lt;C-g&gt; neocomplcache#undo_completion() inoremap &lt;expr&gt;&lt;C-l&gt; neocomplcache#complete_common_string() &quot;inoremap &lt;expr&gt;&lt;CR&gt; neocomplcache#complete_common_string() function! CleverCr() if pumvisible() if neosnippet#expandable() let exp &#x3D; &quot;\\&lt;Plug&gt;(neosnippet_expand)&quot; return exp . neocomplcache#close_popup() else return neocomplcache#close_popup() endif else return &quot;\\&lt;CR&gt;&quot; endif endfunction &quot; &lt;CR&gt; close popup and save indent or expand snippet imap &lt;expr&gt; &lt;CR&gt; CleverCr() &quot; &lt;CR&gt;: close popup &quot; &lt;s-CR&gt;: close popup and save indent. inoremap &lt;expr&gt;&lt;s-CR&gt; pumvisible() ? neocomplcache#close_popup().&quot;\\&lt;CR&gt;&quot; : &quot;\\&lt;CR&gt;&quot; &quot;inoremap &lt;expr&gt;&lt;CR&gt; pumvisible() ? neocomplcache#close_popup() : &quot;\\&lt;CR&gt;&quot; &quot; &lt;C-h&gt;, &lt;BS&gt;: close popup and delete backword char. inoremap &lt;expr&gt;&lt;BS&gt; neocomplcache#smart_close_popup().&quot;\\&lt;C-h&gt;&quot; inoremap &lt;expr&gt;&lt;C-y&gt; neocomplcache#close_popup() endif &quot; &lt;TAB&gt;: completion. inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : &quot;\\&lt;TAB&gt;&quot; inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\\&lt;C-p&gt;&quot; : &quot;\\&lt;TAB&gt;&quot; &quot; &#125; &quot; Enable omni completion. autocmd FileType css setlocal omnifunc&#x3D;csscomplete#CompleteCSS autocmd FileType html,markdown setlocal omnifunc&#x3D;htmlcomplete#CompleteTags autocmd FileType javascript setlocal omnifunc&#x3D;javascriptcomplete#CompleteJS autocmd FileType python setlocal omnifunc&#x3D;pythoncomplete#Complete autocmd FileType xml setlocal omnifunc&#x3D;xmlcomplete#CompleteTags autocmd FileType ruby setlocal omnifunc&#x3D;rubycomplete#Complete autocmd FileType haskell setlocal omnifunc&#x3D;necoghc#omnifunc &quot; Enable heavy omni completion. if !exists(&#39;g:neocomplcache_omni_patterns&#39;) let g:neocomplcache_omni_patterns &#x3D; &#123;&#125; endif let g:neocomplcache_omni_patterns.php &#x3D; &#39;[^. \\t]-&gt;\\h\\w*\\|\\h\\w*::&#39; let g:neocomplcache_omni_patterns.perl &#x3D; &#39;\\h\\w*-&gt;\\h\\w*\\|\\h\\w*::&#39; let g:neocomplcache_omni_patterns.c &#x3D; &#39;[^.[:digit:] *\\t]\\%(\\.\\|-&gt;\\)&#39; let g:neocomplcache_omni_patterns.cpp &#x3D; &#39;[^.[:digit:] *\\t]\\%(\\.\\|-&gt;\\)\\|\\h\\w*::&#39; let g:neocomplcache_omni_patterns.ruby &#x3D; &#39;[^. *\\t]\\.\\h\\w*\\|\\h\\w*::&#39; let g:neocomplcache_omni_patterns.go &#x3D; &#39;\\h\\w*\\.\\?&#39; &quot; &#125; &quot; Normal Vim omni-completion &#123; &quot; To disable omni complete, add the following to your .vimrc.before.local file: &quot; let g:spf13_no_omni_complete &#x3D; 1 elseif !exists(&#39;g:spf13_no_omni_complete&#39;) &quot; Enable omni-completion. autocmd FileType css setlocal omnifunc&#x3D;csscomplete#CompleteCSS autocmd FileType html,markdown setlocal omnifunc&#x3D;htmlcomplete#CompleteTags autocmd FileType javascript setlocal omnifunc&#x3D;javascriptcomplete#CompleteJS autocmd FileType python setlocal omnifunc&#x3D;pythoncomplete#Complete autocmd FileType xml setlocal omnifunc&#x3D;xmlcomplete#CompleteTags autocmd FileType ruby setlocal omnifunc&#x3D;rubycomplete#Complete autocmd FileType haskell setlocal omnifunc&#x3D;necoghc#omnifunc endif &quot; &#125; &quot; Snippets &#123; if count(g:spf13_bundle_groups, &#39;neocomplcache&#39;) || \\ count(g:spf13_bundle_groups, &#39;neocomplete&#39;) &quot; Use honza&#39;s snippets. let g:neosnippet#snippets_directory&#x3D;&#39;~&#x2F;.vim&#x2F;bundle&#x2F;vim-snippets&#x2F;snippets&#39; &quot; Enable neosnippet snipmate compatibility mode let g:neosnippet#enable_snipmate_compatibility &#x3D; 1 &quot; For snippet_complete marker. if !exists(&quot;g:spf13_no_conceal&quot;) if has(&#39;conceal&#39;) set conceallevel&#x3D;2 concealcursor&#x3D;i endif endif &quot; Enable neosnippets when using go let g:go_snippet_engine &#x3D; &quot;neosnippet&quot; &quot; Disable the neosnippet preview candidate window &quot; When enabled, there can be too much visual noise &quot; especially when splits are used. set completeopt-&#x3D;preview endif &quot; &#125; &quot; FIXME: Isn&#39;t this for Syntastic to handle? &quot; Haskell post write lint and check with ghcmod &quot; $ &#96;cabal install ghcmod&#96; if missing and ensure &quot; ~&#x2F;.cabal&#x2F;bin is in your $PATH. if !executable(&quot;ghcmod&quot;) autocmd BufWritePost *.hs GhcModCheckAndLintAsync endif &quot; UndoTree &#123; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;undotree&#x2F;&quot;)) nnoremap &lt;Leader&gt;u :UndotreeToggle&lt;CR&gt; &quot; If undotree is opened, it is likely one wants to interact with it. let g:undotree_SetFocusWhenToggle&#x3D;1 endif &quot; &#125; &quot; indent_guides &#123; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;vim-indent-guides&#x2F;&quot;)) let g:indent_guides_start_level &#x3D; 2 let g:indent_guides_guide_size &#x3D; 1 let g:indent_guides_enable_on_vim_startup &#x3D; 1 endif &quot; &#125; &quot; Wildfire &#123; let g:wildfire_objects &#x3D; &#123; \\ &quot;*&quot; : [&quot;i&#39;&quot;, &#39;i&quot;&#39;, &quot;i)&quot;, &quot;i]&quot;, &quot;i&#125;&quot;, &quot;ip&quot;], \\ &quot;html,xml&quot; : [&quot;at&quot;], \\ &#125; &quot; &#125; &quot; vim-airline &#123; &quot; Set configuration options for the statusline plugin vim-airline. &quot; Use the powerline theme and optionally enable powerline symbols. &quot; To use the symbols , , , , , , and .in the statusline &quot; segments add the following to your .vimrc.before.local file: &quot; let g:airline_powerline_fonts&#x3D;1 &quot; If the previous symbols do not render for you then install a &quot; powerline enabled font. &quot; See &#96;:echo g:airline_theme_map&#96; for some more choices &quot; Default in terminal vim is &#39;dark&#39; if isdirectory(expand(&quot;~&#x2F;.vim&#x2F;bundle&#x2F;vim-airline-themes&#x2F;&quot;)) if !exists(&#39;g:airline_theme&#39;) let g:airline_theme &#x3D; &#39;solarized&#39; endif if !exists(&#39;g:airline_powerline_fonts&#39;) &quot; Use the default set of separators with a few customizations let g:airline_left_sep&#x3D;&#39;›&#39; &quot; Slightly fancier than &#39;&gt;&#39; let g:airline_right_sep&#x3D;&#39;‹&#39; &quot; Slightly fancier than &#39;&lt;&#39; endif endif &quot; &#125;&quot; &#125;&quot; GUI Settings &#123; &quot; GVIM- (here instead of .gvimrc) if has(&#39;gui_running&#39;) set guioptions-&#x3D;T &quot; Remove the toolbar set lines&#x3D;40 &quot; 40 lines of text instead of 24 if !exists(&quot;g:spf13_no_big_font&quot;) if LINUX() &amp;&amp; has(&quot;gui_running&quot;) set guifont&#x3D;Andale\\ Mono\\ Regular\\ 12,Menlo\\ Regular\\ 11,Consolas\\ Regular\\ 12,Courier\\ New\\ Regular\\ 14 elseif OSX() &amp;&amp; has(&quot;gui_running&quot;) set guifont&#x3D;Andale\\ Mono\\ Regular:h12,Menlo\\ Regular:h11,Consolas\\ Regular:h12,Courier\\ New\\ Regular:h14 elseif WINDOWS() &amp;&amp; has(&quot;gui_running&quot;) set guifont&#x3D;Andale_Mono:h10,Menlo:h10,Consolas:h10,Courier_New:h10 endif endif else if &amp;term &#x3D;&#x3D; &#39;xterm&#39; || &amp;term &#x3D;&#x3D; &#39;screen&#39; set t_Co&#x3D;256 &quot; Enable 256 colors to stop the CSApprox warning and make xterm vim shine endif &quot;set term&#x3D;builtin_ansi &quot; Make arrow and other keys work endif&quot; &#125;&quot; Functions &#123; &quot; Initialize directories &#123; function! InitializeDirectories() let parent &#x3D; $HOME let prefix &#x3D; &#39;vim&#39; let dir_list &#x3D; &#123; \\ &#39;backup&#39;: &#39;backupdir&#39;, \\ &#39;views&#39;: &#39;viewdir&#39;, \\ &#39;swap&#39;: &#39;directory&#39; &#125; if has(&#39;persistent_undo&#39;) let dir_list[&#39;undo&#39;] &#x3D; &#39;undodir&#39; endif &quot; To specify a different directory in which to place the vimbackup, &quot; vimviews, vimundo, and vimswap files&#x2F;directories, add the following to &quot; your .vimrc.before.local file: &quot; let g:spf13_consolidated_directory &#x3D; &lt;full path to desired directory&gt; &quot; eg: let g:spf13_consolidated_directory &#x3D; $HOME . &#39;&#x2F;.vim&#x2F;&#39; if exists(&#39;g:spf13_consolidated_directory&#39;) let common_dir &#x3D; g:spf13_consolidated_directory . prefix else let common_dir &#x3D; parent . &#39;&#x2F;.&#39; . prefix endif for [dirname, settingname] in items(dir_list) let directory &#x3D; common_dir . dirname . &#39;&#x2F;&#39; if exists(&quot;*mkdir&quot;) if !isdirectory(directory) call mkdir(directory) endif endif if !isdirectory(directory) echo &quot;Warning: Unable to create backup directory: &quot; . directory echo &quot;Try: mkdir -p &quot; . directory else let directory &#x3D; substitute(directory, &quot; &quot;, &quot;\\\\\\\\ &quot;, &quot;g&quot;) exec &quot;set &quot; . settingname . &quot;&#x3D;&quot; . directory endif endfor endfunction call InitializeDirectories() &quot; &#125; &quot; Initialize NERDTree as needed &#123; function! NERDTreeInitAsNeeded() redir &#x3D;&gt; bufoutput buffers! redir END let idx &#x3D; stridx(bufoutput, &quot;NERD_tree&quot;) if idx &gt; -1 NERDTreeMirror NERDTreeFind wincmd l endif endfunction &quot; &#125; &quot; Strip whitespace &#123; function! StripTrailingWhitespace() &quot; Preparation: save last search, and cursor position. let _s&#x3D;@&#x2F; let l &#x3D; line(&quot;.&quot;) let c &#x3D; col(&quot;.&quot;) &quot; do the business: %s&#x2F;\\s\\+$&#x2F;&#x2F;e &quot; clean up: restore previous search history, and cursor position let @&#x2F;&#x3D;_s call cursor(l, c) endfunction &quot; &#125; &quot; Shell command &#123; function! s:RunShellCommand(cmdline) botright new setlocal buftype&#x3D;nofile setlocal bufhidden&#x3D;delete setlocal nobuflisted setlocal noswapfile setlocal nowrap setlocal filetype&#x3D;shell setlocal syntax&#x3D;shell call setline(1, a:cmdline) call setline(2, substitute(a:cmdline, &#39;.&#39;, &#39;&#x3D;&#39;, &#39;g&#39;)) execute &#39;silent $read !&#39; . escape(a:cmdline, &#39;%#&#39;) setlocal nomodifiable 1 endfunction command! -complete&#x3D;file -nargs&#x3D;+ Shell call s:RunShellCommand(&lt;q-args&gt;) &quot; e.g. Grep current file for &lt;search_term&gt;: Shell grep -Hn &lt;search_term&gt; % &quot; &#125; function! s:IsSpf13Fork() let s:is_fork &#x3D; 0 let s:fork_files &#x3D; [&quot;~&#x2F;.vimrc.fork&quot;, &quot;~&#x2F;.vimrc.before.fork&quot;, &quot;~&#x2F;.vimrc.bundles.fork&quot;] for fork_file in s:fork_files if filereadable(expand(fork_file, &quot;:p&quot;)) let s:is_fork &#x3D; 1 break endif endfor return s:is_fork endfunction function! s:ExpandFilenameAndExecute(command, file) execute a:command . &quot; &quot; . expand(a:file, &quot;:p&quot;) endfunction function! s:EditSpf13Config() call &lt;SID&gt;ExpandFilenameAndExecute(&quot;tabedit&quot;, &quot;~&#x2F;.vimrc&quot;) call &lt;SID&gt;ExpandFilenameAndExecute(&quot;vsplit&quot;, &quot;~&#x2F;.vimrc.before&quot;) call &lt;SID&gt;ExpandFilenameAndExecute(&quot;vsplit&quot;, &quot;~&#x2F;.vimrc.bundles&quot;) execute bufwinnr(&quot;.vimrc&quot;) . &quot;wincmd w&quot; call &lt;SID&gt;ExpandFilenameAndExecute(&quot;split&quot;, &quot;~&#x2F;.vimrc.local&quot;) wincmd l call &lt;SID&gt;ExpandFilenameAndExecute(&quot;split&quot;, &quot;~&#x2F;.vimrc.before.local&quot;) wincmd l call &lt;SID&gt;ExpandFilenameAndExecute(&quot;split&quot;, &quot;~&#x2F;.vimrc.bundles.local&quot;) if &lt;SID&gt;IsSpf13Fork() execute bufwinnr(&quot;.vimrc&quot;) . &quot;wincmd w&quot; call &lt;SID&gt;ExpandFilenameAndExecute(&quot;split&quot;, &quot;~&#x2F;.vimrc.fork&quot;) wincmd l call &lt;SID&gt;ExpandFilenameAndExecute(&quot;split&quot;, &quot;~&#x2F;.vimrc.before.fork&quot;) wincmd l call &lt;SID&gt;ExpandFilenameAndExecute(&quot;split&quot;, &quot;~&#x2F;.vimrc.bundles.fork&quot;) endif execute bufwinnr(&quot;.vimrc.local&quot;) . &quot;wincmd w&quot; endfunction execute &quot;noremap &quot; . s:spf13_edit_config_mapping &quot; :call &lt;SID&gt;EditSpf13Config()&lt;CR&gt;&quot; execute &quot;noremap &quot; . s:spf13_apply_config_mapping . &quot; :source ~&#x2F;.vimrc&lt;CR&gt;&quot;&quot; &#125;&quot; Use fork vimrc if available &#123; if filereadable(expand(&quot;~&#x2F;.vimrc.fork&quot;)) source ~&#x2F;.vimrc.fork endif&quot; &#125;&quot; Use local vimrc if available &#123; if filereadable(expand(&quot;~&#x2F;.vimrc.local&quot;)) source ~&#x2F;.vimrc.local endif&quot; &#125;&quot; Use local gvimrc if available and gui is running &#123; if has(&#39;gui_running&#39;) if filereadable(expand(&quot;~&#x2F;.gvimrc.local&quot;)) source ~&#x2F;.gvimrc.local endif endif&quot; &#125;","tags":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/tags/vim%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/categories/vim%E4%BD%BF%E7%94%A8/"}]},{"title":"vim配置","date":"2021-02-20T15:19:54.238Z","path":"wiki/2021-03-03-vim配置/","text":"安装插件vim在8之后已经开始支持自带的插件管理系统了，只需要在～/.vim/pack/vendor/start下防止自己安装的插件目录即可成功安装，然后就可以在~/.vimrc中配置vim以及他的插件还有～/.vim.pack/vendor/opt放置安装不需要打开vim就启动的插件的 youcompleteme插件安装首先复制github的项目官网地址，然后克隆到本地 下载编译安装所需要的软件包：sudo pacman -S cmake git python(3) base-devel vim(8) npm java nodejs go cd到youcompleteme目录下，执行git submodule update --init --recursive 有时候网速不好，可能需要终止之后继续执行，等待操作完成之后就好 然后执行补全插件的安装：./install.py --all安装全部的--cland-completerc家族的--java-completer还有许多，可以看官网自己挑选 配置在vimrc添加一句：let g:ycm_global_ycm_extra_conf=&#39;~/.vim/pack/vendor/start/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#39;这样才能保持正确的配置补全 对于java的补全，必须是创建好的项目文才可以补全 自动回到上一次编辑的光标位置配置文件中添加 1234augroup resCur autocmd! autocmd BufReadPost * call setpos(&quot;.&quot;, getpos(&quot;&#39;\\&quot;&quot;)) augroup END","tags":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/tags/vim%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/categories/vim%E4%BD%BF%E7%94%A8/"}]},{"title":"超级用户","date":"2021-02-20T13:41:45.714Z","path":"wiki/2021-03-03-超级用户/","text":"/root这个目录是超级用户的家目录，和其他用户的家目录是一样的 所有其他用户的配置方法在这个超级用户下面也是适用的 因此想要超级用户拥有其他用户的一样的配置，只需要将配置文件复制到这个目录下面就可以啦","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"快速注释和取消注释","date":"2021-02-20T13:23:59.714Z","path":"wiki/2021-03-03-快速注释和取消注释/","text":"快速注释 按ESC进入命令行模式； ctrl+v进入块选择模式； 操作k和j进行上下行选择； 按大写I进入插入模式，输入注释符//或#(shell脚本注释符)； 最后按下ESC即可完成注释。 取消注释 按ESC进入命令行模式； ctrl+v进入块选择模式； 操作k和j进行上下行选择,还可以操作h和l键进行左右控制； 按d键删除注释符； 最后按下ESC即可完成取消注释。 插件的方式nerdcommenter下载插件，放置到～/.vim/pack/vendor/start下添加配置项到配置文件中 1234567891011121314151617181920212223242526&quot; Create default mappingslet g:NERDCreateDefaultMappings \\&#x3D; 1&quot; Add spaces after comment delimiters by defaultlet g:NERDSpaceDelims \\&#x3D; 1&quot; Use compact syntax for prettified multi-line commentslet g:NERDCompactSexyComs \\&#x3D; 1&quot; Align line-wise comment delimiters flush left instead of following code indentationlet g:NERDDefaultAlign \\&#x3D; &#39;left&#39;&quot; Set a language to use its alternate delimiters by defaultlet g:NERDAltDelims\\_java \\&#x3D; 1&quot; Add your own custom formats or override the defaultslet g:NERDCustomDelimiters \\&#x3D; &#123; &#39;c&#39;: &#123; &#39;left&#39;: &#39;&#x2F;\\*\\*&#39;,&#39;right&#39;: &#39;\\*&#x2F;&#39; &#125; &#125;&quot; Allow commenting and inverting empty lines (useful when commenting a region)let g:NERDCommentEmptyLines \\&#x3D; 1&quot; Enable trimming of trailing whitespace when uncommentinglet g:NERDTrimTrailingWhitespace \\&#x3D; 1&quot; Enable NERDCommenterToggle to check all selected lines is commented or not let g:NERDToggleCheckAllLines \\&#x3D; 1 然后就可以使用带前缀的快捷键来进行快速注释/取消注释了每个命令都支持前面带数字的多行注释/取消注释：一般是在visualmode下的按键设置3&lt;leader&gt;cc：快速注释当前行及其之后的两行 其中的leader是配置文件中设置的leader符号let mapleader=&quot;,&quot; [count]&lt;leader&gt;cc |NERDCommenterComment| Comment out the current line or text selected in visual mode. [count]&lt;leader&gt;cn |NERDCommenterNested| Same as cc but forces nesting. [count]&lt;leader&gt;c&lt;space&gt; |NERDCommenterToggle| Toggles the comment state of the selected line(s). If the topmost selected line is commented, all selected lines are uncommented and vice versa. [count]&lt;leader&gt;cm |NERDCommenterMinimal| Comments the given lines using only one set of multipart delimiters. [count]&lt;leader&gt;ci |NERDCommenterInvert| Toggles the comment state of the selected line(s) individually. [count]&lt;leader&gt;cs |NERDCommenterSexy| Comments out the selected lines with a pretty block formatted layout. [count]&lt;leader&gt;cy |NERDCommenterYank| Same as cc except that the commented line(s) are yanked first. &lt;leader&gt;c$ |NERDCommenterToEOL| Comments the current line from the cursor to the end of line. &lt;leader&gt;cA |NERDCommenterAppend| Adds comment delimiters to the end of line and goes into insert mode between them. |NERDCommenterInsert| Adds comment delimiters at the current cursor position and inserts between. Disabled by default. &lt;leader&gt;ca |NERDCommenterAltDelims| Switches to the alternative set of delimiters. [count]&lt;leader&gt;cl |NERDCommenterAlignLeft [count]&lt;leader&gt;cb |NERDCommenterAlignBoth Same as |NERDCommenterComment| except that the delimiters are aligned down the left side (&lt;leader&gt;cl) or both sides (&lt;leader&gt;cb). [count]&lt;leader&gt;cu |NERDCommenterUncomment| Uncomments the selected line(s).","tags":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/tags/vim%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/categories/vim%E4%BD%BF%E7%94%A8/"}]},{"title":"加载第三方软件包和库","date":"2021-02-19T09:41:55.576Z","path":"wiki/2021-03-03-加载第三方软件包和库/","text":"创建项目mvn archetype:generate -DgroupId=com.jiabao.app -DartifactId=project-name -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false也可执行mvn archetype:generate然后通过交互的方式新建项目 修改pom.xml根据自己项目的需要进行相应的修改即可 对于第三方包的添加，添加下面类似的标签添加依赖还可以通过手动加载的方法，先在src目录下新建lib目录，将需要的包放在该目录下就可以了，然后再写进到pom.xml的依赖项中 12345&lt;dependencies&gt; &lt;dependency&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 执行编译进入到项目目录执行mvn compile执行下面操作之后就将需要的依赖下载下来了 打包执行 打包 进入到项目文件中，执行mvn package 执行java -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App 生成sitemvn site命令生成网站文档","tags":[{"name":"maven-note","slug":"maven-note","permalink":"http://example.com/tags/maven-note/"}],"categories":[{"name":"maven-note","slug":"maven-note","permalink":"http://example.com/categories/maven-note/"}]},{"title":"quick-start","date":"2021-02-18T09:37:25.441Z","path":"wiki/2021-03-03-quick-start/","text":"maven安装下载好相应的压缩包，解压到自己想放的目录。然后将该目录设置到环境变量中去使用mvn -v查看环境变量是不是设置好安装好了 quick-startmvn archetype:generate -DgroupId=com.jiabao.app -DartifactId=my-app -DarchetyprArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=falsemvn archetype:generate &quot;-DgroupId=com.companyname.bank&quot; &quot;-DartifactId=consumerBanking&quot; &quot;-DarchetypeArtifactId=maven-archetype-quickstart&quot; &quot;-DinteractiveMode=false&quot;这一行命令就是用来创建项目的命令 编译打包命令mvn package 运行打包好的jarjava -cp tartget/my-app-1.0-SNAPSHOT.jar com.jiabao.app.App","tags":[{"name":"maven-note","slug":"maven-note","permalink":"http://example.com/tags/maven-note/"}],"categories":[{"name":"maven-note","slug":"maven-note","permalink":"http://example.com/categories/maven-note/"}]},{"title":"颜色配置","date":"2021-02-18T08:36:15.907Z","path":"wiki/2021-03-03-颜色配置/","text":"less颜色配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657LESS_TERMCAP_xx# 下面是xx的一些特殊符号的表示mbStart blinkingmdStart bold modemeEnd all mode like so, us, mb, md and mrsoStart standout modeseEnd standout modeusStart underliningueEnd underliningexport LESS&#x3D;-Rexport LESS\\_TERMCAP\\_mb&#x3D;$&#39;\\\\E\\[1;31m&#39; # begin blinkexport LESS\\_TERMCAP\\_md&#x3D;$&#39;\\\\E\\[1;36m&#39; # begin boldexport LESS\\_TERMCAP\\_me&#x3D;$&#39;\\\\E\\[0m&#39; # reset bold&#x2F;blinkexport LESS\\_TERMCAP\\_so&#x3D;$&#39;\\\\E\\[01;44;33m&#39; # begin reverse videoexport LESS\\_TERMCAP\\_se&#x3D;$&#39;\\\\E\\[0m&#39; # reset reverse videoexport LESS\\_TERMCAP\\_us&#x3D;$&#39;\\\\E\\[1;32m&#39; # begin underlineexport LESS\\_TERMCAP\\_ue&#x3D;$&#39;\\\\E\\[0m&#39; # reset underline# and so onman() &#123; env \\ LESS_TERMCAP_mb&#x3D;$(printf &quot;\\e[1;31m&quot;) \\ LESS_TERMCAP_md&#x3D;$(printf &quot;\\e[1;31m&quot;) \\ LESS_TERMCAP_me&#x3D;$(printf &quot;\\e[0m&quot;) \\ LESS_TERMCAP_se&#x3D;$(printf &quot;\\e[0m&quot;) \\ LESS_TERMCAP_so&#x3D;$(printf &quot;\\e[1;44;33m&quot;) \\ LESS_TERMCAP_ue&#x3D;$(printf &quot;\\e[0m&quot;) \\ LESS_TERMCAP_us&#x3D;$(printf &quot;\\e[1;32m&quot;) \\ man &quot;$@&quot;&#125;# 遵循的格式\\e[(one or more numbers separated by semicolons)m# 颜色的表示0 Reset to standard configuration1 Bold31 Set foreground color to red32 Set foreground color to green33 Set foreground color to yellow44 Set background color to blue# ansi标准30–37 Foreground color, dark90–97 Foreground color, bright40–47 Background color, dark100–107 Background color, bright38;5;### Set foreground color to color ### (256-color extension)48;5;### Set background color to color ### (256-color extension)","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"i3配置","date":"2021-02-18T07:25:14.797Z","path":"wiki/2021-03-03-i3配置/","text":"i3的配置i3的配置文件：～/.config/i3/config自带的默认配置文件放在：/etc/i3/config 配置文件用处 在startx启动图形管理界面的时候加载自定义的一些设置项（如字体设置，功能键的指定） 绑定自定义的快捷键（bindsym shortkey-name exec --no-startup-id softwarename）如果碰到了那些需要释放之后再运行的快捷键绑定，如scrot截图快捷键绑定，加上–release选项：bingsym --release $mod+s exec --no-startup-id exec &quot;scrot -s -q 100 ~/Pictures/Screenshot/$(date &#39;+%Y-%m-$d-%H:%M:%S&#39;.png)&quot; 开启图形界面时自动启动某些指定的软件或者脚本文件（exec --no-startup-id softwarename） 必要的软件包sudo pacman -S feh rofi polybar picom terminator xclip scrot peek 软件菜单项展示（rofi）配置：获取完整的配置文件可以使用：rofi -dump-configrofi -dump-config &gt; ~/.config/rofi/rofi.rasi命令生成配置文件到指定目录文件，可以在这个配置文件中进行自己需要的配置进行修改（取消注释） XDG：～/.config/rofi/rofi.rasi这是配置文件 Xresources：使用~/.Xresources配置文件类似的配置文件如下123456configuration &#123; modi: &quot;window,drun,ssh,combi&quot;; theme: &quot;solarized&quot;; font: &quot;hack 10&quot;; combi-modi: &quot;window,drun,ssh&quot;; &#125; 命令行配置：rofi -combi-modi window,drun,ssh -theme solarized -font &quot;hack 10&quot; -show combi 壁纸设置软件（feh） exec --no-startup-id feh --randomsize --bg-fill wallpaper-dir 控制台模拟器（erminator) bingsym $Mod+Enter --no-startup-id termiantor绑定启动快捷键 状态栏polybar polybar配置https://wiki.archlinux.org/index.php/Polybar#Configuration配置文件放在：～/.config/polybar/config官方定义的配置文件在：/usr/share/doc/polybar/config可以按照官网定义的配置项进行改进也可以自己按照官方文档的详细介绍按照自己喜欢需要的项目进行设置 透明化软件picom（comptom的改进版）picom配置文档 官方自带的配置文件：/etc/xdg/picom.conf自定义的配置文件在：~/.config/picom/picom.conf或者~/.config/picom.conf exec --no-startup-id picom -b后台运行该软件 截图（scrot和xclip）或者maim（比scrot更简单，不用设置太多选项）![[Pasted image 20210216224312.png]]scrot使用：scrot desktop.png抓取桌面scrot -bs window.png-b抓取窗口同时抓取外边框，-s让用户选择抓哪个窗口scrot -s area.png-s抓取区域，截取鼠标拖拽区域内容-cd：延时抓取，c显示倒计时-t %50 ：生成缩略图-q 1-100：改变品质-e ‘mv $f ~/Pictures/png’：这个选项可以执行另外一个操作 123scrot -q 100 -s -b -m -e &#39;xclip -selection clipoard -t &quot;image&#x2F;png&quot; $f &amp;&amp; mv $f ~&#x2F;Picture&#x2F;ScreenShortcut&#x2F;%Y-%m-%d_%H:%M:%S.png&#39;# 截取区域复制到剪切板并保存到指定文件夹下，也可点击窗口截取整个窗口 12scrot -e &#39;xclip -selection clipoard -t &quot;image&#x2F;png&quot; $f &amp;&amp; mv $f ~&#x2F;Picture&#x2F;ScreenShortcut&#x2F;%Y-%m-%d_%H:%m_desktop.png&#39;# 截取整个屏幕 12scrot -u -b -m -e &#39;xclip -selection clipoard -t &quot;image&#x2F;png&quot; $f &amp;&amp; mv $f ~&#x2F;Picture&#x2F;ScreenShortcut&#x2F;%Y-%m-%d_%H:%m_current.png&#39;# 截取当前活动窗口 xclip使用：xclip -selection clipboard -t &#39;file_format&#39;复制标准输入到xclip -o &gt; file将剪切板内容输出到文件中 maim使用：bindsym --release $mod+s --no-startuo-id exec &quot;maim -s | xclip -selection clipboard -t &#39;image/png&#39;)&quot;复制到剪切板-t选项指定的是复制过来的文件的格式 gif录制peek使用：sudo pacman -S peek是一个图形界面的录制软件，可以自己选择录制窗口，也可以选择录制gif，mp4等格式 息屏黑屏设置黑屏时间设定，即多久用户无操作黑屏i3wm的黑屏和屏保是一个意思，但是都得设置，如下： 先把屏保功能关了： exec –no-startup-id xset s 0 然后黑屏、睡眠、断电时间分别设为6000s，8000s，9000s，也可以只写前一个，不必三个都写 exec –no-startup-id xset dpms 6000 8000 9000","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"automount at boot","date":"2021-02-18T07:07:41.445Z","path":"wiki/2021-03-03-automount at boot/","text":"开机自动挂载想要的分区fdisk查看分区信息lsblk 查看分区信息和挂载点 首先使用blkid命令查询系统的所有分区的uuid信息 然后可以在/etc/fstab分区配置文件中添加挂载分区的信息格式：&lt;device&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;fsck&gt; &lt;device&gt; describes the block special device or remote filesystem to be mounted; see &lt;dir&gt; describes the mount point &lt;type&gt; the file system “File system” type.ext4,ntfs,swap &lt;options&gt; the associated mount options &lt;dump&gt; is checked by the dump(8) utility. This field is usually set to 0, which disables the check. &lt;fsck&gt; sets the order for filesystem .e. For the root device it should be 1. For other partitions it should be 2, or 0 to disable checking. 有两种挂载分区的格式： /dev/partition mount_point filesystem default 0 0 UUID=partition_uuid mount_point filesystem default 0 0","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"Generic","date":"2021-02-16T16:06:52.274Z","path":"wiki/2021-03-03-Generic/","text":"Generic[[generic Array List]]conceptgeneric is used for ==stronger type checking==(for compile-time safety), and you can use one declaration to have ==many method or many type class which have same name==, but these have different type. Generic can specify a set of related methods or classes with a single generic declaration. why use generic? ==stronger type checking and compile-time safety== ==elimination cast== ==Enable programmers to implement generic algorithms that work on colections of different types, and these are type safe and easier to read.== generic class or interfaee123456789101112public class ClassName &lt;T&gt;&#123; private T t; public ClassName(T t)&#123; this.t = t; &#125; public static void main(String[] args)&#123; ClassName&lt;Number&gt; numberClass = new ClassName&lt;&gt;(); // &lt;&gt;diamond operator &#125;&#125;public interface InterfaceName &lt;T&gt;&#123; void printHello();&#125; Above is declaration of generic class. First, access modifier, then ClassName, then **type parameters ** generic typeYou can call generic class or generic interface as generic type.the diamond operator：when generic instancialization happen, you can use the diamond to omit the type parameter after new keyword.parameterized type：this is a generic type after pass specific type parameter, you can pass it to type parameters. raw typeYou can call this type instancialization as raw type when you instancialize a generic type without type parameters.ClassName&lt;Integer&gt; integerClass = new ClassName&lt;&gt;();ClassName rawType = new ClassName(); 123ClassName rawtype1 = integerClass; // ok, no error messageClassName&lt;Integer&gt; integerClass1 = rawType; // warning, unchecked conversion There will get unchecked error message, when mixing legacy code with generic. generic method12345678public ClassName&lt;T&gt;&#123; private T t; public &lt;T&gt; void methodName(T t)&#123; this.t = t; System.out.println(t);&#125;&#125; Above is the declaration of generic methods.First, access modifier,then parameters type, then return type, then methodName, then parameters in parathesis parameter type name convention E, represent collections N, represent Number T, type, represent Objects, first one K, represent key of map V, represent values of map S, represent second type U, represent third type V, represent Fouth type bounded type parameters single bounded &lt;T extends Number&gt;It is a bounded type parameter. This can be used for restricting the passed type. Bounded type parameter allows you to invoke the bounded type’s defined methods. multiple bounded &lt;T extends A1 &amp; A2 &amp; A3&gt; It is a multiple bounded type parameter.If extenden types have class, it must be placed in the first. In this case, you can pass these type and its subtypes to be parameter. input variable and output variable input：pass datas to the code ,provide datas output：hold datas which has been updated, use to accept datas. wildcard upper bounded wildcard ：&lt;? extends Type&gt;(input variable, use upper bounded) lower bounded wildcard：&lt;? super type&gt;(output variable ,use lower bounded. because if use lower bounded, other subclass also can use super to cast type, in case wrong things) unbounded wildcard：&lt;?&gt; -&gt;Object(unsure whether is input or output) generic’s characters No primitive type：can not pass primitive data type to generic. No instance：parameter type can not be instancialized, but you can use reflection to achieve the same effect.T t = TName.newInstance() No static fields：If have static fields（shared among objects）, will cause compiler don’t know use which type。 No cast：In generic, you don’t need to cast type. No instanceOf：You can’t veryfied the difference between Box and Box, which is caused by type erasure. No Array：due to type erasure, you can add any type into array, this will cause array can’t throws ArrayStoreException. No Exception：can’t use type parameter in catch block. No overload：Due to type erasure, you can’t use Box and Box to overload method. type erasuregeneric is only used to strength type check, when comes to runtime, the parameters will be erased by a process which is called as type erasue. unbounded : after type erasure, it is Object bounded: after type erasure, it is the upper bounded. For connection, compiler will generate a bridge method.Why need bridge method, it is for ploymorphism","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"casting","date":"2021-02-16T15:54:11.646Z","path":"wiki/2021-03-03-casting/","text":"类型转换：从一个类型转换到另外一个类型的过程。和基本数据类型的转换一致，有时候我们需要对对象类型进行转换。int i = 1;double a = (double)i;Dog dog = new Dog();Animal animal = new Animal(); 当你忘记了一个对象的实际类型，但你又想要完全使用该对象的能力时，可以使用类型转换。 每个对象变量都有一个类型，这个类型是这个变量指向的对象类型或者说他能做什么。 当你为变量储存值的时候，编译器会检查你是否承诺了太多的东西给他。当你将父类变量指向子类对象时，并没有承诺太多，但是当你将子类变量指向父类对象时，就承诺了过多的东西。指向父类reference时，这个时候可能就需要做一个类型转换cast。 如果你的类型转换不合理，编译器会抛出ClassCastException，如果不对这个异常进行捕获，程序就会终止。但是可以利用instaceof进行判断来省略异常的捕获。if (obj instanceof Class)&#123;&#125; 实际上，不是大多时候都需要进行类型转换，因为由于多态的特性存在，很多时候不进行类型转换也可以正常工作。仅仅在你需要调用子类的某个特有的方法的时候，需要进行类型转换。","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Polymorphism","date":"2021-02-16T15:42:48.521Z","path":"wiki/2021-03-03-Polymorphism/","text":"多态是面对对象编程的一大重要特性，特别在一个父类有众多个子类的时候，多态的特性更容易展现。可以利用接口和类的type reference来实现多态 123456789101112131415161718192021class Person&#123; public Person()&#123; &#125; public void printName()&#123; &#125;&#125;class Student&#123; public Student()&#123; &#125; @Override public void printName()&#123; &#125; public printGrade()&#123; &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Person person = new Student(); // 这种type cast可以实现多态，利用父类的type reference调用子类的重写方法，但是不能调用父类中没有的方法 &#125;&#125; dynamic binding动态绑定是Java运行中的特性，这项特性用来去确定调用哪个方法。与动态绑定对应的是静态绑定static binding。动态绑定的步骤： Java编译器查看声明的对象类型和方法 通过参数对象的类型去确定调用的方法，用参数的类型去找寻最佳的匹配。 在运行时，通过动态绑定来确定调用的方法，利用之前编译器生成的method table去查找应该调用的方法，这个表在类的等级制度下生成的，方法表中主要是类名.方法名(param)。静态绑定是指那些定义为static final的方法，这些方法都是在编译阶段就可以确定哪个类下的哪个方法调用 这个动态绑定主要靠JVM来实现，JVM首先找到调用对象的实际类型，并去该类下查找方法，如果找不到，就去到父类中查找，在类的等级制度中一层一层寻找，如果找不到，抛出错误。（JVM取出方法表，JVM确定对象类型，确定调用方法，JVM调用方法）","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Package","date":"2021-02-16T15:41:47.915Z","path":"wiki/2021-03-03-Package/","text":"是一个Java用来管理拥有相近功能的类和接口的组件。通过javac -d destinationFile class.java编译后，编译好的类文件便放在了目标文件夹中，之后可通过import语句导入该包下的类和接口 package定义的时候，避免首项出现java，这在Java中被禁止使用，防止与Java内置的包名发生冲突。==默认包中的变量、方法和类可以不用导入直接使用。== 包的一些基本内容 包的导入：import packageName;package可以使用全名来引用包中的类和接口等内容，还有一种节省时间的方法，就是通过import语句将你需要多次使用的某个包中的类和接口导入，之后便可以直接通过类名来使用该类。 包中静态成员的导入import static packageName; package的创建：在源文件的第一行（首行）须有package的声明：package myjava.myclass;，==且每个源文件只能有一个package’声明==。一个源文件只能有一个公共类，且文件名必须是公共类的类名ClassName.java。创建好包之后，可以使用命令javac -d destination_class_dir ClassName.java进行编译，该命令将编译好的类文件放置到目标路径下。==包的路径在编译时会自动创建，因此可以不用提前创建好包路径==，对于该命令编译好的类文件，若需要运行，需把包路径带上java destination_class_dir/ClassName，==不然会出现无法加载主类或找不到主类的错误==。==类搜索路径==：在classpath中设置的路径，就是在import时，搜索类文件的路径。文件编译的时候可以利用-cp参数后面带上类文件的路径即可，运行类文件的时候也可以利用-cp带上类文件所在的路径，以防出现找不到主类的错误。java/javac -cp class_path;.;jar_path 这是在java和javac命令时的添加classpath的语句。 包的scope：class被保存在文件路径结构中，class所在的路径需要和package的包名一致。class文件还可存放在.jar文件中（压缩文件，保存class文件，保存空间提升性能）。对于包的访问权限，定义为public的类和接口，在任何的包中都可访问，定义为默认的，只能在相同的包下才可访问，而对于private，只有自己类才可访问，protected是只有自己类和子类可以访问。对于变量来说，==除非有用public和默认的条件，不然最好建议使用private==。package sealing：是Java用来禁止往某特定包里面再添加类的一种方法，为了减少冲突 class的路径包主要是用来管理分发类文件的，防止类文件的命名冲突问题，包通过文件的结构来控制类文件。类文件还可以存放在jar文件中。在设置类的搜索路径时，可以如下：-cp myclass_dir;.;jarclass_dir,myclass_dir放置创建的类文件，.代表的是当前路径下的类文件，jarclass_dir时放置jar压缩文件的。还可以使用通配符jarclass_dir\\\\*代表将所有的jar文件放置到类路径下。==javac编译的时候，如果设置路径的时候忘记将当前路径设置进去，如果没有设置，为默认的时候，不会出错，但是没设置.时便会出现运行不了的情况。==编译器在查找类路径的时候比虚拟机查找需要更长时间。首先在java.lang中寻找，接着会在导入语句中去寻找：import java.util.\\*;``import myclass.study.\\*，最后再在当前路径下寻找。如果找到了多个相同的类名，会出现编译错误的情况编译器还会多进行一个步骤，进入到源文件查看是否比类文件有更新，如果有，自动重新编译源文件。==从别的包文件中只能导入公共类== 设置classpath==建议==使用-cp或者-classpath选项来设置类文件路径java -cp classpath;.;archive\\\\* className还可以使用环境变量来进行设置CLASSPATH。set CLASSPATH=...|export CLASSPATH= :.:| setenv CLASSPATH :.:三种不同环境下设置环境变量。把所有的jar放在同一个文件夹下和使用CLASSPATH环境变量并不可取。前者由于可能会出错并且可能会遗忘，后者若是忘记设置当前路径，可能造成一些问题。","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"console 增强","date":"2021-02-16T13:49:08.904Z","path":"wiki/2021-03-03-console 增强/","text":"tab 补全彩色输出命令设置12345678910111213141516171819202122232425262728293031323334353637alias diff&#x3D;&#39;diff --color&#x3D;auto&#39; # diff的alias grep&#x3D;&#39;grep --color&#x3D;auto&#39;alias ip&#x3D;&#39;ip -color&#x3D;auto&#39;alias ls&#x3D;&#39;ls --color&#x3D;auto&#39;# pacman的彩色输出通过取消color行的注释即可# less 设置好下面这些，可以让man彩色输出export LESS&#x3D;-Rexport LESS\\_TERMCAP\\_mb&#x3D;$&#39;\\\\E\\[1;31m&#39; # begin blinkexport LESS\\_TERMCAP\\_md&#x3D;$&#39;\\\\E\\[1;36m&#39; # begin boldexport LESS\\_TERMCAP\\_me&#x3D;$&#39;\\\\E\\[0m&#39; # reset bold&#x2F;blinkexport LESS\\_TERMCAP\\_so&#x3D;$&#39;\\\\E\\[01;44;33m&#39; # begin reverse videoexport LESS\\_TERMCAP\\_se&#x3D;$&#39;\\\\E\\[0m&#39; # reset reverse videoexport LESS\\_TERMCAP\\_us&#x3D;$&#39;\\\\E\\[1;32m&#39; # begin underlineexport LESS\\_TERMCAP\\_ue&#x3D;$&#39;\\\\E\\[0m&#39; # reset underline# and so on# manman() &#123; LESS\\_TERMCAP\\_md&#x3D;$&#39;\\\\e\\[01;31m&#39; \\\\ LESS\\_TERMCAP\\_me&#x3D;$&#39;\\\\e\\[0m&#39; \\\\ LESS\\_TERMCAP\\_se&#x3D;$&#39;\\\\e\\[0m&#39; \\\\ LESS\\_TERMCAP\\_so&#x3D;$&#39;\\\\e\\[01;44;33m&#39; \\\\ LESS\\_TERMCAP\\_ue&#x3D;$&#39;\\\\e\\[0m&#39; \\\\ LESS\\_TERMCAP\\_us&#x3D;$&#39;\\\\e\\[01;32m&#39; \\\\ command man &quot;$@&quot;&#125;## less的语法彩色输出You can enable code syntax coloring in less. First, install source-highlight, then add these lines to your shell configuration file:~&#x2F;.bashrcexport LESSOPEN&#x3D;&quot;| &#x2F;usr&#x2F;bin&#x2F;source-highlight-esc.sh %s&quot;export LESS&#x3D;&#39;-R &#39; alias别名增加将常用的一些命令加参数可以绑定为别名，使用alias ip=‘ip -color=auto下面是一些比较常用的alias绑定，别名绑定一般放在用户目录下的~/.bashrc/~/.zshrc系统级别的alias绑定一般放在/etc/bash.bashrc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#\\# Modified commandsalias diff&#x3D;&#39;colordiff&#39; # requires colordiff packagealias grep&#x3D;&#39;grep --color&#x3D;auto&#39;alias more&#x3D;&#39;less&#39;alias df&#x3D;&#39;df -h&#39;alias du&#x3D;&#39;du -c -h&#39;alias mkdir&#x3D;&#39;mkdir -p -v&#39;alias nano&#x3D;&#39;nano -w&#39;alias ping&#x3D;&#39;ping -c 5&#39;alias dmesg&#x3D;&#39;dmesg -HL&#39;#\\# New commandsalias da&#x3D;&#39;date &quot;+%A, %B %d, %Y \\[%T\\]&quot;&#39;alias du1&#x3D;&#39;du --max-depth&#x3D;1&#39;alias hist&#x3D;&#39;history | grep&#39; # requires an argumentalias openports&#x3D;&#39;ss --all --numeric --processes --ipv4 --ipv6&#39;alias pgg&#x3D;&#39;ps -Af | grep&#39; # requires an argumentalias ..&#x3D;&#39;cd ..&#39;# Privileged accessif (( UID !&#x3D; 0 )); thenalias sudo&#x3D;&#39;sudo &#39;alias scat&#x3D;&#39;sudo cat&#39;alias svim&#x3D;&#39;sudoedit&#39;alias root&#x3D;&#39;sudo -i&#39;alias reboot&#x3D;&#39;sudo systemctl reboot&#39;alias poweroff&#x3D;&#39;sudo systemctl poweroff&#39;alias update&#x3D;&#39;sudo pacman -Su&#39;alias netctl&#x3D;&#39;sudo netctl&#39;fi#\\# lsalias ls&#x3D;&#39;ls -hF --color&#x3D;auto&#39;alias lr&#x3D;&#39;ls -R&#39; # recursive lsalias ll&#x3D;&#39;ls -l&#39;alias la&#x3D;&#39;ll -A&#39;alias lx&#x3D;&#39;ll -BX&#39; # sort by extensionalias lz&#x3D;&#39;ll -rS&#39; # sort by sizealias lt&#x3D;&#39;ll -rt&#39; # sort by datealias lm&#x3D;&#39;la | more&#39;#\\# Safety featuresalias cp&#x3D;&#39;cp -i&#39;alias mv&#x3D;&#39;mv -i&#39;alias rm&#x3D;&#39;rm -I&#39; # &#39;rm -i&#39; prompts for every file# safer alternative w&#x2F; timeout, not stored in historyalias rm&#x3D;&#39; timeout 3 rm -Iv --one-file-system&#39;alias ln&#x3D;&#39;ln -i&#39;alias chown&#x3D;&#39;chown --preserve-root&#39;alias chmod&#x3D;&#39;chmod --preserve-root&#39;alias chgrp&#x3D;&#39;chgrp --preserve-root&#39;alias cls&#x3D;&#39; echo -ne &quot;\\\\033c&quot;&#39; # clear screen for real (it does not work in Terminology)#\\# Make Bash error tolerantalias :q&#x3D;&#39; exit&#39;alias :Q&#x3D;&#39; exit&#39;alias :x&#x3D;&#39; exit&#39;alias cd..&#x3D;&#39;cd ..&#39;# 有颜色的输出设置alias ip&#x3D;&#39;ip -color&#x3D;auto&#39;alias grep&#x3D;&#39;grep -color&#x3D;auto&#39; bash function (设置函数来完成特定的命令操作也是可以的)在上述的几个配置文件中增加函数方法，也能当成命令来使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 展示错误代码EC() &#123; echo -e &#39;\\\\e\\[1;33m&#39;code $?&#39;\\\\e\\[m\\\\n&#39;&#125;trap EC ERR# 用来提取众多类型压缩文件的通用解压命令extract() &#123; local c e i (($#)) || return for i; do c&#x3D;&#39;&#39; e&#x3D;1 if \\[\\[ ! -r $i \\]\\]; then echo &quot;$0: file is unreadable: \\\\\\&#96;$i&#39;&quot; &gt;&amp;2 continue fi case $i in \\*.t@(gz|lz|xz|b@(2|z?(2))|a@(z|r?(.@(Z|bz?(2)|gz|lzma|xz))))) c&#x3D;(bsdtar xvf);; \\*.7z) c&#x3D;(7z x);; \\*.Z) c&#x3D;(uncompress);; \\*.bz2) c&#x3D;(bunzip2);; \\*.exe) c&#x3D;(cabextract);; \\*.gz) c&#x3D;(gunzip);; \\*.rar) c&#x3D;(unrar x);; \\*.xz) c&#x3D;(unxz);; \\*.zip) c&#x3D;(unzip);; \\*.zst) c&#x3D;(unzstd);; \\*) echo &quot;$0: unrecognized file extension: \\\\\\&#96;$i&#39;&quot; &gt;&amp;2 continue;; esac command &quot;$&#123;c\\[@\\]&#125;&quot; &quot;$i&quot; ((e &#x3D; e || $?)) done return &quot;$e&quot;&#125;# 上述的类似方法定义操作可以根据自己的实际情况来设置，比如调节亮度也可以使用这个来进行定义执行 command not found命令找不到pkgfile包含了一个命令找不到的钩子脚本，这个脚本可以用来搜寻标准库来寻找可能提供该命令的包，pkgfile安装pkgfile -U同步包 bash的command not found设置为了激活这个，需要在配置文件~/.bashrc中source这个hook，在配置文件中添加这一行即可source /usr/share/doc/pkgfile/command-not-found.bash zsh的设置 可以在～/.zshrc中添加一个command_not_found_handler()方法，用来指定命令找不到时的处理方法方法内容如下： 1234567891011121314151617181920command\\_not\\_found\\_handler() &#123; local pkgs cmd&#x3D;&quot;$1&quot; files&#x3D;() printf &#39;zsh: command not found: %s&#39; &quot;$cmd&quot; # print command not found asap, then search for packages files&#x3D;($&#123;(f)&quot;$(pacman -F --machinereadable -- &quot;&#x2F;usr&#x2F;bin&#x2F;$&#123;cmd&#125;&quot;)&quot;&#125;) if (( $&#123;#files\\[@\\]&#125; )); then printf &#39;\\\\r%s may be found in the following packages:\\\\n&#39; &quot;$cmd&quot; local res&#x3D;() repo package version file for file in &quot;$files\\[@\\]&quot;; do res&#x3D;(&quot;$&#123;(0)file&#125;&quot;) repo&#x3D;&quot;$res\\[1\\]&quot; package&#x3D;&quot;$res\\[2\\]&quot; version&#x3D;&quot;$res\\[3\\]&quot; file&#x3D;&quot;$res\\[4\\]&quot; printf &#39; %s&#x2F;%s %s: &#x2F;%s\\\\n&#39; &quot;$repo&quot; &quot;$package&quot; &quot;$version&quot; &quot;$file&quot; done else printf &#39;\\\\n&#39; fi return 127&#125; 或者利用pkgfile包提供的/usr/share/doc/pkgfile/command-not-found.zsh同bash的设置","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"arch安装后配置","date":"2021-02-16T09:20:50.756Z","path":"wiki/2021-03-03-arch安装后配置/","text":"添加archlinuxcn镜像源在/etc/pacman.conf文件末尾中添加以下内容： 1234[archlinuxcn]# Siglevel &#x3D; Never &#x2F; Optional TrustedAll&#x2F; TrustedOnlyServer &#x3D; https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinuxcn&#x2F;$arch# Sever &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinuxcn&#x2F;$arch 安装GPG KEYsudo pacman -Syyusudo pacman -S archlinuxcn-keyring 配置aur安装：sudo pacman -S yay修改aururl镜像源yay --aururl https://aur.tuna.tsinghua.edu.cn --save 配置zsh shell更换shellchsh -s /bin/zsh重启生效 安装oh-my-zsh插件sudo pacman -S git wget curl需要先安装一些软件包 curl安装： sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; wget安装（国内）： wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh修改install.sh有可执行权限，然后执行安装脚本即可安装好oh-my-zsh ==如果执行比较慢，修改install.sh==找到以下部分： 12345# Default settingsZSH&#x3D;$&#123;ZSH:-~&#x2F;.oh-my-zsh&#125;REPO&#x3D;$&#123;REPO:-ohmyzsh&#x2F;ohmyzsh&#125;REMOTE&#x3D;$&#123;REMOTE:-https:&#x2F;&#x2F;github.com&#x2F;$&#123;REPO&#125;.git&#125;BRANCH&#x3D;$&#123;BRANCH:-master&#125; 然后将中间两行改为： 12REPO&#x3D;$&#123;REPO:-mirrors&#x2F;oh-my-zsh&#125;REMOTE&#x3D;$&#123;REMOTE:-https:&#x2F;&#x2F;gitee.com&#x2F;$&#123;REPO&#125;.git&#125; 配置zshzsh的配置文件：～/.zshrc 主题： 在配置文件中的ZSH_THEME=&#39;&#39;修改为想要的主题即可 p10k主题安装： git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH\\_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k 搭配字体： MesloLGS NF Regular.ttf MesloLGS NF Bold.ttf MesloLGS NF Italic.ttf MesloLGS NF Bold Italic.ttf设置.zshrctheme：ZSH_THEME=&#39;powerlevel10k/powerlevel10k&#39; 插件： plugin=&#123;git zsh-syntax-highlighting zsh-autosuggestions&#125;如果～/.bash_profile有配置内容还需添加source ~/.bash_profile 安装插件： zsh-syntax-highlighting：git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH\\_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlightingzsh-autosuggestions：git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH\\_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 输入法安装sudo pacman -S fcitx5-im fcitx5-configtools fcitx5-material-color 中文支持包： fcitx5-chinese-addons fcitx5-rime fcitx5-chewing fcitx5-chinese-addons 包含了大量中文输入方式：拼音、双拼、五笔拼音、自然码、仓颉、冰蟾全息、二笔等 fcitx5-rime 对经典的 Rime IME 输入法的包装，内置了繁体中文和简体中文的支持。其官网位于：[1] fcitx5-chewing 对注音输入法 libchewing 的包装 需要在其他软件界面下切换输入法： 在~/.pam_environment加入： 1234GTK_IM_MODULE DEFAULT&#x3D;fcitxQT_IM_MODULE DEFAULT&#x3D;fcitxXMODIFIERS DEFAULT&#x3D;\\@im&#x3D;fcitxSDL_IM_MODULE DEFAULT&#x3D;fcitx 或者在/etc/environment加入： 123GTK_IM_MODULE&#x3D;fcitxQT_IM_MODULE&#x3D;fcitxXMODIFIERS&#x3D;@im&#x3D;fcitx 开发环境配置python下载pip：sudo pacman -S python-pip设置pip源：pip config set global.indec-url https://pypi.tuna.tsinghua.edu.cn/simple go 安装go：sudo pacman -S go 选择一个Go工作目录：～/Documents/go在这个目录下新建三个目录：src，bin，pkg 配置环境变量：GOROOT=/usr/lib/go设定为自己的安装目录编辑～/.xprofile，加入：1234export GOROOT&#x3D;&#x2F;usr&#x2F;lib&#x2F;goexport GOPATH&#x3D;~&#x2F;Documents&#x2F;goexport GOBIN&#x3D;~&#x2F;Documents&#x2F;go&#x2F;binexport Path&#x3D;$PATH:$GOROOT&#x2F;bin:$GOBIN 配置GOPROXY：go env -w GOPROXY=https;//goproxy.io,direct或者：export GOPROXY=https://goproxy.io java查看当前系统的jdk：archlinux-java status需安装archlinux-java选中其中一个为默认jdk：archlinux-java set 列出的名字安装最新jdk：sudo pacman -S jdkjdk8安装：sudo pacman -S jdk8-openjdk nodejs安装：sudo pacman -S nodejs npm使用淘宝镜像：npm config set registry https://registry.npm.taobao.org安装软件包：npm install -g @vue/cli docker安装docker：sudo pacman -Syu docker免sudo执行docker：sudo gpasswd -a $&#123;USER&#125; docker配置docker镜像：在/etc/docker目录新建maemon.json写入： 123&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]&#125; 重启docker生效：sudo systemctl restart docker mysql 安装matria DB：sudo pacman -S mariadb 配置目录：sudo mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql 启动mariadb:sudo systemctl start mysqld 为root用户设置新密码：sudo mysqladmin -u root password &#39;password&#39; 进入数据库命令：mysql -u root -p 设置为开机自启的命令：sudo systemctl enable mysql 常用软件安装 QQ: wine(qq)：sudo pacman -S deppin.com.qq.im qq(linux):qq-linux tim:deepin.com.qq.office lightqq:deepin.com.qq.im/light 微信：deepin.com.wechat2QQ微信在KDE遇到打不开的问题：sudo pacman -S gnome-setting-daemon执行：sudo cp /etc/xdg/autostart/org.gnome.SettingsDaemon.Xsettings.desktop ~/.config/autostart然后在设置中开机关机中的自动启动，开启该插件，需在高级模式下，选中只在Palsma中启用telegram:telegram-desktop WPS：wps-office-cn/wps-office wps-office-ttf-wps-fonts typora：typora mindmap：mindmaster-cn需使用yay vscode：code/visual-studio-code-bin postman：postman-bin eclipse：eclipse-java pycharm：pycharm-professional / pycharm-community-edition intellij idea：intellij-idea-ultimate-edition/ intelli-idea-community-edition 网易云：netsease-cloud-musicqq音乐：deepin.com.qq.qqmusic google：google-chrome-stable/chromium/firefox virtual-box：virtualbox 百度网盘：baidunetdisk-bin qv2ray：qv2ray翻墙","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"安装和简单配置","date":"2021-02-16T08:41:40.588Z","path":"wiki/2021-03-03-安装和简单配置/","text":"Archlinux安装Bios设置关闭安全启动，关闭快速启动，开启ACHI如果有uefi最好开启 镜像盘制作 下载ventoy镜像盘制作软件 插入U盘（8-32G主流计算机都可识别） 打开软件格式化制作启动盘 制作完成后，下载archlinux的iso文件（官网速度比较慢的话使用清华或者中科大镜像下载） 安装进入bios，选择启动顺序为U盘先启动，进入之后选择archlinux的镜像启动盘 设置网络环境，wlan的连接使用iwctl这个软件包iw的命令，设置连接。device list也是查看接口的，station device show查看可用的连接，station device connect con用来连接网络 设置好网络之后，更新系统的时间，使用timedatectl set-ntp true更新，timedatectl status查看时间 设置镜像源，进入/etc/pacman.d/mirrorlist，将我国的镜像源置于最前面，再修改/etc/pacman.conf，在后面加入archlinuxcn的server源 123[arhlinuxcn]SigLevel&#x3D;Never(用来设置成不设限制的安装)Optional TrustALl、。等Server&#x3D;https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;$arch 设置linux的分区，首先先去创建自己需要的分区，cfdisk disk-name进入到指定的硬盘，如cfdisk /dev/nvme1n1然后在弹出的界面按自己需要进行分区的创建 分区建议：根目录/看自己的需要，/boot启动盘大小至少512m，/home按需要选择，swap交换分区看自己的内存进行选择2-8G，/var分区8-12G，/usr不建议创建，如果后挂载创建可能会导致进入不了安装的系统 格式化分区：/boot使用mkfs.vfat 分区（fat32）命令格式化，mkswap 分区进行交换分区的格式化，mkfs.ext4（ext4）进行其他分区的格式化 挂载分区，按自己设定的分区挂载，mount root-partirion /mnt挂载根分区，mount boot-partition /mnt/boot 类似这样（挂载前需要在相应的位置创建对应的文件夹，交换分区不需要），交换分区的挂载使用swapon 分区激活 使用pacstrap /mnt base linux linux-firmware vim安装linux系统到挂载的根目录中 生成分区记录表fstab：genfstab -U /mnt &gt; /mnt/etc/fstab arch-chroot /mnt进入到自己安装创建好新系统 时区设置：ln -sf /usr/share/zoneinfo/Asia（地区）/Shanghai(城市) /etc/localtime 生成/etc/adjtime：使用命令hwclock --systohc 设置区域和locale标准：在/etc/locale.gen中找到en_US.UTF-8和你想要的区域如zh_CN.UTF-8取消注释 设置/etc/locale.conf，加入：LANG=en_US.UTF-8 设置hostname：/etc/hostname设置想要的hostname，如Archlinux 设置hosts：/etc/hosts加入：123127.0.0.1 localhost：：1 localhost127.0.1.1 Archlinux.localdomain Archlinux # 此处的Archlinux就是上一部的hostname的值 到这一步基本的配置结束，然后生成root的密码： passwd设置两遍密码即可 安装引导程序生成引导启动项，首先安装引导程序和一些必要的程序软件pacman -S grub efibooemgr os-prober ntfs-3g networkmanager network-manager-applet wireless-tools dialog sudo git wpa_supplicant mtools dosfstools base-devel linux-headers reflectornetworkmanager是网络管理连接的软件包，用以在安装重启后进行网络连接，也可以下载iw包，就是之前用的iwctl的包组在执行这一步的安装操作之前，需要进行一下镜像源的配置，同上。这里面的软件包建议安装，如果你知道这些软件包的用处且你不需要，你就可以不安装 grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Archlinux这是64位电脑的安装步骤 grub-mkconfig -o /boot/grub/grub.cfg生成启动项，生成好之后查看一下是否正确配置好启动项，也可以使用efibootmgr查看启动项和启动顺序，在生成grub之前可以先下载好grub的主题文件，并将其放在/usr/share/grub/themes文件下，然后在/etc/default/grub找到GRUB_THEME=&#39;/usr/share/grub/themes/manjaro/theme.txt&#39;修改成主题文件目录下的theme.txt再执行生成操作，就可生成该主题的启动界面 到上一步结束，安装就完成了，一路exit到安装系统进入的界面，然后执行umount -a取消所有挂载，reboot重启 安装后的配置网络连接 首先开启NetworkManager服务：systemctl enable NetworkManager然后systemctl start NetworkManager 使用nmtui进入网配置界面，选择需要的网络进行连接 用户创建useradd -s /bin/zsh -G groupname -m jiabao -d /home/homedir -s指定用的shell环境 -G指定群组 -m指定用户名字如果没有指定家目录，自动创建同名的家目录 -d指定家目录 除了这些还有几个选项可以用，通过man useradd去查看用户权限设置，可以在/etc/sudoers进行设置，取消wheel群组的注释即可让该群组下的用户拥有超级权限 驱动安装显卡驱动安装 lspci | grep -e VGA -e 3D查看显卡的类型 根据自己的显卡类型去选择合适的驱动进行安装intel：sudo pacman -S xf86-video-intelamd：sudo pacman -S xf86-video-amdgpunvidia：sudo pacman -S nvidia可再安装nvidia-utilsnvidia管理工具以上基本可以满足驱动要求，一般情况下都可以了，具体的配置要求和驱动安装可以看：驱动安装 声卡驱动sudo pacmam -S alas-utils pulseaudio pulseaudio-alsa 触摸板驱动sudo pacman -S xf86-input-synaptics 输入设备驱动pacman -S xf86-input-libinput 字体安装sudo pacman -S wqy-microhei wqy-microhei-lite wqy-bitmapfont wqy-zenhei ttf -arphic-ukai ttf-arphic-uming adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts 输入法安装安装fcitx5-im和fcitx5-configtool主题fcitx5-material-theme 中文输入法插件fcitx5-chinese-addons 需要在其他应用可以调用需要创建～/.pam_environment文件 1234GTK\\_IM\\_MODULE DEFAULT&#x3D;fcitxQT\\_IM\\_MODULE DEFAULT&#x3D;fcitxXMODIFIERS DEFAULT&#x3D;\\\\@im&#x3D;fcitxSDL\\_IM\\_MODULE DEFAULT&#x3D;fcitx 配置就可以使用fcitx5-configtool进行相应的配置 软件的安装obsidian visual-studio-code-bin chromium 图形界面的安装配置xorg的安装配置首先安装开源世界最流行的xorgsudo pacman -S xorg-server最小的支持也可安装：xorg包含xorg-server 字体 xorg-apps安装好之后，且所有的驱动都安装好，就可以生成配置文件Xorg :0 -configure这个命令可以在 /root/xorg.conf.new然后将这个配置文件复制到/etc/X11/xorg.conf查看一下是否配置好了 i3的安装配置sudo pacman -S i3-gaps i3lock cp /etc/X11/xinit/xinitrc ~/.xinitrc复制xinitrc到家目录下，在最后的几行注释掉之后，加入exec i3现在执行startx就可以进入i3的图形界面 自动登陆之后进入图形界面的配置使用bash：～/.bash_profile使用zsh： ～/.zprofile加入下面的内容 123if [[ ! $DISPLAY &amp;&amp; $XDG_VTNA -eq 1 ]]; then startxfi cp /usr/share/doc/i3 ~/.config/i3/config复制i3的配置文件到家目录下这是i3界面的配置文件 美化软件的安装：feh polybar terminator picom xautolock 锁屏快捷键绑定：bindsym $mod+l exec --no-startup-id i3lock -i /home/jiabao/BingWallpaper/lock/lock.png执行息屏设置exec --no-startup-id xset dpms 300自动锁屏exec --no-startup-id xautolock -time 8 -locker &quot;i3lock -i /home/jiabao/BingWallpaper/lock/lock.png&quot;","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"启动数字键盘激活","date":"2021-02-15T15:52:51.893Z","path":"wiki/2021-03-03-启动数字键盘激活/","text":"控制台激活 使用单独的服务来开启创建激活脚本： 12345678910&#x2F;usr&#x2F;local&#x2F;bin&#x2F;numlock#!&#x2F;bin&#x2F;bashfor tty in &#x2F;dev&#x2F;tty&#123;1..6&#125;do &#x2F;usr&#x2F;bin&#x2F;setleds -D +num &lt; &quot;$tty&quot;;done## 更改为可执行 然后创建和激活systemd服务项： 123456789101112&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;numlock.service[Unit]Description&#x3D;numlock[Service]ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;numlockStandardInput&#x3D;ttyRemainAfterExit&#x3D;yes[Install]WantedBy&#x3D;multi-user.target 扩展getty@.service为getty@.service添加服务：添加到原来的unit的顶部 12345&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;getty@.service.d&#x2F;activate-numlock.conf[Service]ExecStartPre&#x3D;&#x2F;bin&#x2F;sh -c &#39;setleds -D +num &lt; &#x2F;dev&#x2F;%I&#39;### 如果遇见问题，替换ExecStartPre为ExecStartPost 关闭登陆屏幕的提示 edit getty@tty1.service and add --nohints to agetty options: 123[Service]ExecStart&#x3D;ExecStart&#x3D;-&#x2F;sbin&#x2F;agetty &#39;-p -- \\\\\\\\u&#39; --nohints --noclear %I $TERM bash的方案：添加setleds -D +num to ~/.bash_profile，需登陆后生效 所有的xorg下的numlock配置 startx：安装脚本numlockx，然后在～/.xinitrc的exec之前加一句：numlockx &amp; GDM：在~/.xprofile加入 123if [ -x &#x2F;usr&#x2F;bin&#x2F;numlockx ]; then &#x2F;usr&#x2F;bin&#x2F;numlockx onfi GNOME：执行命令gsettings set org.gnome.desktop.peripherals.keyboard numlock-state true为了记住numlockx的最后状态，使用：gsettings set org.gnome.desktop.peripherals.keyboard remember-numlock-state true","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"system maintenance","date":"2021-02-15T15:40:03.992Z","path":"wiki/2021-03-03-system maintenance/","text":"系统维护定期的系统维护对于一段时间后的archlinux的完好功能很有必要定期的维护是许多用户需要适应习惯的练习 检查错误 systemctl --failed 查看是否有系统服务发生错误 日志文件的错误查看[[journalctl]]journalctl -p 3 -xb查看位于/var/log日志文件中的高优先级错误 Xorg#troubleshooting查看xorg日志文件错误 备份一定时间间隔创建重要文件的备份 下面是一些比较重要的需要备份的一些文件类型 配置文件在修改你的配置文件之前，先进行备份，这样可以在除了问题的时候随时回复最初状态 安装包组的列表维持一个全部安装包组的列表，这样可以让安全重装不可避免的时候，更容易的重新回复到最初的环境pacman -Qqe &gt; pkglist.txtpacman的列出安装包的列表的技巧pacman -S --needed - &lt; pkglist.txt安装list文件中的所有package pacman数据库tar -cjf pacman_database.tar.bz2 /var/lib/pacman/local备份local的pacman数据库 加密元数据系统备份定期备份系统和用户数据是很重要的，例如在/etc, /home,/root,/var对于服务器，还有/srv 使用Btrfs snapshots 使用LVM SNAPSHOTS 使用rsync 使用tar [[tar系统备份]] 使用SquashFS 升级系统建议使用定期的完全系统升级通过pacman -Syu避免使用pacman -Sy部分升级 使用包管理器安装软件pacman在追踪文件上有优势，有时候手动安装可能会忘记之前的操作，因此使用包管理器可以更好的管理安装的包 选择开源驱动而不是proprietary driver大部分时候，开源驱动更加稳定可靠，开源驱动的bug修复更快更容易，但是闭源驱动更全面功能更多关于更多的驱动信息在这个网站：linux-driver 小心非官方源的软件包从aur和非官方源的用户目录安装包时要小心 定期更新镜像源由于镜像源的质量随着时间在不断变化，有些可能下线或者速度变慢 清理文件系统Disk usage displaydisk cleaningpacman cache cleaning/var/cache/pacman/pkg/在这里面清理不需要的软件包下载：pacman-contrib包，使用paccache -r清理所有，保留最近的3个 详细的paccache信息：cache cleanning 清理不使用的包使用下面一条命令清理orphans和他们的配置文件pacman -Qtdq | pacman -Rns - 旧的配置文件寻找以下几个文件： ～/.config ~/.cache ~/.local/share 破坏的symlinks可以通过下面两个链接找到方法： 尽管可以删掉破损的链接，但是盲目删除可能会出问题，因此应该注意一点，具体的内容看this links 使用下面的命令查找破损的链接find / -xtype l -print 系统维护的建议和技巧 使用官方信任的软件包 安装linux-lts package长期维护支持版本的","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"tar系统备份","date":"2021-02-15T15:05:20.275Z","path":"wiki/2021-03-03-tar系统备份/","text":"系统备份使用tar做一个整个系统的备份（节省硬盘空间）： 从liveCD启动 改变跟目录到安装的linux下面：mkdir /mnt/archnext mount /dev/archroot-dir /mnt/archnextcd /mnt/archnext chroot . /bin/bash==warning==在这里注意不要使用arch-chroot，这会出问题 如果有额外的分区，需要挂载好 添加不备份的限制，创建一个exclude_file，然后在脚本文件中指定 123456789# Not old backups&#x2F;opt&#x2F;backup&#x2F;arch-full\\*# Not temporary files&#x2F;tmp&#x2F;*# Not the cache for pacman&#x2F;var&#x2F;cache&#x2F;pacman&#x2F;pkg&#x2F;# 支持正则表达式，忽略指定的这些目录不备份 使用下面的备份脚本进行备份 恢复备份文件tar --acls --xattrs -xpf backupfile 12345678910111213141516171819202122232425262728293031323334353637#!&#x2F;bin&#x2F;bash# full system backup# Backup destinationbackdest&#x3D;&#x2F;opt&#x2F;backup# Labels for backup name#PC&#x3D;$&#123;HOSTNAME&#125;pc&#x3D;paviliondistro&#x3D;archtype&#x3D;fulldate&#x3D;$(date &quot;+%F&quot;)backupfile&#x3D;&quot;$backdest&#x2F;$distro-$type-$date.tar.gz&quot;# Exclude file locationprog&#x3D;$&#123;0##\\*&#x2F;&#125; # Program name from filenameexcdir&#x3D;&quot;&#x2F;home&#x2F;&lt;user&gt;&#x2F;.bin&#x2F;root&#x2F;backup&quot;exclude\\_file&#x3D;&quot;$excdir&#x2F;$prog-exc.txt&quot;# Check if chrooted prompt.echo -n &quot;First chroot from a LiveCD. Are you ready to backup? (y&#x2F;n): &quot;read executeback# Check if exclude file existsif \\[ ! -f $exclude\\_file \\]; then echo -n &quot;No exclude file exists, continue? (y&#x2F;n): &quot; read continue if \\[ $continue &#x3D;&#x3D; &quot;n&quot; \\]; then exit; fifiif \\[ $executeback &#x3D; &quot;y&quot; \\]; then # -p, --acls and --xattrs store all permissions, ACLs and extended attributes. # Without both of these, many programs will stop working! # It is safe to remove the verbose (-v) flag. If you are using a # slow terminal, this can greatly speed up the backup process. tar --exclude-from&#x3D;$exclude\\_file --acls --xattrs -cpvf $backupfile &#x2F;fi Backup with parallel compressionTo back up using parallel compression (SMP), use pbzip2 (Parallel bzip2): tar -cvf /path/to/chosen/directory/etc-backup.tar.bz2 -I pbzip2 /etc Store etc-backup.tar.bz2 on one or more offline media, such as a USB stick, external hard drive, or CD-R. Occasionally verify the integrity of the backup process by comparing original files and directories with their backups. Possibly maintain a list of hashes of the backed up files to make the comparison quicker. Restore corrupted /etc files by extracting the etc-backup.tar.bz2 file in a temporary working directory, and copying over individual files and directories as needed. To restore the entire /etc directory with all its contents execute the following command as root: tar -xvf etc-backup.tar.bz2 -C","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"shortcut-keys","date":"2021-02-15T14:45:01.447Z","path":"wiki/2021-03-03-shortcut-keys/","text":"剪切板shift+insert","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"journalctl","date":"2021-02-15T14:18:02.428Z","path":"wiki/2021-03-03-journalctl/","text":"日志文件优先级 value severity keyword description 0 emergency emerg 系统不可用 1 alert alert 应该立即修正 2 critical crit 致命错误 3 error error 错误发生 4 warning warning 警告 5 notice notice 提示 6 info info 7 debug debug","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"systemd","date":"2021-02-15T13:56:56.038Z","path":"wiki/2021-03-03-systemd/","text":"SYSTEMDArchlinux使用这个==是archlinux作为init进程的service管理程序==，是linux的系统和服务的管理软件套装 作为PID1进程，并且用来启动系统的后续程序和配置文件等。 ==一些特点== systemd拥有良好的同步能力 使用socket和D-bus activation作为启动服务 提供的合适的守护进程daemons的启动 使用linux的control group追踪进程 保持挂载和自动挂载点 systemd支持SysV和LSB的init脚本并且作为sysinit的替代者 包含有日志守护进程以及控制基本系统配置（hostname，date，locale）的utilities 维持一系列的登陆用户并且运行容器和虚拟机，系统账户，正在使用的目录和设置，管理进但网络配置的守护进程，网络时间同步，日志记录以及域名解析（name resolution） 基本使用主要的用来introspect和控制系统的命令是systemctl==用处==：检查系统状态，管理系统和服务，使用systemctl -H USER@HOST可以管理远程机器（使用的是SSH连接）Plasma用户下载systemd-kcm是图形界面管理程序 分析系统状态systemd status查看系统的状态systemctlorsystemd list-units列出正在运行的单元systemctl --failed列出失败单元可用的的单元文件（可以是service，.mount，.device或者.socket）可以在/usr/lib/systemd/system/and/etc/systemd/system/中看到systemdctl list-unit-files列出安装的单元文件（unit files）systemctl status PID展示指定PID的cgroups slice 内存和父母进程 使用unitssystemd.unit详细信息使用systemctl的时候，一般来说必须指定unit file的全名，包括后缀，有时候可以不指定后缀也可以 不指定后缀时，默认为service,netctl等同netctl.service 挂载点自动转换为.mount，/home=home.mount 和挂载点一样，设备device也是自动转换 systemctl help unit查看unit的手册文档systemctl status unit查看unit状态systemctl is-enable unitunit是否可以激活systemctl start/stop/restart/reload开启/停止/重启/重加载systemctl daemon-reload重载system管理器的配置文件systemctl enable unit启动的时候自动启动unitsystemctl enable --now unit设置开机启动并立马启动systemctl disable unit不再自动启动systemctl reenable unit自从上次开启之后安装部分发生改变之后使用这个命令 power managerment电源管理polkit是非特权用户电源管理所必须的如果没有本地系统登陆用户session或其他的session在使用，下面的命令直接生效而不用系统权限，不然需要系统密码systemctl reboot/poweroff/suspend/hibernate/hybrid-sleep重启/关机/suspend/休眠/混合休眠","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"息屏和休眠设置","date":"2021-02-15T12:54:02.646Z","path":"wiki/2021-03-03-息屏和休眠设置/","text":"息屏exec xset dmps seconds","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"自动登陆","date":"2021-02-14T05:34:42.332Z","path":"wiki/2021-03-03-自动登陆/","text":"####自动登陆的设置 自动登陆图形管理器或桌面管理器在～/.zprofile加入下面一句的设置 123456if [ -z &quot;$&#123;DISPLAY&#125;&quot; ] &amp;&amp; [ &quot;$&#123;XDG_VTNR&#125;&quot; -eq 1 ]; then exec startx # 需要i3退出时不推出登陆，就删除exec # 但是在有人可以杀死x进程的话，就可以访问你的家目录，安全性不足fi# 需要在tty1-tty3可以使用自动登陆选项，将-eq 1改成-le 3 自动登陆虚拟控制台可以通过在下面的文件中添加配置文件，或者是通过执行命令systemctl edit getty@tty1再进行添加配置的操作 1234567&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;getty@tty1.service.d&#x2F;override.conf[Service]ExecStart&#x3D;ExecStart&#x3D;-&#x2F;usr&#x2F;bin&#x2F;agetty --autologin username --noclear %I $TERM# 替换--autologin username 为 --skip-login --login-options username可以使用输入用户名的自动登陆方法 自动登陆指定用户只需要输入密码即可，按下面的配置进行设置： 12345678&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;getty@tty1.service.d&#x2F;override.conf[Service]ExecStart&#x3D;ExecStart&#x3D;-&#x2F;sbin&#x2F;agetty -n -o username %I### 配置好之后执行\\# systemctl enable getty@tty1命令激活","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"DPI缩放调节","date":"2021-02-11T14:36:42.785Z","path":"wiki/2021-03-03-DPI缩放调节/","text":"根据不同的图形界面环境，设置有所不同，具体的配置请看官方文档 gnome桌面环境kde桌面环境xfce桌面环境xorg环境（如i3此类的窗口管理器）通过Xresource来进行配置，在家目录下添加.Xresource文件，加入下面的内容： 123456789Xft.dpi: 192 ! 这个数值是以96为100%比例，具体数值看自己需要的缩放! These might also be useful depending on your monitor and personal preference:Xft.autohint: 0Xft.lcdfilter: lcddefaultXft.hintstyle: hintfullXft.hinting: 1Xft.antialias: 1Xft.rgba: rgb 为了确保在X启动的时候顺利加载DPI设置，需要使用xrdb -merge ~/.Xresource可以在～/.xinitrc也可以在其他的启动x时启动的配置文件中设置xdrdb需要安装xorg-xrdb包","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"亮度调节","date":"2021-02-11T10:08:41.150Z","path":"wiki/2021-03-03-亮度调节/","text":"使用命令echo num &gt; /sys/class/backlight/intel_backlight/brightness其中的num是你需要设置的屏幕亮度最大的屏幕亮度在/etc/class/backlight/intel_backlight/max_brightness文件中暂时性的设置就可以通过上面的设置进行调节，每次开机的时候就设置可以创建一个脚本，每次启动都执行这个脚本就可以：简单的脚本文件如下 12345#！ &#x2F;bin.bashecho 2000 &gt; &#x2F;sys&#x2F;class&#x2F;backlight&#x2F;intel_backlight.brightness# 可以在这个基础上进行更进一步的配置，可以进行用户配置百分比的选择echo $pencent*max_brightness &gt; &#x2F;sys&#x2F;class&#x2F;backlight&#x2F;intel_backlight&#x2F;brightness 可以将这个脚本放在/etc/rc.local中执行 自定义的按需设置就可设置为读取命令行输入的一个配置文件来进行设置新建一个更好的脚本文件来达到该设置效果就好 12345#！ &#x2F;bin&#x2F;bashread -p &quot;Please enter a brightness percent&quot; percentMAX_BRIGHTNESS&#x3D;$(cat &#x2F;sys&#x2F;class&#x2F;bcaklight&#x2F;intel_backlight&#x2F;max_brightness)brightness&#x3D;&#96;expr $percent \\* $MAXBRIGHTNESS&#96;echo &gt; &#x2F;sys&#x2F;class&#x2F;backlight&#x2F;intel_backlight&#x2F;brightness","tags":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"}]},{"title":"Interface","date":"2021-02-03T15:53:55.777Z","path":"wiki/2021-03-03-Interface/","text":"接口时Java中很重要的一部分，接口只可以被implements，并不可以实例化接口。接口中可以有静态fields(但是默认被定义为final fields，不可修改)，抽象方法（abstract默认就是，可不写）、静态方法（static,必须有方法体）、默认方法（default，必须有方法体）。==所有的方法默认是public的，因此可省略public==access_modifier interface InterfaceName&#123;&#125; 1234567891011public interface FuncInterface&#123; static String name = &quot;FuncInterface&quot;; // 默认final不可修改 void prinName(); // 抽象方法，implements该接口的类必须实现的方法 String getName(); default void setName(String name)&#123; this.name = name; &#125;; // 默认方法，必须有方法主体，子类implements时，要么不提该方法，要么重写该方法。 static String getFields()&#123; return this.name &#125; // 静态方法可以覆盖hide，不重写利用类对象访问不了static方法，只能通过接口名来访问静态方法&#125; 扩展接口时：对于原有的方法可以不用提，直接从父接口继承过来。特别是default方法，要么不提，要么重写。 default方法的存在可以让原来使用这个接口的类不需要更新还能继续使用，不会出错，不然，接口更新了一个抽象方法之后，原来的类也需要去更新，实现方法重写。这样做可以让用户决定是否更新或者继续使用，从而维护了正常使用让用户不知情的情况下认仍然可以继续使用 Java中的interface也可以用来type reference，正式由于类和接口的reference，组成了Java的多态 lambda表达式语法：参数 -&gt; 表达式(first, second) -&gt; second-first如果一行代码解决不了，可以使用{}来包裹代码块一般lambda在java中主要使用在那些需要传入函数参数的地方 lambda表达式可以访问外围参数，但是有限制，只能访问那些变量值不会改变的，如果可以个改变那么，并发执行多个动作就会不安全 lambda表达式捕获的参数必须是事实最终变量（变量初始化之后不会再赋新值） lambda表达式中不可以声明包裹体的变量同名的参数或者同名的局部变量。 lambda中使用this是使用的创建这个lambda表达式的方法的this ==lambda表达式类似于别的语言中的闭包== 函数式借口对于那些只有一个抽象方法的接口，就叫做函数式接口对于函数式接口的对象的创建，可以提供一个lambda表达式","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Java basic","date":"2021-02-03T15:25:55.079Z","path":"wiki/2021-03-03-Java basic/","text":"Java basicJava Enviroment VariableJAVA_HOME：Java的JDK安装路径CLASSPATH：Java的包查找路径PATH：Java的可执行文件路径，使得可在命令行执行java编译和运行 name rule以字母、美符或者_开始，之后可以是数字、字母、下划线和美元符的组合。关键字不可以用来命名。 Name convention Java大小写敏感 methodName: 只有一个单词时，全小写，如果好几个单词，后面单词的首字母大写。一般方法命名是：动词+形容词/名词 ClassName：只有一个单词首字母大写，其他单词首字母大写。一般的类名是：名词+名词 variableName：和方法名类似,名词+名词。如果是常量，全大写并且不同单词之间使用”_“连接。 basic rule 一个源文件中从public static void main(String[] args)&#123;&#125;开始执行 一个源文件中只能声明一个public类，但是可以有多个非public的类。 在一个源文件中，package声明必须在最开始一行，如果有import语句，则需放在package和类之间。 源文件的文件名需和源文件中的public类的类名一致，无package时import在首行 package和import语句对整个源文件中的类都有效，但是不能对源文件中不同类有不同的package声明 [[Java modifier]]（identifier） access modifier：public，default，private，protected non-access modifier：static，final，abstract，synchronized，volatile，transient [[Java variable]] static variable：以static关键字定义的变量，在类中，方法外。类变量每个类只有一份拷贝。静态变量的访问建议使用className.staticName访问。程序结束后销毁。 instance variable：不以static关键字声明的在方法外类中的变量。不同类的实例拥有各自的实例变量。可以直接变量名访问，也可以this.instanceName访问。对象销毁时变量销毁。 local variable：定义在block中的变量，仅在块体中可以访问，语句执行完成后变量销毁。局部变量不可以使用访问控制符。 Java comment 单行注释：//，，，/**/ 多行注释：/**\\n\\n*/ Java parameters 隐式参数：就是类变量，this关键字代替，指向的是对象 显式参数：方法中实际显示表现出来的参数","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Java variable","date":"2021-02-03T15:21:17.433Z","path":"wiki/2021-03-03-Java variable/","text":"类中Java的不同类型的变量，访问的方法最好是： static fields：ClassName.filedsName(可以使用对象访问，但实际上，静态变量每个类只有一份拷贝)静态方法访问非静态成员时编译会报错。静态成员在类中多有对象是共享的 。 instance fields ：Obj.fieldsName(可以使用类访问，实例变量每个对象有一份拷贝) this keyword：this指代当前的对象，可以用来访问当前对象的instance变量和构造方法，this可以在构造方法和实例方法中调用来访问当前对象的成员，==this在静态方法使用会报错==。this.fieldsName，this()（当前对象的构造方法的调用，可以传入参数） 可变变量（Type… varName）这种变量形式就是可变数量的变量 var关键字的使用var是java10之后新加的一项功能，如果可以从变量的初始值推出变量的类型，用于声明局部变量，而无需指定类型Employee a = new Employee(&quot;jiaboa&quot;,15);var a = new Employee(&quot;jiabao&quot;,15);","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Plaxis_knowledges","date":"2020-12-07T07:22:25.315Z","path":"wiki/2021-03-03-Plaxis_knowledges/","text":"plaxis学习笔记plaxis图形文件导出在output程序中选择输出到文件会导出你当前视图中的显示内容并带有水印，还可以选择复制到剪切板，就将内容输送到剪切板下，只需要粘贴即可显示。 材料属性的设置：土体材料属性设置的时候里面的大多参数是土力学中学过的参数，饱和重度和重度等，以及一些强度参数，还有渗流相关的参数，渗透系数x、y、z方向和其他的渗流相关参数。还有超固结比参数等等，都是土力学相关参数。其中的强度参数和材料力学相关，在后面的其他的一些结构和混凝土等都和材料力学有关，其中的大部分参数是从材料力学中衍生而来或者规范的参数。因此材料力学土力学和岩石力学在这个软件的应用中很重要，因此需要掌握。 岩土体的材料模型（material model）（stress-strain relationship） 土体岩体的力学行为可以以不同程度的精确度建立模型，例如Hooke’s law of linear, isotropic elasticity被认为是最简单应用的应力应变关系，由于只包含变形模量E（Young&#39;s modulus）和泊松比v（Poisson&#39;s ratio）通常由于精度不足而难以捕捉岩土体的行为的关键特征内容。 摩尔库仑模型被认为是首选（first-order）的岩土体behaviour的模拟。 plaxis还提供一些高级的材料模型，这些模型考虑了一些特定的特征：stress-dependency of stiffness（刚度的应力依赖性），strain-hardening/softening（应变硬化和软化）， memory of pre-consolidation（预固结记忆性），critical state（临界状态）， anisotropy（各向异性）， creep（蠕变），膨胀（swelling）``shrinkage收缩。使用这些模型可是模拟更加接近实际情况，因此可以获得更加精确的结果。其中还有一个单独的土体测试界面，可以用来辅助获取相应模型的参数。isotropic（各向同性的） 线弹性模型（linear elastic model）LE线弹性模型是基于（各向同性的胡克定律）Hooke&#39;s law of isotropoc elasticity，包含了E（Young’s modulus）弹性模量（岩土力学中，应力应变曲线的初始斜率为E0，对应50%强度的为E50，对于有很大线弹性范围的高度超固结粘土和岩石，使用E0符合实际，而对于砂土和接近正常固结的粘土，使用E50）和泊松比v（Possion’s ratio）。 尽管线弹性模型并不适合模拟土体，可以用于模拟土体的坚硬介质stiff volumes，如混凝土墙壁（concrete wall）或者天然岩层（intact rock formation）主要用于模拟土体内部刚性结构的模拟 摩尔库伦模型（Mohr-Coulomb model）MCthe linear elastic perfectly-plastic Mohr-Coulomb model（线弹性完全塑形摩尔库仑模型）有五个可输入的参数，E，v土体弹性参数。内摩擦角和凝聚力（土体塑形）以及（剪胀角）。 这个模型是soil-rock behaviour岩体性状的初步近似first-order approximation。建议在考虑问题的初步分析可以使用这个模型，对每一层近似为一个恒定刚度或者和深度成线性关系的刚度，由于使用恒定的刚度，计算往往相对更加快并且可以获得一个初步估计的变形。 硬化土体模型（Hardening Soil model）HS硬化土体模型是一个模拟土体行为的高级模型。对于摩尔库仑模型，通过摩擦角（friction angle）凝聚力（cohesion）和膨胀角（dilatancy angle）来描述应力的限定状态。但是，土体的刚度通过三个不同的刚度描述可以更准确：E50（triaxial loading stiffness），Eur（triaxial unloading stiffness）和Eoed（oedometer loading stiffness）作为多种土体类型的 平均值，默认设为Eur≈3E50和Eoed≈E50。但是软土和坚硬土往往可以设置其他的Eoed/E50比值，用户可以自己设置。 和摩尔库伦模型不同的是硬化土体模型包含stress-dependecy of stiffness moduli，意味着所有的stiffness随着压力增加而增加。因此，所有的三个输入stiffness 和reference stress相关，通常take as 100kPa 除了上述的提到的参数之外，初始土体条件，如pre-consolidation在大部分土体变形问题起着关键作用，可以在initial stress generation考虑进来。 该模型使用摩擦硬化的塑性定义，属于双曲线模型，还用到了压缩硬化，用来模拟土体在初始压缩条件下发生的不可逆压缩。可以用来模拟砂土，砾石以及包含粘土和粉土等较软类型的土体性状。 小应变硬化土体模型（Hardening Soil model with small-strain stiffness）HSsmall是上一个模型的修改，比上个模型多考虑了小应变的土体刚度增量（increased stiffness of soil at small strains）在小应变情况大多数土体比在工程应变情况（engineering strain levels）展示了更高的stiffness，而且这个刚度和应变不成线性关系。这种情况behaviour通过使用附加的应变历史参数strain-history和两个额外的材料参数G0^ref^（小应变剪切模量）和γ0.7（衰减到70%的小应变剪切模量）HSsmall模型的高级特点在working load conditions更明显，这个模型比HS模型提供更可靠的位移当使用dynamic application时还引入了hysterical material damping 软土模型（Soft Soil model）是一个Cam-Clay类型的模型，尤其meant for几乎正常固结的粘土类型土体的primary compression。尽管这个模型的模拟能力被HS模型superseded，但它更加适合模拟软弱土的压缩行为（初始压缩行为） 软土蠕变模型（Soft Soil Creep model）SSC硬化土体模型一般适合所有土体，但是它并未考虑viscous effects（creep，stress relaxing）蠕变和应力松弛。事实上，所有的土体都表现出蠕变且主压缩后面跟随一定的二次压缩。 后者主要出现在软土如normally consolidated clays，silts和peat。软土蠕变模型主要应用于settlement problems of foundation，enbankments等。对于卸载问题，在隧洞和其他开挖问题较常遇到，软土蠕变模型hardly supersededs 简单的摩尔库伦模型。对于HS模型，当使用软土蠕变模型时，合适的初始土层条件是必要的。还包含pre-consolidation stress数据作为包含effect of over-consolidation。注意：初始over-consolidation ratio同样决定了初始蠕变比creep rate 用于模拟与时间有关的软土性状 节理岩石模型（Jointed Rock model）这个模型是一个各向异性的弹塑性的模型（anisotropic elastic-plastic model）尤其适合模拟stratification（分层，层）岩体和特定的断层方向的岩层的behaviour效应。塑形plasticity只发生在三个剪切方向的最大剪切面。每个面有他自己的强度参数凝聚力和摩擦角。天然岩石被认为表现出拥有constant stiffness properties E和v的完全弹性体。弹性降低性质可能会在分层的方向被定义 该模型可用来模拟成层或者节理岩体性状 混凝土模型（concrete model）这是一个用来模拟混凝土和shotcrete structures的高级弹塑性模型。他模拟了time-dependent strength和stiffness of concrete，strain hardening-softening in compression andtension以及creep and shrinkage。失效判据（failure criteria）包含了一个摩尔库伦屈服面（yield surface）for deviatoric loading（偏心荷载），这结合了Rankine yield surface in the tensile regime（抗拉强度）。混凝土模型布置了25个输入参数，但是其中大多数都可以来自standard uniaxial tensile and compression tests（标准单轴抗拉抗压试验）而且一般都是结构工程师熟悉的内容 使用SoilTest facility去校准模型参数SoilTest facility可以被用来检查材料模型的表现（performance）这些模型参数都是在良好的土体试验条件下和任意的应力应变条件获得的。用这个方式，可以很好的比较在真实实验数据下的模型响应并了解模型模拟的soil behaviour的准确性。但即使获取到了很好的匹配结果，仍有必要知道calibrated material models在实际运用时，结果和显示仍有一定差异。尽管如此，SoilTest facility仍可以帮助理解材料模型的有点和局限性以及模型参数的影响。 材料模型的局限性（limitation） plaxis软件是用来模拟解决真实的岩土地质问题，土体模型是soil behaviour，模型参数是用来量化土体特征。尽管很努力的优化代码和土体模型，实际模拟也只是一个近似，不可避免的会有一些数学和代码错误，而且对于问题的模型化的专业程度，土体模型和局限性的理解，模型参数选择以及对于计算结果的可靠性的评定能力都很大的影响实际的准确性 线弹性模型局限性soil behaviour（土质，土体性状）基本是非线性的和irreversible。线弹性模型很难抓住土体的本质特征。但是该模型被认为可以模拟坚硬的大规模的结构或岩床岩层。 排水类型注意固结和渗流计算中,排水取决于渗透系数. 下述内容只应用于塑性计算. 排水排水或者长期材料行为中,刚度和强度是定义为有效应力参数. 不排水 A不排水或者短期材料行为,采用有效刚度参数及有效强度参数. 水被自动赋予很大的体积模量,使土不可压缩, 同时计算(超)孔压(包括水位之上或之下). 不排水 C不排水或者短期材料行为,采用不排水刚度和强度参数. 超孔压的计算包含在总应力计算中,不单独进行计算. 非多孔的不会产生孔压的材料行为. 软件的科学理论plaxis基于的几个基础理论有：变形理论（deformation theory）地下水流理论（groundwater flow theory）、固结理论（consolidation theory）和动力学相关理论（dynamic）以及一些数值方法（numeric methods） 变形理论地下水流理论固结理论动力学有限元的基础公式理论灵敏度分析和参数变化理论 软件的介绍输入前处理 平面应变模型，适用于断面(大致)均匀的几何形状，其中垂直于断面z-方向）一定长度上的应力状态和加载机制是相同的。z 轴方向上的位移和应变设为零。但是，完全考虑了z轴正应力。轴对称模型，适用于径向断面（大致）均匀的圆形结构，加载机制围绕中心轴，设沿任意径向的变形和应力状态一致。注意：轴对称问题的 x坐标表示半径，y坐标对应于对称轴线。不能使用负x坐标值。选择平面应变或轴对称，意味着二维有限元模型的每个节点，只具备 2个平移自由度（即x-和y-方向）。 6节点或15节点三角形单元，都可以用来模拟土层和其它块体。默认单元为15节点三角形单元。该单元提供4阶位移插值，数值积分采用12个高斯点（应力点）。6节点三角形单元的插值为2阶，数值积分采用3个高斯点。结构单元和界面单元类型将自动和土单元类型相匹配。15节点三角形是一种非常精确的单元，对各类问题能得出精度很高的应力计算结果，比如不可压缩性土体破坏性能的计算。使用15节点三角形单元需要较大的内存，计算和运行相对较慢。因而，必要时也可以使用一个更简单的单元类型。6 节点三角形单元具有相当的精度。标准变形分析时，如果单元划分够密，可以得出理想的计算结果。然而，在使用轴对称模型时，或可能发生破坏的情况下——比如计算承载力或使用 phi-c折减法进行安全性分析——要特别小心。使用 6 个节点三角形单元，计算所得的破坏荷载和安全系数一般会偏大。这时，宜使用 15个节点三角形单元。一个 15 节点三角形单元可以看成是 4 个 6 节点三角形单元的组合，因为节点总数和应力点总数相等。然而，15 节点三角形单元比 4 个 6 节点三角形单元的组合功能更强大。 几何模型：几何组件类型和属性：（几何组件的选择工具再按住shift选择可以将类型相同的几何组件） 点和线：鼠标点击直线和点选项，然后就可鼠标点击或者命令行输入坐标进行绘制，如果指针附近有几何点，不会新建点。需要不再连续汇点成线右键鼠标点击即可取消绘制。如果要在线上新建点，捕捉到该直线新建点即可，直线会自动分割成两条直线。删除点通过选择点之后按删除键。如果删除点是两直线以上的直线交点，会同时删除这些直线。 每执行一步绘图操作，程序会判断是否能够形成类组，类组是由不同的几何线围成的封闭图形。判断出来的类组会用淡的阴影表示，可以给每一个类组定义材料性质用来模拟几何图形相应部位土的性状。类组在网格生成时会被分割为土单元。 板：板是用来模拟地层中的细长型结构对象，具有相当的抗弯刚度（弯曲刚度）和轴向刚度。板可以用来模拟沿z轴方向延伸的挡土墙、板、壳体和衬砌的影响。（蓝线表示） 板单元的创建和生成线的方法类似，生成板时，相应几何线也同时生成。板的材料性质包含在材料数据组内。最重要的参数时抗弯刚度EI和轴向刚度EA。有了着两参数可以计算板的等效厚度deq=sqrt(12*EI/ES)。在分步施工作为荷载输入的计算阶段，板可以被激活或者关闭 土工格构：是具有轴向刚度而无弯曲刚度的细长型结构。土工格构只能承受压力不能承受拉力。该对象一般用于模拟土体的加固作用。土工格构生成和板类似，土工格构的唯一材料性质是弹性法向刚度EA，在材料库中定义。 在计算阶段把分布施工作为荷载输入，可以激活或关闭土工格构和点对点锚杆相组合的土工格构可以用来模拟底层锚杆。这种组合情况，土工格构模拟锚杆的锚固段，点对点锚杆模拟锚杆的自由段。 界面：每一个界面都有自己设定的虚拟厚度，用来定义材料性质的家乡尺寸。虚拟厚度越大，产生的弹性变形越大。一般假定界面单元的弹性变形非常小，因而虚拟厚度也比较小。而如果虚拟厚度太小，可能出现数值病态，虚拟厚度等于虚拟厚度因子乘以平均单元尺寸，平均单元尺寸取决于网格生成的整体粗熟度设置。他的大小可以通过输出程序的一般信息窗口获取。虚拟厚度的因子默认值设置为0.1。双击几何线，可以在选择对话框中修改虚拟厚度因子的值，如果界面单元受到极大的正应力作用，就有可能需要减少虚拟厚度因子取值。 界面新建的方法：类似于几何线，界面用几何线右侧的虚线表示。几何线两侧都可布置界面。利用界面可以研究结构对象（挡土墙、板、土工格构等）和周围土体的相互作用，可以使用加号和减号标注几何线可能出现的两个界面，没有意义不影响计算，只是为了区别界面 应用界面的典型情况：模拟板桩墙和土体之间的相互作用（介于光滑和完全粗糙的表面）。相互作用的糙率通过给定界面选取合适的界面强度折减因子（Rinter）的值来模拟。该因子将界面强度（挡土墙摩擦和内聚力）和土体强度（摩擦角和内聚力）相互联系在一起。除了Rinter确定，还可和土体强度参数（土和界面的材料数据组中设定）一同确定。计算阶段把分布施工作为荷载输入，可以激活或者关闭界面 点对点锚杆：用两点间的一根弹簧来模拟的。通过几何子菜单或在工具栏里点击相应的按钮，可以选择这类锚杆。不建议在需要布置点对点锚杆的位置绘制一条几何线。点对点锚杆的端点必须和几何线相连，但不一定连接到现有的几何点。新建点对点锚杆和新建几何线的方法类似，但和新建其他结构对象不同，生成点对点锚杆时不会生成相应的几何线，因此，点对点锚杆不会分割类组也不会生成新类组。 一个点对点锚杆用一个常轴向刚度的弹簧来模拟的，它具有两个节点。该单元既可受拉也可受压，最大拉力和压力受破坏荷载的限制。属性可以在锚杆的材料数据库中输入。计算阶段把分布施工作为荷载输入，可以激活或者关闭点对点锚杆或者施加预应力 锚定杆：是用一端固定的弹簧来模拟的。应用锚定杆可以模拟板桩墙支撑（或支柱）。锚定杆必须总是和现有的几何线相连，但不一定不一定必须连接到现有几何点位置。锚定杆用一个转动某一角度的T表示。T长度时任意的，并不具有任何物理意义。默认情况下，锚定杆位于正x的方向，即在x，y平面内的转角为零，双击图形T的中部，弹出锚杆属性窗口，可以修改锚杆x，y平面的方位角。定义该角正向为逆时针方向，即由正x转向y方向，在属性窗口可以输入锚杆的等效长度，等效长度为连接点到假想唯一为零的锚杆地段的距离。 锚定杆是一个具有一个节点的弹性弹簧单元，其弹簧刚度（轴向刚度）为定值锚杆的另一端是固定的。这些属性可以在锚杆的材料数据库输入。计算阶段可将分布施工作为荷载输入，可以激活或者关闭锚定杆或者施加预应力。 隧道：可以新建几何模型里面的圆形和非圆形的隧道断面。隧道断面由直线和弧线组成，又是附带衬砌和界面。隧道断面可以作为一个对象存储在硬盘上（扩展为.TNL文件）能用在其他工程项目上。 隧洞设计器： 隧道种类：无、钻孔隧道或NATM隧道 荷载和边界条件 指定位移：为了控制某些点的位移而强加于模型的特殊条件。 约束：大小为零的指定位移即为约束。既可应用于几何线也可应用于几何点，在荷载子菜单可以选中约束。几何模型中区分水平约束（ux=0）和竖直约束（uy=0）。还可选择二者组合（ux=uy=0），即总约束 标准固定边界： 分布荷载：分布荷载的输入值为单位面积上的力，包括x和y两个方向分量，默认垂直边界的单位压力。激活的指定位移优先于分布荷载 集中荷载：实际上是平面外单位宽度上的线荷载，实际情况计算力的输入值，实际的集中荷载必须除以2Π，才能得到对称模型中心的力的输入值。如果几何图形同时施加指定位移和集中荷载，计算过程中激活状态的指定位移优先于集中荷载，用不着在全约束线段上添加集中荷载。如果只有一个位移方向时 预加的，其他方向是自由的，就可在自由位移方向施加集中荷载。 转动约束：用来固定板绕z轴的转动自由度。 排水线：描述几何模型内部的（超）孔压为零的线，和固结分析或地下水渗流计算有关。 排水点：描述的是用来从该处土体抽取某个特定流量，或把这个流量由该点位置注入到土体当中，该选项之和地下水渗流计算有关。 材料数据库：岩土和结构的材料性质参数，存储在材料数据组中。有四类：土和界面材料组、板材料组、土工格构材料组和锚杆材料组，所有数据存储在材料数据库里。从材料数据库可将有关数据分配到几何模型的岩土类组，或者分配给相应的结构对象。 材料数据组的数据库：有现有工程项目数据库和全局数据库。 著名的摩尔-库伦模型，是实际岩土性状的一阶近似。该理想塑形模型要用到5个基本输入参数：弹性模量E，泊松比v，内聚力c，摩擦角和剪胀角。由于岩土工程师一般熟悉以上5个参数，而又很少可以得到其他岩土参数有关的数据，故主要集中于该基本岩土模型上。当然也有高级岩土模型。模型参数和实际岩土性状的关系：由标准三轴排水实验得出的典型应力-应变曲线（下图），可以理解上诉5个基本模型参数。试验时首先对材料施加各向相同的围压σ3，保证径向压力不变的同时，增加轴向应力σ1。在加载的第二阶段，土工材料会表现出下图a的趋势。体积增加的趋势尤其反映在砂土中，这在岩石试验中也经常可以观察到。b是对实验结果理想化后的情形。表示了5个基本参数的含义和影响，注意：==为模拟体积不可逆增加的情形需要用到剪胀角== 材料模型： 材料性状种类-材料类型：原则上讲，plaxis的所有模型参数用来描述有效的土体响应，即：土骨架有关的应力和应变之间的关系。岩土的重要特点是存在孔隙水，孔压显著影响土体的响应，为了能够在土体响应里考虑谁-骨架的相互作用，plaxis提供三种性状： 基本步骤 新建项目，设置项目名称、选择项目的模型和单元情况（是平面应变还是轴对称，是15节点还是6节点）和项目几何模型的尺寸（尺寸要能够容纳新建的几何模型，如果发现不能容纳，在文件子菜单项目属性可以修改） 输入程序界面的组成：（有五个tabsheet界面，用来选择不同步骤下几何模型绘制、设置和激活等步骤。前两个是用来设定模型情况的：1. 土界面用来绘制钻孔、设置土层材料和土层地下水等信息的界面（可导入土层模型）2. 结构界面用来绘制工程中特定结构或者模拟特定结构的单元的，绘制特定的单元之后可在选择对象浏览器中设置其中的一些属性和才来特性并分配到相应结构单元上，如果土层在这个阶段绘制，需使用土多边形按钮将绘制的闭合图形设置为土层，才能设置相应的土层材料。后三个tabsheet界面用来计算处理模型的：3. 网格界面是用来生成有限元网格的，在生成相应的有限元网格时可以设置单元分布密度（等级越高计算时间越长，默认中等），可以加密处理或者粗糙处理，当然也可以局部细化或者粗糙处理，在这个界面还可以选取之后绘制曲线的点单元（设置的时输出程序曲线管理器中绘制曲线的点）。网格处理好之后可以查看网格划分情况）。4. 渗流水力条件界面：用来设置地下水水位和地下水边界以及特定类组设定为干即无水力条件的类组。5. 分布施工阶段：在这个界面，可以设置不同的施工阶段并激活不同的结构单元，设定好特定阶段并且相应的结构激活好之后即可进行计算，计算完毕之后就可以去输出程序查看相应的变形、受力、曲线等，并对其进行相应的分析） 为了后续有限元模型的生成，首先需要新建几何模型，用来表示拟分析的问题。几何模型由点线和类组构成，点和线用户输入，类组程序生成。几何模型还包含有一些结构对象和特殊条件，这些特殊条件和结构用来模型隧洞衬砌、挡土墙、板、土-结构之间的相互作用和荷载。 绘制几何模型时一般先绘制总体的模型几何轮廓。此外，材料层、结构物施工分区线、荷载、边界条件也可以定义设置。几何模型不仅要包含初始条件，还要包括不同计算阶段的一些状况。 几何模型建立好后，就可以定义材料参数的数据组，需要定义的材料属性由土层参数，各类结构的参数，建立好之后将他们分配到对应的几何组件上取（分配方式有三种：1. 鼠标左键按住材料属性框中的材料拖到需要分配的类组上。2. 双击需要分配属性的类组，在弹出的对象浏览器中选取对应的材料。3. 鼠标右键单击需要分配的类组单元，选择对应的材料即可）。 在上述的步骤进行完毕后就可以开始生成有限元的网格单元了。 有限元的网格单元生成后，就可以定义初始水力条件和初始的应力条件 初始条件定义好后，就可以准备开始计算了。 工程实践中，要把一个项目分成几个项目阶段。plaxis中计算也分为好几个计算工序：如在某个阶段激活某个特定的荷载、模拟一个施工阶段、引入一个固结时段、计算安全系数等等。每个计算工序往往是分布计算的，分布计算是因为土的非线性性状要求分布加载（荷载分步），大多数情况还是只要设定计算工序末要达到的荷载情况就可以了。plaxis程序会自动对加载过程进行适当的分步。（plaxis程序允许等到一个工序计算完成以后再定义一个新的计算工序，所以不必在计算过程开始以前就定义好所有的计算工序） 再插入和删除计算工序的时候需要留意：下一个计算工序的起始条件会发生变化，必须手动输入的方法对它加以说明。通常在工序列表的结尾添加工序定义一个新的工序，当然也可以在工序之间插入新的工序，在需要添加工序的行插入光标点击插入。通常新工序的计算起点是列表里它前面的那个工序的就算结果，前一个工序的工序号在新工序的起始工序号里面标出。新工序里面激活的类组、结构对象、荷载、水力条件和乘子采用的是前一个工序的状态。定义插入的工序的方法类似于在工序列表的末尾定义新工序的方法，在本来前后相连的两个工序之间插入新的工序之后，原先的下一个工序会保留它原有的起始工序号，不会根据插入的工序自动调整。如果希望新插入的工序变为下一个工序的计算起点，需要手动修改一般标签页里面的起始工序号参数，此时原有的下一个工序的起始条件改变了，因此需要对其进行完全的重新定义，可能对后开的工序产生影响，因此，尽量不要插入工序。删除计算工序时，应当检查这个要删除的工序被哪些工序的起始工序号所引用。确认删除后，所有引用的被删除工序号的工序都会自动的做出相应修改，将起始工序号指向删除工序之前的工序。尽管如此，还是需要重新定义以这些修改了的工序。因此工序数量多的时候一定要事先规划号具体的工序，不要出现插入和删除的操作，不然会有点麻烦！ 大致的工作路径 了解工程背景及模型 边坡的岩性，边坡的剖面状况，坡面治理的情况，软弱结构面的位置，坡面施工状况分析要点： 岩质边坡的软弱结构面是一个界面单元，它具有单独的结构面属性，该处用单独的材料来模拟 支护结构情况：锚杆的自由端和锚固段位置和长度，锚杆格构梁的位置布置（喷射混凝土面层，在2d下可以简化成板来模拟），抗滑桩的位置和布置 材料参数：岩质边坡是具有一定抗拉强度的，软肉结构面性质与土类似，无抗拉强度 模型创建和网格划分 成果形成并查看结果 稳定性分析——安全系数的计算研究 曲线管理器：位移安全系数曲线 位移增量 结构内力 具体工作步骤 导入模型：可以通过dwg，csv, 有分隔符的txt， dxf，geo，sti文件导入。位置在土的导入土层选项。利用 钻孔创建土层的时候，可能不同钻孔的上下边界不一致，就可以在钻孔设置里面设置，这样就可以设置不一样的土层厚度或者定义非水平的土层同样也可设置没有厚度的层。钻孔土层设置遵循的是从上至下的创建方式。还可以添加钻孔，钻孔的添加在修改土层界面的钻孔按钮的子菜单中，点击添加就可添加相应x位置的钻孔。土层还可以通过结构里面的创建土多边形功能进行创建。（如果模型属于对称模型，可只分析一半模型） 土层属性的设置有三种方法：1. 点击材料按钮，在其中弹出的材料设置窗口就可对添加土层并设置相应的图层属性，设置完成后就可以拖拽到相应的添加该图层的类组中。2. 在修改土层界面的材料按钮就可以进行材料设置。3. 右键单击土层，选择土菜单中的材料设置也可进行设置。相应的材料属性设置成功之后，就可打开材料窗口，拖拽相应的材料到特定结构或者土层即可。土层的属性设置时，有一般、参数、地下水、热、界面和初始条件六个设置页面，不同的土体模型其可设置的参数还不一样。材料模型：线弹性、摩尔库伦、土体硬化、小应变土体硬化、软土、软土蠕变、节理岩体等，还可以用户自定义。 除了土层，还需定义一下相应的地下水条件（在修改土层可以进行设置，在第四个tabsheet也可进行设置）许多情况可以忽略地下水流并且稳定孔压或多或少可以通过土层研究数据得到。但有时，在水流发生时并不清楚孔压分布，为了产生孔压还需进行地下水流计算。水条件的设置在修改土层的水tabsheet中的下拉列表进行修改，可选参数如下：土还有一个初始条件，这个设置在修改土层界面的初始条件菜单中，可以设置为自动也可选择手动输入。还有预固结设置，也在修改土层界面，有从材料和从钻孔两个选项。 土层的划分设置可以通过导入土层选项进行导入，可选的导入文件格式有：txt，dxf，csv，geo，sti，stp等。导入文件之后有：尺寸的设置和是否保持原有比例、选择导入的对象类型（点、线、多边形）设置全局坐标的偏移设置以及展示图形的边界坐标设置。导入之后，需要导入土层的地层和结构，首先需要使用图多边形去进行选取绘制，然后再将相应的性质的土材料拖拽到设定的土多边形即可。 场地响应分析：首先需要设置乘数因子：位移乘子和荷载乘子。然后就可以进行计算。对于结构的动态研究来说，场地响应分析是一个有必要的预备研究，因为结构的地震响应受到支撑土层的岩土参数的影响。在修改土层界面地下site response按钮进行设置分析。 按工程概况将支护结构绘制到模型中（抗滑桩和格构梁和喷护可用板来模拟） 结构模式下的选择工具、选择多个对象工具用来选取结构土层对象的，阵列工具是用来复制选中的对象，以环形或者平移的类型来复制选中对象。 点和线是基础的绘制几何模型的输入对象，绘制的线如果没有界面包裹，并不会影响实际情况，一般有些需要绘制这样的线来更好的区分图形情况 土多边形是用来绘制特定封闭曲线的土层单元的，有（绘制土多边形，绘制土矩形，沿等高线绘制，切割土多边形（将已有的土多边形切割出子土层），添加土多边形点等）。 特征分配到存在的几何对象：分配这些加强结构的方式：1. 边栏的button选取绘制。2. 把特征分配到已有的几何对象上。3.使用命令行的方法。 合并对象：（通常情况，一个点只能有一个点，两个点只能有一个线）例如创建点对点锚杆时，命令行的方法并不会自动合并多余的几何对象（1. 需要鼠标右击在模型浏览器的几何对象、点或者线，然后选择合并相同的对象，或者命令行输入命令：mergeequivalents geometry，Mergeequirvalents geomerty 0.2这行命令是将不在同一位置但是在小于0.2范围的相似对象合并为一个。），第一种会自动合并多余的线，第二种并不会创建新的 。 snap捕捉：有捕捉对象和网格两种。在绘图区下面可以进行设置。 group组对象：选中需要合并的对象，右击选择组即可合并到一组，在模型浏览器可以看到合并的组信息，group允许一次修改组内对象的共同属性 导入几何模型：几何模型和土层信息可以通过导入几何模型按钮进行文件选择然后导入，类似土层导入。 荷载：通过相应的荷载按钮选项进行选择、设置和放置。有点荷载和线荷载。每种荷载又包含：静态荷载和动荷载，选项和设置可在选择浏览器中进行设置配置。点荷载的输入值是指：平面外方向的单位宽度的力，默认值是-y方向的1单元的力。线荷载：输入值是平面外的单位长度上的力，默认是-y方向的单位力。 指定位移荷载：施加于模型的可以控制特定位置的位移的特殊条件，可以通过在已有的几何对象上右键创建，在计算时优先于荷载。选择对象浏览器包含：静态和动态的，类似于荷载里的。有：点位移、线位移和线收缩（其中的动态荷载的设置是通过输入值和一个乘子来详细指定的，每个时间阶time step的实际动态值等于输入值乘以乘子multiplier） 结构单元：锚定杆、板、土工格构、嵌入式排梁、界面和点对点锚杆。1.锚定杆可以以简单的方法模拟piles桩，而不考虑piles-soil相互作用。绘制锚定杆结构时确定锚定杆的位置以及等效长度（等效长度在选择对象浏览器中可以设置），并设置锚定杆的材料属性，即可完成锚定杆的设置配置。2. 点对点锚杆可以用来承受拉力和压力。3. 嵌入式排梁：由于piles（桩）、rock bolts（锚杆）、ground anchors（地锚，锚钉）周围的应力状态和变形模式都是三维的，2d模型不能很好的实际模拟这种结构，2d的嵌入式排梁只是一种简化的方法在2d平面应力模型来模拟三维情况。可以用来模拟传递荷载到周围岩土体的长细结构单元，嵌入式排梁需要的信息有单桩、锚杆或者groutbody的性质以及平面外方向的spacing。4. 板的设置和配置首先确定板的位置和范围，绘制好结构后就可设置板材料的属性，然后再设置板的界面，右击板选择界面绘制（正向界面和反向界面，正负号并不会影响计算） 由于软件并不能识别曲线，cad画模型的软弱面的时候需要注意使用多段线绘制直线，软弱结构面用双向界面来模拟 待所有几何模型导入完毕后先施加需要的约束和荷载，然后就可以导入材料属性了。材料属性可以先做一个属性文件再放入项目文件里面就可以了。然后将对应的材料属性拉到对应的位置处就好，或者在对应的结构或者土体上右击选择材也可。 在相应的几何模型设定完毕，对应的材料属性和结构配置好之后，就可以确定区域进行网格的划分 注意：模型中的线只要没在线的两侧加涂层界面 划分新的土层单元就不会将这个线看成是一个分界线 网格划分完成之后就可以进行稳定系数的计算，首先进行不同阶段的选取，选取了不同阶段之后，需要去激活相应的结构或者土体（激活相应的土体或者结构之前，需要对他们进行一些设置和配置，在选择对象浏览器和模型浏览器中可以进行相应的设置配置）在不同的阶段里进行相应阶段的分析计算。初始阶段如果选择K0过程，一定记得需要设置，记得需要设置==cc ==参数的值，表示施加的重力占总重力的比例关系。 在所有阶段划分计算进行完成之后，在输出程序点击查看结构便可以将结果输出，然后就可以查看相应阶段应力变形和安全系数等内容，然后就可以进行对应的分析和研究。 查看的内容有变形，内力以及安全系数的变化情况（曲线管理器查看安全系数变化，可以对曲线进行坐标轴、图例、线型和颜色的设置） 重点关注重要内容最重要的便是专业知识过硬，能够分析具体工况转为plaxis可以模拟的条件，然后找寻自己需要的各种参数并进行自己的模拟。plaxis软件学习的最重要的内容应该是：将实际工况转换为plaxis可以模拟的条件。 分析具体工况，将工况内的一些条件转换为plaxis中的土层和结构 确定划分网格区域的具体精度要求选取合适的网格精度 确定好自己需要研究的不同阶段，并设置好各阶段的具体条件 工况模拟的一些要点 墙、喷射的混凝土面层可以定义为plaxis结构中的板 土层确定好之后就需要去找寻自己需要的相关参数并设置土层的材料属性。 结构的材料属性也是如此，根据工况确定好具体的结构之后就需要找出相关结构的材料属性并设置好 还需要注意的是有些结构在分阶段施工中需要设置特定的条件，这些特定条件一般在选择对象浏览器，对象浏览器和模型浏览器等分界面进行设置 分阶段是施工过程可以选择自己定义的不同阶段去进行结构和土层的激活冻结等操作，根据具体情况需要去进行操作，相应的特定条件设置在这里也可以通过选择对象浏览器和模型浏览器进行修改设定。具体条件应用场景需要自己阅读手册去进一步理解掌握。 阶段定义完成之后可进行计算，计算完毕查看计算结果，计算结果查看的种类多样，需要根据实际需求去选择自己需要展示的结果。结果分析其实是plaxis应用中最重要的部分，后期自己需要通过多阅读相关论文积累经验提升自己的分析能力。 实际应用的工况模拟结构条件等的选取 实际板的界面或者其他的一些具体界面，可以设置具体界面的材料，通过拖拽土层材料到界面单元的点即可。 2D中怎么模拟桩：由于桩本身是一个三维的结构，怎么在2D模拟是很重要的。 板单元+界面：可能性：可定义轴向刚度和抗弯刚度，得到桩身的内力，界面单元来模拟桩-土之间的相互作用。局限性：土无法穿过板（无间距），使用界面单元会产生不真实的（连续）剪切面。 点间锚杆单元：可能性：可定义轴向刚度，得到桩身轴力，土可以穿过点间锚杆（有间距）。局限性：无法模拟桩-土相互作用，无法定义抗弯刚度 2D排桩单元：综合上述两种方法的优势，可定义轴向刚度和抗弯刚度，得到桩身内力，使用特殊界面模拟桩-土之间相互作用，且不会产生不真实的剪切面，土可以穿过排桩 锚杆的自由端通过点对点锚杆模拟，嵌固端通过嵌固桩(或者土工格构)模拟，并设置好相应的结构材料属性，嵌固桩的连接方式需要看情况设置，有必要设置顶部于下层土单元的连接为自由，和锚杆的连接自动生成。荷载在创建完成之后在选择对象浏览器可以指定位移分布形式和值的大小，不同结构可设置的属性条件有差异。在模型浏览器的变形菜单中可以设置相应的边界条件，一般情况下就选择默认边界条件和约束（底部是完全固定边界条件（位移为0），垂直边界约束水平向（ux=0，uy=自由））在模型浏览器（根据设置的结构不同显示内容不同）菜单选项中可以设置许多的属性条件，根据实际工况和要求选择。在分布施工界面，模型浏览器有一个模型条件，可以设定整个模型的众多条件（1. 气候2. 变形（变形边界条件）3. 动力学4.场地应力（实际场地条件）5.地下水（设置边界）6.precipitation降水（降水量等的设置）7. pseudostatic（设置地震条件，伪稳定）8.thermalflow（热流条件）9.water（设置全局水位条件）） 案例一实操步骤 创建项目，创建项目时设置项目的范围。如果设置出错后续可以通过文件的项目属性进行更改 根据实际工况可要求设置土层和钻孔信息，图层设置有许多的参数需要查看规范或者根据已有资料来进行设置。 设置好了土层之后就可以绘制相应的模型图，并将相应的土层通过拖拉的方式绘制上去。 土层绘制之后就进行结构的绘制放置。 结构绘制完毕后就可以进行相应的网格划分，网格划分通过生成网格按钮进行划分，划分网格默认中等，需要更高精度单元可以进行网格细化。然后就可以通过点击查看网格查看相应的网格划分情况 网格划分完毕之后就可以进行渗流水压力等工况的设置 设置渗流情况之后就可以进行分阶段施工了，通过点击分布施工进入，然后点击添加阶段添加需要添加的阶段并进行相应的设置。设置完一个阶段之后就可以进行计算。带到每个阶段都计算完毕后就可以进入到输出的plaxis2d软件界面进行查看和分析了。 可以查看的内容有变形，应力，以及曲线控制器查看相应的曲线变化情况。曲线管理器首先需要选择查看曲线的点，然后才能看到相应的曲线信息。 水下基坑开挖操作步骤前处理阶段： 首先分析需要分析的问题，确定工程的实际工况、结构的种类和分布情况。将实际工程的工况结构等简化模型到二维情况（可直接再CAD绘制出简化的模型，然后保存为dxf文件留待后续plaxis导入），在本例中设置边界为（-20 30）（0 65） 创建模型，新建项目，设定名称并按实际工程情况设定模型边界，选择模型的类型和单元（15节点或者6节点），也可设置自己需要的相应单位（unit），设置完成后就可进入土层设置界面 土层设置可以通过钻孔来设置，也可在结构界面绘制相应的土多边形来进行土层绘制设置。点击钻孔命令并点击需要设置钻孔的位置点击，在弹出的修改土层界面可以设置土层的信息，也可设置水头的信息。设置好土层的材料属性就可将他们分配给特定的位置。土层设置完毕就可切换到结构界面绘制结构单元了.本例中有两个土层：砂土（土体硬化）和粘土（软土）==注意：当强度下拉菜单选中刚性选项，界面的强度和土的强度一样（Rinter-=1.0）如果 Rinter&lt;1.0，同时减小了界面的强度和刚度。 不使用界面的默认值，可以在选择对象浏览器材料模式下拉菜单中选择合适的材料数据组直接指定。== 本例中需要绘制的结构有锚定杆、板、界面、线荷载。在工程要求的部位绘制相应的结构单元并设置需求的参数即可。==提示：通常情况下，在一点只能有一个点，两点之间只能有一条线。重合的点或者线会自动减小为一个点或者线。更多信息查看参考手册的相关章节==。 设置锚定杆的等效长度时：==提示：等效长度是锚定杆坐标位置和沿锚定杆方向位移为零的点的距离。== 绘制界面单元时：==提示：为了区别线两面指定的界面，需要添加正号负号。这个符号没有任何物理意义，对结果也没有任何影响。== 为了模拟开挖的不同阶段，需要对挖方土进行分割设置：利用直线单元分割，程序会自动分辨出类组。 结构土层设置完毕后，进入网格划分阶段，选择网格划分按钮，选择默认的中等就好（当然也可细化或者糙化，如果有部分需要，还可局部细化或者糙化），点击查看网格划分，查看具体情况。划分好之后就可进入渗流条件界面进行设置，渗流条件设置基本上只要设置水位，如果有特殊需要才设置其他的参数。 在以上的四个界面设置完毕之后就可以进入分布施工界面进行不同阶段的创建和相关结构的激活。（土层的挖方可以通过选择相应的挖方土层右击选择土再选择冻结即可）初始阶段默认创建好的，计算类型默认K0过程，确保所有土层激活，而其他所有的结构单元和荷载全部冻结。添加其他的阶段并激活相应阶段需要激活的结构或者土层即可。==提示：在 PLAXIS 中，当冻结土层时，孔隙水压力不会自动冻结。因此，开挖处仍然存在水压力，这样就可以模拟未降水开挖。==阶段设置配置好了之后就可以在输入界面选择一些较为明显的特征点好在之后选取绘制曲线的部位点。 操作完毕之后就可以进行计算，点击计算等待计算完成，完成之后就可以点击查看结果查看计算后的变形、内力、结构的弯矩剪力（双击结构弹出显示轴力窗口选择弯矩即可）、地下水的一些参数以及曲线管理器中查看相关内容的曲线变化情况。 后处理分析： ==提示：在输出窗口中，显示荷载、边界条件和指定位移可以通过几何菜单中对应的选项打开或关闭。==除了输出土位移和应力，还可查看结构内力。 在变形菜单选择增量位移，视图显示位移增量的云图，该云图表示墙后土移动的机理。点击视图中不同的按钮可切换不同的图形样式。有矢量图以箭头形式展示增量位移的，箭头长度代表了增量位移的相对大小。 选择应力菜单中的有效主应力选项，视图中显示每一个土单元的三个应力点的有效主应力，有效主应力既代表了方向又显示了该值的相对大小。==注意：如果选中了中主应力的方向选项，主应力的方向显示了基坑开挖底部一个大的被动区和内支撑后小的被动区==。曲线生成：打开工具菜单的曲线管理器窗口，新建一个图标，下拉菜单选中需要绘制的点，并选中需要绘制 曲线的内容，y选中项目，选中其中的相应的乘子，最后点击确定即可生成曲线。 曲线显示了分步施工阶段。对于每一个阶段参数∑ 𝑀𝑠tage.从 0 到 1.最后一个阶段曲线的斜率逐渐减缓意味着塑性变形在增大。然而，计算结果表明，施工的最后阶段开挖过程是稳定的。 软土地基上的路基建造 输入创建地层地基等土层结构，设置好地下水位，设置好土层材料属性和地基材料属性 生成网格 定义需要分析的几个阶段并根据相应的阶段去激活相应的土层结构地下水位等内容。1. 初始阶段：需要冻结代表路基的土。初始水压力完全是静水压力，潜水位线位于要求的位置，此水位是在钻孔指定的水头高度。除了水位线的考虑，还需要设置模型的边界条件。初始时段，出了底部边界，其余的边界都是排水的，以便水能够自由流出边界条件和消散超孔压力。边界条件在模型条件里的地下水流子菜单选择设置 固结分析：固结分析考虑计算的时间因素，为了正确执行固结分析，需设置一个合适的时间步，如果时间步小于临界最小值可能导致应力波动。plaxis固结选项程序考虑了临界时间步，自动设置时间步选项。有三种方式：1. 包括几何模型的该改变效应，预定义时间的固结（分布施工）2. 固结直到几何模型的所有超孔压力减小到给定的最小值（最小孔隙水压力）。3. 固结直到指定的饱和度（固结度）在阶段设置的时候，计算类型可以选择设置，根据实际选择，荷载类型也可选择，按需要选取。计算类型有：固结，安全系数计算等 设置完毕之后就进行计算","tags":[{"name":"plaxis_notebook","slug":"plaxis-notebook","permalink":"http://example.com/tags/plaxis-notebook/"}],"categories":[{"name":"plaxis_notebook","slug":"plaxis-notebook","permalink":"http://example.com/categories/plaxis-notebook/"}]},{"title":"Inner class","date":"2020-12-06T08:08:42.051Z","path":"wiki/2021-03-03-Inner class/","text":"内部类有一个隐式引用，创建一个指针指向引用实例化该内部对象的外部对象。 内部类有以下几种： 非静态内部类 静态内部类：不能访问外部类的对象，只能访问静态成员 局部类 匿名类 内部类的使用： - 静态：OuterClass.InnerClass a = new OuterClass.InnerClass - 非静态：OuterClass.InnerClass a = outObj.new InnerClass 内部类对于外部类的引用正式语法：OuterClass.this [[Local class]][[Annoymous class]][[Static inner class]]","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Static inner class","date":"2020-12-06T08:02:19.329Z","path":"wiki/2021-03-03-Static inner class/","text":"使用静态内部类的情况： 当目的只是为了把类隐藏在另一个类内部的时候 这个时候不需要内部类引用外部类对象，static可以取消产生的引用 在接口中声明的内部类自动成为public static 12345678910111213141516171819202122232425262728293031323334public class StaticTest&#123; public static void main(String[] args)&#123; Int[] intArray = new int[10]; for (int i=0; i &lt; 10; i++)&#123; intArray[i] = Math.random()*100; &#125; OuterClass.Pair a = OuterClass.minmax(intArray); System.out.println(a.getFirst()); System.out.println(a.getSecond()); &#125;&#125;class OuterClass&#123; static class Pair&#123; private int first; private int second; public Pair(int f, int s)&#123; first = f; second = s; &#125; public int getFirst()&#123;return first;&#125; public int getSecond()&#123;return second;&#125; &#125; public static Pair minmax(int[] array)&#123; int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; for(int value:array)&#123; if(value &lt; min) min = value; if(value &gt; max) max = value; &#125; return new Pair(min, max); &#125;&#125;","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Java OOP","date":"2020-12-06T06:42:03.207Z","path":"wiki/2021-03-03-Java OOP/","text":"类的几个重要提示： 尽量使用private属性，保证封装性 属性初始化 不要使用太多的基本类型的属性，可以尝试用类来替换 不是所有的属性都需要被获取或者被修改 一个类只做一类事，如果类太过驳杂，将其分解成多个类 命名要能体现要做的事或者要表达的内容 OOP characters[[Inheritance]][[casting]][[Override]][[Abstraction]][[Encapsulation]][[Polymorphism]][[Interface]][[Package]][[Object]][[Class]][[Inner class]][[Enum]]","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Questions and Exercises  JAR","date":"2020-12-06T04:46:14.853Z","path":"wiki/2021-03-03-Questions and Exercises  JAR/","text":"Questions and Exercises: JARQuestions How do you invoke an applet that is packaged as a JAR file? What is the purpose of the -e option in a jar command? What is the significance of the manifest in a JAR file? How do you modify a JAR’s manifest file? Check your answers.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"The JarRunner Class","date":"2020-12-06T04:46:11.102Z","path":"wiki/2021-03-03-The JarRunner Class/","text":"The JarRunner ClassThe JarRunner application is launched with a command of this form: 123java JarRunner *url [arguments]* In the previous section, we’ve seen how JarClassLoader is able to identify and load the main class of a JAR-bundled application from a given URL. To complete the JarRunner application, therefore, we need to be able to take a URL and any arguments from the command line, and pass them to an instance of JarClassLoader. These tasks belong to the JarRunner class, the entry point of the JarRunner application. It begins by creating a java.net.URL object from the URL specified on the command line: 123456789101112public static void main(String[] args) &#123; if (args.length &lt; 1) &#123; usage(); &#125; URL url &#x3D; null; try &#123; url &#x3D; new URL(args[0]); &#125; catch (MalformedURLException e) &#123; fatal(&quot;Invalid URL: &quot; + args[0]); &#125; If args.length&#160;&lt;&#160;1, that means no URL was specified on the command line, so a usage message is printed. If the first command-line argument is a good URL, a new URL object is created to represent it. Next, JarRunner creates a new instance of JarClassLoader, passing to the constructor the URL that was specified on the command-line: 123JarClassLoader cl &#x3D; new JarClassLoader(url); As we saw in the previous section, it’s through JarClassLoader that JarRunner taps into the JAR-handling APIs. The URL that’s passed to the JarClassLoader constructor is the URL of the JAR-bundled application that you want to run. JarRunner next calls the class loader’s getMainClassName method to identify the entry-point class for the application: 1234567891011121314String name &#x3D; null;try &#123; **name &#x3D; cl.getMainClassName();**&#125; catch (IOException e) &#123; System.err.println(&quot;I&#x2F;O error while loading JAR file:&quot;); e.printStackTrace(); System.exit(1);&#125;if (name &#x3D;&#x3D; null) &#123; fatal(&quot;Specified jar file does not contain a &#39;Main-Class&#39;&quot; + &quot; manifest attribute&quot;);&#125; The key statement is highlighted in bold. The other statements are for error handling. Once JarRunner has identified the application’s entry-point class, only two steps remain: passing any arguments to the application and actually launching the application. JarRunner performs these steps with this code: 12345678910111213141516&#x2F;&#x2F; Get arguments for the applicationString[] newArgs &#x3D; new String[args.length - 1];**System.arraycopy(args, 1, newArgs, 0, newArgs.length);**&#x2F;&#x2F; Invoke application&#39;s main classtry &#123; cl.invokeClass(name, newArgs);&#125; catch (ClassNotFoundException e) &#123; fatal(&quot;Class not found: &quot; + name);&#125; catch (NoSuchMethodException e) &#123; fatal(&quot;Class does not define a &#39;main&#39; method: &quot; + name);&#125; catch (InvocationTargetException e) &#123; e.getTargetException().printStackTrace(); System.exit(1);&#125; Recall that the first command-line argument was the URL of the JAR-bundled application. Any arguments to be passed to that application are therefore in element 1 and beyond in the args array. JarRunner takes those elements, and creates a new array called newArgs to pass to the application (bold line above). JarRunner then passes the entry-point’s class name and the new argument list to the invokeClass method of JarClassLoader. As we saw in the previous section, invokeClass will load the application’s entry-point class, pass it any arguments, and launch the application.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"The JarClassLoader Class","date":"2020-12-06T04:46:07.477Z","path":"wiki/2021-03-03-The JarClassLoader Class/","text":"The JarClassLoader ClassThe JarClassLoader class extends java.net.URLClassLoader. As its name implies, URLClassLoader is designed to be used for loading classes and resources that are accessed by searching a set of URLs. The URLs can refer either to directories or to JAR files. In addition to subclassing URLClassLoader, JarClassLoader also makes use of features in two other new JAR-related APIs, the java.util.jar package and the java.net.JarURLConnection class. In this section, we’ll look in detail at the constructor and two methods of JarClassLoader. The JarClassLoader ConstructorThe constructor takes an instance of java.net.URL as an argument. The URL passed to this constructor will be used elsewhere in JarClassLoader to find the JAR file from which classes are to be loaded. 123456public JarClassLoader(URL url) &#123; super(new URL[] &#123; url &#125;); this.url &#x3D; url;&#125; The URL object is passed to the constructor of the superclass, URLClassLoader, which takes a URL[] array, rather than a single URL instance, as an argument. The getMainClassName MethodOnce a JarClassLoader object is constructed with the URL of a JAR-bundled application, it’s going to need a way to determine which class in the JAR file is the application’s entry point. That’s the job of the getMainClassName method: 12345678910public String getMainClassName() throws IOException &#123; URL u &#x3D; new URL(&quot;jar&quot;, &quot;&quot;, url + &quot;!&#x2F;&quot;); JarURLConnection uc &#x3D; (JarURLConnection)u.openConnection(); Attributes attr &#x3D; uc.getMainAttributes(); return attr !&#x3D; null ? attr.getValue(Attributes.Name.MAIN_CLASS) : null;&#125; You may recall from a previous lesson that a JAR-bundled application’s entry point is specified by the Main-Class header of the JAR file’s manifest. To understand how getMainClassName accesses the Main-Class header value, let’s look at the method in detail, paying special attention to the new JAR-handling features that it uses: The JarURLConnection class and JAR URLsThe getMainClassName method uses the JAR URL format specified by the java.net.JarURLConnection class. The syntax for the URL of a JAR file is as in this example: 123jar:http:&#x2F;&#x2F;www.example.com&#x2F;jarfile.jar!&#x2F; The terminating !/ separator indicates that the URL refers to an entire JAR file. Anything following the separator refers to specific JAR-file contents, as in this example: 123jar:http:&#x2F;&#x2F;www.example.com&#x2F;jarfile.jar!&#x2F;mypackage&#x2F;myclass.class The first line in the getMainClassName method is: 123URL u &#x3D; new URL(&quot;jar&quot;, &quot;&quot;, url + &quot;!&#x2F;&quot;); This statement constructs a new URL object representing a JAR URL, appending the !/ separator to the URL that was used in creating the JarClassLoader instance. The java.net.JarURLConnection classThis class represents a communications link between an application and a JAR file. It has methods for accessing the JAR file’s manifest. The second line of getMainClassName is: 123JarURLConnection uc &#x3D; (JarURLConnection)u.openConnection(); In this statement, URL instance created in the first line opens a URLConnection. The URLConnection instance is then cast to JarURLConnection so it can take advantage of JarURLConnection‘s JAR-handling features. Fetching Manifest Attributes: java.util.jar.AttributesWith a JarURLConnection open to a JAR file, you can access the header information in the JAR file’s manifest by using the getMainAttributes method of JarURLConnection. This method returns an instance of java.util.jar.Attributes, a class that maps header names in JAR-file manifests with their associated string values. The third line in getMainClassName creates an Attributes object: 123Attributes attr &#x3D; uc.getMainAttributes(); To get the value of the manifest’s Main-Class header, the fourth line of getMainClassName invokes the Attributes.getValue method: 12345return attr !&#x3D; null ? attr.getValue(Attributes.Name.MAIN_CLASS) : null; The method’s argument, Attributes.Name.MAIN_CLASS, specifies that it’s the value of the Main-Class header that you want. (The Attributes.Name class also provides static fields such as MANIFEST_VERSION, CLASS_PATH, and SEALED for specifying other standard manifest headers.) The invokeClass MethodWe’ve seen how JarURLClassLoader can identify the main class in a JAR-bundled application. The last method to consider, JarURLClassLoader.invokeClass, enables that main class to be invoked to launch the JAR-bundled application: 123456789101112131415161718192021public void invokeClass(String name, String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException&#123; Class c &#x3D; loadClass(name); Method m &#x3D; c.getMethod(&quot;main&quot;, new Class[] &#123; args.getClass() &#125;); m.setAccessible(true); int mods &#x3D; m.getModifiers(); if (m.getReturnType() !&#x3D; void.class || !Modifier.isStatic(mods) || !Modifier.isPublic(mods)) &#123; throw new NoSuchMethodException(&quot;main&quot;); &#125; try &#123; m.invoke(null, new Object[] &#123; args &#125;); &#125; catch (IllegalAccessException e) &#123; &#x2F;&#x2F; This should not happen, as we have disabled access checks &#125;&#125; The invokeClass method takes two arguments: the name of the application’s entry-point class and an array of string arguments to pass to the entry-point class’s main method. First, the main class is loaded: 123Class c &#x3D; loadClass(name); The loadClass method is inherited from java.lang.ClassLoader. Once the main class is loaded, the reflection API of the java.lang.reflect package is used to pass the arguments to the class and launch it. You can refer to the tutorial on The Reflection API for a review of reflection.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Using JAR-related APIs","date":"2020-12-06T04:46:04.843Z","path":"wiki/2021-03-03-Using JAR-related APIs/","text":"Using JAR-related APIsThe Java platform contains several classes for use with JAR files. Some of these APIs are: [The **java.util.jar** package](https://docs.oracle.com/javase/8/docs/api/java/util/jar/package-summary.html) [The **java.net.JarURLConnection** class](https://docs.oracle.com/javase/8/docs/api/java/net/JarURLConnection.html) [The **java.net.URLClassLoader** class](https://docs.oracle.com/javase/8/docs/api/java/net/URLClassLoader.html) To give you an idea of the possibilities that are opened up by these new APIs, this lesson guides you through the inner workings of a sample application called JarRunner. An Example - The JarRunner ApplicationJarRunner enables you to run an application that’s bundled in a JAR file by specifying the JAR file’s URL on the command line. For example, if an application called TargetApp were bundled in a JAR file at http://www.example.com/TargetApp.jar, you could run the application using this command: 123java JarRunner http:&#x2F;&#x2F;www.example.com&#x2F;TargetApp.jar In order for JarRunner to work, it must be able to perform the following tasks, all of which are accomplished by using the new APIs: Access the remote JAR file and establish a communications link with it. Inspect the JAR file’s manifest to see which of the classes in the archive is the main class. Load the classes in the JAR file. The JarRunner application consists of two classes, JarRunner and JarClassLoader. JarRunner delegates most of the JAR-handling tasks to the JarClassLoader class. JarClassLoader extends the java.net.URLClassLoader class. You can browse the source code for the JarRunner and JarClassLoader classes before proceeding with the lesson: [`JarRunner.java`](examples/JarRunner.java) [`JarClassLoader.java`](examples/JarClassLoader.java) This lesson has two parts: The JarClassLoader ClassThis section shows you how JarClassLoader uses some of the new APIs to perform tasks required for the JarRunner application to work. The JarRunner ClassThis section summarizes the JarRunner class that comprises the JarRunner application.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Verifying Signed JAR Files","date":"2020-12-06T04:46:02.265Z","path":"wiki/2021-03-03-Verifying Signed JAR Files/","text":"Verifying Signed JAR FilesTypically, verification of signed JAR files will be the responsibility of your Java&#8482; Runtime Environment. Your browser will verify signed applets that it downloads. Signed applications invoked with the -jar option of the interpreter will be verified by the runtime environment. However, you can verify signed JAR files yourself by using the jarsigner tool. You might want to do this, for example, to test a signed JAR file that you’ve prepared. The basic command to use for verifying a signed JAR file is: 123jarsigner -verify *jar-file* This command will verify the JAR file’s signature and ensure that the files in the archive haven’t changed since it was signed. You’ll see the following message if the verification is successful: 123jar verified. If you try to verify an unsigned JAR file, the following message results: 123jar is unsigned. (signatures missing or not parsable) If the verification fails, an appropriate message is displayed. For example, if the contents of a JAR file have changed since the JAR file was signed, a message similar to the following will result if you try to verify the file: 1234jarsigner: java.lang.SecurityException: invalid SHA1 signature file digest for test&#x2F;classes&#x2F;Manifest.class","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Signing JAR Files","date":"2020-12-06T04:45:59.746Z","path":"wiki/2021-03-03-Signing JAR Files/","text":"Signing JAR FilesYou use the JAR Signing and Verification Tool to sign JAR files and time stamp the signature. You invoke the JAR Signing and Verification Tool by using the jarsigner command, so we’ll refer to it as “Jarsigner” for short. To sign a JAR file, you must first have a private key. Private keys and their associated public-key certificates are stored in password-protected databases called keystores. A keystore can hold the keys of many potential signers. Each key in the keystore can be identified by an alias which is typically the name of the signer who owns the key. The key belonging to Rita Jones might have the alias “rita”, for example. The basic form of the command for signing a JAR file is 123jarsigner *jar-file alias* In this command: jar-file is the pathname of the JAR file that’s to be signed. alias is the alias identifying the private key that’s to be used to sign the JAR file, and the key’s associated certificate. The Jarsigner tool will prompt you for the passwords for the keystore and alias. This basic form of the command assumes that the keystore to be used is in a file named .keystore in your home directory. It will create signature and signature block files with names x.SF and x.DSA respectively, where x is the first eight letters of the alias, all converted to upper case. This basic command will overwrite the original JAR file with the signed JAR file. In practice, you might want to use one or more of the command options that are available. For example, time stamping the signature is encouraged so that any tool used to deploy your application can verify that the certificate used to sign the JAR file was valid at the time that the file was signed. A warning is issued by the Jarsigner tool if a time stamp is not included. Options precede the jar-file pathname. The following table describes the options that are available: OptionDescription -keystore&#160;*url*Specifies a keystore to be used if you don't want to use the .keystore default database. -sigfile&#160;*file*Specifies the base name for the .SF and .DSA files if you don't want the base name to be taken from your alias. *file* must be composed only of upper case letters (A-Z), numerals (0-9), hyphen (-), and underscore (_). -signedjar&#160;*file*Specifies the name of the signed JAR file to be generated if you don't want the original unsigned file to be overwritten with the signed file. -tsa&#160;*url*Generates a time stamp for the signature using the Time Stamping Authority (TSA) identified by the URL. -tsacert&#160;*alias*Generates a time stamp for the signature using the TSA's public key certificate identified by *alias*. -altsigner&#160;*class*Indicates that an alternative signing mechanism be used to time stamp the signature. The fully-qualified class name identifies the class used. -altsignerpath&#160;*classpathlist*Provides the path to the class identified by the altsigner option and any JAR files that the class depends on. ExampleLet’s look at a couple of examples of signing a JAR file with the Jarsigner tool. In these examples, we will assume the following: Your alias is “johndoe”. The keystore you want to use is in a file named “mykeys” in the current working directory. The TSA that you want to use to time stamp the signature is located at http://tsa.url.example.com. Under these assumptions, you could use this command to sign a JAR file named app.jar: 123jarsigner -keystore mykeys -tsa http:&#x2F;&#x2F;tsa.url.example.com app.jar johndoe You will be prompted to enter the passwords for both the keystore and your alias. Because this command doesn’t make use of the -sigfile option, the .SF and .DSA files it creates would be named JOHNDOE.SF and JOHNDOE.DSA. Because the command doesn’t use the -signedjar option, the resulting signed file will overwrite the original version of app.jar. Let’s look at what would happen if you used a different combination of options: 1234jarsigner -keystore mykeys -sigfile SIG -signedjar SignedApp.jar -tsacert testalias app.jar johndoe The signature and signature block files would be named SIG.SF and SIG.DSA, respectively, and the signed JAR file SignedApp.jar would be placed in the current directory. The original unsigned JAR file would remain unchanged. Also, the signature would be time stamped with the TSA’s public key certificate identified as testalias. Additional InformationComplete reference pages for the JAR Signing and Verification Tool are on-line:Summary of Security Tools","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Understanding Signing and Verification","date":"2020-12-06T04:45:57.255Z","path":"wiki/2021-03-03-Understanding Signing and Verification/","text":"Understanding Signing and VerificationThe Java&#8482; platform enables you to digitally sign JAR files. You digitally sign a file for the same reason you might sign a paper document with pen and ink – to let readers know that you wrote the document, or at least that the document has your approval. When you sign a letter, for example, everyone who recognizes your signature can confirm that you wrote the letter. Similarly when you digitally sign a file, anyone who “recognizes” your digital signature knows that the file came from you. The process of “recognizing” electronic signatures is called verification. When the JAR file is signed, you also have the option of time stamping the signature. Similar to putting a date on a paper document, time stamping the signature identifies when the JAR file was signed. The time stamp can be used to verify that the certificate used to sign the JAR file was valid at the time of signing. The ability to sign and verify files is an important part of the Java platform’s security architecture. Security is controlled by the security policy that’s in force at runtime. You can configure the policy to grant security privileges to applets and to applications. For example, you could grant permission to an applet to perform normally forbidden operations such as reading and writing local files or running local executable programs. If you have downloaded some code that’s signed by a trusted entity, you can use that fact as a criterion in deciding which security permissions to assign to the code. Once you (or your browser) have verified that an applet is from a trusted source, you can have the platform relax security restrictions to let the applet perform operations that would ordinarily be forbidden. A trusted applet can have freedoms as specified by the policy file in force. The Java platform enables signing and verification by using special numbers called public and private keys. Public keys and private keys come in pairs, and they play complementary roles. The private key is the electronic “pen” with which you can sign a file. As its name implies, your private key is known only to you so that no one else can “forge” your signature. A file signed with your private key can be verified only by the corresponding public key. Public and private keys alone, however, aren’t enough to truly verify a signature. Even if you’ve verified that a signed file contains a matching key pair, you still need some way to confirm that the public key actually comes from the signer that it purports to come from. One more element, therefore, is required to make signing and verification work. That additional element is the certificate that the signer includes in a signed JAR file. A certificate is a digitally signed statement from a recognized certification authority that indicates who owns a particular public key. Certification authorities are entities (typically firms specializing in digital security) that are trusted throughout the industry to sign and issue certificates for keys and their owners. In the case of signed JAR files, the certificate indicates who owns the public key contained in the JAR file. When you sign a JAR file your public key is placed inside the archive along with an associated certificate so that it’s easily available for use by anyone wanting to verify your signature. To summarize digital signing: The signer signs the JAR file using a private key. The corresponding public key is placed in the JAR file, together with its certificate, so that it is available for use by anyone who wants to verify the signature. Digests and the Signature FileWhen you sign a JAR file, each file in the archive is given a digest entry in the archive’s manifest. Here’s an example of what such an entry might look like: 1234Name: test&#x2F;classes&#x2F;ClassOne.classSHA1-Digest: TD1GZt8G11dXY2p4olSZPc5Rj64&#x3D; The digest values are hashes or encoded representations of the contents of the files as they were at the time of signing. A file’s digest will change if and only if the file itself changes. When a JAR file is signed, a signature file is automatically generated and placed in the JAR file’s META-INF directory, the same directory that contains the archive’s manifest. Signature files have filenames with an .SF extension. Here is an example of the contents of a signature file: 1234567891011121314151617Signature-Version: 1.0SHA1-Digest-Manifest: h1yS+K9T7DyHtZrtI+LxvgqaMYM&#x3D;Created-By: 1.7.0_06 (Oracle Corporation)Name: test&#x2F;classes&#x2F;ClassOne.classSHA1-Digest: fcav7ShIG6i86xPepmitOVo4vWY&#x3D;Name: test&#x2F;classes&#x2F;ClassTwo.classSHA1-Digest: xrQem9snnPhLySDiZyclMlsFdtM&#x3D;Name: test&#x2F;images&#x2F;ImageOne.gifSHA1-Digest: kdHbE7kL9ZHLgK7akHttYV4XIa0&#x3D;Name: test&#x2F;images&#x2F;ImageTwo.gifSHA1-Digest: mF0D5zpk68R4oaxEqoS9Q7nhm60&#x3D; As you can see, the signature file contains digest entries for the archive’s files that look similar to the digest-value entries in the manifest. However, while the digest values in the manifest are computed from the files themselves, the digest values in the signature file are computed from the corresponding entries in the manifest. Signature files also contain a digest value for the entire manifest (see the SHA1-Digest-Manifest header in the above example). When a signed JAR file is being verified, the digests of each of its files are re-computed and compared with the digests recorded in the manifest to ensure that the contents of the JAR file haven’t changed since it was signed. As an additional check, digest values for the manifest file itself are re-computed and compared against the values recorded in the signature file. You can read additional information about signature files on theManifest Format page of the JDK&#8482; documentation. The Signature Block FileIn addition to the signature file, a signature block file is automatically placed in the META-INF directory when a JAR file is signed. Unlike the manifest file or the signature file, signature block files are not human-readable. The signature block file contains two elements essential for verification: The digital signature for the JAR file that was generated with the signer’s private key The certificate containing the signer’s public key, to be used by anyone wanting to verify the signed JAR file Signature block filenames typically will have a .DSA extension indicating that they were created by the default Digital Signature Algorithm. Other filename extensions are possible if keys associated with some other standard algorithm are used for signing. Related DocumentationFor additional information about keys, certificates, and certification authorities, see [The JDK Security Tools](https://docs.oracle.com/javase/8/docs/technotes/tools/index.html#security) [X.509 Certificates](https://docs.oracle.com/javase/8/docs/technotes/guides/security/cert3.html) For more information about the Java platform’s security architecture, see this related documentation: [Security Features in Java SE](../../security/index.html) [Java SE Security](http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html) [Security Tools](https://docs.oracle.com/javase/8/docs/technotes/tools/index.html#security)","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Signing and Verifying JAR Files","date":"2020-12-06T04:45:54.470Z","path":"wiki/2021-03-03-Signing and Verifying JAR Files/","text":"Signing and Verifying JAR FilesYou can optionally sign a JAR file with your electronic “signature.” Users who verify your signature can grant your JAR-bundled software security privileges that it wouldn’t ordinarily have. Conversely, you can verify the signatures of signed JAR files that you want to use. This lesson shows you how to use the tools provided in the JDK to sign and verify JAR files: Understanding Signing and VerificationIf you’re not familiar with the concepts of signing and verification, this section will help to bring you up to speed. It contains definitions of the relevant terms, explanations of some of the benefits provided by signing, and an outline of the signing mechanism used by the Java platform as it relates to JAR files. Signing JAR FilesIn this section, you’ll learn how to use the JDK&#8482; tools to digitally sign your JAR files. Verifying Signed JAR FilesThis section shows you how to use the JDK tool set to verify signed JAR files.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Enhancing Security with Manifest Attributes","date":"2020-12-06T04:45:52.015Z","path":"wiki/2021-03-03-Enhancing Security with Manifest Attributes/","text":"Enhancing Security with Manifest AttributesThe following JAR file manifest attributes are available to help ensure the security of your applet or Java Web Start application. Only the Permissions attribute is required. The Permissions attribute is used to ensure that the application requests only the level of permissions that is specified in the applet tag or JNLP file used to invoke the application. Use this attribute to help prevent someone from re-deploying an application that is signed with your certificate and running it at a different privilege level. This attribute is required in the manifest for the main JAR file. See [Permissions Attribute](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/manifest.html#JSDPG896) in the Java Platform, Standard Edition Deployment Guide for more information. The Codebase attribute is used to ensure that the code base of the JAR file is restricted to specific domains. Use this attribute to prevent someone from re-deploying your application on another website for malicious purposes. See [Codebase Attribute](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/manifest.html#JSDPG897) in the Java Platform, Standard Edition Deployment Guide for more information. The Application-Name attribute is used to provide the title that is shown in the security prompts for signed applications. See [Application-Name Attribute](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/manifest.html#JSDPG899) in the Java Platform, Standard Edition Deployment Guide for more information. The Application-Library-Allowable-Codebase attribute is used to identify the locations where your application is expected to be found. Use this attribute to reduce the number of locations shown in the security prompt when the JAR file is in a different location than the JNLP file or the HTML page. See [Application-Library-Allowable-Codebase Attribute](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/manifest.html#JSDPG900) in the Java Platform, Standard Edition Deployment Guide for more information. The Caller-Allowable-Codebase attribute is used to identify the domains from which JavaScript code can make calls to your application. Use this attribute to prevent unknown JavaScript code from accessing your application. See [Caller-Allowable-Codebase Attribute](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/manifest.html#JSDPG901) in the Java Platform, Standard Edition Deployment Guide for more information. The Entry-Point attribute is used to identify the classes that are allowed to be used as entry points to your RIA. Use this attribute to prevent unauthorized code from being run from other available entry points in the JAR file. See [Entry-Point Attribute](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/manifest.html#JSDPG902) in the Java Platform, Standard Edition Deployment Guide for more information. The Trusted-Only attribute is used to prevent untrusted components from being loaded. See [Trusted-Only Attribute](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/manifest.html#JSDPG903) in the Java Platform, Standard Edition Deployment Guide for more information. The Trusted-Library attribute is used to allow calls between privileged Java code and sandbox Java code without prompting the user for permission. See [Trusted-Library Attribute](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/manifest.html#JSDPG904) in the Java Platform, Standard Edition Deployment Guide for more information. SeeModifying a Manifest File for information on adding these attributes to the manifest file.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Sealing Packages within a JAR File","date":"2020-12-06T04:45:49.503Z","path":"wiki/2021-03-03-Sealing Packages within a JAR File/","text":"Sealing Packages within a JAR FilePackages within JAR files can be optionally sealed, which means that all classes defined in that package must be archived in the same JAR file. You might want to seal a package, for example, to ensure version consistency among the classes in your software. You seal a package in a JAR file by adding the Sealed header in the manifest, which has the general form: 1234Name: myCompany&#x2F;myPackage&#x2F;Sealed: true The value myCompany/myPackage/ is the name of the package to seal. Note that the package name must end with a “/“. An ExampleWe want to seal two packages firstPackage and secondPackage in the JAR file MyJar.jar. We first create a text file named Manifest.txt with the following contents: 1234567Name: myCompany&#x2F;firstPackage&#x2F;Sealed: trueName: myCompany&#x2F;secondPackage&#x2F;Sealed: true We then create a JAR file named MyJar.jar by entering the following command: 123jar cfm MyJar.jar Manifest.txt MyPackage&#x2F;*.class This creates the JAR file with a manifest with the following contents: 12345678Manifest-Version: 1.0Created-By: 1.7.0_06 (Oracle Corporation)Name: myCompany&#x2F;firstPackage&#x2F;Sealed: trueName: myCompany&#x2F;secondPackage&#x2F;Sealed: true Sealing JAR FilesIf you want to guarantee that all classes in a package come from the same code source, use JAR sealing. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden on a per-package basis. To seal a JAR file, use the Sealed manifest header with the value true. For example, 123Sealed: true specifies that all packages in this archive are sealed unless explicitly overridden for particular packages with the Sealed attribute in a manifest entry.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Setting Package Version Information","date":"2020-12-06T04:45:47.005Z","path":"wiki/2021-03-03-Setting Package Version Information/","text":"Setting Package Version InformationYou may need to include package version information in a JAR file’s manifest. You provide this information with the following headers in the manifest: HeaderDefinition NameThe name of the specification. Specification-TitleThe title of the specification. Specification-VersionThe version of the specification. Specification-VendorThe vendor of the specification. Implementation-TitleThe title of the implementation. Implementation-VersionThe build number of the implementation. Implementation-VendorThe vendor of the implementation. One set of such headers can be assigned to each package. The versioning headers should appear directly beneath the Name header for the package. This example shows all the versioning headers: 123456789Name: java&#x2F;util&#x2F;Specification-Title: Java Utility ClassesSpecification-Version: 1.2Specification-Vendor: Example Tech, Inc.Implementation-Title: java.utilImplementation-Version: build57Implementation-Vendor: Example Tech, Inc. For more information about package version headers, see thePackage Versioning specification . An ExampleWe want to include the headers in the example above in the manifest of MyJar.jar. We first create a text file named Manifest.txt with the following contents: 123456789Name: java&#x2F;util&#x2F;Specification-Title: Java Utility ClassesSpecification-Version: 1.2Specification-Vendor: Example Tech, Inc.Implementation-Title: java.util Implementation-Version: build57Implementation-Vendor: Example Tech, Inc. We then create a JAR file named MyJar.jar by entering the following command: 123jar cfm MyJar.jar Manifest.txt MyPackage&#x2F;*.class This creates the JAR file with a manifest with the following contents: 1234567891011Manifest-Version: 1.0Created-By: 1.7.0_06 (Oracle Corporation)Name: java&#x2F;util&#x2F;Specification-Title: Java Utility ClassesSpecification-Version: 1.2Specification-Vendor: Example Tech, Inc.Implementation-Title: java.util Implementation-Version: build57Implementation-Vendor: Example Tech, Inc.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Adding Classes to the JAR File's Classpath","date":"2020-12-06T04:45:44.424Z","path":"wiki/2021-03-03-Adding Classes to the JAR File's Classpath/","text":"Adding Classes to the JAR File’s ClasspathYou may need to reference classes in other JAR files from within a JAR file. For example, in a typical situation an applet is bundled in a JAR file whose manifest references a different JAR file (or several different JAR files) that serves as utilities for the purposes of that applet. You specify classes to include in the Class-Path header field in the manifest file of an applet or application. The Class-Path header takes the following form: 123Class-Path: **jar1-name jar2-name directory-name&#x2F;jar3-name** By using the Class-Path header in the manifest, you can avoid having to specify a long -classpath flag when invoking Java to run the your application. An ExampleWe want to load classes in MyUtils.jar into the class path for use in MyJar.jar. These two JAR files are in the same directory. We first create a text file named Manifest.txt with the following contents: 123Class-Path: MyUtils.jar We then create a JAR file named MyJar.jar by entering the following command: 123jar cfm MyJar.jar Manifest.txt MyPackage&#x2F;*.class This creates the JAR file with a manifest with the following contents: 12345Manifest-Version: 1.0Class-Path: MyUtils.jarCreated-By: 1.7.0_06 (Oracle Corporation) The classes in MyUtils.jar are now loaded into the class path when you run MyJar.jar.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Setting an Application's Entry Point","date":"2020-12-06T04:45:41.782Z","path":"wiki/2021-03-03-Setting an Application's Entry Point/","text":"Setting an Application’s Entry PointIf you have an application bundled in a JAR file, you need some way to indicate which class within the JAR file is your application’s entry point. You provide this information with the Main-Class header in the manifest, which has the general form: 123Main-Class: **classname** The value classname is the name of the class that is your application’s entry point. Recall that the entry point is a class having a method with signature public&amp;#160;static&amp;#160;void&amp;#160;main(String[]&amp;#160;args). After you have set the Main-Class header in the manifest, you then run the JAR file using the following form of the java command: 123java -jar **JAR-name** The main method of the class specified in the Main-Class header is executed. An ExampleWe want to execute the main method in the class MyClass in the package MyPackage when we run the JAR file. We first create a text file named Manifest.txt with the following contents: 123Main-Class: MyPackage.MyClass We then create a JAR file named MyJar.jar by entering the following command: 123jar cfm MyJar.jar Manifest.txt MyPackage&#x2F;*.class This creates the JAR file with a manifest with the following contents: 12345Manifest-Version: 1.0Created-By: 1.7.0_06 (Oracle Corporation)Main-Class: MyPackage.MyClass When you run the JAR file with the following command, the main method of MyClass executes: 123java -jar MyJar.jar Setting an Entry Point with the JAR ToolThe ‘e’ flag (for ‘entrypoint’) creates or overrides the manifest’s Main-Class attribute. It can be used while creating or updating a JAR file. Use it to specify the application entry point without editing or creating the manifest file.For example, this command creates app.jar where the Main-Class attribute value in the manifest is set to MyApp: 123jar cfe app.jar MyApp MyApp.class You can directly invoke this application by running the following command: 123java -jar app.jar If the entrypoint class name is in a package it may use a ‘.’ (dot) character as the delimiter. For example, if Main.class is in a package called foo the entry point can be specified in the following ways: 123jar cfe Main.jar foo.Main foo&#x2F;Main.class","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Understanding the Default Manifest","date":"2020-12-06T04:45:36.189Z","path":"wiki/2021-03-03-Understanding the Default Manifest/","text":"Understanding the Default ManifestWhen you create a JAR file, it automatically receives a default manifest file. There can be only one manifest file in an archive, and it always has the pathname 123META-INF&#x2F;MANIFEST.MF When you create a JAR file, the default manifest file simply contains the following: 1234Manifest-Version: 1.0Created-By: 1.7.0_06 (Oracle Corporation) These lines show that a manifest’s entries take the form of “header: value” pairs. The name of a header is separated from its value by a colon. The default manifest conforms to version 1.0 of the manifest specification and was created by the 1.7.0_06 version of the JDK. The manifest can also contain information about the other files that are packaged in the archive. Exactly what file information should be recorded in the manifest depends on how you intend to use the JAR file. The default manifest makes no assumptions about what information it should record about other files. Digest information is not included in the default manifest. To learn more about digests and signing, see the Signing and Verifying JAR Files lesson.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Working with Manifest Files  The Basics","date":"2020-12-06T04:45:33.067Z","path":"wiki/2021-03-03-Working with Manifest Files  The Basics/","text":"Working with Manifest Files: The BasicsJAR files support a wide range of functionality, including electronic signing, version control, package sealing, and others. What gives a JAR file this versatility? The answer is the JAR file’s manifest. The manifest is a special file that can contain information about the files packaged in a JAR file. By tailoring this “meta” information that the manifest contains, you enable the JAR file to serve a variety of purposes. This lesson will explain the contents of the manifest file and show you how to work with it, with examples for the basic features: Understanding the Default Manifest When you create a JAR file, a default manifest is created automatically. This section describes the default manifest. Modifying a Manifest File This section shows you the basic method of modifying a manifest file. The later sections demonstrate specific modifications you may want to make. Setting an Application’s Entry Point This section describes how to use the Main-Class header in the manifest file to set an application’s entry point. Adding Classes to the JAR File’s Classpath This section describes how to use the Class-Path header in the manifest file to add classes in other JAR files to the classpath when running an applet or application. Setting Package Version Information This section describes how to use the package version headers in the manifest file. Sealing Packages within a JAR File This section describes how to seal packages within a JAR file by modifying the manifest file. Enhancing Security with Manifest Attributes This section describes how to use manifest attributes to increase the security of an applet or Java Web Start application. Additional InformationAspecification of the manifest format is part of the on-line JDK documentation.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Running JAR-Packaged Software","date":"2020-12-06T04:45:30.662Z","path":"wiki/2021-03-03-Running JAR-Packaged Software/","text":"Running JAR-Packaged SoftwareNow that you have learned how to create JAR files, how do you actually run the code you packaged? Consider these scenarios: Your JAR file contains an applet that is to be run inside a browser. Your JAR file contains an application that is to be started from the command line. Your JAR file contains code that you want to use as an extension. This section will cover the first two situations. A separate trail in the tutorial on theextension mechanism covers the use of JAR files as extensions. Applets Packaged in JAR FilesTo start any applet from an HTML file for running inside a browser, you use the applet tag. For more information, see theJava Applets lesson. If the applet is bundled as a JAR file, the only thing you need to do differently is to use the archive parameter to specify the relative path to the JAR file. As an example, use the TicTacToe demo applet. The applet tag in the HTML file that displays the applet can be marked up like this: 12345&lt;applet code&#x3D;TicTacToe.class width&#x3D;&quot;120&quot; height&#x3D;&quot;120&quot;&gt;&lt;&#x2F;applet&gt; If the TicTacToe demo was packaged in a JAR file named TicTacToe.jar, you can modify the applet tag with the addition of an archive parameter: 123456&lt;applet code&#x3D;TicTacToe.class archive&#x3D;&quot;TicTacToe.jar&quot; width&#x3D;&quot;120&quot; height&#x3D;&quot;120&quot;&gt;&lt;&#x2F;applet&gt; The archive parameter specifies the relative path to the JAR file that contains TicTacToe.class. For this example it is assumed that the JAR file and the HTML file are in the same directory. If they are not, you must include the JAR file’s relative path in the archive parameter’s value. For example, if the JAR file was one directory below the HTML file in a directory called applets, the applet tag would look like this: 123456&lt;applet code&#x3D;TicTacToe.class archive&#x3D;&quot;applets&#x2F;TicTacToe.jar&quot; width&#x3D;&quot;120&quot; height&#x3D;&quot;120&quot;&gt;&lt;&#x2F;applet&gt; JAR Files as ApplicationsYou can run JAR packaged applications with the Java launcher (java command). The basic command is: 123java -jar *jar-file* The -jar flag tells the launcher that the application is packaged in the JAR file format. You can only specify one JAR file, which must contain all of the application-specific code. Before you execute this command, make sure that the runtime environment has information about which class within the JAR file is the application’s entry point. To indicate which class is the application’s entry point, you must add a Main-Class header to the JAR file’s manifest. The header takes the form: 123Main-Class: *classname* The header’s value, classname, is the name of the class that is the application’s entry point. For more information, see theSetting an Application’s Entry Point section. When the Main-Class is set in the manifest file, you can run the application from the command line: 123java -jar app.jar To run the application from the JAR file that is in another directory, you must specify the path of that directory:java -jar path/app.jar","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Updating a JAR File","date":"2020-12-06T04:45:27.537Z","path":"wiki/2021-03-03-Updating a JAR File/","text":"Updating a JAR FileThe Jar tool provides a u option which you can use to update the contents of an existing JAR file by modifying its manifest or by adding files. The basic command for adding files has this format: 123jar uf *jar-file input-file(s)* In this command: The u option indicates that you want to update an existing JAR file. The f option indicates that the JAR file to update is specified on the command line. jar-file is the existing JAR file that is to be updated. input-file(s) is a space-delimited list of one or more files that you want to add to the JAR file. Any files already in the archive having the same pathname as a file being added will be overwritten. When creating a new JAR file, you can optionally use the -C option to indicate a change of directory. For more information, see theCreating a JAR File section. ExamplesRecall that TicTacToe.jar has these contents: 12345678910111213141516META-INF&#x2F;MANIFEST.MFTicTacToe.classTicTacToe.classTicTacToe.javaaudio&#x2F;audio&#x2F;beep.auaudio&#x2F;ding.auaudio&#x2F;return.auaudio&#x2F;yahoo1.auaudio&#x2F;yahoo2.auexample1.htmlimages&#x2F;images&#x2F;cross.gifimages&#x2F;not.gif Suppose that you want to add the file images/new.gif to the JAR file. You could accomplish that by issuing this command from the parent directory of the images directory: 123jar uf TicTacToe.jar images&#x2F;new.gif The revised JAR file would have this table of contents: 1234567891011121314151617META-INF&#x2F;MANIFEST.MFTicTacToe.classTicTacToe.classTicTacToe.javaaudio&#x2F;audio&#x2F;beep.auaudio&#x2F;ding.auaudio&#x2F;return.auaudio&#x2F;yahoo1.auaudio&#x2F;yahoo2.auexample1.htmlimages&#x2F;images&#x2F;cross.gifimages&#x2F;not.gifimages&#x2F;new.gif You can use the -C option to “change directories” during execution of the command. For example: 123jar uf TicTacToe.jar -C images new.gif This command would change to the images directory before adding new.gif to the JAR file. The images directory would not be included in the pathname of new.gif when it’s added to the archive, resulting in a table of contents that looks like this: 123456789101112131415161718META-INF&#x2F;MANIFEST.MFMETA-INF&#x2F;MANIFEST.MFTicTacToe.classTicTacToe.classTicTacToe.javaaudio&#x2F;audio&#x2F;beep.auaudio&#x2F;ding.auaudio&#x2F;return.auaudio&#x2F;yahoo1.auaudio&#x2F;yahoo2.auexample1.htmlimages&#x2F;images&#x2F;cross.gifimages&#x2F;not.gifnew.gif","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Extracting the Contents of a JAR File","date":"2020-12-06T04:45:25.139Z","path":"wiki/2021-03-03-Extracting the Contents of a JAR File/","text":"Extracting the Contents of a JAR FileThe basic command to use for extracting the contents of a JAR file is: 123jar xf *jar-file [archived-file(s)]* Let’s look at the options and arguments in this command: The x option indicates that you want to extract files from the JAR archive. The f options indicates that the JAR file from which files are to be extracted is specified on the command line, rather than through stdin. The jar-file argument is the filename (or path and filename) of the JAR file from which to extract files. archived-file(s) is an optional argument consisting of a space-separated list of the files to be extracted from the archive. If this argument is not present, the Jar tool will extract all the files in the archive. As usual, the order in which the x and f options appear in the command doesn’t matter, but there must not be a space between them. When extracting files, the Jar tool makes copies of the desired files and writes them to the current directory, reproducing the directory structure that the files have in the archive. The original JAR file remains unchanged. An ExampleLet’s extract some files from the TicTacToe JAR file we’ve been using in previous sections. Recall that the contents of TicTacToe.jar are: 12345678910111213141516META-INF&#x2F;MANIFEST.MFTicTacToe.classTicTacToe.classTicTacToe.javaaudio&#x2F;audio&#x2F;beep.auaudio&#x2F;ding.auaudio&#x2F;return.auaudio&#x2F;yahoo1.auaudio&#x2F;yahoo2.auexample1.htmlimages&#x2F;images&#x2F;cross.gifimages&#x2F;not.gif Suppose you want to extract the TicTacToe class file and the cross.gif image file. To do so, you can use this command: 123jar xf TicTacToe.jar TicTacToe.class images&#x2F;cross.gif This command does two things: It places a copy of TicTacToe.class in the current directory. It creates the directory images, if it doesn’t already exist, and places a copy of cross.gif within it. The original TicTacToe JAR file remains unchanged. As many files as desired can be extracted from the JAR file in the same way. When the command doesn’t specify which files to extract, the Jar tool extracts all files in the archive. For example, you can extract all the files in the TicTacToe archive by using this command: 123jar xf TicTacToe.jar","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Viewing the Contents of a JAR File","date":"2020-12-06T04:45:22.739Z","path":"wiki/2021-03-03-Viewing the Contents of a JAR File/","text":"Viewing the Contents of a JAR FileThe basic format of the command for viewing the contents of a JAR file is: 123jar tf *jar-file* Let’s look at the options and argument used in this command: The t option indicates that you want to view the table of contents of the JAR file. The f option indicates that the JAR file whose contents are to be viewed is specified on the command line. The jar-file argument is the path and name of the JAR file whose contents you want to view. The t and f options can appear in either order, but there must not be any space between them. This command will display the JAR file’s table of contents to stdout. You can optionally add the verbose option, v, to produce additional information about file sizes and last-modified dates in the output. An ExampleLet’s use the Jar tool to list the contents of the TicTacToe.jar file we created in the previous section: 123jar tf TicTacToe.jar This command displays the contents of the JAR file to stdout: 12345678910111213META-INF&#x2F;MANIFEST.MFTicTacToe.classaudio&#x2F;audio&#x2F;beep.auaudio&#x2F;ding.auaudio&#x2F;return.auaudio&#x2F;yahoo1.auaudio&#x2F;yahoo2.auimages&#x2F;images&#x2F;cross.gifimages&#x2F;not.gif The JAR file contains the TicTacToe class file and the audio and images directory, as expected. The output also shows that the JAR file contains a default manifest file, META-INF/MANIFEST.MF, which was automatically placed in the archive by the JAR tool. For more information, see theUnderstanding the Default Manifest section. All pathnames are displayed with forward slashes, regardless of the platform or operating system you’re using. Paths in JAR files are always relative; you’ll never see a path beginning with C:, for example. The JAR tool will display additional information if you use the v option: 123jar tvf TicTacToe.jar For example, the verbose output for the TicTacToe JAR file would look similar to this: 12345678910111213141516 68 Thu Nov 01 20:00:40 PDT 2012 META-INF&#x2F;MANIFEST.MF 553 Mon Sep 24 21:57:48 PDT 2012 TicTacToe.class3708 Mon Sep 24 21:57:48 PDT 2012 TicTacToe.class9584 Mon Sep 24 21:57:48 PDT 2012 TicTacToe.java 0 Mon Sep 24 21:57:48 PDT 2012 audio&#x2F;4032 Mon Sep 24 21:57:48 PDT 2012 audio&#x2F;beep.au2566 Mon Sep 24 21:57:48 PDT 2012 audio&#x2F;ding.au6558 Mon Sep 24 21:57:48 PDT 2012 audio&#x2F;return.au7834 Mon Sep 24 21:57:48 PDT 2012 audio&#x2F;yahoo1.au7463 Mon Sep 24 21:57:48 PDT 2012 audio&#x2F;yahoo2.au 424 Mon Sep 24 21:57:48 PDT 2012 example1.html 0 Mon Sep 24 21:57:48 PDT 2012 images&#x2F; 157 Mon Sep 24 21:57:48 PDT 2012 images&#x2F;cross.gif 158 Mon Sep 24 21:57:48 PDT 2012 images&#x2F;not.gif","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Creating a JAR File","date":"2020-12-06T04:45:20.363Z","path":"wiki/2021-03-03-Creating a JAR File/","text":"Creating a JAR FileThe basic format of the command for creating a JAR file is: 123jar cf *jar-file input-file(s)* The options and arguments used in this command are: The c option indicates that you want to create a JAR file. The f option indicates that you want the output to go to a file rather than to stdout. jar-file is the name that you want the resulting JAR file to have. You can use any filename for a JAR file. By convention, JAR filenames are given a .jar extension, though this is not required. The input-file(s) argument is a space-separated list of one or more files that you want to include in your JAR file. The input-file(s) argument can contain the wildcard * symbol. If any of the “input-files” are directories, the contents of those directories are added to the JAR archive recursively. The c and f options can appear in either order, but there must not be any space between them. This command will generate a compressed JAR file and place it in the current directory. The command will also generate adefault manifest file for the JAR archive. The metadata in the JAR file, such as the entry names, comments, and contents of the manifest, must be encoded in UTF8. You can add any of these additional options to the cf options of the basic command: OptionDescription vProduces **verbose** output on stdout while the JAR file is being built. The verbose output tells you the name of each file as it's added to the JAR file. 0 (zero)Indicates that you don't want the JAR file to be compressed. MIndicates that the default manifest file should not be produced. mUsed to include manifest information from an existing manifest file. The format for using this option is:`jar cmf **jar-file** **existing-manifest** **input-file(s)**`See [Modifying a Manifest File](modman.html) for more information about this option.**Warning:**&#160;The manifest must end with a new line or carriage return. The last line will not be parsed properly if it does not end with a new line or carriage return. -CTo change directories during execution of the command. See below for an example. When you create a JAR file, the time of creation is stored in the JAR file. Therefore, even if the contents of the JAR file do not change, when you create a JAR file multiple times, the resulting files are not exactly identical. You should be aware of this when you are using JAR files in a build environment. It is recommended that you use versioning information in the manifest file, rather than creation time, to control versions of a JAR file. See theSetting Package Version Information section. An ExampleLet us look at an example. A simple TicTacToe applet. You can see the source code of this applet by downloading the JDK Demos and Samples bundle fromJava SE Downloads. This demo contains class files, audio files, and images having this structure: The audio and images subdirectories contain sound files and GIF images used by the applet. You can obtain all these files from jar/examples directory when you download the entire Tutorial online. To package this demo into a single JAR file named TicTacToe.jar, you would run this command from inside the TicTacToe directory: 123jar cvf TicTacToe.jar TicTacToe.class audio images The audio and images arguments represent directories, so the Jar tool will recursively place them and their contents in the JAR file. The generated JAR file TicTacToe.jar will be placed in the current directory. Because the command used the v option for verbose output, you would see something similar to this output when you run the command: 123456789101112adding: TicTacToe.class (in&#x3D;3825) (out&#x3D;2222) (deflated 41%)adding: audio&#x2F; (in&#x3D;0) (out&#x3D;0) (stored 0%)adding: audio&#x2F;beep.au (in&#x3D;4032) (out&#x3D;3572) (deflated 11%)adding: audio&#x2F;ding.au (in&#x3D;2566) (out&#x3D;2055) (deflated 19%)adding: audio&#x2F;return.au (in&#x3D;6558) (out&#x3D;4401) (deflated 32%)adding: audio&#x2F;yahoo1.au (in&#x3D;7834) (out&#x3D;6985) (deflated 10%)adding: audio&#x2F;yahoo2.au (in&#x3D;7463) (out&#x3D;4607) (deflated 38%)adding: images&#x2F; (in&#x3D;0) (out&#x3D;0) (stored 0%)adding: images&#x2F;cross.gif (in&#x3D;157) (out&#x3D;160) (deflated -1%)adding: images&#x2F;not.gif (in&#x3D;158) (out&#x3D;161) (deflated -1%) You can see from this output that the JAR file TicTacToe.jar is compressed. The Jar tool compresses files by default. You can turn off the compression feature by using the 0 (zero) option, so that the command would look like: 123jar cvf0 TicTacToe.jar TicTacToe.class audio images You might want to avoid compression, for example, to increase the speed with which a JAR file could be loaded by a browser. Uncompressed JAR files can generally be loaded more quickly than compressed files because the need to decompress the files during loading is eliminated. However, there is a tradeoff in that download time over a network may be longer for larger, uncompressed files. The Jar tool will accept arguments that use the wildcard * symbol. As long as there weren’t any unwanted files in the TicTacToe directory, you could have used this alternative command to construct the JAR file: 123jar cvf TicTacToe.jar * Though the verbose output doesn’t indicate it, the Jar tool automatically adds a manifest file to the JAR archive with path name META-INF/MANIFEST.MF. See theWorking with Manifest Files: The Basics section for information about manifest files. In the above example, the files in the archive retained their relative path names and directory structure. The Jar tool provides the -C option that you can use to create a JAR file in which the relative paths of the archived files are not preserved. It’s modeled after TAR’s -C option. As an example, suppose you wanted to put audio files and gif images used by the TicTacToe demo into a JAR file, and that you wanted all the files to be on the top level, with no directory hierarchy. You could accomplish that by issuing this command from the parent directory of the images and audio directories: 123jar cf ImageAudio.jar -C images . -C audio . The -C&#160;images part of this command directs the Jar tool to go to the images directory, and the . following -C&#160;images directs the Jar tool to archive all the contents of that directory. The -C&#160;audio&#160;. part of the command then does the same with the audio directory. The resulting JAR file would have this table of contents: 12345678910META-INF&#x2F;MANIFEST.MFcross.gifnot.gifbeep.auding.aureturn.auyahoo1.auyahoo2.au By contrast, suppose that you used a command that did not employ the -C option: 123jar cf ImageAudio.jar images audio The resulting JAR file would have this table of contents: 12345678910META-INF&#x2F;MANIFEST.MFimages&#x2F;cross.gifimages&#x2F;not.gifaudio&#x2F;beep.auaudio&#x2F;ding.auaudio&#x2F;return.auaudio&#x2F;yahoo1.auaudio&#x2F;yahoo2.au","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Using JAR Files  The Basics","date":"2020-12-06T04:45:17.948Z","path":"wiki/2021-03-03-Using JAR Files  The Basics/","text":"Using JAR Files: The BasicsJAR files are packaged with the ZIP file format, so you can use them for tasks such as lossless data compression, archiving, decompression, and archive unpacking. These tasks are among the most common uses of JAR files, and you can realize many JAR file benefits using only these basic features. Even if you want to take advantage of advanced functionality provided by the JAR file format such as electronic signing, you’ll first need to become familiar with the fundamental operations. To perform basic tasks with JAR files, you use the Java Archive Tool provided as part of the Java Development Kit (JDK). Because the Java Archive tool is invoked by using the jar command, this tutorial refers to it as ‘the Jar tool’. As a synopsis and preview of some of the topics to be covered in this section, the following table summarizes common JAR file operations: OperationCommand To create a JAR filejar cf *jar-file input-file(s)* To view the contents of a JAR filejar tf *jar-file* To extract the contents of a JAR filejar xf *jar-file* To extract specific files from a JAR filejar xf *jar-file archived-file(s)* To run an application packaged as a JAR file (requires the [Main-class](appman.html) manifest header)java -jar *app.jar* To invoke an applet packaged as a JAR file`&lt;applet code=**AppletClassName.class** archive=\"**JarFileName.jar**\" width=**width** height=**height**&gt;&lt;/applet&gt;` This section shows you how to perform the most common JAR-file operations, with examples for each of the basic features: Creating a JAR File This section shows you how to use the Jar tool to package files and directories into a JAR file. Viewing the Contents of a JAR File You can display a JAR file’s table of contents to see what it contains without actually unpacking the JAR file. Extracting the Contents of a JAR File You can use the Jar tool to unpack a JAR file. When extracting files, the Jar tool makes copies of the desired files and writes them to the current directory, reproducing the directory structure that the files have in the archive. Updating a JAR File This section shows you how to update the contents of an existing JAR file by modifying its manifest or by adding files. Running JAR-Packaged Software This section shows you how to invoke and run applets and applications that are packaged in JAR files. Additional ReferencesThe documentation for the JDK includes reference pages for the Jar tool: [Jar tool reference for the Windows platform](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jar.html) [Jar tool reference for UNIX-based platforms](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jar.html)","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Packaging Programs in JAR Files","date":"2020-12-06T04:45:14.874Z","path":"wiki/2021-03-03-Packaging Programs in JAR Files/","text":"Lesson: Packaging Programs in JAR FilesThe Java&#8482; Archive (JAR) file format enables you to bundle multiple files into a single archive file. Typically a JAR file contains the class files and auxiliary resources associated with applets and applications. The JAR file format provides many benefits: Security: You can digitally sign the contents of a JAR file. Users who recognize your signature can then optionally grant your software security privileges it wouldn’t otherwise have. Decreased download time: If your applet is bundled in a JAR file, the applet’s class files and associated resources can be downloaded to a browser in a single HTTP transaction without the need for opening a new connection for each file. Compression: The JAR format allows you to compress your files for efficient storage. Packaging for extensions: The extensions framework provides a means by which you can add functionality to the Java core platform, and the JAR file format defines the packaging for extensions. By using the JAR file format, you can turn your software into extensions as well. Package Sealing: Packages stored in JAR files can be optionally sealed so that the package can enforce version consistency. Sealing a package within a JAR file means that all classes defined in that package must be found in the same JAR file. Package Versioning: A JAR file can hold data about the files it contains, such as vendor and version information. Portability: The mechanism for handling JAR files is a standard part of the Java platform’s core API. This lesson has four sections: Using JAR Files: The Basics This section shows you how to perform basic JAR-file operations, and how to run software that is bundled in JAR files. Working with Manifest Files: The Basics This section explains manifest files and how to customize them so you can do such things as seal packages and set an application’s entry point. Signing and Verifying JAR Files This section shows you how to digitally sign JAR files and verify the signatures of signed JAR files. Using JAR-related APIs This section introduces you to some of the JAR-handling features of the Java platform. The JAR file format is an important part of the Java platform’s extension mechanism. You can learn more about that aspect of JAR files in the The Extension Mechanism trail of this tutorial. Questions and Exercises: JAR Test what you’ve learned about JAR. Additional ReferencesThe documentation for the Java Development Kit (JDK) includes information about the Jar tool: [Java Archive (JAR) Files Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/jar/index.html) [JAR File Specification](https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html)","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Questions and Exercises  Self-Contained Applications","date":"2020-12-06T04:45:11.719Z","path":"wiki/2021-03-03-Questions and Exercises  Self-Contained Applications/","text":"Questions and Exercises: Self-Contained ApplicationsQuestions Which of the following items is not an advantage of self-contained applications? 1. Users install the application with an installer that is familiar to them. 1. The application runs as a native application. 1. The application requires less space on a user's machine. 1. You control the version of the JRE that is used by the application. 1. The application does not require a browser to run. True or False: MIME type must always be used to set up a file association. What elements are used to identify the entry points for self-contained applications in the &amp;lt;fx:deploy&amp;gt; Ant task? Exercises Write the `&lt;fx:deploy&gt;` Ant task to generate a Windows MSI bundle for a simple application named My Sample App. The JAR file for the application is in the `dist` directory, the main class is `samples.MyApp`, and output files are to be written to the current directory. Enhance the code from the previous exercise to create bundles for all Windows installers and define a file association for text files. Check your answers.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Using Multiple Entry Points","date":"2020-12-06T04:45:09.122Z","path":"wiki/2021-03-03-Using Multiple Entry Points/","text":"Using Multiple Entry PointsSelf-contained applications are useful when you have a set of related applications that you want users to deploy. A self-contained application provides a single, installable bundle that installs all of the applications and the JRE needed to run them. The Multiple Launchers Demo includes the Dynamic Tree Demo described inConverting an Existing Application and the File Association Demo described inUsing File Associations. The /src directory of the project contains the source file for both applications. You can download the source files for the Multiple Launchers Demo fromSelf-Contained Application Examples. The primary entry point for a self-contained application is identified by the mainClass attribute of the &amp;lt;fx:application&amp;gt; element. In the Multiple Launchers Demo, the primary entry point is the File Association Demo. The main class is sample.fa.ScriptRunnerAppliation for Linux and Windows, or sample.fa.ScriptRunnerApplicationMac for OS X. SeeUsing a Common Build File for All Platforms for information on how the class to use is determined when a single build file is used across platforms. Each secondary entry point is identified by an instance of the &amp;lt;fx:secondaryLauncher&amp;gt; element. See&lt;fx:secondaryLauncher&gt; for information about this element. In the Multiple Launchers Demo, the secondary entry point is the Dynamic Tree Demo. The following code in the build.xml file shows how the second entry point is defined: 12345678910111213&lt;fx:secondaryLauncher name&#x3D;&quot;Dynamic Tree Demo&quot; mainClass&#x3D;&quot;webstartComponentArch.DynamicTreeApplication&quot; version&#x3D;&quot;1.0&quot; title&#x3D;&quot;Dynamic Tree Demo&quot; vendor&#x3D;&quot;My Company&quot; description&#x3D;&quot;A Demo of Multiple Launchers for JavaPackager&quot; copyright&#x3D;&quot;(c) 2014 My Company&quot; menu&#x3D;&quot;true&quot; shortcut&#x3D;&quot;false&quot; &gt;&lt;&#x2F;fx:secondaryLauncher&gt; Seebuild.xml for the complete build code. To generate the installable bundles for the Multiple Launchers Demo, see the “Generating the Bundles” section inConverting an Existing Application. When your self-contained application is installed, the File Association Demo is installed with the Multiple Launchers entry point and the Dynamic Tree Demo is installed with its own entry point. For example, on Windows, the Java Demos folder in the Start menu contains two entries: Dynamic Tree Demo and Multiple Launchers Demo. Note that file associations are set up for the Multiple Launchers entry point, so opening a JavaScript or Groovy file starts Multiple Launchers. Additional ResourcesFor more information about multiple entry points, seeSupporting Multiple Entry Points. For more information about JavaFX Ant arguments, seeJavaFX Ant Task Reference.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Using a Common Build File for All Platforms","date":"2020-12-06T04:45:05.870Z","path":"wiki/2021-03-03-Using a Common Build File for All Platforms/","text":"Using a Common Build File for All PlatformsTo generate a self-contained application bundle for each platform on which your application runs, you must run the packaging tool on each platform. You have the option of using platform-specific build files or setting up one build file that can be run on all platforms. Platform-specific files can be simpler to set up, but then you must maintain multiple files. The File Association Demo described inUsing File Associations uses a single build file that works on all platforms. The following elements of the build file support its use for all platforms: The main class for the application is `ScriptRunnerApplication.java` for Linux and Windows and `ScriptRunnerApplicationMac.java` for OS X. The following code in the `-pre-init` task is used to determine which class to use: &lt;condition property=\"main.class\" value=\"sample.fa.ScriptRunnerApplication\" else=\"sample.fa.ScriptRunnerApplicationMac\"&gt; &lt;not&gt;&lt;os family=\"mac\"/&gt;&lt;/not&gt; &lt;/condition&gt; &lt;li&gt;The following code in the `-pre-init` task is used to prevent the main class for OS X from being compiled when running on Linux or Windows: &lt;condition property=\"excludes\" value=\"**/*Mac.java\"&gt; &lt;not&gt;&lt;os family=\"mac\"/&gt;&lt;/not&gt; &lt;/condition&gt; &lt;fx:bundleArgument&gt; elements are used to pass arguments to the different bundlers available. Arguments that are not used by a bundler are ignored, so the build file can contain the arguments needed by all platforms. The following code defines arguments for Linux, OS X, and Windows: &lt;fx:bundleArgument arg=\"classpath\" value=\"FileAssociationsDemo.jar lib/groovy-all-2.3.8.jar\"/&gt; &lt;fx:bundleArgument arg=”win.exe.systemWide” value=”true”/&gt; &lt;fx:bundleArgument arg=”linux.bundleName” value=”file-association-demo”/&gt;&lt;fx:bundleArgument arg=”email” value=”&#x6d;&#97;&#105;&#110;&#116;&#x61;&#x69;&#110;&#x65;&#114;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;“/&gt;&lt;fx:bundleArgument arg=”mac.CFBundleName” value=”File Assoc Demo”/&gt;&lt;fx:bundleArgument arg=”win.menuGroup” value=”Java Demos”/&gt; Seebuild.xml for the complete build code. You can download the source files for the File Association Demo fromSelf-Contained Application Examples.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Providing a Default Argument","date":"2020-12-06T04:45:03.308Z","path":"wiki/2021-03-03-Providing a Default Argument/","text":"Providing a Default ArgumentArguments are passed to Java applications when an application is started. Self-contained applications can be set up with a default argument that is used when no argument is specified. The &amp;lt;fx:argument&amp;gt; element is used to define the argument. More than one argument can be passed by adding an &amp;lt;fx:argument&amp;gt; element for each argument. See&lt;fx:argument&gt; for information about this element. The File Association Demo described inUsing File Associations is set up use the name of one of the sample files that is bundled with the application as the default argument. The following code in the &amp;lt;fx:deploy&amp;gt; task in the build.xml file shows how the default argument is defined: 12345678&lt;fx:application id&#x3D;&quot;fileassociationdemo&quot; name&#x3D;&quot;File Association Demo&quot; mainClass&#x3D;&quot;$&#123;main.class&#125;&quot; version&#x3D;&quot;1.0&quot;&gt; &lt;fx:argument&gt;sample.js&lt;&#x2F;fx:argument&gt;&lt;&#x2F;fx:application&gt; Seebuild.xml for the complete build code. You can download the source files for the File Association Demo fromSelf-Contained Application Examples. Additional ResourcesFor more information about default arguments, seePassing Arguments to a Self-Contained Application. For more information about JavaFX Ant arguments, seeJavaFX Ant Task Reference.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Adding an External Library","date":"2020-12-06T04:45:00.422Z","path":"wiki/2021-03-03-Adding an External Library/","text":"Adding an External LibrarySelf-contained applications include everything that an application needs to run. If your application requires an external library, that library can be added to the bundle for the application. Adding the library can be done in different ways. The File Association Demo described inUsing File Associations downloads the Groovy library as part of the build process. The library is placed in the /lib directory in the project for the application. This directory is then copied to the /dist directory from which the self-contained application bundle is generated. The following code in the -pre-init task in the build.xml file shows how the library is downloaded: 12345678&lt;!-- download and copy groovy library --&gt;&lt;copy toFile&#x3D;&quot;lib&#x2F;groovy-all-2.3.8.jar&quot;&gt; &lt;resources&gt; &lt;url url&#x3D;&quot;http:&#x2F;&#x2F;central.maven.org&#x2F;maven2&#x2F;org&#x2F;codehaus&#x2F;groovy&#x2F;groovy-all&#x2F;2.3.8&#x2F;groovy-all-2.3.8.jar&quot;&#x2F;&gt; &lt;&#x2F;resources&gt;&lt;&#x2F;copy&gt; Seebuild.xml for the complete build code. You can download the source files for the File Association Demo fromSelf-Contained Application Examples.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Using File Associations","date":"2020-12-06T04:44:57.896Z","path":"wiki/2021-03-03-Using File Associations/","text":"Using File AssociationsOne of the advantages of providing a self-contained application to your users is the ability to set up file associations. Specific types of files can be associated with your application based on MIME type or file extension so that your application is used to open an associated file. For example, if your application edits text files, you can set up a file association that runs your application when a user double-clicks on a file with the extension .txt. The File Association Demo reads JavaScript and Groovy code. Using both MIME types and file extensions, the application is associated with JavaScript and Groovy files. You can download the source files for the File Association Demo fromSelf-Contained Application Examples. Setting Up File AssociationsThe Ant tasks for generating the self-contained application bundles are in the build.xml file for the File Association Demo. The &amp;lt;fx:association&amp;gt; Ant element is used to associate file extensions or MIME types with your application. Linux bundlers require the MIME type, Windows bundlers require the file extension, and OS X bundlers require at least one of the properties. It is a good practice to use both properties with a one-to-one mapping between the MIME type and file extension, which enables you to use the same build file on multiple platforms. See&lt;fx:association&gt; for more information about this element. The following code shows what needs to be included in the fx:deploy element to associate the application with the extensions .js and .groovy and the MIME types text/javascript and text/x-groovy. 12345678910&lt;fx:info title&#x3D;&quot;File Association Demo&quot; vendor&#x3D;&quot;MySamples&quot; description&#x3D;&quot;A Demo of File Associations for Java Packager&quot; category&#x3D;&quot;Demos&quot; license&#x3D;&quot;3 Clause BSD&quot;&gt; &lt;fx:association extension&#x3D;&quot;js&quot; mimetype&#x3D;&quot;text&#x2F;javascript&quot; description&#x3D;&quot;JavaScript Source&quot;&#x2F;&gt; &lt;fx:association extension&#x3D;&quot;groovy&quot; mimetype&#x3D;&quot;text&#x2F;x-groovy&quot; description&#x3D;&quot;Groovy Source&quot;&#x2F;&gt;&lt;&#x2F;fx:info&gt; If a bundler does not support file associations, the associations are ignored. As of the 8u40 release of the JDK, the Windows EXE and MSI bundlers, Linux DEB and RPM bundlers, and the Mac .app bundler support file associations. The OS X PKG and DMG bundlers support file associations through their use of the Mac .app bundler. Seebuild.xml for the complete build code. To generate the installable bundles for the File Association Demo, see the “Generating the Bundles” section inConverting an Existing Application. Launching from Associated FilesFile associations are set up by the installer when the self-contained application bundle is installed on a user’s system. After the application is installed, opening a file that is associated with your application causes your application to be started. The actions taken to launch your application depend on the platform on which it is running. Launching on Linux and WindowsOn Linux and Windows, when an application is launched based on a file association, the files being opened are passed as arguments to the main class, which overrides the default argument for the class. For the File Associations Demo, the arguments are passed to the loadscript method after an instance of the application is started. A different instance of the application is started for each file opened. SeeScriptRunnerApplication.java for the Linux and Windows version of the code. Launching on OS XOn OS X, only a single instance of an application is run. When an associated file is opened, an event is sent to the application. The application must have an event listener registered to handle the event. The File Association Demo for OS X has a subclass with a different main method than the version for Linux and Windows. This main method handles the default argument in the same way as the main method for the Linux and Windows version, and then registers a listener with OS X for FileOpenHandler. The event method for this listener is called when an associated file is opened, and the file name is extracted from the getFiles method of the OpenFilesEvent object. SeeScriptRunnerApplicationMac.java for the OS X version of the code. Building the OS X version of the File Association Demo requires access to the OS X-specific classes that come with the Oracle JDK. Most com.apple.eawt classes are not included in the symbols file that the javac compiler uses. To tell the compiler to ignore the symbols file, the -XDignore.symbol.file=true argument is passed to the javac compiler in the -pre-init Ant task in the build file. Seebuild.xml. More About the File Association DemoThe project for the File Association Demo contains the Java source files for the application in the /src/sample/fa directory. Custom icons are provided in the /src/package/&lt;var&gt;platform&lt;/var&gt; directory. Sample files to be packaged with the application are in the /src directory. To handle Groovy code, the File Association Demo requires the Groovy library. The build process downloads the Groovy library to the /lib directory. SeeAdding an External Library for information. After the JAR file is generated, the build process copies the /src and /lib directories to the /dist directory. The /dist directory then contains all of the files for your application. The File Association Demo takes a file name as an argument. If the application is started by opening an associated file, the name of the associated file is passed in. If the application is started directly, the sample file sample.js, which is bundled with the application, is passed in. SeeProviding a Default Argument for information. Admin privileges are required to set up file associations. By default the EXE installer for Windows does not request admin privileges. To force a request for admin privileges for the File Association Demo, the bundle argument win.exe.systemWide is set to true. This setting indicates that a system-wide installation is performed, which requires admin privileges. The File Association Demo runs on Linux, OS X, and Windows. The demo is set up to use a single build file that contains the information for all platforms. SeeUsing a Common Build File for All Platforms for information. Additional ResourcesFor more information about file associations, seeAssociating Files with a Self-Contained Application. For more information about JavaFX Ant arguments, seeJavaFX Ant Task Reference.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Converting an Existing Application","date":"2020-12-06T04:44:54.892Z","path":"wiki/2021-03-03-Converting an Existing Application/","text":"Converting an Existing ApplicationAny standalone Java application or Java Web Start application can be packaged as a self-contained application. If you have a Java applet, seeRe-writing a Java Applet as a Java Web Start Application for information on coverting the applet to a Java Web Start application, which can then be packaged as a self-contained application. Before converting an application, make sure that you have the required pre-requisites installed for your platform. SeePre-Requisites for Packaging Self-Contained Applications for information. This section converts the Dynamic Tree Demo fromDeploying a Java Web Start Application to a self-contained application.You can download the source files for this demo fromSelf-Contained Application Examples. Setting Up the DirectoriesIdentify and organize the files that are needed by your application. A simple application might require only a JAR file. A more complex application might also require additional libraries or resources. Custom resources such as icons or configuration files can also be used by self-contained applications. The Dynamic Tree Demo requires only the DynamicTreeDemo.jar file, which is in the /dist directory of the project. The HTML and JNLP files that were needed for the Java Web Start version of the application are not needed and are ignored by the bundlers for self-contained applications. To provide a custom icon for the Dynamic Tree Demo, which represents the application when it is installed on a user’s desktop, an icon is provided for each platform supported. These icons are placed in the /src/package/&lt;var&gt;platform&lt;/var&gt; directories. The icon is provided in a different format for each supported platform: .ico format for Windows, .png format for Linux, and .icns format for OS X. The following example shows the directory structure for the Dynamic Tree Demo project before the self-contained bundles are created: 12345678910111213&#x2F;packager_DynamicTreeDemo &lt;--- application project &#x2F;dist DynamicTreeDemo.jar ... &#x2F;src &#x2F;package &lt;--- custom resources &#x2F;linux &#x2F;macosx &#x2F;windows &#x2F;webstartComponentArch &lt;--- application source files ... Setting Up the Build FileSet up the Ant tasks for the packaging tasks that are needed. These tasks can be added to the build.xml file for the project, or placed in a separate file that is imported by the build.xml file. For the Dynamic Tree Demo, the packager.xml file in the root directory of the project contains the Ant tasks for generating the self-contained application bundles. The source for the packager.xml file is shown in the following example: 123456789101112131415161718192021222324252627282930313233343536373839&lt;project name&#x3D;&quot;DynamicTreePackaging&quot; default&#x3D;&quot;default&quot; basedir&#x3D;&quot;.&quot; xmlns:fx&#x3D;&quot;javafx:com.sun.javafx.tools.ant&quot;&gt; &lt;echo&gt;$&#123;java.home&#125;&#x2F;..&#x2F;lib&#x2F;ant-javafx.jar&lt;&#x2F;echo&gt; &lt;target name&#x3D;&quot;package&quot; depends&#x3D;&quot;jar&quot;&gt; &lt;taskdef resource&#x3D;&quot;com&#x2F;sun&#x2F;javafx&#x2F;tools&#x2F;ant&#x2F;antlib.xml&quot; uri&#x3D;&quot;javafx:com.sun.javafx.tools.ant&quot; classpath&#x3D;&quot;$&#123;java.home&#125;&#x2F;..&#x2F;lib&#x2F;ant-javafx.jar;src&quot;&#x2F;&gt; &lt;fx:deploy outdir&#x3D;&quot;$&#123;basedir&#125;&#x2F;build&#x2F;packager&quot; outfile&#x3D;&quot;DynamicTreeDemo&quot; nativeBundles&#x3D;&quot;all&quot; verbose&#x3D;&quot;false&quot;&gt; &lt;fx:application name&#x3D;&quot;Dynamic Tree Demo&quot; mainClass&#x3D;&quot;webstartComponentArch.DynamicTreeApplication&quot; version&#x3D;&quot;1.0&quot; &#x2F;&gt; &lt;fx:resources&gt; &lt;fx:fileset dir&#x3D;&quot;dist&quot; includes&#x3D;&quot;DynamicTreeDemo.jar&quot;&#x2F;&gt; &lt;&#x2F;fx:resources&gt; &lt;fx:info title&#x3D;&quot;Dynamic Tree Demo&quot; vendor&#x3D;&quot;My Company&quot; description&#x3D;&quot;A Demo of a Dynamic Swing Tree&quot; category&#x3D;&quot;Demos&quot; copyright&#x3D;&quot;(c) 2014 My Company&quot; license&#x3D;&quot;3 Clause BSD&quot; &#x2F;&gt; &lt;fx:bundleArgument arg&#x3D;&quot;linux.bundleName&quot; value&#x3D;&quot;dynamic-tree-demo&quot;&#x2F;&gt; &lt;fx:bundleArgument arg&#x3D;&quot;email&quot; value&#x3D;&quot;maintainer@example.com&quot;&#x2F;&gt; &lt;fx:bundleArgument arg&#x3D;&quot;mac.CFBundleName&quot; value&#x3D;&quot;Java Tree Demo&quot;&#x2F;&gt; &lt;fx:bundleArgument arg&#x3D;&quot;win.menuGroup&quot; value&#x3D;&quot;Java Demos&quot;&#x2F;&gt; &lt;&#x2F;fx:deploy&gt; &lt;&#x2F;target&gt;&lt;&#x2F;project&gt; Use the following information to set up the Ant tasks: Use xmlns:fx=&quot;javafx:com.sun.javafx.tools.ant for the namespace. The `taskdef` task must be executed before the `fx:deploy` task. The `classpath` attribute contains the location of the `ant-javafx.jar` file from the JDK and the directory that contains the custom resources. For the Dynamic Tree Demo, the `classpath` attribute includes the `/src` directory, which contains the custom icons. Place the `fx:deploy` task inside the desired target. Specify the output directory where the native binaries are placed, and specify the native binaries that you want to produce. If `all` is specified for the native binaries, all possible binaries for the platform on which you execute this task file are generated, including the disk image. Valid values for all platforms are `all`; `image`, which generates the file directory on Windows and Linux and the `.app` file on OSX; and `installer`, which generates only installable bundles for the platform, not the disk image. Valid values for platform-specific binaries are `exe` and `msi` for Windows; `deb` and `rpm` for Linux; `deb`, `pkg`, and `mac.appStore` for OS X. You must have the required tools installed to build the binary of your choice. For the Dynamic Tree Demo, the `outdir` attribute is set to `${basedir}/build/packager`. `basedir` is defined in the `project` element, in this case it is set to the current directory. The `nativeBundles` attribute is set to `all` so all formats for the platform on which the packaging task is run are built. - The `verbose` attribute is optional. Use this attribute to provide diagnostic information. - Provide information about the application. Set the name of the application in the `name` attribute of the `fx:application` element and the `title` attribute of the `fx:info` element. Set the version of the application in the `version` attribute of the `fx:application` element. Use the `fx:info` element to provide a description of the application, the name of the vendor, license information, and other metadata. - Information about the JAR file and other resources is set in the `fx:resources` element. Launch information is set in the `mainclass` attribute of the `fx:application` element. For the Dynamic Tree Demo, a simple single launcher is used, `webstartComponentArch.DynamicTreeApplication`, which is the main class for the application. Other platform-specific customizations are provided in the `fx:bundleArgument` elements. Arguments that are not recognized by a bundler are ignored, so one build file can contain the packaging information for all platforms. For the Dynamic Tree Demo, the following customizations are applied: - The bundle name for Linux is set to `dynamic-tree-demo`. - An email address is provided. - The name that appears in the menu bar for OS X is set to `Java Tree Demo`. - The name of the menu group in which the application is stored for Windows is set to `Java Demos`. ## Generating the Bundles Run the packaging tasks that you created on the platform for which you want to build the bundle for your self-contained application. For the Dynamic Tree Demo, run the following command from the root folder for the project: 123ant package When the packaging task completes, the build/packager/bundles directory in the application project contains the native binaries that were produced. The following example shows the directory structure for the Dynamic Tree Demo project after the self-contained bundles are generated for Windows: 1234567891011121314151617181920&#x2F;packager_DynamicTreeDemo &lt;--- application project &#x2F;build &#x2F;packager &#x2F;bundles Dynamic Tree Demo &lt;---folder image Dynamic Tree Demo-1.0.exe &lt;---EXE installer Dynamic Tree Demo-1.0.msi &lt;---MSI installer ... &#x2F;dist DynamicTreeDemo.jar ... &#x2F;src &#x2F;package &lt;--- custom resources &#x2F;linux &#x2F;macosx &#x2F;windows &#x2F;webstartComponentArch &lt;--- application source files ... Note that in addition to the self-contained bundles, the packaging tool always generates the JAR, JNLP, annd HTML files for an application. These files provide other options for distributing your application. Additional ReferencesFor more information about self-contained applications, seeSelf-Contained Application Packaging. For more information about the Ant tasks for the Java packaging tools, see JavaFX Ant Tasks, which are used for Java and JavaFX applications.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Pre-Requisites for Packaging Self-Contained Applications","date":"2020-12-06T04:44:47.190Z","path":"wiki/2021-03-03-Pre-Requisites for Packaging Self-Contained Applications/","text":"Pre-Requisites for Packaging Self-Contained ApplicationsThe Java Development Kit (JDK) is required to compile and package your application. The installable bundle must be created on the platform on which the self-contained application will run. For example, if your application runs on Windows and Linux, you must run the packaging tool on Windows to create a .exe or .msi bundle, and run the packaging tool on Linux to create a .rpm or .deb file. Third party tools are required to create the installable bundle. The following table identifies the tools for each supported platform. PlatformFormatTool WindowsEXEInno Setup 5 or later WindowsMSIWiX Toolset 3.8 or later LinuxRPMRPMBuild LinuxDEBDebian packaging tools OS XDMG&#160; OS XPKG&#160;","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Deploying Self-Contained Applications","date":"2020-12-06T04:44:43.414Z","path":"wiki/2021-03-03-Deploying Self-Contained Applications/","text":"Lesson: Deploying Self-Contained ApplicationsA self-contained application consists of a single, installable bundle that contains your application and a copy of the JRE needed to run the application. When the application is installed, it behaves the in the same way as any native application. Providing users with a self-contained application avoids the security issues related to running an application in a browser. You can customize a self-contained application by providing your own icons. File associations can be set up so when a user opens a file that your application can handle, your application is started automatically. Multiple entry points are supported so you can deliver a suite of applications in a single self-contained application bundle. Self-contained applications can be packaged using the Java Packaging tools. The javapackager command creates the bundle for self-contained applications from the command line. NetBeans can also be used to created self-contained application bundles. This lesson describes how to use Ant tasks to create the bundles. Additional ReferencesFor more information about self-contained applications, seeSelf-Contained Application Packaging in the Java Platform, Standard Edition Deployment Guide. For information about Ant tasks for Java packaging, seeJavaFX Ant Tasks, which are used for packaging Java SE and JavaFX applications. For information about the javapackager command, seeJava Deployment Tools.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Questions and Exercises  Deployment In-Depth","date":"2020-12-06T04:44:40.870Z","path":"wiki/2021-03-03-Questions and Exercises  Deployment In-Depth/","text":"Questions and Exercises: Deployment In-DepthQuestions What script contains functions to deploy applets and Java Web Start applications? True or False: You should always sign your RIA just to be sure it will always work. Exercises Write the JavaScript code to deploy the Exercise applet using the ex.jnlp file. Check your answers.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Ensuring the Presence of the JRE Software","date":"2020-12-06T04:44:37.451Z","path":"wiki/2021-03-03-Ensuring the Presence of the JRE Software/","text":"Ensuring the Presence of the JRE SoftwareRich Internet applications (RIAs) usually need a minimum version of the Java Runtime Environment (JRE) software to be present on the client machine. When deploying a RIA, you need to ensure that client machines have the required version of the JRE software so that your RIA can function well. With the Deployment Toolkit script, you have at least two ways to handle this requirement. You can check the version of client JRE software as soon as users access your web site and install the latest version if necessary. You can let users navigate the web site, and check and install the latest JRE only when they attempt to use your RIA. Checking and Installing the Latest JRE Software When the User Accesses Your Web SiteThe following example checks if a user has at least version 1.6.0_13 of the JRE software installed. If not, the code installs the latest JRE software. See inline comments in the code. 12345678910111213141516171819202122&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; &#x2F;&#x2F; check if current JRE version is greater than 1.6.0 alert(&quot;versioncheck &quot; + deployJava.versionCheck(&#39;1.6.0_10+&#39;)); if (deployJava.versionCheck(&#39;1.6.0_10+&#39;) &#x3D;&#x3D; false) &#123; userInput &#x3D; confirm( &quot;You need the latest Java(TM) Runtime Environment. &quot; + &quot;Would you like to update now?&quot;); if (userInput &#x3D;&#x3D; true) &#123; &#x2F;&#x2F; Set deployJava.returnPage to make sure user comes back to &#x2F;&#x2F; your web site after installing the JRE deployJava.returnPage &#x3D; location.href; &#x2F;&#x2F; Install latest JRE or redirect user to another page to get JRE deployJava.installLatestJRE(); &#125; &#125;&lt;&#x2F;script&gt; Installing the Correct JRE Software Only When the User Attempts to Use Your RIAWhen you specify the minimum version of the JRE software in the runApplet or createWebStartLaunchButton function, the Deployment Toolkit script makes sure that the required version of the JRE software exists on the client before running your RIA. Use the runApplet function to deploy an applet, as shown in the following example. The last parameter of the runApplet function is the minimum version that is required to run your applet (version 1.6). 123456789 &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; var attributes &#x3D; &#123; code:&#39;components.DynamicTreeApplet&#39;, width:300, height:300&#125;; var parameters &#x3D; &#123;jnlp_href: &#39;dynamictree_applet.jnlp&#39;&#125;; deployJava.runApplet(attributes, parameters, &#39;1.6&#39;);&lt;&#x2F;script&gt; To deploy a Java Web Start application, use the createWebStartLaunchButton function with the correct minimum version parameter (version 1.6). 1234567&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; var url &#x3D; &quot;dynamictree_applet.jnlp&quot;; deployJava.createWebStartLaunchButton(url, &#39;1.6.0&#39;);&lt;&#x2F;script&gt; The runApplet and createWebStartLaunchButton functions check the client’s version of the JRE software. If the minimum version is not installed, the functions install the latest version of the JRE software.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Avoiding Unnecessary Update Checks","date":"2020-12-06T04:44:34.274Z","path":"wiki/2021-03-03-Avoiding Unnecessary Update Checks/","text":"Avoiding Unnecessary Update ChecksRich Internet applications (RIAs) are cached locally to improve startup time. However, before launching a RIA, the launch software checks to make sure that every JAR file referenced in the RIA’s Java Network Launch Protocol (JNLP) file is up-to-date. In other words, the launch software makes sure that you are running the latest version of the RIA and not an older cached copy. These update checks can take up to a few hundred milliseconds depending on the number of JAR files and network speed. Use the techniques described in this topic to avoid unnecessary update checks and to enhance the start up time of your RIA. The term “launch software” is used here to collectively refer to the Java Plug-in software and the Java Web Start software. The Java Plug-in software launches applets while the Java Web Start software launches Java Web Start applications. Leveraging the Version Download ProtocolYou can leverage the version download protocol to eliminate unnecessary version checks. See the following steps to enable this protocol. Rename the JAR files to include a version number suffix with the following naming convention: **&lt;JAR file name&gt;**__V**&lt;version number&gt;**.jar For example, rename `DynamicTreeDemo.jar` to `DynamicTreeDemo__V1.0.jar`. In the JNLP file, specify a version for every JAR file, and set the `jnlp.versionEnabled` property to `true`. &lt;resources&gt; &lt;!-- Application Resources --&gt; &lt;j2se version=\"1.6+\" href=\"http://java.sun.com/products/autodl/j2se\" max-heap-size=\"128m\" /&gt; &lt;jar href=\"DynamicTreeDemo.jar\" main=\"true\" **version=\"1.0\"**/&gt; &lt;jar href=\"SomeOther.jar\" version=\"2.0\"/&gt; &lt;property name=\"jnlp.versionEnabled\" value=\"true\"/&gt; &lt;!-- ... --&gt; &lt;/resources&gt; When the `jnlp.versionEnabled` property is enabled, the launch software performs only **one** update check to make sure that the JNLP file is up-to-date. The software compares the version numbers that are specified in the JNLP file with the corresponding JAR file versions (according to the naming convention mentioned in step 1) and updates only the outdated JAR files. This approach is efficient because only the update check for the JNLP file occurs over the network. All other version checks occur locally. If a file with the correct version number is not found, the launch software attempts to load the default JAR file (for example, `DynamicTreeDemo.jar`). Performing Update Checks in the BackgroundIf it is not critical for the user to immediately run the latest version of your RIA, you can specify that all update checks should occur in the background. In this case, the launch software launches the locally cached copy for immediate usage and downloads a newer version of the RIA in the background. The newer version of the RIA will be launched the next time the user attempts to use your RIA. To enable background update checks, add the following line to your JNLP file: 123&lt;update check&#x3D;&#39;background&#39;&#x2F;&gt; The following code snippet shows a sample JNLP file with the background update check enabled: 12345678910111213141516171819202122232425&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;jnlp spec&#x3D;&quot;1.0+&quot; codebase&#x3D;&quot;&quot; href&#x3D;&quot;&quot;&gt; &lt;information&gt; &lt;title&gt;Applet Takes Params&lt;&#x2F;title&gt; &lt;vendor&gt;Dynamic Team&lt;&#x2F;vendor&gt; &lt;&#x2F;information&gt; &lt;resources&gt; &lt;!-- Application Resources --&gt; &lt;j2se version&#x3D;&quot;1.6+&quot; href&#x3D; &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;products&#x2F;autodl&#x2F;j2se&quot;&#x2F;&gt; &lt;jar href&#x3D;&quot;applet_AppletWithParameters.jar&quot; main&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;resources&gt; &lt;applet-desc name&#x3D;&quot;Applet Takes Params&quot; main-class&#x3D;&quot;AppletTakesParams&quot; width&#x3D;&quot;800&quot; height&#x3D;&quot;50&quot;&gt; &lt;param name&#x3D;&quot;paramStr&quot; value&#x3D;&quot;someString&quot;&#x2F;&gt; &lt;param name&#x3D;&quot;paramInt&quot; value&#x3D;&quot;22&quot;&#x2F;&gt; &lt;&#x2F;applet-desc&gt; **&lt;update check&#x3D;&quot;background&quot;&#x2F;&gt;**&lt;&#x2F;jnlp&gt;","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Reducing the Download Time","date":"2020-12-06T04:44:31.144Z","path":"wiki/2021-03-03-Reducing the Download Time/","text":"Reducing the Download TimeRich Internet applications (RIAs) are downloaded from a web site when the user tries to access them. (RIAs can be cached after the initial download to improve performance). The time taken to download a RIA depends on the size of the RIA’s JAR file. Larger JAR files take longer to download. You can reduce the download time of your RIA by applying the following techniques: Compress your RIA's JAR file by using the [`pack200`](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/pack200.html) tool. - Remove unnecessary white space from the Java Network Launch Protocol (JNLP) file and the JavaScript files. - Optimize images and animation. The following steps describe how to create and deploy a compressed JAR file for a signed RIA. Normalize the JAR file using the `--repack` option. This step ensures that the security certificate and JAR file will pass verification checks when the RIA is launched. pack200 --repack DynamicTreeDemo.jar Sign the normalized JAR file. jarsigner -keystore myKeyStore DynamicTreeDemo.jar me where `myKeyStore` is the name of the keystore and `me` is the alias for the keystore. Pack the signed JAR file pack200 DynamicTreeDemo.jar.pack.gz DynamicTreeDemo.jar Set the `jnlp.packEnabled` property to `true` in the RIA's JNLP file. &lt;resources&gt; &lt;j2se version=\"1.6+\" href=\"http://java.sun.com/products/autodl/j2se\" max-heap-size=\"128m\" /&gt; &lt;jar href=\"DynamicTreeDemo.jar\" main=\"true\"/&gt; &lt;property name=\"jnlp.packEnabled\" value=\"true\"/&gt; &lt;!-- ... --&gt; &lt;/resources&gt; When the jnlp.packEnabled property is set in the JNLP file, the Java Plug-in software looks for the compressed JAR file with the .pack.gz extension (for example, DynamicTreeDemo.jar.pack.gz). If found, the Java Plug-in software automatically unpacks and loads the JAR file. If a file with the .pack.gz extension is not found, then the Java Plug-in software attempts to load the regular JAR file (for example, DynamicTreeDemo.jar).","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Deployment Best Practices","date":"2020-12-06T04:44:28.017Z","path":"wiki/2021-03-03-Deployment Best Practices/","text":"Deployment Best PracticesYou can improve the user experience of your rich Internet application (RIA) using the best practices described in this topic. Sign the RIA using a certificate from a recognized certificate authority. Make sure that all artifacts are signed, and that the certificate has not expired. See [Signing and Verifying JAR Files](../jar/signindex.html) for information on signing. Request the minimum level of permissions that is needed. If the RIA does not require unrestricted access to a user's system, specify the permission level to be sandbox. See [Security in Rich Internet Applications ](../doingMoreWithRIA/security.html) for more security guidelines. Optimize the size of JAR files and related resources so that your RIA can load quickly. See [Reducing the Download Time](../deploymentInDepth/reducingDownloadTime.html) for optimization techniques. Enable the version download protocol and use background update checks to enable your RIA to start quickly. See [Avoiding Unnecessary Update Checks](../deploymentInDepth/avoidingUnnecessaryUpdateChecks.html) to learn more about the version download protocol and update checks. Make sure that the client has the required version of the Java Runtime Environment software. See [Ensuring the Presence of the JRE Software](../deploymentInDepth/ensuringJRE.html) for details on how the Deployment Toolkit script can be used for this purpose. Embed the contents of your applet's JNLP file in the `&lt;applet&gt;` tag to avoid loading the JNLP file from the network. This feature was introduced in the Java SE 7 release. See [Embedding JNLP File in Applet Tag](../deploymentInDepth/embeddingJNLPFileInWebPage.html) to learn how to embed the contents of the applet's JNLP file in the web page. Preload your Java Web Start application, if possible. If you plan to deploy your RIA as a Java Web Start application in an enterprise where you have some administrative control, you can preload your application to various clients so that it is cached and ready to use. Use the following command to preload your Java Web Start application: javaws -import -silent **&lt;jnlp url&gt;**","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Structure of the JNLP File","date":"2020-12-06T04:44:24.903Z","path":"wiki/2021-03-03-Structure of the JNLP File/","text":"Structure of the JNLP FileThis topic describes the syntax of the Java Network Launch Protocol (JNLP) file for rich Internet applications (RIAs). The following code snippet shows a sample JNLP file for a Java Web Start application: 1234567891011121314151617181920212223242526&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;jnlp spec&#x3D;&quot;1.0+&quot; codebase&#x3D;&quot;&quot; href&#x3D;&quot;&quot;&gt; &lt;information&gt; &lt;title&gt;Dynamic Tree Demo&lt;&#x2F;title&gt; &lt;vendor&gt;Dynamic Team&lt;&#x2F;vendor&gt; &lt;icon href&#x3D;&quot;sometree-icon.jpg&quot;&#x2F;&gt; &lt;offline-allowed&#x2F;&gt; &lt;&#x2F;information&gt; &lt;resources&gt; &lt;!-- Application Resources --&gt; &lt;j2se version&#x3D;&quot;1.6+&quot; href&#x3D; &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;products&#x2F;autodl&#x2F;j2se&quot;&#x2F;&gt; &lt;jar href&#x3D;&quot;DynamicTreeDemo.jar&quot; main&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;resources&gt; &lt;application-desc name&#x3D;&quot;Dynamic Tree Demo Application&quot; main-class&#x3D;&quot;webstartComponentArch.DynamicTreeApplication&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;300&quot;&gt; &lt;&#x2F;application-desc&gt; &lt;update check&#x3D;&quot;background&quot;&#x2F;&gt;&lt;&#x2F;jnlp&gt; The following table describes the elements and attributes commonly used in JNLP files. Click the parent link to view an element’s parent. ElementAttributesDescriptionSinceRequired Attributes Since jnlpThe topmost xml element for a JNLP file.1.0Yes 1.0 specValue of the attribute can be 1.0, 1.5, or 6.0, or can use wildcards such as 1.0+. It denotes the minimum version of the JNLP Specification that this JNLP file can work with.1.0 spec 1.0 codebaseThe base location for all relative URLs specified in `href` attributes in the JNLP file.1.0 codebase 1.0 hrefThe URL of the JNLP file itself.1.0 href 1.0 versionThe version of the RIA being launched, as well as the version of the JNLP file itself.1.0 version 1.0 &#160;&#160;&#160;&#160; [parent](#jnlp)Contains other elements that describe the RIA and its source.1.0Yes 1.0 osThe operating system for which this information element should be considered.1.5.0 os 1.5.0 archThe architecture for which this information element should be considered.1.5.0 arch 1.5.0 platformThe platform for which this information element should be considered.1.5.0 platform 1.5.0 localeThe locale for which this information element should be considered.1.5.0 locale 1.5.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; title [parent](#information)The title of the RIA.1.0Yes 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; vendor [parent](#information)The provider of the RIA.1.0Yes 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; homepage [parent](#information)The homepage of the RIA.1.0 1.0 hrefA URL pointing to where more information about this RIA can be found.1.0Yes href 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; description [parent](#information)A short statement describing the RIA.1.0 1.0 kindAn indicator as to the type of description. Legal values are one-line, short, and tooltip.1.0 kind 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; icon [parent](#information)An icon that can be used to identify the RIA to the user.1.0 1.0 hrefA URL pointing to the icon file. Can be in one of the following formats: gif, jpg, png, ico.1.0Yes href 1.0 kindIndicates the suggested use of the icon, can be: default, selected, disabled, rollover, splash, or shortcut.1.0 kind 1.0 widthCan be used to indicate the resolution of the image.1.0 width 1.0 heightCan be used to indicate the resolution of the image.1.0 height 1.0 depthCan be used to indicate the resolution of the image.1.0 depth 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; offline-allowed [parent](#information)Indicates that this RIA can operate when the client system is disconnected from the network.1.0 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; shortcut [parent](#information)Can be used to indicate the RIA's preferences for desktop integration.1.5.0 1.5.0 onlineCan be used to describe the RIA's preference for creating a shortcut to run online or offline.1.5.0 online 1.5.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; desktop [parent](#information)Can be used to indicate the RIA's preference for putting a shortcut on the user's desktop.1.5.0 1.5.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; menu [parent](#information)Can be used to indicate the RIA's preference for putting a menu item in the user's start menus.1.5.0 1.5.0 sub-menuCan be used to indicate the RIA's preference for where to place the menu item.1.5.0 sub-menu 1.5.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; association [parent](#information)Can be used to hint to the JNLP client that the RIA wants to be registered with the operating system as the primary handler of certain extensions and a certain mime-type. If this element is included, either the offline-allowed element must also be included, or the href attribute must be set for the jnlp element.1.5.0 1.5.0 extensionsA list of file extensions (separated by spaces) that the RIA requests it be registered to handle.1.5.0 extensions 1.5.0 mime-typeThe mime-type that the RIA requests it be registered to handle.1.5.0 mime-type 1.5.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; related-content [parent](#information)An additional piece of related content that can be integrated with the RIA.1.5.0 1.5.0 hrefA URL pointing to the related content.1.5.0Yes href 1.5.0 &#160;&#160;&#160;&#160;update [parent](#jnlp)The preferences for how RIA updates should be handled by the JNLP client.1.6.0 1.6.0 checkThe preference for when the JNLP client should check for updates. Value can be always, timeout, or background..1.6.0 check 1.6.0 policyThe preference for how the JNLP client should handle a RIA update when a new version is available before the RIA is launched. Values can be always, prompt-update, or prompt-run.1.6.0 policy 1.6.0 1.0 1.0 &#160;&#160;&#160;&#160;[parent](#jnlp)Can be used to request enhanced permissions. If this element is not included, the application is run in the security sandbox.1.0 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; all-permissions [parent](#security)Requests that the RIA be run with all permissions.1.0 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; j2ee-application-client-permissions [parent](#security)Requests that the RIA be run with a permission set that meets the security specifications of the J2EE application client environment.1.0 1.0 &#160;&#160;&#160;&#160;[parent](#jnlp)Describes all the resources that are needed for the RIA.1.0Yes 1.0 osThe operating system for which the resources element should be considered.1.0 os 1.0 archThe architecture for which the resources element should be considered.1.0 arch 1.0 localeThe locales for which the resources element should be considered. locale &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; java or j2se [parent](#resources)Versions of Java software to run the RIA with.1.6.0 (java) 1.6.0 (java) versionOrdered list of version ranges to use.1.0Yes version 1.0 hrefThe URL denoting the supplier of this version of Java software, and from where it can be downloaded.1.0 href 1.0 java-vm-argsAn additional set of standard and non-standard virtual machine arguments that the RIA would prefer the JNLP client use when launching the JRE software.1.0 java-vm-args 1.0 initial-heap-sizeThe initial size of the Java heap.1.0 initial-heap-size 1.0 max-heap-sizeThe maximum size of the Java heap.1.0 max-heap-size 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; jar [parent](#resources)A JAR file that is part of the RIA's classpath.1.0Yes 1.0 hrefThe URL of the JAR file.1.0Yes href 1.0 versionThe requested version of the JAR file. Requires using the version-based download protocol1.0 version 1.0 mainIndicates if this JAR file contains the class containing the `main` method of the RIA.1.0 main 1.0 downloadIndicates that this JAR file can be downloaded lazily, or when needed.1.0 download 1.0 sizeThe downloadable size of the JAR file in bytes.1.0 size 1.0 partCan be used to group resources together so that they are downloaded at the same time.1.0 part 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; nativelib [parent](#resources)A JAR file that contains native libraries in its root directory.1.0 1.0 hrefThe URL of the JAR file.1.0Yes href 1.0 versionThe requested version of the JAR file. Requires using the version-based download protocol1.0 version 1.0 downloadCan be used to indicate this JAR file can be downloaded lazily.1.0 download 1.0 sizeThe downloadable size of the JAR file in bytes.1.0 size 1.0 partCan be used to group resources together so they will be downloaded at the same time.1.0 part 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; [parent](#resources)A pointer to an additional component-desc or installer-desc to be used with this RIA.1.0 1.0 hrefThe URL to the additional extension JNLP file.1.0Yes href 1.0 versionThe version of the additional extension JNLP file.1.0 version 1.0 nameThe name of the additional extension JNLP file1.0 name 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ext-download [parent](#extension)Can be used in an extension element to denote the parts contained in a component-extension.1.0 1.0 ext-partThe name of a part that can be expected to be found in the extension.1.0Yes ext-part 1.0 downloadCan be used to indicate this extension can be downloaded eagerly or lazily.1.0 download 1.0 partDenotes the name of a part in this JNLP file in which to include the extension.1.0 part 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; package [parent](#resources)Can be used to indicate to the JNLP client which packages are implemented in which JAR files.1.0 1.0 namePackage name contained in the JAR files of the given part.1.0Yes name 1.0 partPart name containing the JAR files that include the given package name.1.0Yes part 1.0 recursiveCan be used to indicate that all package names, beginning with the given name, can be found in the given part.1.0 recursive 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; property [parent](#resources)Defines a system property that will be available through the `System.getProperty` and `System.getProperties` methods.1.0 1.0 nameName of the system property.1.0Yes name 1.0 valueValue of the system property.1.0Yes value 1.0 Note: A JNLP file must contain one of the following: application-desc, applet-desc, component-desc, or installer-desc.1.0Yes 1.0 &#160;&#160;&#160;&#160;[parent](#jnlp)Denotes this is the JNLP file for an application.1.0 1.0 main-classThe name of the class containing the `public static void main(String[])` method of the application.1.0Yes main-class 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; argument [parent](#applicationdesc)Each argument contains (in order) an additional argument to be passed to the `main` method.1.0 1.0 &#160;&#160;&#160;&#160;[parent](#jnlp)Denotes this is the JNLP file for an applet.1.0 1.0 main-classThe name of the main applet class.1.0Yes main-class 1.0 documentbaseThe document base for the applet as a URL.1.0 documentbase 1.0 nameName of the applet.1.0Yes name 1.0 widthThe width of the applet in pixels.1.0Yes width 1.0 heightThe height of the applet in pixels.1.0Yes height 1.0 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; param [parent](#appletdesc)A set of parameters that can be passed to the applet.1.0 1.0 nameThe name of this parameter.1.0Yes name 1.0 valueThe value of this parameter.1.0Yes value 1.0 &#160;&#160;&#160;&#160;component-desc [parent](#jnlp)Denotes this is the JNLP file for a component extension.1.0 1.0 &#160;&#160;&#160;&#160;installer-desc [parent](#jnlp)Denotes this is the JNLP file for an installed extension.1.0 1.0 main-classThe name of the class containing the `public static void main(String[])` method of the installer.1.0Yes main-class 1.0 Encoding JNLP FilesJava Web Start software supports encoding of JNLP files in any character encoding supported by the Java platform. For more information about character encoding in the Java platform, see theSupported Encodings Guide. To encode a JNLP file, specify an encoding in the XML prolog of that file. For example, the following line indicates that the JNLP file is encoded in UTF-16. 123&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-16&quot;?&gt;","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Java Network Launch Protocol","date":"2020-12-06T04:44:21.711Z","path":"wiki/2021-03-03-Java Network Launch Protocol/","text":"Java Network Launch ProtocolThe Java Network Launch Protocol (JNLP) enables an application to be launched on a client desktop by using resources that are hosted on a remote web server. Java Plug-in software and Java Web Start software are considered JNLP clients because they can launch remotely hosted applets and applications on a client desktop. SeeJava Network Launching Protocol and API Specification Change Log for details. Recent improvements in deployment technologies enable us to launch rich Internet applications (RIAs) by using JNLP. Both applets and Java Web Start applications can be launched by using this protocol. RIAs that are launched by using JNLP also have access to JNLP APIs. These JNLP APIs allow the RIAs to access the client desktop with the user’s permission. JNLP is enabled by a RIA’s JNLP file. The JNLP file describes the RIA. The JNLP file specifies the name of the main JAR file, the version of Java Runtime Environment software that is required to run the RIA, name and display information, optional packages, runtime parameters, system properties, and so on. You can find more information about deploying RIAs by using JNLP in the following topics: [Deploying an Applet](../applet/deployingApplet.html) [Deploying a Java Web Start Application](../webstart/deploying.html) [JNLP API](../doingMoreWithRIA/jnlpAPI.html) [Structure of the JNLP File](../deploymentInDepth/jnlpFileSyntax.html)","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Checking the Client JRE Software Version","date":"2020-12-06T04:44:18.555Z","path":"wiki/2021-03-03-Checking the Client JRE Software Version/","text":"Checking the Client JRE Software VersionThere are many reasons to check if a particular version of the Java Runtime Environment (JRE) software is available on a client machine. For example, you might want to launch a different version of your rich Internet application (RIA) or redirect the user to a different page depending on the client’s JRE software version. Use the Deployment Toolkit script’s versionCheck function to check if a particular version or range of JRE versions is installed on the client. Function signature: versionCheck: function(versionPattern) Parameters: versionPattern &#8211; String specifying the version or range of versions to check for, such as such as “1.4”, “1.5.0*” (1.5.x family), and “1.6.0_02+” (any version greater than or equal to 1.6.0_02). Usage: Creating a different user experience depending on the client’s JRE software version In this example, a Launch button is created for the Notepad application only if the version of JRE software on the client is greater than or equal to 1.6. If not, the browser is redirected to oracle.com. 12345678910111213 &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; if (deployJava.versionCheck(&#39;1.6+&#39;)) &#123; var url &#x3D; &quot;https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorialJWS&#x2F;deployment&#x2F;webstart&#x2F;examples&#x2F;Notepad.jnlp&quot;; &lt;!-- you can also invoke deployJava.runApplet here --&gt; deployJava.createWebStartLaunchButton(url, &#39;1.6.0&#39;); &#125; else &#123; document.location.href&#x3D;&quot;http:&#x2F;&#x2F;oracle.com&quot;; &#125;&lt;&#x2F;script&gt;","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Deploying Without Codebase","date":"2020-12-06T04:44:15.429Z","path":"wiki/2021-03-03-Deploying Without Codebase/","text":"Deploying Without CodebaseBeginning in the Java SE 7 release, you do not have to specify an absolute path for the codebase attribute in the Java Web Start application’s Java Network Launch Protocol (JNLP) file. You can develop and test your applications in different environments without having to modify the path in the codebase attribute. If no codebase is specified, the Java Web Start software assumes that the codebase is relative to the web page from which the Java Web Start application is launched. The following functions of the Deployment Toolkit script can be used to deploy Java Web Start applications in a web page when the JNLP file does not contain the codebase attribute: launchWebStartApplication &#8211; Use this function in an HTML link to deploy your Java Web Start application. createWebStartLaunchButtonEx &#8211; Use this function to create a Launch button for your Java Web Start application. Function signature: launchWebStartApplication: function(jnlp) Parameter: jnlp &#8211; The path to the JNLP file containing deployment information for the Java Web Start application. This path can be relative to the web page in which the Java Web Start application is deployed. Usage: In the following example, the launchWebStartApplication function is invoked in the href attribute of an HTML anchor (a) tag. The&lt;code&gt;dynamictree_webstart_no_codebase.jnlp JNLP file is used to deploy the Dynamic Tree Demo application. 1234&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;a href&#x3D;&quot;javascript:deployJava.launchWebStartApplication(&#39;dynamictree_webstart_no_codebase.jnlp&#39;);&quot;&gt;Launch&lt;&#x2F;a&gt; The Java Web Start application is launched when the user clicks the resulting HTML link. Function signature: createWebStartLaunchButtonEx: function(jnlp) Parameter: jnlp &#8211; The path to the JNLP file containing deployment information for the Java Web Start application. This path can be relative to the web page in which the Java Web Start application is deployed. Usage: The following example shows the usage of the createWebStartLaunchButtonEx function. The&lt;code&gt;dynamictree_webstart_no_codebase.jnlp JNLP file is used to deploy the Dynamic Tree Demo application. 1234567&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; var jnlpFile &#x3D; &quot;dynamictree_webstart_no_codebase.jnlp&quot;; deployJava.createWebStartLaunchButtonEx(jnlpFile);&lt;&#x2F;script&gt; The Java Web Start application is launched when the user clicks the resulting Launch button. Open&lt;code&gt;JavaWebStartAppPage_No_Codebase.html in a browser to view the Dynamic Tree Demo application that is deployed by using the functions described in this topic. You can also launch the Java Web Start application at the system command prompt by invoking the javaws command with the complete url of the JNLP file as shown in the following code snippet. 123javaws http:&#x2F;&#x2F;example.com&#x2F;dynamictree_webstart_no_codebase.jnlp Download source code for the Dynamic Tree Demo example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Changing the Launch Button","date":"2020-12-06T04:44:11.643Z","path":"wiki/2021-03-03-Changing the Launch Button/","text":"Changing the Launch ButtonYou can change your Java Web Start application’s Launch button image, if you don’t like the default button or if you have another image that you have standardized on. Use the deployJava.launchButtonPNG variable to point to the location of your Launch button’s image. Variable: deployJava.launchButtonPNG Usage: Providing an alternate image URL In this example, the Notepad application’s Launch button is now an image of Duke waving. 12345678 &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; deployJava.launchButtonPNG&#x3D;&#39;https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;images&#x2F;DukeWave.gif&#39;; var url &#x3D; &quot;https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorialJWS&#x2F;deployment&#x2F;webstart&#x2F;examples&#x2F;Notepad.jnlp&quot;; deployJava.createWebStartLaunchButton(url, &#39;1.6.0&#39;);&lt;&#x2F;script&gt; The Notepad application’s new Launch button (Duke waving) follows. Click on Duke’s image to launch the Notepad application.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Deploying a Java Web Start Application","date":"2020-12-06T04:44:08.502Z","path":"wiki/2021-03-03-Deploying a Java Web Start Application/","text":"Deploying a Java Web Start ApplicationYou can deploy Java Web Start applications by using the createWebStartLaunchButton function of theDeployment Toolkit script. Java Web Start applications are launched using Java Network Launch Protocol (JNLP) The createWebStartLaunchButton function generates a link (HTML anchor tag - &amp;lt;a&amp;gt;) to the Java Web Start application’s JNLP file. This generated anchor tag is the Java Web Start application’s button. When the end user clicks the Launch button, the Deployment Toolkit script ensures that the appropriate Java Runtime Environment (JRE) software is installed and then launches the Java Web Start application. Function signature: createWebStartLaunchButton: function(jnlp, minimumVersion) or createWebStartLaunchButton: function(jnlp) Parameters: jnlp &#8211; The URL of the JNLP file containing deployment information for the Java Web Start application. This URL should be an absolute path. minimumVersion &#8211; The minimum version of JRE software required to run this application Usage: Specifying a minimum version of JRE software that is required to run the application &lt;script src=\"https://www.java.com/js/deployJava.js\"&gt;&lt;/script&gt; &lt;script&gt; var url = \"http://java.sun.com/javase/technologies/desktop/javawebstart/apps/notepad.jnlp\"; deployJava.createWebStartLaunchButton(url, '1.6.0'); &lt;/script&gt; Enabling Java Web Start application to run on any JRE software version Use the `createWebStartLaunchButton: function(jnlp)` function if your application does not have a minimum JRE software version requirement.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Embedding JNLP File in Applet Tag","date":"2020-12-06T04:44:05.825Z","path":"wiki/2021-03-03-Embedding JNLP File in Applet Tag/","text":"Embedding JNLP File in Applet TagWhen applets are deployed by using the Java Network Launch Protocol (JNLP), the Java Plug-in software launches the applet after downloading the JNLP file from the network. Beginning in the Java SE 7 release, you can reduce the the time it takes for applets to launch, by embedding the JNLP file in the web page itself so that an additional network request can be avoided the first time the applet is loaded. This will result in applets launching quickly on the web browser. A Base64 encoded JNLP file can be embedded in the jnlp_embedded parameter when deploying an applet in a web page. The attributes of the &amp;lt;jnlp&amp;gt; element should meet the following restrictions: The href attribute should contain a relative path. The codebase attribute should not be specified. This implies that the codebase will be derived from the URL of the web page in which the applet is loaded. The following steps describe how to embed a JNLP file in a web page to deploy an applet. Create a [`JNLP`](examples/depl_EmbeddingJNLPInWebPage/src/dynamictree_applet.jnlp) file for your applet. A sample file is shown next. &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- href attribute contains relative path; codebase attribute not specified --&gt; &lt;jnlp href=\"dynamictree_applet.jnlp\"&gt; &lt;information&gt; &lt;title&gt;Dynamic Tree Demo&lt;/title&gt; &lt;vendor&gt;Dynamic Team&lt;/vendor&gt; &lt;/information&gt; &lt;resources&gt; &lt;!-- Application Resources --&gt; &lt;j2se version=\"1.7+\" /&gt; &lt;jar href= \"dist/applet_ComponentArch_DynamicTreeDemo/DynamicTreeDemo.jar\" main=\"true\" /&gt; &lt;/resources&gt; &lt;applet-desc name=\"Dynamic Tree Demo Applet\" main-class=\"appletComponentArch.DynamicTreeApplet\" width=\"300\" height=\"300\"&gt; &lt;/applet-desc&gt; &lt;update check=\"background\"/&gt; &lt;/jnlp&gt; Encode the contents of the JNLP file using the Base64 scheme. You can use any Base64 encoding tool to encode the the JNLP file. Check the usage of the tool to create a string with Base64 encoding. Some examples of tools and web sites that may be used are as follows: 1. UNIX commands &#8211; `base64`, `uuencode` Web sites &#8211; [Base64 Encode and Decode](http://base64encode.org/), [Base64 Encoder](http://www.opinionatedgeek.com/dotnet/tools/base64encode/) When deploying the applet in a web page, specify the `jnlp_embedded` parameter with it's value set to the Base64 encoded JNLP string. Make sure to include only the actual Base64 bytes without any encoding tool specific headers or footers. &lt;script src=\"https://www.java.com/js/deployJava.js\"&gt;&lt;/script&gt; &lt;script&gt; var attributes = &#123;&#125; ; &lt;!-- Base64 encoded string truncated below for readability --&gt; var parameters = &#123;jnlp_href: 'dynamictree_applet.jnlp', **jnlp_embedded: 'PCEtLSANCi8qDQogKiBDb ... bmxwPg=='** &#125; ; deployJava.runApplet(attributes, parameters, '1.6'); &lt;/script&gt; Some encoding tools may wrap the encoded string into several 76-column lines. To use this multi-line attribute value in JavaScript code, specify the attribute value as a set of concatenated strings. You can include the multi-line attribute value as is if the applet is deployed directly with the `&lt;applet&gt;` HTML tag. Open&lt;code&gt;AppletPage.html in a browser to view the Dynamic Tree Demo applet that is launched by using the JNLP file embedded in the web page. Download source code for the Embedded JNLP example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Deploying an Applet","date":"2020-12-06T04:44:02.659Z","path":"wiki/2021-03-03-Deploying an Applet/","text":"Deploying an AppletYou can deploy applets by using the runApplet function of theDeployment Toolkit script. The runApplet function ensures that the required minimum version of the Java Runtime Environment (JRE) software exists on the client and then runs the applet. The runApplet function generates an HTML &amp;lt;applet&amp;gt; tag with the information provided. You can deploy applets by specifying the deployment options as attributes and parameters of the &amp;lt;applet&amp;gt; tag. You can also specify deployment options in a Java Network Launch Protocol (JNLP) file to take advantage of advanced features. See theJava Network Launch Protocol topic for more information about this protocol. If the client does not have the required minimum version of the JRE software, the Deployment Toolkit script redirects the browser to http://www.java.com to allow users to download the latest JRE software. On some platforms, users might be redirected before they can view the web page containing the applet. The parameters to the runApplet function vary depending on whether you are using JNLP. Applets deployed by using JNLP can run only if the next generation Java Plug-in software exists on the client machine (the next generation Java Plug-in software was introduced in the Java Platform, Standard Edition 6 update 10 release). The next section shows how to use the runApplet function in the HTML page that will display the applet. The following usage scenarios are described: Specifying deployment options as attribute and parameter name-value pairs Using the jnlp_href parameter to specify deployment options in a JNLP file Specifying attribute and parameter name-value pairs as well as a JNLP file (enables applet to run on the old and next generation Java Plug-in software) Function signature: runApplet: function(attributes, parameters, minimumVersion) Parameters: attributes &#8211; The names and values of the attributes of the generated &amp;lt;applet&amp;gt; tag parameters &#8211; The names and values of the &amp;lt;param&amp;gt; tags in the generated &amp;lt;applet&amp;gt; tag minimumVersion &#8211; The minimum version of the JRE software that is required to run this applet Usage: Specifying deployment options as attribute and parameter name-value pairs The attributes and parameters passed as name-value pairs are written out as attributes and nested `&lt;param&gt;` tags in the generated `&lt;applet&gt;` tag. Applets deployed in this manner can be run by the old Java Plug-in software. // launch the Java 2D applet on JRE version 1.6.0 // or higher with one parameter (fontSize) &lt;script src= \"https://www.java.com/js/deployJava.js\"&gt;&lt;/script&gt; &lt;script&gt; var attributes = &#123;code:'java2d.Java2DemoApplet.class', archive:'Java2Demo.jar', width:710, height:540&#125;; var parameters = &#123; fontSize:16, permissions:'sandbox' &#125;; var version = '1.6'; deployJava.runApplet(attributes, parameters, version); &lt;/script&gt; Open [`DeployUsingNameValuePairs.html`](examples/dist/depltoolkit_Java2Demo/DeployUsingNameValuePairs.html) in a browser to view the the Java2D applet. **Note:** &#160;If you don't see the applet running, you need to install at least the [Java SE Development Kit (JDK) 7](http://www.oracle.com/technetwork/java/javase/downloads/index.html) release. Using the `jnlp_href` parameter to specify deployment options in a JNLP file The attributes and parameters (`jnlp_href` in this case) passed as name-value pairs are written out as attributes and nested `&lt;param&gt;` tags in the generated `&lt;applet&gt;` tag. Applets deployed in this manner can be run by the next generation Java Plug-in software only. It is better to specify the applet's width and height as attributes as follows: &lt;script src=\"https://www.java.com/js/deployJava.js\"&gt;&lt;/script&gt; &lt;script&gt; var attributes = &#123; code:'java2d.Java2DemoApplet', width:710, height:540 &#125;; var parameters = &#123; jnlp_href: 'java2d.jnlp' &#125;; deployJava.runApplet(attributes, parameters, '1.6'); &lt;/script&gt; Open [`DeployUsingJNLP.html`](examples/dist/depltoolkit_Java2Demo/DeployUsingJNLP.html) in a browser to view the the Java2D applet. **Note:** &#160;If you don't see the applet running, you need to install at least the [Java SE Development Kit (JDK) 6 update 10](http://www.oracle.com/technetwork/java/javase/downloads/index.html) release. Specifying attribute and parameter name-value pairs **as well as** a JNLP file Applets deployed by using JNLP will run only if end users have the next generation Java Plug-in software running on their browsers. If you would like your applet to run on the old Java Plug-in software also, specify deployment options using attribute and parameter name-value pairs **as well as** a JNLP file. &lt;script src=\"https://www.java.com/js/deployJava.js\"&gt;&lt;/script&gt; &lt;script&gt; var attributes = &#123;code:'java2d.Java2DemoApplet.class', archive:'Java2Demo.jar', width:710, height:540&#125;; var parameters = &#123; fontSize:16, jnlp_href:'java2d.jnlp' &#125;; var version = '1.6' ; deployJava.runApplet(attributes, parameters, version); &lt;/script&gt; The following guidelines are helpful if some deployment options have different values in the attribute name-value pairs and in the JNLP file: Specify width and height as attribute name-value pairs (not in the JNLP file). Specify parameters such as image and boxbgcolor as parameter name-value pairs (not in the JNLP file). These parameters are needed early on in the applet startup process. In the JNLP file, leave the codebase attribute empty or specify an absolute URL. When the codebase attribute is left empty, it defaults to the directory containing the JNLP file. If the applet is launched using a JNLP file, the values for the code, codebase, and archive attributes are taken from the JNLP file. If these attributes are also specified separately as attribute name-value pairs, the attribute name-value pairs are ignored. Open&lt;code&gt;DeployUsingNameValuePairsAndJNLP.html in a browser to view the the Java2D applet. Download source code for the Run Applet example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Deployment Toolkit","date":"2020-12-06T04:44:00.031Z","path":"wiki/2021-03-03-Deployment Toolkit/","text":"Deployment ToolkitThe Deployment Toolkit script is a set of JavaScript functions that can help developers deploy rich Internet applications (RIAs) consistently across various browser and operating system configurations. The Deployment Toolkit script evaluates the underlying browser and operating system, and deploys the RIA with the correct HTML. This script can also ensure that the required version of the Java Runtime Environment (JRE) software is present on the client machine. The Deployment Toolkit script was introduced in the Java Platform, Standard Edition 6 update 10 release. Location of Deployment Toolkit ScriptThe Deployment Toolkit script exists at the following web addresses: **http:**//www.java.com/js/deployJava.js (See note.) **https:**//www.java.com/js/deployJava.js &#8211; When deploying your applet on a secure page, use the Deployment Toolkit script from this secure location to avoid mixed content warnings when the page is loaded. The JavaScript code in this location has been minimized so that it can load quickly. You can view the human readable version of the JavaScript code with associated comment blocks athttps://www.java.com/js/deployJava.txt.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"User Acceptance of RIAs","date":"2020-12-06T04:43:57.476Z","path":"wiki/2021-03-03-User Acceptance of RIAs/","text":"User Acceptance of RIAsFor security, users are prompted for permission to run an RIA before launching for the first time, even if the application is signed or doesn’t require access outside of the security sandbox. The prompt includes the following information, depending on the RIA being run: Name of the RIA, or notification that the application is unsigned. Information about the publisher, if the app is signed with a certificate from a trusted authority. If the certificate is expired, a warning is included. If the application is self-signed, the publisher is shown as UNKNOWN. Warnings if the certificate is expired, revoked, or the revocation status cannot be checked. Location from which the application is accessed. Level of access required by the application. Limited access restricts the application to the security sandbox, unrestricted access provides the application with access to resources on the user’s system. Warning about missing JAR file manifest attributes if recommended attributes are not present. For unsigned or self-signed applications, a checkbox that the user must select to accept the application. In some cases, the option to not show the prompt again. For a description of the prompts, seeWhat should I do when I see a security prompt from Java? Users are also warned if they are running an out-of-date JRE and are given the opportunity to update to the latest version before running an application. Users can also choose to run with the JRE on their system, or to block the application from running. The security level setting in the Java Control Panel determines if users are given the opportunity to run RIAs. The default setting of High prompts users for permission to run applications that are signed with a valid certificate and include the Permissions attribute in the manifest for the main JAR file. If the revocation status of an application cannot be checked, the application is also allowed to run with the user’s permsision. Signing your RIA provides the user with a level of trust. Consider the following when preparing your application for deployment: The best user experience is provided by an application that is signed with a certificate issued by a recognized certificate authority. Self-signed and unsigned applications are not allowed to be run unless an exception site list or deployment rule set has been created to explicitly allow the application to run. Signed applications can be either privileged applications or sandbox applications. Privileged applications are provided unrestricted access to resources on the user's system. Sandbox applications are restricted to the Java security sandbox. Unsigned applications are restricted to the sandbox.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Deployment In-Depth","date":"2020-12-06T04:43:54.868Z","path":"wiki/2021-03-03-Deployment In-Depth/","text":"Lesson: Deployment In-DepthRich Internet application (RIA) deployment involves various technologies and tools such as the Java Network Launch Protocol (JNLP), Deployment Toolkit, pack200, jarsigner and so on. This lesson explores how these technologies and tools help developers deploy RIAs (applets and Java Web Start applications). The main components that are involved in RIA deployment are the following: The HTML page in which the RIA will be deployed The JNLP file for the RIA The JAR file containing the class files and resources of the RIA These components are referred to in subsequent topics.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Questions and Exercises  Doing More With Rich Internet Applications","date":"2020-12-06T04:43:52.005Z","path":"wiki/2021-03-03-Questions and Exercises  Doing More With Rich Internet Applications/","text":"Questions and Exercises: Doing More With Rich Internet ApplicationsQuestions True or False: Rich Internet applications (RIAs) can set secure properties by prefixing the property name with &quot;jnlp.&quot;. True or False: Only signed RIAs can use JNLP API to access files on the client. ExercisesTo the following JNLP file, add a secure property called `jnlp.foo` and set its value to `true`. &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;jnlp spec=\"1.0+\" codebase=\"\" href=\"\"&gt; &lt;information&gt; &lt;title&gt;Dynamic Tree Demo&lt;/title&gt; &lt;vendor&gt;Dynamic Team&lt;/vendor&gt; &amp;lt;/information&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;!-- Application Resources --&amp;gt; &amp;lt;j2se version=&quot;1.6+&quot; href= &quot;http://java.sun.com/products/autodl/j2se&quot; /&amp;gt; &amp;lt;jar href=&quot;DynamicTreeDemo.jar&quot; main=&quot;true&quot; /&amp;gt; &amp;lt;/resources&amp;gt; &amp;lt;applet-desc name=&quot;Dynamic Tree Demo Applet&quot; main-class=&quot;components.DynamicTreeApplet&quot; width=&quot;300&quot; height=&quot;300&quot;&amp;gt; &amp;lt;/applet-desc&amp;gt; &amp;lt;update check=&quot;background&quot;/&amp;gt; &lt;/jnlp&gt; Check your answers.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Guidelines for Securing Rich Internet Applications","date":"2020-12-06T04:43:49.395Z","path":"wiki/2021-03-03-Guidelines for Securing Rich Internet Applications/","text":"Guidelines for Securing Rich Internet ApplicationsThe following guidelines provide steps you can take to reduce the vulnerability of the Rich Internet Applications (RIAs) that you provide to users. Follow Secure Coding Guidelines Test with the Latest Version of the JRE Include Manifest Attributes Use a Signed JNLP File Sign and Time Stamp JAR Files Use the HTTPS Protocol Avoid Local RIAs Follow Secure Coding GuidelinesFollow the recommendations in theSecure Coding Guidelines for the Java Programming Language. Section 4, “Accessibility and Extensibility” describes how to limit accessibility to classes and packages, which reduces the vulnerability of your code. JavaScript code is considered insecure and is restricted to the security sandbox by default. Minimize interactions between your RIA and JavaScript code. Use the AccessController.doPrivileged block with care because it allows access from any HTML page or JavaScript code. Test with the Latest Version of the JREMake sure that your RIA runs on the latest, secure version of the JRE. The Java platform supports the ability for RIAs to specify the Java version that is needed to run the RIA, however, requiring users to maintain more than one version of the JRE, especially older, insecure versions, is a security risk for the user. One of the benefits of RIAs is that updated versions of the RIA are automatically download to a user’s system. Test your RIA against each update of the JRE and make sure that it works. If changes are needed, update your RIA on the server so that users can install the latest JRE and still run the RIA. Include Manifest AttributesAdd attributes to the JAR file manifest that describe the properties of the RIA. Values in the JNLP file or the applet tag are compared to values in the manifest to verify that the correct code is run. Request sandbox permissions when your RIA does not require access beyond the security sandbox. The Java sandbox provides additional protections for users, and users might not run a privileged application if they do not understand why it requests unrestricted access to their system. Manifest attributes can also be used to identify the locations from which your RIA can be accessed. This includes locations from which JavaScript code can call your RIA, and locations of JNLP files or applet tags that can start your RIA. SeeEnhancing Security with Manifest Attributes for information on the manifest attributes that are available. Use a Signed JNLP FileIf your RIA needs to access non-secure system properties or JVM arguments, use a signed JNLP. If some variation between the external and internal JNLP files is required, use JNLP templates. SeeSigned JNLP Files in the Java Platform, Standard Edition Deployment Guide for information. To access non-secure system properties or JVM arguments, include the property or argument in the JNLP file as described inSetting Trusted Arguments and Secure Properties. Sign and Time Stamp JAR FilesObtain a code signing certificate from a trusted certificate authority and use it to sign the JAR files for your RIA. Deploy to users only RIAs that are signed with a valid certificate. When you sign your JAR file, also time stamp the signature. Time stamping verifies that the certificate was valid at the time that the JAR was signed, so the RIA is not automatically blocked when the certificate expires. SeeSigning JAR Files for information on signing and time stamping. Self-signed and unsigned RIAs are considered unsafe and are not allowed to run unless an exception site list or deployment rule set is set up to allow specific applications. However, self-signing can be useful for testing purposes. To test using your self-signed RIA, you can import the self-signed certificate into the trusted keystore. Use the HTTPS ProtocolUse the HTTPS protocol for the web server from which users get your RIA. The HTTPS protocol is encrypted and validated by the server, making it more difficult for anyone to tamper with your RIA. Avoid Local RIAsLocal RIAs are not intended for use in production. To ensure that users run the code that you intend for them to run, host your RIA on an application server. For testing, the use of a web server is recommended. Another option is to add your application to the exception site list, which is managed in the Security tab of the Java Control Panel.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Security in Rich Internet Applications","date":"2020-12-06T04:43:46.702Z","path":"wiki/2021-03-03-Security in Rich Internet Applications /","text":"Security in Rich Internet ApplicationsThe security model behind rich Internet applications (RIAs) works to protect the user from malicious Internet applications. This topic discusses security aspects that are common to applets and Java Web Start applications. See the following topics for more information: [What Applets Can and Cannot Do](../applet/security.html) [Java Web Start and Security](../webstart/security.html) RIAs can be restricted to the Java security sandbox or request permission to access resources outside the sandbox. The first time an RIA is launched, the user is prompted for permission to run. The dialog shown provides information about the signer’s certificate and indicates if the RIA requests permission to run outside the sandbox. The user can then make an informed decision about running the application. Apply the following guidelines to help secure your RIAs. Sign the JAR file of the RIA with a certificate from a recognized certificate authority. For more information, see the [Signing and Verifying JAR Files](../jar/signindex.html) topic. If the RIA requires access outside of the security sandbox, specify the `all-permissions` element in the JNLP file for the RIA. Otherwise, let the RIA default to running in the security sandbox. The following code snippet shows the `all-permissions` element in the RIA's JNLP file. &lt;security&gt; &lt;all-permissions/&gt; &lt;/security&gt; If the applet tag is used, see [Deploying With the Applet Tag](../applet/html.html) for information on setting the permissions level. A JNLP file can only include JAR files signed by the same certificate. If you have JAR files that are signed using different certificates, specify them in separate JNLP files. In the RIA's main JNLP file, specify the `component-desc` element to include the other JNLP files as component extensions. See [Structure of the JNLP File](../deploymentInDepth/jnlpFileSyntax.html) for information. The security model for RIAs does not allow JavaScript code from a web page to invoke security-sensitive code in a signed JAR file unless you explicitly enable this. In the signed JAR file, wrap the section of code that you want JavaScript code to be able to invoke in a [`AccessController.doPrivileged`](https://docs.oracle.com/javase/8/docs/api/java/security/AccessController.html) block. This allows the JavaScript code to run with elevated permissions when executing the code in the `doPrivileged` code block. Avoid mixing privileged and sandbox components in a RIA, if possible, as they can raise security warnings about mixed code. See [Mixing Privileged Code and Sandbox Code](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/mixed_code.html) for more information. Include the `Permissions` and `Codebase` attributes in the JAR file manifest to ensure that your RIA requests only the permissions you specify, and that the RIA is accessed from the correct location. See [JAR File Manifest Attributes for Security ](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/manifest.html) for information. JAR file manifest attributes enable you to restrict access to your RIA and help to ensure that your code is not tampered with. See [Enhancing Security with Manifest Attributes](../jar/secman.html) for information on all of the JAR file manifest attributes that are available.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Accessing Cookies","date":"2020-12-06T04:43:44.150Z","path":"wiki/2021-03-03-Accessing Cookies/","text":"Accessing CookiesYou can set and retrieve cookies in your rich Internet application (RIA). Cookies can enhance the capabilities of your RIA. For example, consider the scenario where you have applets on various web pages. An applet on a web page cannot directly access or share information with an applet on another web page. In this scenario, cookies provide an important connection between applets and help one applet pass information to another applet on a different web page. Java Web Start applications can also use cookies to store information on the client. The Cookie Applet example has aCookieAccessor class that retrieves and sets cookies. Retrieving CookiesThe following code snippet shows the getCookieUsingCookieHandler method of the CookieAccessor class: 1234567891011121314151617181920212223242526272829public void getCookieUsingCookieHandler() &#123; try &#123; &#x2F;&#x2F; Instantiate CookieManager; &#x2F;&#x2F; make sure to set CookiePolicy CookieManager manager &#x3D; new CookieManager(); manager.setCookiePolicy(CookiePolicy.ACCEPT_ALL); CookieHandler.setDefault(manager); &#x2F;&#x2F; get content from URLConnection; &#x2F;&#x2F; cookies are set by web site URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;host.example.com&quot;); URLConnection connection &#x3D; url.openConnection(); connection.getContent(); &#x2F;&#x2F; get cookies from underlying &#x2F;&#x2F; CookieStore CookieStore cookieJar &#x3D; manager.getCookieStore(); List &lt;HttpCookie&gt; cookies &#x3D; cookieJar.getCookies(); for (HttpCookie cookie: cookies) &#123; System.out.println(&quot;CookieHandler retrieved cookie: &quot; + cookie); &#125; &#125; catch(Exception e) &#123; System.out.println(&quot;Unable to get cookie using CookieHandler&quot;); e.printStackTrace(); &#125;&#125; TheCookieManager class is the main entry point for cookie management. Create an instance of the CookieManager class and set itsCookiePolicy. Set this instance of the CookieManager as the defaultCookieHandler. Open aURLConnection to the website of your choice. Next, retrieve cookies from the underlyingCookieStore by using the getCookies method. Setting CookiesThe following code snippet shows the setCookieUsingCookieHandler method of the CookieAccessor class: 12345678910111213141516171819202122public void setCookieUsingCookieHandler() &#123; try &#123; &#x2F;&#x2F; instantiate CookieManager CookieManager manager &#x3D; new CookieManager(); CookieHandler.setDefault(manager); CookieStore cookieJar &#x3D; manager.getCookieStore(); &#x2F;&#x2F; create cookie HttpCookie cookie &#x3D; new HttpCookie(&quot;UserName&quot;, &quot;John Doe&quot;); &#x2F;&#x2F; add cookie to CookieStore for a &#x2F;&#x2F; particular URL URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;host.example.com&quot;); cookieJar.add(url.toURI(), cookie); System.out.println(&quot;Added cookie using cookie handler&quot;); &#125; catch(Exception e) &#123; System.out.println(&quot;Unable to set cookie using CookieHandler&quot;); e.printStackTrace(); &#125;&#125; As shown in Retrieving Cookies, theCookieManager class is the main entry point for cookie management. Create an instance of the CookieManager class and set the instance as the defaultCookieHandler. Create the desiredHttpCookie with the necessary information. In our example, we have created a new HttpCookie that sets the UserName as John Doe. Next, add the cookie to the underlying cookie store. Running the Cookie Applet ExampleTo access cookies, you must sign your RIA JAR file and request permission to run outside of the security sandbox. See the documentation for thejarsigner tool to learn how to sign JAR files. SeeSecurity in Rich Internet Applications for information on requesting permissions. Download source code for the Cookie Applet example to experiment further. Running the Cookie Applet ExampleOpenAppletPage.html in a browser to run the Cookie Applet example. Check the Java Console log for details of cookies that have been set and retrieved. You should see the following output in the Java Console log (session details vary). 1234567&#x3D;&#x3D;&#x3D; Access cookies using CookieHandler &#x3D;&#x3D;&#x3D;CookieHandler retrieved cookie: JSESSIONID&#x3D;3bc935c18b8d36319be9497fb892CookieHandler retrieved cookie: JROUTE&#x3D;eKVJ4oW0NOer888sAdded cookie using cookie handler... Download source code for the Cookie Applet example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Cookies","date":"2020-12-06T04:43:41.671Z","path":"wiki/2021-03-03-Cookies/","text":"CookiesWeb applications are typically a series of Hypertext Transfer Protocol (HTTP) requests and responses. As HTTP is a stateless protocol, information is not automatically saved between HTTP requests. Web applications use cookies to store state information on the client. Cookies can be used to store information about the user, the user’s shopping cart, and so on. Types of CookiesThe two types of cookies follow: Session cookies &#8211; Session cookies are stored in memory and are accessible as long as the user is using the web application. Session cookies are lost when the user exits the web application. Such cookies are identified by a session ID and are most commonly used to store details of a shopping cart. Permanent cookies &#8211; Permanent cookies are used to store long-term information such as user preferences and user identification information. Permanent cookies are stored in persistent storage and are not lost when the user exits the application. Permanent cookies are lost when they expire. Cookie Support in Rich Internet ApplicationsRich Internet applications (applets and Java Web Start applications) support session and permanent cookies. The underlying cookie store depends on the browser and the operating system on the client. To learn more about cookies, see the following: [Working With Cookies](../../networking/cookies/index.html) lesson in the Java Tutorial [API Documentation for CookieManager](https://docs.oracle.com/javase/8/docs/api/java/net/CookieManager.html) and related classes","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Accessing the Client Using JNLP API","date":"2020-12-06T04:43:39.056Z","path":"wiki/2021-03-03-Accessing the Client Using JNLP API/","text":"Accessing the Client Using JNLP APIWhen launched by using the Java Network Launch Protocol (JNLP), rich Internet applications (RIAs) can access the client with the user’s permission. Consider the Text Editor applet example to understand how to use JNLP API based services. The Text Editor has a text area and buttons labeled Open, Save, and SaveAs. The Text Editor can be used to open an existing text file, edit it, and save it back to disk. The Text Editor applet is shown next. TheTextEditor andTextEditorApplet classes lay out the user interface and display it as an applet. TheFileHandler class contains the core functionality with respect to using JNLP API based services. Remember, the techniques described in this topic apply to Java Web Start applications as well. To make use of a JNLP service, first retrieve a reference to the service. The initialize method of the FileHandler class retrieves references to JNLP services as shown in the following code snippet: 12345678910111213private static synchronized void initialize() &#123; ... try &#123; &lt;b&gt;fos &#x3D; (FileOpenService) ServiceManager.lookup(&quot;javax.jnlp.FileOpenService&quot;); fss &#x3D; (FileSaveService) ServiceManager.lookup(&quot;javax.jnlp.FileSaveService&quot;);&lt;&#x2F;b&gt; &#125; catch (UnavailableServiceException e) &#123; ... &#125;&#125; After you have a reference to the required services, invoke methods on the service to perform the necessary operations. The open method of the FileHandler class invokes the openFileDialog method of theFileOpenService class to display a file chooser. The open method returns the contents of the selected file. 123456789101112public static String open() &#123; initialize(); try &#123; **fc &#x3D; fos.openFileDialog(null, null);** return readFromFile(fc); &#125; catch (IOException ioe) &#123; ioe.printStackTrace(System.out); return null; &#125;&#125; Similarly, the save and saveAs methods of the FileHandler class invoke corresponding methods of theFileSaveService class to enable the user to select a file name and save the contents of the text area to disk. 123456789101112131415161718public static void saveAs(String txt) &#123; initialize(); try &#123; if (fc &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; If not already saved. &#x2F;&#x2F; Save-as is like save save(txt); &#125; else &#123; &lt;b&gt;fc &#x3D; fss.saveAsFileDialog(null, null, fc);&lt;&#x2F;b&gt; save(txt); &#125; &#125; catch (IOException ioe) &#123; ioe.printStackTrace(System.out); &#125;&#125; At runtime, when the RIA attempts to open or save a file, users see a security dialog asking them if they want to allow the action. The operation will proceed only if users allow the RIA to access their environment. The complete source of theFileHandler class is shown next. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&#x2F;&#x2F; add javaws.jar to the classpath during compilation import javax.jnlp.FileOpenService;import javax.jnlp.FileSaveService;import javax.jnlp.FileContents;import javax.jnlp.ServiceManager;import javax.jnlp.UnavailableServiceException;import java.io.*;public class FileHandler &#123; static private FileOpenService fos &#x3D; null; static private FileSaveService fss &#x3D; null; static private FileContents fc &#x3D; null; &#x2F;&#x2F; retrieves a reference to the JNLP services private static synchronized void initialize() &#123; if (fss !&#x3D; null) &#123; return; &#125; try &#123; fos &#x3D; (FileOpenService) ServiceManager.lookup(&quot;javax.jnlp.FileOpenService&quot;); fss &#x3D; (FileSaveService) ServiceManager.lookup(&quot;javax.jnlp.FileSaveService&quot;); &#125; catch (UnavailableServiceException e) &#123; fos &#x3D; null; fss &#x3D; null; &#125; &#125; &#x2F;&#x2F; displays open file dialog and reads selected file using FileOpenService public static String open() &#123; initialize(); try &#123; fc &#x3D; fos.openFileDialog(null, null); return readFromFile(fc); &#125; catch (IOException ioe) &#123; ioe.printStackTrace(System.out); return null; &#125; &#125; &#x2F;&#x2F; displays saveFileDialog and saves file using FileSaveService public static void save(String txt) &#123; initialize(); try &#123; &#x2F;&#x2F; Show save dialog if no name is already given if (fc &#x3D;&#x3D; null) &#123; fc &#x3D; fss.saveFileDialog(null, null, new ByteArrayInputStream(txt.getBytes()), null); &#x2F;&#x2F; file saved, done return; &#125; &#x2F;&#x2F; use this only when filename is known if (fc !&#x3D; null) &#123; writeToFile(txt, fc); &#125; &#125; catch (IOException ioe) &#123; ioe.printStackTrace(System.out); &#125; &#125; &#x2F;&#x2F; displays saveAsFileDialog and saves file using FileSaveService public static void saveAs(String txt) &#123; initialize(); try &#123; if (fc &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; If not already saved. Save-as is like save save(txt); &#125; else &#123; fc &#x3D; fss.saveAsFileDialog(null, null, fc); save(txt); &#125; &#125; catch (IOException ioe) &#123; ioe.printStackTrace(System.out); &#125; &#125; private static void writeToFile(String txt, FileContents fc) throws IOException &#123; int sizeNeeded &#x3D; txt.length() * 2; if (sizeNeeded &gt; fc.getMaxLength()) &#123; fc.setMaxLength(sizeNeeded); &#125; BufferedWriter os &#x3D; new BufferedWriter(new OutputStreamWriter(fc.getOutputStream(true))); os.write(txt); os.close(); &#125; private static String readFromFile(FileContents fc) throws IOException &#123; if (fc &#x3D;&#x3D; null) &#123; return null; &#125; BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(fc.getInputStream())); StringBuffer sb &#x3D; new StringBuffer((int) fc.getLength()); String line &#x3D; br.readLine(); while (line !&#x3D; null) &#123; sb.append(line); sb.append(&quot;\\n&quot;); line &#x3D; br.readLine(); &#125; br.close(); return sb.toString(); &#125;&#125; Download source code for the Text Editor Applet example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"JNLP API","date":"2020-12-06T04:43:35.966Z","path":"wiki/2021-03-03-JNLP API/","text":"JNLP APIRich Internet applications (RIAs) can use the Java Network Launch Protocol (JNLP) API to perform extensive operations on the user’s environment. When launched by using JNLP, even unsigned RIAs can perform the following operations with the user’s permission: They can use the [`FileOpenService`](https://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/javax/jnlp/FileOpenService.html) and [`FileSaveService`](https://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/javax/jnlp/FileSaveService.html) API to access the user's file system.. They can use the [`ClipboardService`](https://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/javax/jnlp/ClipboardService.html) API to access the shared system-wide clipboard. They can use the [`PrintService`](https://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/javax/jnlp/PrintService.html) API to access printing functions. They can use the [`PersistenceService`](https://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/javax/jnlp/PersistenceService.html) API to access persistence storage. They can use the [`DownloadService`](https://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/javax/jnlp/DownloadService.html) API to control how the RIA is downloaded and cached. They can use the [`DownloadServiceListener`](https://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/javax/jnlp/DownloadServiceListener.html) API to determine progress of the RIA's download. They can use the [`SingleInstanceService`](https://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/javax/jnlp/SingleInstanceService.html) API to decide how to handle arguments when multiple instances of the RIA are launched. They can use the [`ExtendedService`](https://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/javax/jnlp/ExtendedService.html) API to request permission to open certain files that have not been opened before. Check theJNLP API documentation to see the complete list of the functionality available to RIAs that are launched by using JNLP.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"System Properties","date":"2020-12-06T04:43:32.902Z","path":"wiki/2021-03-03-System Properties/","text":"System PropertiesThis topic lists system properties that can be accessed by rich Internet applications (RIAs) that are restricted to the security sandbox and are launched with or without the Java Network Launch Protocol (JNLP). Some system properties cannot be accessed by sandbox RIAs. Secure System Properties Accessible by All RIAsAll RIAs can retrieve the following secure system properties: &lt;code&gt;java.class.version &lt;code&gt;java.vendor &lt;code&gt;java.vendor.url &lt;code&gt;java.version &lt;code&gt;os.name &lt;code&gt;os.arch &lt;code&gt;os.version &lt;code&gt;file.separator &lt;code&gt;path.separator &lt;code&gt;line.separator Secure System Properties Accessible by RIAs Launched by Using JNLPRIAs launched by using JNLP can set and retrieve the following secure properties: awt.useSystemAAFontSettings http.agent http.keepAlive java.awt.syncLWRequests java.awt.Window.locationByPlatform javaws.cfg.jauthenticator javax.swing.defaultlf sun.awt.noerasebackground sun.awt.erasebackgroundonresize sun.java2d.d3d sun.java2d.dpiaware sun.java2d.noddraw sun.java2d.opengl swing.boldMetal swing.metalTheme swing.noxp swing.useSystemFontSettings Forbidden System PropertiesSandbox RIAs cannot access the following system properties: java.class.path java.home user.dir user.home user.name","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Setting Trusted Arguments and Secure Properties","date":"2020-12-06T04:43:29.801Z","path":"wiki/2021-03-03-Setting Trusted Arguments and Secure Properties/","text":"Setting Trusted Arguments and Secure PropertiesYou can set certain Java Virtual Machine arguments and secure properties for your rich Internet application (RIA) in the RIA’s Java Network Launch Protocol (JNLP) file. For applets, you can also set arguments in the java_arguments parameter of the &amp;lt;applet&amp;gt; tag. Although there is a predefined set of secure properties, you can also define new secure properties by prefixing the property name with “jnlp.“ or “javaws.“. Properties can be retrieved in your RIA by using the System.getProperty method. Consider the Properties and Arguments Demo applet. The following Java Virtual Machine arguments and properties are set in the applet’s JNLP file,appletpropsargs.jnlp. -Xmx &#8211; A secure argument set equal to “256M” sun.java2d.noddraw &#8211; A predefined secure property set equal to “true” jnlp.myProperty &#8211; A user-defined secure property set equal to “a user-defined property” 123456789101112131415161718192021222324252627282930&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;jnlp spec&#x3D;&quot;1.0+&quot; codebase&#x3D;&quot;&quot; href&#x3D;&quot;&quot;&gt; &lt;information&gt; &lt;title&gt;Properties and Arguments Demo Applet&lt;&#x2F;title&gt; &lt;vendor&gt;Dynamic Team&lt;&#x2F;vendor&gt; &lt;&#x2F;information&gt; &lt;resources&gt; &lt;!-- Application Resources --&gt; &lt;j2se version&#x3D;&quot;1.6+&quot; href&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;products&#x2F;autodl&#x2F;j2se&quot; &lt;!-- secure java vm argument --&gt; java-vm-args&#x3D;&quot;-Xmx256M&quot;&#x2F;&gt; &lt;jar href&#x3D;&quot;applet_PropertiesAndVMArgs.jar&quot; main&#x3D;&quot;true&quot; &#x2F;&gt; &lt;!-- secure properties --&gt; &lt;property name&#x3D;&quot;sun.java2d.noddraw&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;jnlp.myProperty&quot; value&#x3D;&quot;a user-defined property&quot;&#x2F;&gt; &lt;&#x2F;resources&gt; &lt;applet-desc name&#x3D;&quot;Properties and Arguments Demo Applet&quot; main-class&#x3D;&quot;PropertiesArgsDemoApplet&quot; width&#x3D;&quot;800&quot; height&#x3D;&quot;50&quot;&gt; &lt;&#x2F;applet-desc&gt; &lt;update check&#x3D;&quot;background&quot;&#x2F;&gt;&lt;&#x2F;jnlp&gt; ThePropertiesArgsDemoApplet class uses the System.getProperty method to retrieve the java.version property and other properties that are set in the JNLP file. The PropertiesArgsDemoApplet class also displays the properties. 12345678910111213141516171819202122232425262728293031import javax.swing.JApplet;import javax.swing.SwingUtilities;import javax.swing.JLabel;public class PropertiesArgsDemoApplet extends JApplet &#123; public void init() &#123; final String javaVersion &#x3D; System.getProperty(&quot;java.version&quot;); final String swing2dNoDrawProperty &#x3D; System.getProperty(&quot;sun.java2d.noddraw&quot;); final String jnlpMyProperty &#x3D; System.getProperty(&quot;jnlp.myProperty&quot;); try &#123; SwingUtilities.invokeAndWait(new Runnable() &#123; public void run() &#123; createGUI(javaVersion, swing2dNoDrawProperty, jnlpMyProperty); &#125; &#125;); &#125; catch (Exception e) &#123; System.err.println(&quot;createGUI didn&#39;t successfully complete&quot;); &#125; &#125; private void createGUI(String javaVersion, String swing2dNoDrawProperty, String jnlpMyProperty) &#123; String text &#x3D; &quot;Properties: java.version &#x3D; &quot; + javaVersion + &quot;, sun.java2d.noddraw &#x3D; &quot; + swing2dNoDrawProperty + &quot;, jnlp.myProperty &#x3D; &quot; + jnlpMyProperty; JLabel lbl &#x3D; new JLabel(text); add(lbl); &#125;&#125; The Properties and Arguments Demo applet is shown next. You can also see the applet running inAppletPage.html. Download source code for the Properties and Arguments Demo Applet example to experiment further. SeeSystem Properties for a complete set of system properties that can be accessed by RIAs.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Doing More With Java Rich Internet Applications","date":"2020-12-06T04:43:27.141Z","path":"wiki/2021-03-03-Doing More With Java Rich Internet Applications/","text":"Lesson: Doing More With Java Rich Internet ApplicationsApplets launched by using the Java Network Launch Protocol (JNLP) have capabilities similar to those of Java Web Start applications. This lesson contains topics common to the development and deployment of applets and Java Web Start applications (together known as rich Internet applications). If you are unfamiliar with applets or Java Web Start applications, you can learn more in the following lessons of the Java Tutorials: To learn more about applet development and deployment, visit the [Java Applets](../applet/index.html) lesson. To learn more about the development and deployment of Java Web Start applications, visit the [Java Web Start](../webstart/index.html) lesson.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Questions and Exercises  Java Web Start","date":"2020-12-06T04:43:24.042Z","path":"wiki/2021-03-03-Questions and Exercises  Java Web Start/","text":"Questions and Exercises: Java Web StartQuestions In a link that is to run a Java Web Start application, which file is specified as the `a` tag's `href` attribute? Which MIME type must a Web server recognize in order for it to host Java Web Start applications? In an application's `JNLP` file, which two elements must be specified within the `resources` element? Which interface provides the ability to control how the Java Web Start application's resources are cached? 1. `BasicService` 1. `DownloadService` 1. `PersistenceService` 1. `ExtendedService` True or False: Java Web Start applications run in a secure sandbox by default. True or False: If a Java Web Start application is running in a secure sandbox, JAR files for the application can reside on different servers. For a Java Web Start application to support operations outside of the secure sandbox, what must you do? Exercises Write the XML code you would add to a `JNLP` file in order to request that the application have complete access to the client system. For a Java Web Start application, you have two icons, `one.gif` and `two.gif`, in the `images` directory in a JAR file. Write the application code you would use to access these images. Check your answers.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Common Java Web Start Problems","date":"2020-12-06T04:43:20.894Z","path":"wiki/2021-03-03-Common Java Web Start Problems/","text":"Common Java Web Start ProblemsThis section covers some common problems that you might encounter when developing and deploying Java Web Start applications. After each problem is a list of possible reasons and solutions. Problem: My browser shows the Java Network Launch Protocol (JNLP) file for my application as plain text. Most likely, your web server is not aware of the proper MIME type for JNLP files. See theSetting up the web server section for more information. Furthermore, if you are using a proxy server, ensure that the update versions of the files are returned, by updating the time stamp of the resources on the web server such that the proxies will update their caches. Problem: When I try to launch my JNLP file, I get the following error: 123456789101112MissingFieldException[ The following required field is missing from the launch file: (&lt;application-desc&gt;|&lt;applet-desc&gt;|&lt;installer-desc&gt;|&lt;component-desc&gt;)] at com.sun.javaws.jnl.XMLFormat.parse(Unknown Source) at com.sun.javaws.jnl.LaunchDescFactory.buildDescriptor(Unknown Source) at com.sun.javaws.jnl.LaunchDescFactory.buildDescriptor(Unknown Source) at com.sun.javaws.jnl.LaunchDescFactory.buildDescriptor(Unknown Source) at com.sun.javaws.Main.launchApp(Unknown Source) at com.sun.javaws.Main.continueInSecureThread(Unknown Source) at com.sun.javaws.Main.run(Unknown Source) at java.lang.Thread.run(Unknown Source) Often this error occurs when your XML is malformed. You can stare at the code until you figure it out but it is easier to run an XML syntax checker over the file. (NetBeans IDE and jEdit both provide XML syntax checkers.) However, this error can occur in a other situations and the above was caused by the following line in an otherwise well-formed XML file: 123&lt;description kind&#x3D;&quot;short&quot;&gt;Demonstrates choosing the drop location in the target &lt;code&gt;TransferHandler&lt;&#x2F;code&gt;&lt;&#x2F;description&gt; The error was caused by the illegal embedded code tags.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Java Web Start and Security","date":"2020-12-06T04:43:17.791Z","path":"wiki/2021-03-03-Java Web Start and Security/","text":"Java Web Start and SecurityThis section describes the basics of security for applications deployed through Java Web Start and includes: Applications launched with Java Web Start are, by default, run in a restricted environment, known as a sandbox. In this sandbox, Java Web Start: Protects users against malicious code that could affect local files Protects enterprises against code that could attempt to access or destroy data on networks Sandbox applications that are launched by Java Web Start remain in this sandbox, meaning they cannot access local files or the network. SeeSecurity in Rich Internet Applications for information. Dynamic Downloading of HTTPS CertificatesJava Web Start dynamically imports certificates as browsers typically do. To do this, Java Web Start sets its own https handler, using the java.protocol.handler.pkgs system properties, to initialize defaults for theSSLSocketFactory andHostnameVerifier. It sets the defaults with the methodsHttpsURLConnection.setDefaultSSLSocketFactory andHttpsURLConnection.setDefaultHostnameVerifier. If your application uses these two methods, ensure that they are invoked after the Java Web Start initializes the https handler, otherwise your custom handler will be replaced by the Java Web Start default handler. You can ensure that your own customized SSLSocketFactory and HostnameVerifiter are used by doing one of the following: Install your own https handler, to replace the Java Web Start https handler. In your application, invoke HttpsURLConnection.setDefaultSSLSocketFactory or HttpsURLConnection.setDefaultHostnameVerifier only after the first https URL object is created, which executes the Java Web Start https handler initialization code first.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Running a Java Web Start Application","date":"2020-12-06T04:43:14.570Z","path":"wiki/2021-03-03-Running a Java Web Start Application/","text":"Running a Java Web Start ApplicationUsers can run Java Web Start applications in the following ways: [Running a Java Web Start Application From a Browser](#web) [Running a Java Web Start Application From the Java Cache Viewer](#cache) [Running a Java Web Start Application From the Desktop](#desktop) Running a Java Web Start Application From a BrowserYou can run a Java Web Start application from a browser by clicking a link to the application’s JNLP file. The following text is an example of a link to a JNLP file. 123&lt;a href&#x3D;&quot;&#x2F;some&#x2F;path&#x2F;Notepad.jnlp&quot;&gt;Launch Notepad Application&lt;&#x2F;a&gt; Java Web Start software loads and runs the application based on instructions in the JNLP file. Try it now:Run Notepad Running a Java Web Start Application From the Java Cache ViewerIf you are using at least Java Platform, Standard Edition 6 or later, you can run a Java Web Start application through the Java Cache Viewer. When Java Web Start software first loads an application, information from the application’s JNLP file is stored in the local Java Cache Viewer. To launch the application again, you do not need to return to the web page where you first launched it; you can launch it from the Java Cache Viewer. To open the Java Cache Viewer: Open the Control Panel. Double click on the Java icon. The Java Control Panel opens. Select the General tab. Click View. The Java Cache Viewer opens. The application is listed on the Java Cache Viewer screen. To run the application, select it and click the Run button, , or double click the application. The application starts just as it did from the web page. Running a Java Web Start Application From the DesktopYou can add a desktop shortcut to a Java Web Start application. Select the application in the Java Cache Viewer. Right-click and select Install Shortcuts or click the Install button, . A shortcut is added to the desktop. You can then launch the Java Web Start application just as you would launch any native application.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Setting Up a Web Server","date":"2020-12-06T04:43:11.461Z","path":"wiki/2021-03-03-Setting Up a Web Server/","text":"Setting Up a Web ServerYou might need to configure your web server to handle Java Network Launch Protocol (JNLP) files. If the web server is not set up properly, the Java Web Start application will not launch when you click on the link to the JNLP file. Configure the web server so that files with the .jnlp extension are set to the application/x-java-jnlp-file MIME type. The specific steps to set up the JNLP MIME type will vary depending on the web server. As an example, to configure an Apache web server, you should add the following line to the mime.types file. 123application&#x2F;x-java-jnlp-file JNLP For other web servers, check the documentation for instructions on setting MIME types.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Retrieving Resources","date":"2020-12-06T04:43:06.574Z","path":"wiki/2021-03-03-Retrieving Resources/","text":"Retrieving ResourcesUse the getResource method to read resources from a JAR file. For example, the following code retrieves images from a JAR file. 1234567&#x2F;&#x2F; Get current classloaderClassLoader cl &#x3D; this.getClass().getClassLoader();&#x2F;&#x2F; Create iconsIcon saveIcon &#x3D; new ImageIcon(cl.getResource(&quot;images&#x2F;save.gif&quot;));Icon cutIcon &#x3D; new ImageIcon(cl.getResource(&quot;images&#x2F;cut.gif&quot;)); The example assumes that the following entries exist in the application’s JAR file: images/save.gif images/cut.gif","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Developing a Java Web Start Application","date":"2020-12-06T04:43:02.918Z","path":"wiki/2021-03-03-Developing a Java Web Start Application/","text":"Developing a Java Web Start ApplicationSoftware designed by usingcomponent-based architecture can easily be developed and deployed as a Java Web Start application. Consider the example of a Java Web Start application with a Swing-based graphical user interface (GUI). With component-based design, the GUI can be built with smaller building blocks or components. The following general steps are used to create an application’s GUI: Create a MyTopJPanel class that is a subclass of JPanel. Lay out your application’s GUI components in the constructor of the MyTopJPanel class. Create a class called MyApplication that is a subclass of the JFrame class. In the main method of the MyApplication class, instantiate the MyTopJPanel class and set it as the content pane of the JFrame. The following sections explore these steps in greater detail by using the Dynamic Tree Demo application. If you are not familiar with Swing, seeCreating a GUI with Swing to learn more about using Swing GUI components. Click the following Launch button to launch the Dynamic Tree Demo application. Creating the Top JPanel ClassCreate a class that is a subclass of JPanel. This top JPanel acts as a container for all your other UI components. In the following example, the DynamicTreePanel class is the topmost JPanel. The constructor of the DynamicTreePanel class invokes other methods to create and lay out the UI controls properly. 12345678910111213141516171819202122232425262728293031323334353637383940public class DynamicTreePanel extends JPanel implements ActionListener &#123; private int newNodeSuffix &#x3D; 1; private static String ADD_COMMAND &#x3D; &quot;add&quot;; private static String REMOVE_COMMAND &#x3D; &quot;remove&quot;; private static String CLEAR_COMMAND &#x3D; &quot;clear&quot;; private DynamicTree treePanel; public DynamicTreePanel() &#123; super(new BorderLayout()); &#x2F;&#x2F;Create the components. treePanel &#x3D; new DynamicTree(); populateTree(treePanel); JButton addButton &#x3D; new JButton(&quot;Add&quot;); addButton.setActionCommand(ADD_COMMAND); addButton.addActionListener(this); JButton removeButton &#x3D; new JButton(&quot;Remove&quot;); .... JButton clearButton &#x3D; new JButton(&quot;Clear&quot;); ... &#x2F;&#x2F;Lay everything out. treePanel.setPreferredSize( new Dimension(300, 150)); add(treePanel, BorderLayout.CENTER); JPanel panel &#x3D; new JPanel(new GridLayout(0,3)); panel.add(addButton); panel.add(removeButton); panel.add(clearButton); add(panel, BorderLayout.SOUTH); &#125; &#x2F;&#x2F; ...&#125; Creating the ApplicationFor an application that has a Swing-based GUI, create a class that is a subclass of javax.swing.JFrame. Instantiate your top JPanel class and set it as the content pane of the JFrame in the application’s main method. The main method of the DynamicTreeApplication class invokes the createGUI method in the AWT Event Dispatcher thread. 12345678910111213141516171819202122package webstartComponentArch;import javax.swing.JFrame;public class DynamicTreeApplication extends JFrame &#123; public static void main(String [] args) &#123; DynamicTreeApplication app &#x3D; new DynamicTreeApplication(); app.createGUI(); &#125; private void createGUI() &#123; &#x2F;&#x2F;Create and set up the content pane. DynamicTreePanel newContentPane &#x3D; new DynamicTreePanel(); newContentPane.setOpaque(true); setContentPane(newContentPane); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); pack(); setVisible(true); &#125; &#125; Benefits of Separating Core Functionality From the Final Deployment MechanismAnother way to create an application is to just remove the layer of abstraction (separate top JPanel) and lay out all the controls in the application’s main method itself. The downside to creating the GUI directly in the application’s main method is that it will be more difficult to deploy your functionality as an applet, if you choose to do so later. In the Dynamic Tree Demo example, the core functionality is separated into the DynamicTreePanel class. It is now trivial to drop the DynamicTreePanel class into a JApplet and deploy it as an applet. Hence, to preserve portability and keep deployment options open, follow component-based design as described in this topic. Download source code for the Dynamic Tree Demo example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Java Web Start","date":"2020-12-06T04:43:00.069Z","path":"wiki/2021-03-03-Java Web Start/","text":"Lesson: Java Web StartJava Web Start software provides the power to launch full-featured applications with a single click. Users can download and launch applications, such as a complete spreadsheet program or an Internet chat client, without going through lengthy installation procedures. With Java Web Start software, users can launch a Java application by clicking a link in a web page. The link points to a Java Network Launch Protocol (JNLP) file, which instructs Java Web Start software to download, cache, and run the application. Java Web Start software provides Java developers and users with many deployment advantages: With Java Web Start software, you can place a single Java application on a web server for deployment to a wide variety of platforms, including Windows, Linux, and Solaris. Java Web Start software supports multiple, simultaneous versions of the Java platform. An application can request a specific version of the Java Runtime Environment (JRE) software without conflicting with the needs of other applications. Users can create a desktop shortcut to launch a Java Web Start application outside a browser. Java Web Start software takes advantage of the inherent security of the Java platform. By default, applications have restricted access to local disk and network resources. Applications launched with Java Web Start software are cached locally for improved performance. Updates to a Java Web Start application are automatically downloaded when the application is run standalone from the user’s desktop. Java Web Start software is installed as part of the JRE software. Users do not have to install Java Web Start software separately or perform additional tasks to use Java Web Start applications. Additional ReferencesThis lesson is intended to get you started with Java Web Start technology and does not include all available documentation. For more information about Java Web Start technology, see the following: [Java Web Start Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/javaws/developersguide/contents.html) [Java Web Start FAQ](https://docs.oracle.com/javase/8/docs/technotes/guides/javaws/developersguide/faq.html) [JNLP Specification](http://jcp.org/en/jsr/detail?id=56) [`javax.jnlp` API Documentation](https://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/index.html) [Java Web Start Developers Site](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Questions and Exercises  Applets","date":"2020-12-06T04:42:58.006Z","path":"wiki/2021-03-03-Questions and Exercises  Applets/","text":"Questions and Exercises: AppletsQuestions Which classes can an applet extend? For what do you use the `start()` method? True or false: An applet can make network connections to any host on the internet. How do you get the value of a parameter specified in the JNLP file from within the applet's code? Which class enables applets to interact with JavaScript code in the applet's web page? True or False: Applets can modify the contents of the parent web page. Exercises The `Exercise` applet's parent web page has a JavaScript variable called `memberId`. Write the code to set the value of the `memberId` equal to \"123489\" in the applet's `start` method. Check your answers.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Solving Common Applet Problems","date":"2020-12-06T04:42:54.791Z","path":"wiki/2021-03-03-Solving Common Applet Problems/","text":"Solving Common Applet ProblemsThis section covers some common problems that you might encounter when writing Java applets. After each problem is a list of possible reasons and solutions. Problem: My applet does not display. Check the Java Console log for errors. Check the syntax of the applet’s Java Network Launch Protocol (JNLP) file. Incorrect JNLP files are the most common reason for failures without obvious errors.Check the JavaScript syntax if deploying using the `runApplet` function of the Deployment Toolkit. See [Deploying an Applet](../deploymentInDepth/runAppletFunction.html) for details. Problem: The Java Console log displays java.lang.ClassNotFoundException. Make sure your Java source files compiled correctly. If deploying using the &amp;lt;applet&amp;gt; tag, check that the path to the applet JAR file is specified accurately in the archive attribute. If launching using a JNLP file, check the path in the jar tag in the JNLP file. Make sure the applet’s JAR file, JNLP file, and web page are located in the correct directory and reference each other accurately. Problem: I was able to build the code once, but now the build fails even though there are no compilation errors. Close your browser and run the build again. The browser most likely has a lock on the JAR file, because of which the build process is unable to regenerate the JAR file. Problem: When I try to load a web page that has an applet, my browser redirects me to www.java.com without any warning The applet on the web page is most likely deployed using the Deployment Toolkit script. The applet may require a later version of the Java Runtime Environment software than the version that currently exists on the client. Check the `minimumVersion` parameter of the `runApplet` function in the applet's web page. See [Deploying an Applet](../deploymentInDepth/runAppletFunction.html) for details. Problem: I fixed some bugs and re-built my applet’s source code. When I reload the applet’s web page, my fixes are not showing up. You may be viewing a previously cached version of the applet. Close the browser. Open the Java Control Panel and delete temporary internet files. This will remove your applet from cache. Try viewing your applet again.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"What Applets Can and Cannot Do","date":"2020-12-06T04:42:51.066Z","path":"wiki/2021-03-03-What Applets Can and Cannot Do/","text":"What Applets Can and Cannot DoJava applets are loaded on a client when the user visits a page containing an applet. The security model behind Java applets has been designed with the goal of protecting the user from malicious applets. Applets are either sandbox applets or privileged applets. Sandbox applets are run in a security sandbox that allows only a set of safe operations. Privileged applets can run outside the security sandbox and have extensive capabilities to access the client. Applets that are not signed are restricted to the security sandbox, and run only if the user accepts the applet. Applets that are signed by a certificate from a recognized certificate authority can either run only in the sandbox, or can request permission to run outside the sandbox. In either case, the user must accept the applet’s security certificate, otherwise the applet is blocked from running. It is recommended that you launch your applet using Java Network Launch Protocol (JNLP) to leverage expanded capabilities and improve user experience. SeeDeploying an Applet for step by step instructions on applet deployment. It is recommended that you deploy your applets to a web server, even for testing. To run applets locally, add the applets to the exception site list, which is managed from the Security tab of the Java Control Panel. In this topic we will discuss the security restrictions and capabilities of applets. Sandbox AppletsSandbox applets are restricted to the security sandbox and can perform the following operations: They can make network connections to the host and port they came from. Protocols must match, and if a domain name is used to load the applet, the domain name must be used to connect back to the host, not the IP address. They can easily display HTML documents using the showDocument method of the java.applet.AppletContext class. They can invoke public methods of other applets on the same page. Applets that are loaded from the local file system (from a directory in the user’s CLASSPATH) have none of the restrictions that applets loaded over the network do.They can read secure system properties. See [System Properties](../doingMoreWithRIA/properties.html) for a list of secure system properties. When launched by using JNLP, sandbox applets can also perform the following operations: They can open, read, and save files on the client. They can access the shared system-wide clipboard. They can access printing functions.They can store data on the client, decide how applets should be downloaded and cached, and much more. See [JNLP API](../doingMoreWithRIA/jnlpAPI.html) for more information about developing applets by using the JNLP API. Sandbox applets cannot perform the following operations: They cannot access client resources such as the local filesystem, executable files, system clipboard, and printers. They cannot connect to or retrieve resources from any third party server (any server other than the server it originated from). They cannot load native libraries. They cannot change the SecurityManager. They cannot create a ClassLoader.They cannot read certain system properties. See [System Properties](../doingMoreWithRIA/properties.html) for a list of forbidden system properties. Privileged appletsPrivileged applets do not have the security restrictions that are imposed on sandbox applets and can run outside the security sandbox. SeeSecurity in Rich Internet Applications for information on how to work with applets. Additional InformationFor more information about applet security dialog boxes, seeExploring Security Warning Functionality (article on oracle.com/technetwork)","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Network Client Applet Example","date":"2020-12-06T04:42:47.801Z","path":"wiki/2021-03-03-Network Client Applet Example/","text":"Network Client Applet ExampleTheQuoteClientApplet class allows you to fetch quotations from a server-side application that runs on the same host as this applet. This class also displays the quotation received from the server. TheQuoteServer.java andQuoteServerThread.java classes make up the server-side application that returns quotations. Here’s a text file (one-liners.txt) that contains a number of quotations. Perform the following steps to test QuoteClientApplet. Download and save the following files to your local machine. [`QuoteClientApplet`](examples/QuoteClientApplet.java) [`QuoteServer.java`](examples/QuoteServer.java) [`QuoteServerThread.java`](examples/QuoteServerThread.java) [`one-liners.txt`](examples/one-liners.txt) [`quoteApplet.html`](examples/quoteApplet.html) Include the following HTML code in a web page to deploy `QuoteClientApplet`. &lt;script src= \"https://www.java.com/js/deployJava.js\"&gt;&lt;/script&gt; &lt;script&gt; var attributes = &#123; code:'QuoteClientApplet.class', width:500, height:100&#125; ; var parameters = &#123; codebase_lookup:'true', permissions:'sandbox' &#125;; deployJava.runApplet(attributes, parameters, '1.6'); &lt;/script&gt; Alternatively, you can use thequoteApplet.html page that already contains this HTML code. Compile the QuoteClientApplet.java class. Copy the generated class files to the same directory where you saved your web page. Compile the classes for the server-side application, QuoteServer.java and QuoteServerThread.java. Copy the file one-liners.txt to the directory that has the class files for the server-side application (generated in the previous step).Start the server-side application. java QuoteServer You should see a message with the port number, as shown in the following example. Note the port number. QuoteServer listening on port:3862 Open the web page containing your applet in a browser by entering the URL of the web page. The host name in the URL should be the same as the name of the host on which the server-side application is running. For example, if the server-side application is running on a machine named `JohnDoeMachine`, you should enter a similar URL. The exact port number and path will vary depending on your web server setup. http://JohnDoeMachine:8080/quoteApplet/quoteApplet.html The `QuoteClientApplet` will be displayed on the web page. Enter the port number of your server-side application in the applet’s text field and click OK. A quotation is displayed. Here is a screen capture of the applet in action.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Working With a Server-Side Application","date":"2020-12-06T04:42:44.068Z","path":"wiki/2021-03-03-Working With a Server-Side Application /","text":"Working With a Server-Side ApplicationJava applets, like other Java programs, can use the API defined in the java.net package to communicate across the network. A Java applet can communicate with server applications that run on the same host as the applet. This communication does not require any special setup on the server. When the applet is deployed to a web server, use the Applet getCodeBase method and the java.net.URL getHost method to determine which host the applet came from, as follows: 123String host &#x3D; getCodeBase().getHost(); If the applet is deployed locally, the getCodeBase method returns null. Use of a web server is recommended. After you have the correct host name, you can use all the networking code that is documented in theCustom Networking trail. For an example of implementing an applet that is a network client, seeNetwork Client Applet Example.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Communicating With Other Applets","date":"2020-12-06T04:42:39.897Z","path":"wiki/2021-03-03-Communicating With Other Applets/","text":"Communicating With Other AppletsA Java applet can communicate with other Java applets by using JavaScript functions in the parent web page. JavaScript functions enable communication between applets by receiving messages from one applet and invoking methods of other applets. See the following topics for more information about the interaction between Java code and JavaScript code: [Invoking JavaScript Code From an Applet](../applet/invokingJavaScriptFromApplet.html) [Invoking Applet Methods From JavaScript Code](../applet/invokingAppletMethodsFromJavaScript.html) You should avoid using the following mechanisms to find other applets and share data between applets: Avoid using static variables to share data between applets.Do not use the `getApplet` and `getApplets` methods of the [`AppletContext`](https://docs.oracle.com/javase/8/docs/api/java/applet/AppletContext.html) class to find other applets. These methods only find applets that are running in the same instance of the Java Runtime Environment software. Applets must originate from the same directory on the server in order to communicate with each other. The Sender and Receiver applets are shown next. When a user clicks the button to increment the counter, the Sender applet invokes a JavaScript function to send a request to the Receiver applet. Upon receiving the request, the Receiver applet increments a counter variable and displays the value of the variable. Sender Applet Receiver Applet To enable communication with another applet, obtain a reference to an instance of the netscape.javascript.JSObject class. Use this instance to invoke JavaScript functions. TheSender applet uses an instance of the netscape.javascript.JSObject class to invoke a JavaScript function called sendMsgToIncrementCounter. 12345678try &#123; JSObject window &#x3D; JSObject.getWindow(this); window.eval(&quot;sendMsgToIncrementCounter()&quot;);&#125; catch (JSException jse) &#123; &#x2F;&#x2F; ...&#125; Write the JavaScript function that will receive requests from one applet and invoke methods of another applet on the web page. The sendMsgToIncrementCounter JavaScript function invokes the Receiver applet’s incrementCounter method. 12345678&lt;script&gt; function sendMsgToIncrementCounter() &#123; var myReceiver &#x3D; document.getElementById(&quot;receiver&quot;); myReceiver.incrementCounter(); &#125; &lt;script&gt; Note that the JavaScript code uses the name receiver to obtain a reference to the Receiver applet on the web page. This name should be the same as the value of the id attribute that is specified when you deploy the Receiver applet. TheReceiver applet’s incrementCounter method is shown next. 12345678public void incrementCounter() &#123; ctr++; String text &#x3D; &quot; Current Value Of Counter: &quot; + (new Integer(ctr)).toString(); ctrLbl.setText(text);&#125; Deploy the applets on the web page as shown in the following code snippet. You can view the Sender and Receiver applets and associated JavaScript code in&lt;code&gt;AppletPage.html. 1234567891011121314151617181920&lt;!-- Sender Applet --&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; var attributes &#x3D; &#123; code:&#39;Sender.class&#39;, archive:&#39;examples&#x2F;dist&#x2F;applet_SenderReceiver&#x2F;applet_SenderReceiver.jar&#39;, width:300, height:50&#125; ; var parameters &#x3D; &#123; permissions:&#39;sandbox&#39; &#125;; deployJava.runApplet(attributes, parameters, &#39;1.6&#39;);&lt;&#x2F;script&gt;&lt;!-- Receiver Applet --&gt;&lt;script&gt; var attributes &#x3D; &#123; **id:&#39;receiver&#39;**, code:&#39;Receiver.class&#39;, archive:&#39;examples&#x2F;dist&#x2F;applet_SenderReceiver&#x2F;applet_SenderReceiver.jar&#39;, width:300, height:50&#125; ; var parameters &#x3D; &#123; permissions:&#39;sandbox&#39; &#125;; deployJava.runApplet(attributes, parameters, &#39;1.6&#39;);&lt;&#x2F;script&gt; Download source code for the Sender Receiver Applets example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Developing Draggable Applets","date":"2020-12-06T04:42:35.736Z","path":"wiki/2021-03-03-Developing Draggable Applets/","text":"Developing Draggable AppletsA Java applet that is deployed by specifying the draggable parameter can be dragged outside of the browser and dynamically transformed into a Java Web Start application. The Java applet can be dragged by pressing the Alt key and the left mouse button and dragging the mouse. When the drag operation begins, the applet is removed from its parent container (Applet or JApplet) and placed in a new undecorated top-level window (Frame or JFrame). A small floating Close button is displayed next to the dragged applet. When the floating Close button is clicked, the applet is placed back in the browser. Java applets that can be dragged out of the browser shall henceforth be referred to as draggable applets. You can customize the behavior of a draggable applet in the following ways: You can change the keystroke and mouse button sequence that is used to drag the applet outside of the browser. You can add a desktop shortcut that can be used to launch your application outside of the browser. You can define how the applet should be closed after it has been dragged outside of the browser. The following sections describe how to implement and customize a draggable applet. TheMenuChooserApplet class is used to demonstrate the development and deployment of draggable applets. Open&lt;code&gt;AppletPage.html in a browser to view the Menu Chooser applet on a new page. Enabling the Capability to Drag an AppletYou can enable the capability to drag an applet by setting the draggable parameter to true when deploying the applet, as shown in the following code snippet: 12345678&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; var attributes &#x3D; &#123; code:&#39;MenuChooserApplet&#39;, width:900, height:300 &#125;; var parameters &#x3D; &#123; jnlp_href: &#39;draggableapplet.jnlp&#39;, **draggable: &#39;true&#39;** &#125;; deployJava.runApplet(attributes, parameters, &#39;1.6&#39;);&lt;&#x2F;script&gt; Changing the Keystroke and Mouse Button Sequence That Is Used to Drag an AppletYou can change the keystroke and mouse button sequence that is used to drag an applet by implementing the isAppletDragStart method. In the following code snippet, the applet can be dragged by pressing the left mouse button and dragging the mouse: 123456789public boolean isAppletDragStart(MouseEvent e) &#123; if(e.getID() &#x3D;&#x3D; MouseEvent.MOUSE_DRAGGED) &#123; return true; &#125; else &#123; return false; &#125; &#125; Enabling the Addition of a Desktop Shortcut When the Applet Is Disconnected From the BrowserIf the user closes the browser window or navigates away from the page after dragging an applet outside of the page, the applet is said to be disconnected from the browser. You can create a desktop shortcut for the applet when the applet is disconnected from the browser. The desktop shortcut can be used to launch the application outside of the browser. To enable the creation of a desktop shortcut, add the offline-allowed and shortcut tags to the applet’s Java Network Launch Protocol (JNLP) file. 123456789&lt;information&gt; &lt;!-- ... --&gt; &lt;offline-allowed &#x2F;&gt; &lt;shortcut online&#x3D;&quot;false&quot;&gt; &lt;desktop &#x2F;&gt; &lt;&#x2F;shortcut&gt;&lt;&#x2F;information&gt; Defining How the Applet Should Be ClosedYou can define how your applet can be closed. For example, your Swing applet could have a JButton to close the applet instead of relying on the default floating Close button. The Java Plug-in software gives the applet an instance of the ActionListener class. This instance of the ActionListener class, also referred to as the close listener, can be used to modify the default close behavior of the applet. To define how the applet should be closed, implement the setAppletCloseListener and appletRestored methods in your applet. In the following code snippet, theMenuChooserApplet class receives the close listener and passes it on to the instance of theMenuItemChooser class: 12345678910111213MenuItemChooser display &#x3D; null;&#x2F;&#x2F; ...display &#x3D; new MenuItemChooser();&#x2F;&#x2F; ...public void setAppletCloseListener(ActionListener cl) &#123; display.setCloseListener(cl);&#125;public void appletRestored() &#123; display.setCloseListener(null);&#125; The MenuItemChooser class is responsible for controlling the applet’s user interface. The MenuItemChooser class defines a JButton labeled “Close.” The following code is executed when the user clicks this Close button: 123456789private void close() &#123; &#x2F;&#x2F; invoke actionPerformed of closeListener received &#x2F;&#x2F; from the Java Plug-in software. if (closeListener !&#x3D; null) &#123; closeListener.actionPerformed(null); &#125;&#125; Requesting and Customizing Applet DecorationBeginning in the Java SE 7 release, when deploying an applet, you can specify that the window of dragged applet should be decorated with the default or customized window title. To enable window decoration of a dragged applet, specify the java_decorated_frame parameter with a value of &quot;true&quot;. To enable a customized window title, specify the java_applet_title parameter also. The value of this parameter should be the text of the window title. 12345678910111213&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; var attributes &#x3D; &#123; code:&#39;SomeDraggableApplet&#39;, width:100, height:100 &#125;; var parameters &#x3D; &#123; jnlp_href: &#39;somedraggableapplet.jnlp&#39;, &lt;b&gt;java_decorated_frame: &#39;true&#39;, java_applet_title: &#39;A Custom Title&#39;&lt;&#x2F;b&gt; &#125;; deployJava.runApplet(attributes, parameters, &#39;1.7&#39;);&lt;&#x2F;script&gt; The java_decorated_frame and java_applet_title parameters can also be specified in the applet’s JNLP file as shown in the following code snippet: 123456&lt;applet-desc main-class&#x3D;&quot;SayHello&quot; name&#x3D;&quot;main test&quot; height&#x3D;&quot;150&quot; width&#x3D;&quot;300&quot;&gt; &lt;param name&#x3D;&quot;java_decorated_frame&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;param name&#x3D;&quot;java_applet_title&quot; value&#x3D;&quot;&quot; &#x2F;&gt;&lt;&#x2F;applet-desc&gt; Download source code for the Draggable Applet example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Writing Diagnostics to Standard Output and Error Streams","date":"2020-12-06T04:42:31.072Z","path":"wiki/2021-03-03-Writing Diagnostics to Standard Output and Error Streams/","text":"Writing Diagnostics to Standard Output and Error StreamsA Java applet can write messages to the standard output and standard error streams. Writing diagnostics to standard output can be an invaluable tool when you are debugging a Java applet. The following code snippet writes messages to the standard output stream and the standard error stream. 12345678910111213141516**&#x2F;&#x2F; Where instance variables are declared:**boolean DEBUG &#x3D; true;&#x2F;&#x2F; ...**&#x2F;&#x2F; Later, when we want to print some status:**if (DEBUG) &#123; try &#123; &#x2F;&#x2F; ... &#x2F;&#x2F;some code that throws an exception System.out. println(&quot;Called someMethod(&quot; + x + &quot;,&quot; + y + &quot;)&quot;); &#125; catch (Exception e) &#123; e.printStackTrace() &#125;&#125; Check the Java Console log for messages written to the standard output stream or standard error stream. To store messages in a log file, enable logging in the Java Control Panel. Messages will be written to a log file in the user’s home directory (for example, on Windows, the log file might be in C:\\Documents and Settings\\someuser\\Application Data\\Sun\\Java\\Deployment\\log).","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Manipulating DOM of Applet's Web Page","date":"2020-12-06T04:42:27.972Z","path":"wiki/2021-03-03-Manipulating DOM of Applet's Web Page/","text":"Manipulating DOM of Applet’s Web PageEvery web page is composed of a series of nested objects. These objects make up the Document Object Model (DOM). A Java applet can traverse and modify objects of its parent web page using theCommon DOM API. Consider an example of a Java applet that dumps the contents of its parent web page. In order to traverse and manipulate the DOM tree, you must first obtain a reference to the Document object for the web page. You can do so by using the getDocument method in the com.sun.java.browser.plugin2.DOM class. Here is a code snippet that retrieves a reference to a Document object in the&lt;code&gt;DOMDump applet’s start method. See inline comments in the code. 12345678910111213141516171819202122232425public void start() &#123; try &#123; &#x2F;&#x2F; use reflection to get document Class c &#x3D; Class.forName(&quot;com.sun.java.browser.plugin2.DOM&quot;); Method m &#x3D; c.getMethod(&quot;getDocument&quot;, new Class[] &#123; java.applet.Applet.class &#125;); &#x2F;&#x2F; cast object returned as HTMLDocument; &#x2F;&#x2F; then traverse or modify DOM HTMLDocument doc &#x3D; (HTMLDocument) m.invoke(null, new Object[] &#123; this &#125;); HTMLBodyElement body &#x3D; (HTMLBodyElement) doc.getBody(); dump(body, INDENT); &#125; catch (Exception e) &#123; System.out.println(&quot;New Java Plug-In not available&quot;); &#x2F;&#x2F; In this case, you could fallback to the old &#x2F;&#x2F; bootstrapping mechanism available in the &#x2F;&#x2F; com.sun.java.browser.plugin.dom package &#125;&#125; Now that you have a reference to the Document object, you can traverse and modify the DOM tree using the Common DOM API. The DOMDump applet traverses the DOM tree and writes its contents to the Java Console log. 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void dump(Node root, String prefix) &#123; if (root instanceof Element) &#123; System.out.println(prefix + ((Element) root).getTagName() + &quot; &#x2F; &quot; + root.getClass().getName()); &#125; else if (root instanceof CharacterData) &#123; String data &#x3D; ((CharacterData) root).getData().trim(); if (!data.equals(&quot;&quot;)) &#123; System.out.println(prefix + &quot;CharacterData: &quot; + data); &#125; &#125; else &#123; System.out.println(prefix + root.getClass().getName()); &#125; NamedNodeMap attrs &#x3D; root.getAttributes(); if (attrs !&#x3D; null) &#123; int len &#x3D; attrs.getLength(); for (int i &#x3D; 0; i &lt; len; i++) &#123; Node attr &#x3D; attrs.item(i); System.out.print(prefix + HALF_INDENT + &quot;attribute &quot; + i + &quot;: &quot; + attr.getNodeName()); if (attr instanceof Attr) &#123; System.out.print(&quot; &#x3D; &quot; + ((Attr) attr).getValue()); &#125; System.out.println(); &#125; &#125; if (root.hasChildNodes()) &#123; NodeList children &#x3D; root.getChildNodes(); if (children !&#x3D; null) &#123; int len &#x3D; children.getLength(); for (int i &#x3D; 0; i &lt; len; i++) &#123; dump(children.item(i), prefix + INDENT); &#125; &#125; &#125;&#125; Open&lt;code&gt;AppletPage.html in a browser to view the DOMDump applet running. Check the Java Console log for a dump of the DOM tree of the web page. Download the source code for the DOM Dump example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Handling Initialization Status With Event Handlers","date":"2020-12-06T04:42:24.879Z","path":"wiki/2021-03-03-Handling Initialization Status With Event Handlers /","text":"Handling Initialization Status With Event HandlersAn applet cannot handle requests from JavaScript code in the web page until the applet has been initialized. A call to an applet method or access to an applet variable from JavaScript code will be blocked until the applet’s init() method is complete or the applet first invokes JavaScript code from the web page in which it is deployed. As the JavaScript implementation is single-threaded in many browsers, the web page may appear to be frozen during applet startup. Beginning in the JDK 7 release, you can check the status variable of the applet while it is loading to determine if the applet is ready to handle requests from JavaScript code. You can also register event handlers that will automatically be invoked during various stages of applet initialization. To leverage this functionality, the applet should be deployed with the java_status_events parameter set to &quot;true&quot;. In the Status and Event Handler example, JavaScript code registers an onLoad handler with the applet. The onLoad handler is automatically invoked by the Java Plug-in software when the applet has been initialized. The onLoad handler invokes other methods of the applet to draw the graph on the web page. The init method of the&lt;code&gt;DrawingApplet class sleeps for two seconds to simulate a long applet initialization period. The following steps describe how to register event handlers and check an applet’s status. SeeApplet Status and Event Handlers for a complete list of applet status values and applet events for which event handlers can be registered. Create a JavaScript function to register event handlers. The following code snippet shows the `registerAppletStateHandler` function that registers an `onLoad` event handler if the applet has not already loaded. &lt;script&gt; &lt;!-- ... --&gt; var READY = 2; function **registerAppletStateHandler()** &#123; // register onLoad handler if applet has // not loaded yet if (drawApplet.status &lt; READY) &#123; drawApplet.onLoad = onLoadHandler; &#125; else if (drawApplet.status &gt;= READY) &#123; // applet has already loaded or there // was an error document.getElementById(\"mydiv\").innerHTML = \"Applet event handler not registered because applet status is: \" + drawApplet.status; &#125; &#125; function **onLoadHandler()** &#123; // event handler for ready state document.getElementById(\"mydiv\").innerHTML = \"Applet has loaded\"; draw(); &#125; &lt;!-- ... --&gt; &lt;/script&gt; Invoke the previously created `registerAppletStateHandler` function in the `body` tag's onload method. This ensures that the HTML tag for the applet has been created in the Document Object Model (DOM) tree of the web page before the applet's event handlers are registered. &lt;body onload=\"registerAppletStateHandler()\"&gt; Deploy the applet with the `java_status_events` parameter set to `\"true\"`. &lt;script src= \"https://www.java.com/js/deployJava.js\"&gt;&lt;/script&gt; &lt;script&gt; // set java_status_events parameter to true var attributes = &#123; id:'drawApplet', code:'DrawingApplet.class', archive: 'applet_StatusAndCallback.jar', width:600, height:400&#125; ; var parameters = &#123;**java_status_events: 'true'**, permissions:'sandbox' &#125; ; deployJava.runApplet(attributes, parameters, '1.7'); &lt;/script&gt; Open&lt;code&gt;AppletPage.html in a browser to view the behavior of applet event handlers. In the&lt;code&gt;AppletPageUpdatedDuringLoading.html page, the status variable of the applet is checked to determine if the applet has been loaded. Based on the status, the web page is continuously updated while the applet is being loaded. Download source code for the Status and Event Handler example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Invoking Applet Methods From JavaScript Code","date":"2020-12-06T04:42:21.686Z","path":"wiki/2021-03-03-Invoking Applet Methods From JavaScript Code/","text":"Invoking Applet Methods From JavaScript CodeJavaScript code on a web page can interact with Java applets embedded on the page. JavaScript code can perform operations such as the following: Invoke methods on Java objects Get and set fields in Java objects Get and set Java array elements TheLiveConnect Specification describes details about how JavaScript code communicates with Java code. Security warnings are shown when JavaScript code makes calls to a Java applet. To suppress these warnings, add the Caller-Allowable-Codebase attribute to the JAR file manifest. Specify the location of the JavaScript code that is allowed to make calls to the applet. SeeJAR File Manifest Attributes for Security for information about the Caller-Allowable-Codebase attribute. This topic explores JavaScript code to Java applet communication using the Math applet example. The MathApplet class and supporting Calculator class provide a set of public methods and variables. The JavaScript code on the web page invokes and evaluates these public members to pass data and retrieve calculated results. Math Applet and Related ClassesHere is the source code for the&lt;code&gt;MathApplet class. The getCalculator method returns a reference to the Calculator helper class. 1234567891011121314151617181920212223242526 package jstojava;import java.applet.Applet;public class MathApplet extends Applet&#123; public String userName &#x3D; null; public String getGreeting() &#123; return &quot;Hello &quot; + userName; &#125; public Calculator getCalculator() &#123; return new Calculator(); &#125; public DateHelper getDateHelper() &#123; return new DateHelper(); &#125; public void printOut(String text) &#123; System.out.println(text); &#125;&#125; The methods in the&lt;code&gt;Calculator class let the user set two values, add numbers, and retrieve the numbers in a range. 1234567891011121314151617181920212223242526272829package jstojava;public class Calculator &#123; private int a &#x3D; 0; private int b &#x3D; 0; &#x2F;&#x2F; assume b &gt; a public void setNums(int numA, int numB) &#123; a &#x3D; numA; b &#x3D; numB; &#125; public int add() &#123; return a + b; &#125; public int [] getNumInRange() &#123; int x &#x3D; a; int len &#x3D; (b - a) + 1; int [] range &#x3D; new int [len]; for (int i &#x3D; 0; i &lt; len; i++) &#123; range[i]&#x3D; x++; System.out.println(&quot;i: &quot; + i + &quot; ; range[i]: &quot; + range[i]); &#125; return range; &#125;&#125; The getDate method of the&lt;code&gt;DateHelper class returns the current date. 12345678910111213141516package jstojava;import java.util.Date;import java.text.SimpleDateFormat;public class DateHelper &#123; public static String label &#x3D; null; public String getDate() &#123; return label + &quot; &quot; + new SimpleDateFormat().format(new Date()); &#125;&#125; Deploying the AppletDeploy the applet in a web page,&lt;code&gt;AppletPage.html When deploying the applet, make sure that you specify an id for the applet. The applet id is used later to obtain a reference to the applet object. 123456789101112&lt;script src&#x3D; &quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; &lt;!-- applet id can be used to get a reference to the applet object --&gt; var attributes &#x3D; &#123; **id:&#39;mathApplet&#39;**, code:&#39;jstojava.MathApplet&#39;, width:1, height:1&#125; ; var parameters &#x3D; &#123; jnlp_href: &#39;math_applet.jnlp&#39;&#125; ; deployJava.runApplet(attributes, parameters, &#39;1.6&#39;);&lt;&#x2F;script&gt; Next, add some JavaScript code to the&lt;code&gt;AppletPage.html web page. The JavaScript code can use the applet id as a reference to the applet object and invoke the applet’s methods. In the example shown next, the JavaScript code sets the applet’s public member variables, invokes public methods, and retrieves a reference to another object referenced by the applet (Calculator). The JavaScript code is able to handle primitive, array, and object return types. 123456789101112131415161718192021222324252627282930313233&lt;script language&#x3D;&quot;javascript&quot;&gt; function enterNums()&#123; var numA &#x3D; prompt(&#39;Enter number \\&#39;a\\&#39;?&#39;,&#39;0&#39;); var numB &#x3D; prompt( &#39;Enter number \\&#39;b\\&#39; (should be greater than number \\&#39;a\\&#39; ?&#39;,&#39;1&#39;); &#x2F;&#x2F; set applet&#39;s public variable mathApplet.userName &#x3D; &quot;John Doe&quot;; &#x2F;&#x2F; invoke public applet method var greeting &#x3D; mathApplet.getGreeting(); &#x2F;&#x2F; get another class referenced by applet and &#x2F;&#x2F; invoke its methods var calculator &#x3D; mathApplet.getCalculator(); calculator.setNums(numA, numB); &#x2F;&#x2F; primitive datatype returned by applet var sum &#x3D; calculator.add(); &#x2F;&#x2F; array returned by applet var numRange &#x3D; calculator.getNumInRange(); &#x2F;&#x2F; check Java console log for this message mathApplet.printOut(&quot;Testing printing to System.out&quot;); &#x2F;&#x2F; get another class, set static field and invoke its methods var dateHelper &#x3D; mathApplet.getDateHelper(); dateHelper.label &#x3D; &quot;Today\\&#39;s date is: &quot;; var dateStr &#x3D; dateHelper.getDate(); &lt;!-- ... --&gt;&lt;&#x2F;script&gt; The Math applet displays the following results on the web page when the number a = 0 and b = 5: 12345678910111213Results of JavaScript to Java CommunicationHello John Doea &#x3D; 0 ; b &#x3D; 5Sum: 5Numbers in range array: [ 0, 1, 2, 3, 4, 5 ]Today&#39;s date is: 5&#x2F;28&#x2F;13 4:12 PM &#x2F;&#x2F;*shows current date* Open&lt;code&gt;AppletPage.html in a browser to view the Math applet. Checksecurity restrictions placed on applets invoked by JavaScript code. Download source code for the Invoking Applet Methods From JavaScript Code example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Invoking JavaScript Code From an Applet","date":"2020-12-06T04:42:19.035Z","path":"wiki/2021-03-03-Invoking JavaScript Code From an Applet/","text":"Invoking JavaScript Code From an AppletJava applets can invoke JavaScript functions present in the same web page as the applet. TheLiveConnect Specification describes details about how JavaScript code communicates with Java code. The netscape.javascript.JSObject class enables Java applets to retrieve a reference to JavaScript objects and interact with the web page. The Data Summary applet described next invokes JavaScript code to retrieve information from the web page and writes a data summary back to the web page. Assume you have a web page with a few JavaScript functions. The example&lt;code&gt;AppletPage.html has JavaScript functions to retrieve age, address, and phone numbers. There is also a variable called userName which has no value at the outset. 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;head&gt;&lt;title&gt;Data Summary Applet Page - Java to JavaScript LiveConnect&lt;&#x2F;title&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;windows-1252&quot;&#x2F;&gt;&lt;script language&#x3D;&quot;javascript&quot;&gt; var userName &#x3D; &quot;&quot;; &#x2F;&#x2F; returns number function getAge() &#123; return 25; &#125; &#x2F;&#x2F; returns an object function address() &#123; this.street &#x3D; &quot;1 Example Lane&quot;; this.city &#x3D; &quot;Santa Clara&quot;; this.state &#x3D; &quot;CA&quot;; &#125; &#x2F;&#x2F; returns an array function getPhoneNums() &#123; return [&quot;408-555-0100&quot;, &quot;408-555-0102&quot;]; &#125; function writeSummary(summary) &#123; summaryElem &#x3D; document.getElementById(&quot;summary&quot;); summaryElem.innerHTML &#x3D; summary; &#125; &lt;&#x2F;script&gt; &lt;!-- ... --&gt; &lt;&#x2F;head&gt;&lt;body&gt; &lt;script src &#x3D; &quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &lt;!-- ... --&gt; deployJava.runApplet(attributes, parameters, &#39;1.6&#39;); &lt;&#x2F;script&gt; &lt;!-- ... --&gt; &lt;p id&#x3D;&quot;summary&quot;&#x2F;&gt; &#x2F;&#x2F; this HTML element contains &#x2F;&#x2F; the summary &lt;!-- ... --&gt;&lt;&#x2F;body&gt; Next, consider an applet class called DataSummaryApplet. The DataSummaryApplet class performs the following operations. Invokes the JSObject‘s setMember method to set the userName variable to “John Doe”. Retrieves the age, address, and phone numbers and builds a string containing a summary of this data. Invokes the writeSummary JavaScript function to write the summary back to the web page. This applet first needs to retrieve a reference to JSObject as follows: 12345...JSObject window &#x3D; JSObject.getWindow(this);... Put the preceding statement in a try …catch.. block to handle netscape.javascript.JSException. Now that the applet has a reference to JSObject, it can invoke the relevant JavaScript functions by using the eval and call methods of JSObject. 1234567891011121314151617181920212223242526272829303132333435363738394041package javatojs;import java.applet.Applet;import netscape.javascript.*; &#x2F;&#x2F; add plugin.jar to classpath during compilationpublic class DataSummaryApplet extends Applet &#123; public void start() &#123; try &#123; JSObject window &#x3D; JSObject.getWindow(this); String userName &#x3D; &quot;John Doe&quot;; &#x2F;&#x2F; set JavaScript variable window.setMember(&quot;userName&quot;, userName); &#x2F;&#x2F; invoke JavaScript function Number age &#x3D; (Number) window.eval(&quot;getAge()&quot;); &#x2F;&#x2F; get a JavaScript object and retrieve its contents JSObject address &#x3D; (JSObject) window.eval(&quot;new address();&quot;); String addressStr &#x3D; (String) address.getMember(&quot;street&quot;) + &quot;, &quot; + (String) address.getMember(&quot;city&quot;) + &quot;, &quot; + (String) address.getMember(&quot;state&quot;); &#x2F;&#x2F; get an array from JavaScript and retrieve its contents JSObject phoneNums &#x3D; (JSObject) window.eval(&quot;getPhoneNums()&quot;); String phoneNumStr &#x3D; (String) phoneNums.getSlot(0) + &quot;, &quot; + (String) phoneNums.getSlot(1); &#x2F;&#x2F; dynamically change HTML in page; write data summary String summary &#x3D; userName + &quot; : &quot; + age + &quot; : &quot; + addressStr + &quot; : &quot; + phoneNumStr; window.call(&quot;writeSummary&quot;, new Object[] &#123;summary&#125;) ; &#125; catch (JSException jse) &#123; jse.printStackTrace(); &#125; &#125;&#125; To compile Java code that has a reference to classes in the netscape.javascript package, include &amp;lt;your JDK path&amp;gt;/jre/lib/plugin.jar in your classpath. At runtime, the Java Plug-in software automatically makes these classes available to applets. The Data Summary applet displays the following result on the web page: 12345Result of applet&#39;s Java calls to JavaScript on this page John Doe : 25 : 1 Example Lane, Santa Clara, CA : 408-555-0100, 408-555-0102 Open&lt;code&gt;AppletPage.html in a browser to view the Data Summary applet . Download source code for the Invoking JavaScript Code From Applet example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Displaying Documents in the Browser","date":"2020-12-06T04:42:15.834Z","path":"wiki/2021-03-03-Displaying Documents in the Browser/","text":"Displaying Documents in the BrowserA Java applet can load a web page in a browser window using the showDocument methods in thejava.applet.AppletContext class. Here are the two forms of showDocument: 1234public void showDocument(java.net.URL **url**)public void showDocument(java.net.URL **url**, String **targetWindow**) The one-argument form of showDocument simply instructs the browser to display the document at the specified URL, without specifying the window in which to display the document. The two-argument form of showDocument lets you specify the window or HTML frame in which to display the document. The second argument can have one of the folllowing values: &quot;_blank&quot; &#8211; Display the document in a new, nameless window. &quot;**windowName**&quot; &#8211; Displays the document in a window named windowName. This window is created if necessary. &quot;_self&quot; &#8211; Display the document in the window and frame that contain the applet. &quot;_parent&quot; &#8211; Display the document in parent frame of the applet’s frame. If the applet frame has no parent frame, this acts the same as &quot;_self&quot;. &quot;_top&quot; &#8211; Display the document in the top-level frame. If the applet’s frame is the top-level frame, this acts the same as &quot;_self&quot;. The following applet enables you try every argument of both forms of showDocument. The applet opens a window that lets you type in a URL and choose an option for the targetWindow argument. When you press Return or click the Show document button, the applet calls showDocument. Following is the applet code that calls showDocument. Here is the whole program,ShowDocument. 1234567891011121314151617181920212223242526272829303132333435 **...&#x2F;&#x2F;In an Applet subclass:** urlWindow &#x3D; new URLWindow(getAppletContext()); . . .class URLWindow extends Frame &#123; ... public URLWindow(AppletContext appletContext) &#123; ... this.appletContext &#x3D; appletContext; ... &#125; ... public boolean action(Event event, Object o) &#123; ... String urlString &#x3D; **&#x2F;* user-entered string *&#x2F;**; URL url &#x3D; null; try &#123; url &#x3D; new URL(urlString); &#125; catch (MalformedURLException e) &#123; **...&#x2F;&#x2F;Inform the user and return...** &#125; if (url !&#x3D; null) &#123; if (&lt;em&gt;&#x2F;* user doesn&#39;t want to specify the window *&#x2F;&lt;&#x2F;em&gt;) &#123; appletContext.showDocument(url); &#125; else &#123; appletContext.showDocument(url, **&#x2F;* user-specified window *&#x2F;**); &#125; &#125; ... Download source code for the Show Document example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Displaying Short Status Strings","date":"2020-12-06T04:42:12.741Z","path":"wiki/2021-03-03-Displaying Short Status Strings/","text":"Displaying Short Status StringsAll browsers allow Java applets to display a short status string. All Java applets on the page, as well as the browser itself, share the same status line. Never put crucial information in the status line. If many users might need the information, display that information within the applet area. If only a few, sophisticated users might need the information, consider sending the information to standard output (seeWriting Diagnostics to Standard Output and Error Streams). The status line is not usually very prominent, and it can be overwritten by other applets or by the browser. For these reasons, it is best used for incidental, transitory information. For example, an applet that loads several image files might display the name of the image file it is currently loading. Applets display status lines with theshowStatus method, inherited in the JApplet class from the Applet class. Here is an example of its use: 123showStatus(&quot;MyApplet: Loading image file &quot; + file);","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Defining and Using Applet Parameters","date":"2020-12-06T04:42:09.653Z","path":"wiki/2021-03-03-Defining and Using Applet Parameters/","text":"Defining and Using Applet ParametersParameters are to Java applets what command-line arguments are to applications. They enable the user to customize the applet’s operation. By defining parameters, you can increase your applet’s flexibility, making your applet work in multiple situations without recoding and recompiling it. Specifying an Applet’s Input ParametersYou can specify an applet’s input parameters in the applet’s Java Network Launch Protocol (JNLP) file or in the &amp;lt;parameter&amp;gt; element of the &amp;lt;applet&amp;gt; tag. It is usually better to specify the parameters in the applet’s JNLP file so that the parameters can be supplied consistently even if the applet is deployed on multiple web pages. If the applet’s parameters will vary by web page, then you should specify the parameters in the &amp;lt;parameter&amp;gt; element of the &amp;lt;applet&amp;gt; tag. If you are unfamiliar with JNLP, see theJava Network Launch Protocol topic for more information. Consider an applet that takes three parameters. The paramStr and paramInt parameters are specified in the applet’s JNLP file,&lt;code&gt;applettakesparams.jnlp. 12345678910111213141516&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;jnlp spec&#x3D;&quot;1.0+&quot; codebase&#x3D;&quot;&quot; href&#x3D;&quot;&quot;&gt; &lt;!-- ... --&gt; &lt;applet-desc name&#x3D;&quot;Applet Takes Params&quot; main-class&#x3D;&quot;AppletTakesParams&quot; width&#x3D;&quot;800&quot; height&#x3D;&quot;50&quot;&gt; &lt;param name&#x3D;&quot;paramStr&quot; value&#x3D;&quot;someString&quot;&#x2F;&gt; &lt;param name&#x3D;&quot;paramInt&quot; value&#x3D;&quot;22&quot;&#x2F;&gt; &lt;&#x2F;applet-desc&gt; &lt;!-- ... --&gt;&lt;&#x2F;jnlp&gt; The paramOutsideJNLPFile parameter is specified in the parameters variable passed to the Deployment Toolkit script’s runApplet function in&lt;code&gt;AppletPage.html. 123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;title&gt;Applet Takes Params&lt;&#x2F;title&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;windows-1252&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;Applet Takes Params&lt;&#x2F;h1&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.java.com&#x2F;js&#x2F;deployJava.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; var attributes &#x3D; &#123; code:&#39;AppletTakesParams.class&#39;, archive:&#39;applet_AppletWithParameters.jar&#39;, width:800, height:50 &#125;; var parameters &#x3D; &#123;jnlp_href: &#39;applettakesparams.jnlp&#39;, **paramOutsideJNLPFile: &#39;fooOutsideJNLP&#39;** &#125;; deployJava.runApplet(attributes, parameters, &#39;1.7&#39;); &lt;&#x2F;script&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; SeeDeploying an Applet for more information about the runApplet function. Retrieving the Applet’s Input ParametersYou can retrieve the applet’s input parameters by using thegetParameter method of the Applet class. The&lt;code&gt;AppletTakesParams.java applet retrieves and displays all its input parameters (paramStr, paramInt, and paramOutsideJNLPFile). 12345678910111213141516171819202122232425262728293031import javax.swing.JApplet;import javax.swing.SwingUtilities;import javax.swing.JLabel;public class AppletTakesParams extends JApplet &#123; public void init() &#123; final String inputStr &#x3D; getParameter(&quot;paramStr&quot;); final int inputInt &#x3D; Integer.parseInt(getParameter(&quot;paramInt&quot;)); final String inputOutsideJNLPFile &#x3D; getParameter(&quot;paramOutsideJNLPFile&quot;); try &#123; SwingUtilities.invokeAndWait(new Runnable() &#123; public void run() &#123; createGUI(inputStr, inputInt, inputOutsideJNLPFile); &#125; &#125;); &#125; catch (Exception e) &#123; System.err.println(&quot;createGUI didn&#39;t successfully complete&quot;); &#125; &#125; private void createGUI(String inputStr, int inputInt, String inputOutsideJNLPFile) &#123; String text &#x3D; &quot;Applet&#39;s parameters are -- inputStr: &quot; + inputStr + &quot;, inputInt: &quot; + inputInt + &quot;, paramOutsideJNLPFile: &quot; + inputOutsideJNLPFile; JLabel lbl &#x3D; new JLabel(text); add(lbl); &#125;&#125; The AppletTakesParams applet is shown next. Download source code for the Applet With Parameters example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Finding and Loading Data Files","date":"2020-12-06T04:42:06.551Z","path":"wiki/2021-03-03-Finding and Loading Data Files/","text":"Finding and Loading Data FilesWhenever a Java applet needs to load data from a file that is specified with a relative URL (a URL that doesn’t completely specify the file’s location), the applet usually uses either the code base or the document base to form the complete URL. The code base, returned by the JApplet getCodeBase method, is a URL that specifies the directory from which the applet’s classes were loaded. For locally deployed applets, the getCodeBase method returns null. The document base, returned by the JApplet getDocumentBase method, specifies the directory of the HTML page that contains the applet. For locally deployed applets, the getDocumentBase method returns null. Unless the &amp;lt;applet&amp;gt; tag specifies a code base, both the code base and document base refer to the same directory on the same server. Data that the applet might need, or needs to rely on as a backup, is usually specified relative to the code base. Data that the applet developer specifies, often by using parameters, is usually specified relative to the document base. The JApplet class defines convenient forms of image-loading and sound-loading methods that enable you to specify images and sounds relative to a base URL. For example, assume an applet is set up with one of the directory structures shown in the following figure. To create an Image object that uses the a.gif image file under imgDir, the applet can use the following code: 123Image image &#x3D; getImage(getCodeBase(), &quot;imgDir&#x2F;a.gif&quot;);","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Doing More With Applets","date":"2020-12-06T04:42:03.971Z","path":"wiki/2021-03-03-Doing More With Applets/","text":"Doing More With AppletsThe Java applet API enables you to take advantage of the close relationship that applets have with browsers. The API is provided by the javax.swing.JApplet class and the java.applet.AppletContext interface. The applet execution architecture enables applets to interact with their environment to produce a rich user experience. An applet can manipulate its parent web page, interact with JavaScript code in the web page, find other applets running in the same web page, and much more. Advanced capabilities of Java applets are explored in subsequent topics. SeeDoing More With Java Rich Internet Applications for further information on advanced topics that are common to applets and Java Web Start applications (such as setting arguments and properties, using Java Network Launch Protocol API).","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Deploying With the Applet Tag","date":"2020-12-06T04:42:01.407Z","path":"wiki/2021-03-03-Deploying With the Applet Tag/","text":"Deploying With the Applet TagIf you are not sure whether your end users’ browsers will have the JavaScript interpreter enabled, you can deploy your Java applet by manually coding the &amp;lt;applet&amp;gt; HTML tag, instead of using the Deployment Toolkit functions. Depending on the browsers you need to support, you may need to deploy your Java applet using the &amp;lt;object&amp;gt; or &amp;lt;embed&amp;gt; HTML tag. Check theW3C HTML Specification for details on the usage of these tags. You can launch your applet using Java Network Launch Protocol (JNLP) or specify the launch attributes directly in the &amp;lt;applet&amp;gt; tag. Preparing for DeploymentFollow the steps described in theDeploying An Applet topic to compile your source code, create and sign the JAR file, and create the JNLP file if necessary. The overall steps for deployment are still relevant. Only the contents of your HTML page containing the applet will change. Manually Coding Applet Tag, Launching Using JNLPTheAppletPage_WithAppletTag.html page deploys the Dynamic Tree Demo applet with an &amp;lt;applet&amp;gt; tag that has been manually coded (meaning, the applet is not deployed using the Deployment Toolkit which automatically generates the required HTML). The applet is still launched using JNLP. The JNLP file is specified in the jnlp_href attribute. 123456&lt;applet code &#x3D; &#39;appletComponentArch.DynamicTreeApplet&#39; jnlp_href &#x3D; &#39;dynamictree_applet.jnlp&#39; width &#x3D; 300 height &#x3D; 300 &#x2F;&gt; Manually Coding Applet Tag, Launching Without JNLPUsing JNLP is the preferred way to deploy an applet, however, you can also deploy your applet without a JNLP file. TheAppletPage_WithAppletTagNoJNLP.html deploys the Dynamic Tree Demo applet as shown in the following code snippet. 12345678&lt;applet code &#x3D; &#39;appletComponentArch.DynamicTreeApplet&#39; archive &#x3D; &#39;DynamicTreeDemo.jar&#39; width &#x3D; 300 height &#x3D; 300&gt; &lt;param name&#x3D;&quot;permissions&quot; value&#x3D;&quot;sandbox&quot; &#x2F;&gt;&lt;&#x2F;applet&gt; where code is the name of the applet class. archive is the name of jar file containing the applet and its resources. width is the width of the applet. height is the height of the applet. permissions indicates if the applet runs in the security sandbox. Specify “sandbox” for the value to run in the sandbox. Specify “all-permissions” to run outside the sandbox. If the permissions parameter is not present, signed applets default to “all-permissions” and unsigned applets default to “sandbox”.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Developing an Applet","date":"2020-12-06T04:41:55.592Z","path":"wiki/2021-03-03-Developing an Applet/","text":"Developing an AppletAn application designed usingcomponent-based architecture can be developed into a Java applet. Consider the example of a Java applet with a Swing-based graphical user interface (GUI). With component-based design, the GUI can be built with smaller building blocks or components. The following general steps are used to create an applet GUI: Create a class MyTopJPanel that is a subclass of javax.swing.JPanel. Lay out your applet’s GUI components in the constructor of the MyTopJPanel class. Create a class called MyApplet that is a subclass of javax.swing.JApplet. In the init method of MyApplet, instantiate MyTopJPanel and set it as the applet’s content pane. The following sections explore these steps in greater detail by using the Dynamic Tree Demo applet. If you are not familiar with Swing, seeCreating a GUI with Swing to learn more about using Swing GUI components. Creating the Top JPanel ClassCreate a class that is a subclass of JPanel. This top JPanel acts as a container for all your other UI components. In the following example, the DynamicTreePanel class is the topmost JPanel. The constructor of the DynamicTreePanel class invokes other methods to create and lay out the UI controls properly. 123456789101112131415161718192021222324252627282930313233343536373839404142public class DynamicTreePanel extends JPanel implements ActionListener &#123; private int newNodeSuffix &#x3D; 1; private static String ADD_COMMAND &#x3D; &quot;add&quot;; private static String REMOVE_COMMAND &#x3D; &quot;remove&quot;; private static String CLEAR_COMMAND &#x3D; &quot;clear&quot;; private DynamicTree treePanel; public DynamicTreePanel() &#123; super(new BorderLayout()); &#x2F;&#x2F;Create the components. treePanel &#x3D; new DynamicTree(); populateTree(treePanel); JButton addButton &#x3D; new JButton(&quot;Add&quot;); addButton.setActionCommand(ADD_COMMAND); addButton.addActionListener(this); JButton removeButton &#x3D; new JButton(&quot;Remove&quot;); &#x2F;&#x2F; ... JButton clearButton &#x3D; new JButton(&quot;Clear&quot;); &#x2F;&#x2F; ... &#x2F;&#x2F;Lay everything out. treePanel.setPreferredSize( new Dimension(300, 150)); add(treePanel, BorderLayout.CENTER); JPanel panel &#x3D; new JPanel(new GridLayout(0,3)); panel.add(addButton); panel.add(removeButton); panel.add(clearButton); add(panel, BorderLayout.SOUTH); &#125; &#x2F;&#x2F; ...&#125; Creating the AppletFor a Java applet that has a Swing-based GUI, create a class that is a subclass of javax.swing.JApplet. An applet that does not contain a Swing-based GUI can extend the java.applet.Applet class. Override the applet’s init method to instantiate your top JPanel class and create the applet’s GUI. The init method of the DynamicTreeApplet class invokes the createGUI method in the AWT Event Dispatcher thread. 1234567891011121314151617181920212223242526272829package appletComponentArch;import javax.swing.JApplet;import javax.swing.SwingUtilities;public class DynamicTreeApplet extends JApplet &#123; &#x2F;&#x2F;Called when this applet is loaded into the browser. public void init() &#123; &#x2F;&#x2F;Execute a job on the event-dispatching thread; creating this applet&#39;s GUI. try &#123; SwingUtilities.invokeAndWait(new Runnable() &#123; public void run() &#123; createGUI(); &#125; &#125;); &#125; catch (Exception e) &#123; System.err.println(&quot;createGUI didn&#39;t complete successfully&quot;); &#125; &#125; private void createGUI() &#123; &#x2F;&#x2F;Create and set up the content pane. DynamicTreePanel newContentPane &#x3D; new DynamicTreePanel(); newContentPane.setOpaque(true); setContentPane(newContentPane); &#125; &#125; Benefits of Separating Core Functionality From the Final Deployment MechanismAnother way to create an applet is to just remove the layer of abstraction (separate top JPanel) and lay out all the controls in the applet’s init method itself. The downside to creating the GUI directly in the applet is that it will now be more difficult to deploy your functionality as a Java Web Start application, if you choose to do so later. In the Dynamic Tree Demo example, the core functionality resides in the DynamicTreePanel class. It is now trivial to drop the DynamicTreePanel class into a JFrame and deploy as a Java Web Start application. Hence, to preserve portability and keep deployment options open, follow component-based design as described on this page.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Applet's Execution Environment","date":"2020-12-06T04:41:53.039Z","path":"wiki/2021-03-03-Applet's Execution Environment/","text":"Applet’s Execution EnvironmentA Java applet runs in the context of a browser. The Java Plug-in software in the browser controls the launch and execution of Java applets. The browser also has a JavaScript interpreter, which runs the JavaScript code on a web page. This topic describes the behavior of the Java Plug-in software released in Java Platform, Standard Edition 6 update 10. Java Plug-inThe Java Plug-in software creates a worker thread for every Java applet. It launches an applet in an instance of the Java Runtime Environment (JRE) software. Normally, all applets run in the same instance of the JRE. The Java Plug-in software starts a new instance of the JRE in the following cases: When an applet requests to be executed in a specific version of the JRE. When an applet specifies its own JRE startup parameters, for example, the heap size. A new applet uses an existing JRE if its requirements are a subset of an existing JRE, otherwise, a new JRE instance is started. An applet will run in an existing JRE if the following conditions are met: The JRE version required by the applet matches an existing JRE. The JRE’s startup parameters satisfy the applet’s requirements. The following diagram shows how applets are executed in the JRE. Java Plug-in and JavaScript Interpreter InteractionJava applets can invoke JavaScript functions present in the web page. JavaScript functions are also allowed to invoke methods of an applet embedded on the same web page. The Java Plug-in software and the JavaScript interpreter orchestrate calls from Java code to JavaScript code and calls from JavaScript code to Java code. The Java Plug-in software is multi-threaded, while the JavaScript interpreter runs on a single thread. Hence, to avoid thread-related issues, especially when multiple applets are running simultaneously, keep the calls between Java code and JavaScript code short, and avoid round trips, if possible. See the following topics to find out more about interactions between Java code and JavaScript code: [Invoking JavaScript Code From an Applet](../applet/invokingJavaScriptFromApplet.html) [Invoking Applet Methods From JavaScript Code](../applet/invokingAppletMethodsFromJavaScript.html)","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Life Cycle of an Applet","date":"2020-12-06T04:41:50.412Z","path":"wiki/2021-03-03-Life Cycle of an Applet/","text":"Life Cycle of an AppletAn applet can react to major events in the following ways: It can initialize itself. It can start running. It can stop running. It can perform a final cleanup, in preparation for being unloaded. This section introduces a new applet, Simple, that uses all of these methods. Unlike Java applications, applets do not need to implement a main method. Here is the Simple applet. The following is the source code for the Simple applet. This applet displays a descriptive string whenever it encounters a major milestone in its life, such as when the user first visits the page the applet is on. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.applet.Applet;import java.awt.Graphics;&#x2F;&#x2F;No need to extend JApplet, since we don&#39;t add any components;&#x2F;&#x2F;we just paint.public class Simple extends Applet &#123; StringBuffer buffer; public void init() &#123; buffer &#x3D; new StringBuffer(); addItem(&quot;initializing... &quot;); &#125; public void start() &#123; addItem(&quot;starting... &quot;); &#125; public void stop() &#123; addItem(&quot;stopping... &quot;); &#125; public void destroy() &#123; addItem(&quot;preparing for unloading...&quot;); &#125; private void addItem(String newWord) &#123; System.out.println(newWord); buffer.append(newWord); repaint(); &#125; public void paint(Graphics g) &#123; &#x2F;&#x2F;Draw a Rectangle around the applet&#39;s display area. g.drawRect(0, 0, getWidth() - 1, getHeight() - 1); &#x2F;&#x2F;Draw the current string inside the rectangle. g.drawString(buffer.toString(), 5, 15); &#125;&#125; Loading the AppletAs a result of the applet being loaded, you should see the text “initializing… starting…”. When an applet is loaded, here’s what happens: An instance of the applet’s controlling class (an Applet subclass) is created. The applet initializes itself. The applet starts running. Leaving and Returning to the Applet’s PageWhen the user leaves the page, for example, to go to another page, the browser stops and destroys the applet. The state of the applet is not preserved. When the user returns to the page, the browser intializes and starts a new instance of the applet. Reloading the AppletWhen you refresh or reload a browser page, the current instance of the applet is stopped and destroyed and a new instance is created. Quitting the BrowserWhen the user quits the browser, the applet has the opportunity to stop itself and perform a final cleanup before the browser exits. Download source code for the Simple Applet example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Methods for Milestones","date":"2020-12-06T04:41:47.828Z","path":"wiki/2021-03-03-Methods for Milestones/","text":"Methods for MilestonesTheApplet class provides a framework for applet execution, defining methods that the system calls when milestones occur. Milestones are major events in an applet’s life cycle. Most applets override some or all of these methods to respond appropriately to milestones. init MethodThe init method is useful for one-time initialization that doesn’t take very long. The init method typically contains the code that you would normally put into a constructor. The reason applets don’t usually have constructors is that they aren’t guaranteed to have a full environment until their init method is called. Keep the init method short so that your applet can load quickly. start MethodEvery applet that performs tasks after initialization (except in direct response to user actions) must override the start method. The start method starts the execution of the applet. It is good practice to return quickly from the start method. If you need to perform computationally intensive operations it might be better to start a new thread for this purpose. stop MethodMost applets that override the start should also override the stop method. The stop method should suspend the applet’s execution, so that it doesn’t take up system resources when the user isn’t viewing the applet’s page. For example, an applet that displays an animation should stop trying to draw the animation when the user isn’t viewing it. destroy MethodMany applets don’t need to override the destroy method because their stop method (which is called before destroy) will perform all tasks necessary to shut down the applet’s execution. However, the destroy method is available for applets that need to release additional resources.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Defining an Applet Subclass","date":"2020-12-06T04:41:45.004Z","path":"wiki/2021-03-03-Defining an Applet Subclass/","text":"Defining an Applet SubclassEvery Java applet must define a subclass of the Applet or JApplet class. In the Hello World applet, this subclass is called HelloWorld. The following is the source for the&lt;code&gt;HelloWorld class. 1234567891011121314151617181920212223import javax.swing.JApplet;import javax.swing.SwingUtilities;import javax.swing.JLabel;public class HelloWorld extends JApplet &#123; &#x2F;&#x2F;Called when this applet is loaded into the browser. public void init() &#123; &#x2F;&#x2F;Execute a job on the event-dispatching thread; creating this applet&#39;s GUI. try &#123; SwingUtilities.invokeAndWait(new Runnable() &#123; public void run() &#123; JLabel lbl &#x3D; new JLabel(&quot;Hello World&quot;); add(lbl); &#125; &#125;); &#125; catch (Exception e) &#123; System.err.println(&quot;createGUI didn&#39;t complete successfully&quot;); &#125; &#125;&#125; Java applets inherit significant functionality from the Applet or JApplet class, including the capabilities to communicate with the browser and present a graphical user interface (GUI) to the user. An applet that will be using GUI components from Swing (Java’s GUI toolkit) should extend thejavax.swing.JApplet base class, which provides the best integration with Swing’s GUI facilities. JApplet provides a root pane, which is the same top-level component structure as Swing’s JFrame and JDialog components, whereas Applet provides just a basic panel. SeeHow to Use Root Panes for more details on how to use this feature. An applet can extend thejava.applet.Applet class when it does not use Swing’s GUI components.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Getting Started With Applets","date":"2020-12-06T04:41:42.262Z","path":"wiki/2021-03-03-Getting Started With Applets/","text":"Getting Started With AppletsThe HelloWorld applet shown next is a Java class that displays the string “Hello World”. Following is the source code for the HelloWorld applet: 1234567891011121314151617181920212223import javax.swing.JApplet;import javax.swing.SwingUtilities;import javax.swing.JLabel;public class HelloWorld extends JApplet &#123; &#x2F;&#x2F;Called when this applet is loaded into the browser. public void init() &#123; &#x2F;&#x2F;Execute a job on the event-dispatching thread; creating this applet&#39;s GUI. try &#123; SwingUtilities.invokeAndWait(new Runnable() &#123; public void run() &#123; JLabel lbl &#x3D; new JLabel(&quot;Hello World&quot;); add(lbl); &#125; &#125;); &#125; catch (Exception e) &#123; System.err.println(&quot;createGUI didn&#39;t complete successfully&quot;); &#125; &#125;&#125; An applet such as this is typically managed and run by the Java Plug-in software in the browser. Download source code for the Hello World example to experiment further.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Java Applets","date":"2020-12-06T04:41:39.746Z","path":"wiki/2021-03-03-Java Applets/","text":"Lesson: Java AppletsThis lesson discusses the basics of Java applets, how to develop applets that interact richly with their environment, and how to deploy applets. A Java applet is a special kind of Java program that a browser enabled with Java technology can download from the internet and run. An applet is typically embedded inside a web page and runs in the context of a browser. An applet must be a subclass of the java.applet.Applet class. The Applet class provides the standard interface between the applet and the browser environment. Swing provides a special subclass of the Applet class called javax.swing.JApplet. The JApplet class should be used for all applets that use Swing components to construct their graphical user interfaces (GUIs). The browser’s Java Plug-in software manages the lifecycle of an applet. Use a web server to test the examples in this lesson. The use of local applets is not recommended, and local applets are blocked when the security level setting in the Java Control Panel is set to High or Very High.","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"Deployment","date":"2020-12-06T04:41:37.176Z","path":"wiki/2021-03-03-Deployment/","text":"Trail: DeploymentJava rich internet applications (RIA) are applications that have traits similar to desktop applications, but are deployed via the Internet. Java RIAs may be developed and deployed as Java applets or Java Web Start applications. Applets - Java applets run in the context of a browser. The Java Plug-in software controls the execution and lifecycle of Java applets. Java Web Start applications - Java Web Start applications are launched via a browser the first time. They may subsequently be launched from a desktop shortcut. Once a Java Web Start application is downloaded and its security certificate has been accepted by the user, it behaves almost like a standalone application. Component-Based Architecture for RIAsIn the past, the decision of whether to deploy a Java rich internet application inside the browser as an applet, or outside the browser as a Java Web Start application, could significantly impact the design of the application. With the latest Java Plug-in, this decision has been greatly simplified. Traditionally, applications construct their user interfaces, including the top-level Frame, in the main method. This programming style prevents easy re-deployment of the application in the browser, because it assumes that the application creates its own Frame. When running in the browser as an applet, the applet is the top level container that should hold the user interface for the application. A top-level Frame is not needed. Use component-based architecture when designing your Java rich internet application. Try to organize its functionality into one or more components that can be composed together. In this context, the term “component” refers to a GUI element that is a subclass of the AWT Component class, the Swing JComponent class, or another subclass. For example, you could have a top level JPanel which contains other UI components in it (like a combination of more nested JPanels and text fields, combo boxes etc.). With such a design, it becomes relatively easy to deploy the core functionality as an applet or a Java Web Start application. To deploy as a Java applet, you just need to wrap the core functionality in an Applet or JApplet and add the browser specific functionality, if necessary. To deploy as a Java Web Start application, wrap the functionality in a JFrame. Choosing Between Java Applets and Java Web Start ApplicationsTheRich Internet Applications Decision Guide contains detailed information to help you decide whether to deploy your code as a Java applet or Java Web Start application. The Self-Contained Application AlternativeSelf-contained applications provide a deployment option that does not require a browser. Users install your application locally and run it similar to native applications. Self-contained applications include the JRE needed to run the application, so users always have the correct JRE. This trail discusses the development and deployment of RIAs and self-contained applications. SeeWhat’s New for capabilities introduced in various versions of the client Java Runtime Environment (JRE) software. Developing and Deploying Java Applets Developing and Deploying Java Web Start Applications Doing More With Java Rich Internet Applications Deployment In-Depth Deploying Self-Contained Applications Supporting Tools Packaging Programs in JAR Files","tags":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"}],"categories":[{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"}]},{"title":"API Design","date":"2020-12-05T17:53:22.274Z","path":"wiki/2021-03-03-API Design/","text":"API DesignIn this short but important section, you’ll learn a few simple guidelines that will allow your API to interoperate seamlessly with all other APIs that follow these guidelines. In essence, these rules define what it takes to be a good “citizen” in the world of collections. ParametersIf your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collectioninterface types. Never use animplementation type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details. Further, you should always use the least-specific type that makes sense. For example, don’t require aList or aSet if aCollection would do. It’s not that you should never require a List or a Set on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a List on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: Collection and Map. Return ValuesYou can afford to be much more flexible with return values than with input parameters. It’s fine to return an object of any type that implements or extends one of the collection interfaces. This can be one of the interfaces or a special-purpose type that extends or implements one of these interfaces. For example, one could imagine an image-processing package, called ImageList, that returned objects of a new class that implements List. In addition to the List operations, ImageList could support any application-specific operations that seemed desirable. For example, it might provide an indexImage operation that returned an image containing thumbnail images of each graphic in the ImageList. It’s critical to note that even if the API furnishes ImageList instances on output, it should accept arbitrary Collection (or perhaps List) instances on input. In one sense, return values should have the opposite behavior of input parameters: It’s best to return the most specific applicable collection interface rather than the most general. For example, if you’re sure that you’ll always return a SortedMap, you should give the relevant method the return type of SortedMap rather than Map. SortedMap instances are more time-consuming to build than ordinary Map instances and are also more powerful. Given that your module has already invested the time to build a SortedMap, it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a SortedMap, as well as those that accept any Map. Legacy APIsThere are currently plenty of APIs out there that define their own ad hoc collection types. While this is unfortunate, it’s a fact of life, given that there was no Collections Framework in the first two major releases of the Java platform. Suppose you own one of these APIs; here’s what you can do about it. If possible, retrofit your legacy collection type to implement one of the standard collection interfaces. Then all the collections you return will interoperate smoothly with other collection-based APIs. If this is impossible (for example, because one or more of the preexisting type signatures conflict with the standard collection interfaces), define an adapter class that wraps one of your legacy collections objects, allowing it to function as a standard collection. (The Adapter class is an example of acustom implementation.) Retrofit your API with new calls that follow the input guidelines to accept objects of a standard collection interface, if possible. Such calls can coexist with the calls that take the legacy collection type. If this is impossible, provide a constructor or static factory for your legacy type that takes an object of one of the standard interfaces and returns a legacy collection containing the same elements (or mappings). Either of these approaches will allow users to pass arbitrary collections into your API.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Compatibility","date":"2020-12-05T17:53:20.787Z","path":"wiki/2021-03-03-Compatibility/","text":"CompatibilityThe Java Collections Framework was designed to ensure complete interoperability between the corecollection interfaces and the types that were used to represent collections in the early versions of the Java platform:Vector,Hashtable,array, andEnumeration. In this section, you’ll learn how to transform old collections to the Java Collections Framework collections and vice versa. Upward CompatibilitySuppose that you’re using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you’ll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy. Suppose the old API returns an array of objects and the new API requires a Collection. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a List. You useArrays.asList to pass an array to any method requiring a Collection or a List. 1234Foo[] result &#x3D; oldMethod(arg);newMethod(Arrays.asList(result)); If the old API returns a Vector or a Hashtable, you have no work to do at all because Vector was retrofitted to implement the List interface, and Hashtable was retrofitted to implement Map. Therefore, a Vector may be passed directly to any method calling for a Collection or a List. 1234Vector result &#x3D; oldMethod(arg);newMethod(result); Similarly, a Hashtable may be passed directly to any method calling for a Map. 1234Hashtable result &#x3D; oldMethod(arg);newMethod(result); Less frequently, an API may return an Enumeration that represents a collection of objects. The Collections.list method translates an Enumeration into a Collection. 1234Enumeration e &#x3D; oldMethod(arg);newMethod(Collections.list(e)); Backward CompatibilitySuppose you’re using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy. Suppose the new API returns a Collection, and the old API requires an array of Object. As you’re probably aware, the Collection interface contains a toArray method designed expressly for this situation. 1234Collection c &#x3D; newMethod();oldMethod(c.toArray()); What if the old API requires an array of String (or another type) instead of an array of Object? You just use the other form of toArray &#151; the one that takes an array on input. 1234Collection c &#x3D; newMethod();oldMethod((String[]) c.toArray(new String[0])); If the old API requires a Vector, the standard collection constructor comes in handy. 1234Collection c &#x3D; newMethod();oldMethod(new Vector(c)); The case where the old API requires a Hashtable is handled analogously. 1234Map m &#x3D; newMethod();oldMethod(new Hashtable(m)); Finally, what do you do if the old API requires an Enumeration? This case isn’t common, but it does happen from time to time, and theCollections.enumeration method was provided to handle it. This is a static factory method that takes a Collection and returns an Enumeration over the elements of the Collection. 1234Collection c &#x3D; newMethod();oldMethod(Collections.enumeration(c));","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Interoperability","date":"2020-12-05T17:53:19.298Z","path":"wiki/2021-03-03-Interoperability/","text":"Lesson: InteroperabilityIn this section, you’ll learn about the following two aspects of interoperability: [Compatibility](compatibility.html): This subsection describes how collections can be made to work with older APIs that predate the addition of `Collection`s to the Java platform. [API Design](api-design.html): This subsection describes how to design new APIs so that they will interoperate seamlessly with one another.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Custom Collection Implementations","date":"2020-12-05T17:53:17.795Z","path":"wiki/2021-03-03-Custom Collection Implementations/","text":"Lesson: Custom Collection ImplementationsMany programmers will never need to implement their own Collections classes. You can go pretty far using the implementations described in the preceding sections of this chapter. However, someday you might want to write your own implementation. It is fairly easy to do this with the aid of the abstract implementations provided by the Java platform. Before we discuss how to write an implementation, let’s discuss why you might want to write one. Reasons to Write an ImplementationThe following list illustrates the sort of custom Collections you might want to implement. It is not intended to be exhaustive: Persistent: All of the built-in Collection implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs. Application-specific: This is a very broad category. One example is an unmodifiable Map containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the get operation. High-performance, special-purpose: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a List containing long runs of identical element values. Such lists, which occur frequently in text processing, can be run-length encoded &#151; runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an ArrayList. High-performance, general-purpose: The Java Collections Framework’s designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster! Enhanced functionality: Suppose you need an efficient bag implementation (also known as a multiset): a Collection that offers constant-time containment checks while allowing duplicate elements. It’s reasonably straightforward to implement such a collection atop a HashMap. Convenience: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need List instances representing a contiguous range of Integers. Adapter: Suppose you are using a legacy API that has its own ad hoc collections’ API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An adapter implementation is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former. How to Write a Custom ImplementationWriting a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We’ll start with the following example of an implementation ofArrays.asList. 12345678910111213141516171819202122232425262728public static &lt;T&gt; List&lt;T&gt; asList(T[] a) &#123; return new MyArrayList&lt;T&gt;(a);&#125;private static class MyArrayList&lt;T&gt; extends AbstractList&lt;T&gt; &#123; private final T[] a; MyArrayList(T[] array) &#123; a &#x3D; array; &#125; public T get(int index) &#123; return a[index]; &#125; public T set(int index, T element) &#123; T oldValue &#x3D; a[index]; a[index] &#x3D; element; return oldValue; &#125; public int size() &#123; return a.length; &#125;&#125; Believe it or not, this is very close to the implementation that is contained in java.util.Arrays. It’s that simple! You provide a constructor and the get, set, and size methods, and AbstractList does all the rest. You get the ListIterator, bulk operations, search operations, hash code computation, comparison, and string representation for free. Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you’ll know which methods to override to get the performance you want. The preceding implementation’s performance is fine, but it can be improved a bit. In particular, the toArray method iterates over the List, copying one element at a time. Given the internal representation, it’s a lot faster and more sensible just to clone the array. 12345public Object[] toArray() &#123; return (Object[]) a.clone();&#125; With the addition of this override and a few more like it, this implementation is exactly the one found in java.util.Arrays. In the interest of full disclosure, it’s a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it’s still not that difficult. The following list summarizes the abstract implementations: [`AbstractCollection`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html) &#151; a `Collection` that is neither a `Set` nor a `List`. At a minimum, you must provide the `iterator` and the `size` methods. [`AbstractSet`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractSet.html) &#151; a `Set`; use is identical to `AbstractCollection`. [`AbstractList`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractList.html) &#151; a `List` backed up by a random-access data store, such as an array. At a minimum, you must provide the `positional access` methods (`get` and, optionally, `set`, `remove`, and `add`) and the `size` method. The abstract class takes care of `listIterator` (and `iterator`). [`AbstractSequentialList`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractSequentialList.html) &#151; a `List` backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the `listIterator` and `size` methods. The abstract class takes care of the positional access methods. (This is the opposite of `AbstractList`.) [`AbstractQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractQueue.html) &#151; at a minimum, you must provide the `offer`, `peek`, `poll`, and `size` methods and an `iterator` supporting `remove`. [`AbstractMap`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractMap.html) &#151; a `Map`. At a minimum you must provide the `entrySet` view. This is typically implemented with the `AbstractSet` class. If the `Map` is modifiable, you must also provide the `put` method. The process of writing a custom implementation follows: Choose the appropriate abstract implementation class from the preceding list. Provide implementations for all the abstract methods of the class. If your custom collection is to be modifiable, you will have to override one or more of the concrete methods as well. The API documentation for the abstract implementation class will tell you which methods to override. Test and, if necessary, debug the implementation. You now have a working custom collection implementation. If you are concerned about performance, read the API documentation of the abstract implementation class for all the methods whose implementations you’re inheriting. If any seem too slow, override them. If you override any methods, be sure to measure the performance of the method before and after the override. How much effort you put into tweaking performance should be a function of how much use the implementation will get and how critical to performance its use is. (Often this step is best omitted.)","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Algorithms","date":"2020-12-05T17:53:16.314Z","path":"wiki/2021-03-03-Algorithms/","text":"Lesson: AlgorithmsThe polymorphic algorithms described here are pieces of reusable functionality provided by the Java platform. All of them come from theCollections class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate onList instances, but a few of them operate on arbitraryCollection instances. This section briefly describes the following algorithms: Sorting Shuffling Routine Data Manipulation Searching Composition Finding Extreme Values SortingThe sort algorithm reorders a List so that its elements are in ascending order according to an ordering relationship. Two forms of the operation are provided. The simple form takes a List and sorts it according to its elements’ natural ordering. If you’re unfamiliar with the concept of natural ordering, read theObject Ordering section. The sort operation uses a slightly optimized merge sort algorithm that is fast and stable: Fast: It is guaranteed to run in n log(n) time and runs substantially faster on nearly sorted lists. Empirical tests showed it to be as fast as a highly optimized quicksort. A quicksort is generally considered to be faster than a merge sort but isn’t stable and doesn’t guarantee n log(n) performance. Stable: It doesn’t reorder equal elements. This is important if you sort the same list repeatedly on different attributes. If a user of a mail program sorts the inbox by mailing date and then sorts it by sender, the user naturally expects that the now-contiguous list of messages from a given sender will (still) be sorted by mailing date. This is guaranteed only if the second sort was stable. The followingtrivial program prints out its arguments in lexicographic (alphabetical) order. 123456789101112import java.util.*;public class Sort &#123; public static void main(String[] args) &#123; List&lt;String&gt; list &#x3D; Arrays.asList(args); Collections.sort(list); System.out.println(list); &#125;&#125; Let’s run the program. 123% java Sort i walk the line The following output is produced. 123[i, line, the, walk] The program was included only to show you that algorithms really are as easy to use as they appear to be. The second form of sort takes aComparator in addition to a List and sorts the elements with the Comparator. Suppose you want to print out the anagram groups from our earlier example in reverse order of size &#151; largest anagram group first. The example that follows shows you how to achieve this with the help of the second form of the sort method. Recall that the anagram groups are stored as values in a Map, in the form of List instances. The revised printing code iterates through the Map‘s values view, putting every List that passes the minimum-size test into a List of Lists. Then the code sorts this List, using a Comparator that expects List instances, and implements reverse size-ordering. Finally, the code iterates through the sorted List, printing its elements (the anagram groups). The following code replaces the printing code at the end of the main method in the Anagrams example. 1234567891011121314151617&#x2F;&#x2F; Make a List of all anagram groups above size threshold.List&lt;List&lt;String&gt;&gt; winners &#x3D; new ArrayList&lt;List&lt;String&gt;&gt;();for (List&lt;String&gt; l : m.values()) if (l.size() &gt;&#x3D; minGroupSize) winners.add(l);&#x2F;&#x2F; Sort anagram groups according to sizeCollections.sort(winners, new Comparator&lt;List&lt;String&gt;&gt;() &#123; public int compare(List&lt;String&gt; o1, List&lt;String&gt; o2) &#123; return o2.size() - o1.size(); &#125;&#125;);&#x2F;&#x2F; Print anagram groups.for (List&lt;String&gt; l : winners) System.out.println(l.size() + &quot;: &quot; + l); Runningthe program on thesame dictionary as inThe Map Interface section, with the same minimum anagram group size (eight), produces the following output. 123456789101112131415161718192021222324252627282912: [apers, apres, asper, pares, parse, pears, prase, presa, rapes, reaps, spare, spear]11: [alerts, alters, artels, estral, laster, ratels, salter, slater, staler, stelar, talers]10: [least, setal, slate, stale, steal, stela, taels, tales, teals, tesla]9: [estrin, inerts, insert, inters, niters, nitres, sinter, triens, trines]9: [capers, crapes, escarp, pacers, parsec, recaps, scrape, secpar, spacer]9: [palest, palets, pastel, petals, plates, pleats, septal, staple, tepals]9: [anestri, antsier, nastier, ratines, retains, retinas, retsina, stainer, stearin]8: [lapse, leaps, pales, peals, pleas, salep, sepal, spale]8: [aspers, parses, passer, prases, repass, spares, sparse, spears]8: [enters, nester, renest, rentes, resent, tenser, ternes,&amp;#239;&amp;#191;&amp;#189;&amp;#239;&amp;#191;&amp;#189;treens]8: [arles, earls, lares, laser, lears, rales, reals, seral]8: [earings, erasing, gainers, reagins, regains, reginas, searing, seringa]8: [peris, piers, pries, prise, ripes, speir, spier, spire]8: [ates, east, eats, etas, sate, seat, seta, teas]8: [carets, cartes, caster, caters, crates, reacts, recast,&amp;#239;&amp;#191;&amp;#189;&amp;#239;&amp;#191;&amp;#189;traces] ShufflingThe shuffle algorithm does the opposite of what sort does, destroying any trace of order that may have been present in a List. That is, this algorithm reorders the List based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a List of Card objects representing a deck. Also, it’s useful for generating test cases. This operation has two forms: one takes a List and uses a default source of randomness, and the other requires the caller to provide aRandom object to use as a source of randomness. The code for this algorithm is used as an example in theList section. Routine Data ManipulationThe Collections class provides five algorithms for doing routine data manipulation on List objects, all of which are pretty straightforward: reverse &#151; reverses the order of the elements in a List. fill &#151; overwrites every element in a List with the specified value. This operation is useful for reinitializing a List. copy &#151; takes two arguments, a destination List and a source List, and copies the elements of the source into the destination, overwriting its contents. The destination List must be at least as long as the source. If it is longer, the remaining elements in the destination List are unaffected. swap &#151; swaps the elements at the specified positions in a List. addAll &#151; adds all the specified elements to a Collection. The elements to be added may be specified individually or as an array. SearchingThe binarySearch algorithm searches for a specified element in a sorted List. This algorithm has two forms. The first takes a List and an element to search for (the “search key”). This form assumes that the List is sorted in ascending order according to the natural ordering of its elements. The second form takes a Comparator in addition to the List and the search key, and assumes that the List is sorted into ascending order according to the specified Comparator. The sort algorithm can be used to sort the List prior to calling binarySearch. The return value is the same for both forms. If the List contains the search key, its index is returned. If not, the return value is (-(insertion point) - 1), where the insertion point is the point at which the value would be inserted into the List, or the index of the first element greater than the value or list.size() if all elements in the List are less than the specified value. This admittedly ugly formula guarantees that the return value will be &amp;gt;= 0 if and only if the search key is found. It’s basically a hack to combine a boolean (found) and an integer (index) into a single int return value. The following idiom, usable with both forms of the binarySearch operation, looks for the specified search key and inserts it at the appropriate position if it’s not already present. 12345int pos &#x3D; Collections.binarySearch(list, key);if (pos &lt; 0) l.add(-pos-1, key); CompositionThe frequency and disjoint algorithms test some aspect of the composition of one or more Collections: frequency &#151; counts the number of times the specified element occurs in the specified collection disjoint &#151; determines whether two Collections are disjoint; that is, whether they contain no elements in common Finding Extreme ValuesThe min and the max algorithms return, respectively, the minimum and maximum element contained in a specified Collection. Both of these operations come in two forms. The simple form takes only a Collection and returns the minimum (or maximum) element according to the elements’ natural ordering. The second form takes a Comparator in addition to the Collection and returns the minimum (or maximum) element according to the specified Comparator.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Questions and Exercises  Implementations","date":"2020-12-05T17:53:14.823Z","path":"wiki/2021-03-03-Questions and Exercises  Implementations/","text":"Questions and Exercises: ImplementationsQuestions You plan to write a program that uses several basic collection interfaces: Set, List, Queue, and Map. You’re not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? If you need a Set implementation that provides value-ordered iteration, which class should you use? Which class do you use to access wrapper implementations? ExercisesWrite a program that reads a text file, specified by the first command line argument, into a `List`. The program should then print random lines from the file, the number of lines printed to be specified by the second command line argument. Write the program so that a correctly-sized collection is allocated all at once, instead of being gradually expanded as the file is read in. Hint: To determine the number of lines in the file, use [`java.io.File.length`](https://docs.oracle.com/javase/8/docs/api/java/io/File.html#length--) to obtain the size of the file, then divide by an assumed size of an average line. Check your answers.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Summary of Implementations","date":"2020-12-05T17:53:12.999Z","path":"wiki/2021-03-03-Summary of Implementations/","text":"Summary of ImplementationsImplementations are the data objects used to store collections, which implement the interfaces described in theInterfaces lesson. The Java Collections Framework provides several general-purpose implementations of the core interfaces: For the Set interface, HashSet is the most commonly used implementation. For the List interface, ArrayList is the most commonly used implementation. For the Map interface, HashMap is the most commonly used implementation. For the Queue interface, LinkedList is the most commonly used implementation. For the Deque interface, ArrayDeque is the most commonly used implementation. Each of the general-purpose implementations provides all optional operations contained in its interface. The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior. The java.util.concurrent package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock. The Collections class (as opposed to the Collection interface), provides static methods that operate on or return collections, which are known as Wrapper implementations. Finally, there are several Convenience implementations, which can be more efficient than general-purpose implementations when you don’t need their full power. The Convenience implementations are made available through static factory methods.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Convenience Implementations","date":"2020-12-05T17:53:11.714Z","path":"wiki/2021-03-03-Convenience Implementations/","text":"Convenience ImplementationsThis section describes several mini-implementations that can be more convenient and more efficient than general-purpose implementations when you don’t need their full power. All the implementations in this section are made available via static factory methods rather than public classes. List View of an ArrayTheArrays.asList method returns a List view of its array argument. Changes to the List write through to the array and vice versa. The size of the collection is that of the array and cannot be changed. If the add or the remove method is called on the List, an UnsupportedOperationException will result. The normal use of this implementation is as a bridge between array-based and collection-based APIs. It allows you to pass an array to a method expecting a Collection or a List. However, this implementation also has another use. If you need a fixed-size List, it’s more efficient than any general-purpose List implementation. This is the idiom. 123List&lt;String&gt; list &#x3D; Arrays.asList(new String[size]); Note that a reference to the backing array is not retained. Immutable Multiple-Copy ListOccasionally you’ll need an immutable List consisting of multiple copies of the same element. TheCollections.nCopies method returns such a list. This implementation has two main uses. The first is to initialize a newly created List; for example, suppose you want an ArrayList initially consisting of 1,000 null elements. The following incantation does the trick. 123List&lt;Type&gt; list &#x3D; new ArrayList&lt;Type&gt;(Collections.nCopies(1000, (Type)null); Of course, the initial value of each element need not be null. The second main use is to grow an existing List. For example, suppose you want to add 69 copies of the string &quot;fruit bat&quot; to the end of a List&amp;lt;String&amp;gt;. It’s not clear why you’d want to do such a thing, but let’s just suppose you did. The following is how you’d do it. 123lovablePets.addAll(Collections.nCopies(69, &quot;fruit bat&quot;)); By using the form of addAll that takes both an index and a Collection, you can add the new elements to the middle of a List instead of to the end of it. Immutable Singleton SetSometimes you’ll need an immutable singleton Set, which consists of a single, specified element. TheCollections.singleton method returns such a Set. One use of this implementation is to remove all occurrences of a specified element from a Collection. 123c.removeAll(Collections.singleton(e)); A related idiom removes all elements that map to a specified value from a Map. For example, suppose you have a Map &#151; job &#151; that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed. 123job.values().removeAll(Collections.singleton(LAWYER)); One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values. Empty Set, List, and Map ConstantsTheCollections class provides methods to return the empty Set, List, and Map &#151;emptySet,emptyList, andemptyMap. The main use of these constants is as input to methods that take a Collection of values when you don’t want to provide any values at all, as in this example. 123tourist.declarePurchases(Collections.emptySet());","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Wrapper Implementations","date":"2020-12-05T17:53:10.240Z","path":"wiki/2021-03-03-Wrapper Implementations/","text":"Wrapper ImplementationsWrapper implementations delegate all their real work to a specified collection but add extra functionality on top of what this collection offers. For design pattern fans, this is an example of the decorator pattern. Although it may seem a bit exotic, it’s really pretty straightforward. These implementations are anonymous; rather than providing a public class, the library provides a static factory method. All these implementations are found in theCollections class, which consists solely of static methods. Synchronization WrappersThe synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces &#151;Collection,Set,List,Map,SortedSet, andSortedMap &#151; has one static factory method. 12345678public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c);public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s);public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list);public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m);public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s);public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m); Each of these methods returns a synchronized (thread-safe) Collection backed up by the specified collection. To guarantee serial access, all access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick. 123List&lt;Type&gt; list &#x3D; Collections.synchronizedList(new ArrayList&lt;Type&gt;()); A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as aVector. In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection. 1234567Collection&lt;Type&gt; c &#x3D; Collections.synchronizedCollection(myCollection);synchronized(c) &#123; for (Type e : c) foo(e);&#125; If an explicit iterator is used, the iterator method must be called from within the synchronized block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a Collection view of a synchronized Map is similar. It is imperative that the user synchronize on the synchronized Map when iterating over any of its Collection views rather than synchronizing on the Collection view itself, as shown in the following example. 1234567891011Map&lt;KeyType, ValType&gt; m &#x3D; Collections.synchronizedMap(new HashMap&lt;KeyType, ValType&gt;()); ...Set&lt;KeyType&gt; s &#x3D; m.keySet(); ...&#x2F;&#x2F; Synchronizing on m, not s!synchronized(m) &#123; while (KeyType k : s) foo(k);&#125; One minor downside of using wrapper implementations is that you do not have the ability to execute any noninterface operations of a wrapped implementation. So, for instance, in the preceding List example, you cannot call ArrayList‘sensureCapacity operation on the wrapped ArrayList. Unmodifiable WrappersUnlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an UnsupportedOperationException. Unmodifiable wrappers have two main uses, as follows: To make a collection immutable once it has been built. In this case, it’s good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability. To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access. Like synchronization wrappers, each of the six core Collection interfaces has one static factory method. 12345678public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c);public static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s);public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list);public static &lt;K,V&gt; Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m);public static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;? extends T&gt; s);public static &lt;K,V&gt; SortedMap&lt;K, V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m); Checked Interface WrappersThe Collections.checked interface wrappers are provided for use with generic collections. These implementations return a dynamically type-safe view of the specified collection, which throws a ClassCastException if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Deque Implementations","date":"2020-12-05T17:53:08.223Z","path":"wiki/2021-03-03-Deque Implementations/","text":"Deque ImplementationsThe Deque interface, pronounced as “deck”, represents a double-ended queue. The Deque interface can be implemented as various types of Collections. The Deque interface implementationsare grouped into general-purpose and concurrent implementations. General-Purpose Deque ImplementationsThe general-purpose implementations include LinkedList and ArrayDeque classes. The Deque interface supports insertion, removal and retrieval of elements at both ends. TheArrayDeque class is the resizable array implementation of the Deque interface, whereas theLinkedList class is the list implementation. The basic insertion, removal and retieval operations in the Deque interface addFirst, addLast, removeFirst, removeLast, getFirst and getLast. The method addFirst adds an element at the head whereas addLast adds an element at the tail of the Deque instance. The LinkedList implementation is more flexible than the ArrayDeque implementation. LinkedList implements all optional list operations. null elements are allowed in the LinkedList implementation but not in the ArrayDeque implementation. In terms of efficiency, ArrayDeque is more efficient than the LinkedList for add and remove operation at both ends. The best operation in a LinkedList implementation is removing the current element during the iteration. LinkedList implementations are not ideal structures to iterate. The LinkedList implementation consumes more memory than the ArrayDeque implementation. For the ArrayDeque instance traversal use any of the following: foreachThe foreach is fast and can be used for all kinds of lists. 123456789ArrayDeque&lt;String&gt; aDeque &#x3D; new ArrayDeque&lt;String&gt;();. . .for (String str : aDeque) &#123; System.out.println(str);&#125; IteratorThe Iterator can be used for the forward traversal on all kinds of lists for all kinds of data. 12345678ArrayDeque&lt;String&gt; aDeque &#x3D; new ArrayDeque&lt;String&gt;();. . .for (Iterator&lt;String&gt; iter &#x3D; aDeque.iterator(); iter.hasNext(); ) &#123; System.out.println(iter.next());&#125; The ArrayDeque class is used in this tutorial to implement the Deque interface. The complete code of the example used in this tutorial is available in&lt;code&gt;ArrayDequeSample. Both the LinkedList and ArrayDeque classes do not support concurrent access by multiple threads. Concurrent Deque ImplementationsTheLinkedBlockingDeque class is the concurrent implementation of the Deque interface.If the deque is empty then methods such as takeFirst and takeLast wait until the element becomes available, and then retrieves and removes the same element.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Queue Implementations","date":"2020-12-05T17:53:06.340Z","path":"wiki/2021-03-03-Queue Implementations/","text":"Queue ImplementationsThe Queue implementations are grouped into general-purpose and concurrent implementations. General-Purpose Queue ImplementationsAs mentioned in the previous section, LinkedList implements the Queue interface, providing first in, first out (FIFO) queue operations for add, poll, and so on. ThePriorityQueue class is a priority queue based on the heap data structure. This queue orders elements according to the order specified at construction time, which can be the elements’ natural ordering or the ordering imposed by an explicit Comparator. The queue retrieval operations &#151; poll, remove, peek, and element &#151; access the element at the head of the queue. The head of the queue is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily. PriorityQueue and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The iterator provided in method iterator is not guaranteed to traverse the elements of the PriorityQueue in any particular order. For ordered traversal, consider using Arrays.sort(pq.toArray()). Concurrent Queue ImplementationsThe java.util.concurrent package contains a set of synchronized Queue interfaces and classes.BlockingQueue extends Queue with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes: [`LinkedBlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingQueue.html) &#151; an optionally bounded FIFO blocking queue backed by linked nodes [`ArrayBlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ArrayBlockingQueue.html) &#151; a bounded FIFO blocking queue backed by an array [`PriorityBlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/PriorityBlockingQueue.html) &#151; an unbounded blocking priority queue backed by a heap [`DelayQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/DelayQueue.html) &#151; a time-based scheduling queue backed by a heap [`SynchronousQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html) &#151; a simple rendezvous mechanism that uses the `BlockingQueue` interface In JDK 7,TransferQueue is a specialized BlockingQueue in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. TransferQueue has a single implementation: [`LinkedTransferQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedTransferQueue.html) &#151; an unbounded `TransferQueue` based on linked nodes","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Map Implementations","date":"2020-12-05T17:53:04.466Z","path":"wiki/2021-03-03-Map Implementations/","text":"Map ImplementationsMap implementations are grouped into general-purpose, special-purpose, and concurrent implementations. General-Purpose Map ImplementationsThe three general-purposeMap implementations areHashMap,TreeMap andLinkedHashMap. If you need SortedMap operations or key-ordered Collection-view iteration, use TreeMap; if you want maximum speed and don’t care about iteration order, use HashMap; if you want near-HashMap performance and insertion-order iteration, use LinkedHashMap. In this respect, the situation for Map is analogous to Set. Likewise, everything else in theSet Implementations section also applies to Map implementations. LinkedHashMap provides two capabilities that are not available with LinkedHashSet. When you create a LinkedHashMap, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, LinkedHashMap provides the removeEldestEntry method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache. For example, this override will allow the map to grow up to as many as 100 entries and then it will delete the eldest entry each time a new entry is added, maintaining a steady state of 100 entries. 1234567private static final int MAX_ENTRIES &#x3D; 100;protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES;&#125; Special-Purpose Map ImplementationsThere are three special-purpose Map implementations &#151;EnumMap,WeakHashMap andIdentityHashMap. EnumMap, which is internally implemented as an array, is a high-performance Map implementation for use with enum keys. This implementation combines the richness and safety of the Map interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an EnumMap in preference to an array. WeakHashMap is an implementation of the Map interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the WeakHashMap. This class provides the easiest way to harness the power of weak references. It is useful for implementing “registry-like” data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread. IdentityHashMap is an identity-based Map implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based “node table” that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting “spoof attacks” that are a result of intentionally perverse equals methods because IdentityHashMap never invokes the equals method on its keys. An added benefit of this implementation is that it is fast. Concurrent Map ImplementationsThejava.util.concurrent package contains theConcurrentMap interface, which extends Map with atomic putIfAbsent, remove, and replace methods, and theConcurrentHashMap implementation of that interface. ConcurrentHashMap is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for Hashtable: in addition to implementing ConcurrentMap, it supports all the legacy methods peculiar to Hashtable. Again, if you don’t need the legacy operations, be careful to manipulate it with the ConcurrentMap interface.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"List Implementations","date":"2020-12-05T17:53:02.265Z","path":"wiki/2021-03-03-List Implementations/","text":"List ImplementationsList implementations are grouped into general-purpose and special-purpose implementations. General-Purpose List ImplementationsThere are two general-purposeList implementations &#151;ArrayList andLinkedList. Most of the time, you’ll probably use ArrayList, which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the List, and it can take advantage of System.arraycopy when it has to move multiple elements at the same time. Think of ArrayList as Vector without the synchronization overhead. If you frequently add elements to the beginning of the List or iterate over the List to delete elements from its interior, you should consider using LinkedList. These operations require constant-time in a LinkedList and linear-time in an ArrayList. But you pay a big price in performance. Positional access requires linear-time in a LinkedList and constant-time in an ArrayList. Furthermore, the constant factor for LinkedList is much worse. If you think you want to use a LinkedList, measure the performance of your application with both LinkedList and ArrayList before making your choice; ArrayList is usually faster. ArrayList has one tuning parameter &#151; the initial capacity, which refers to the number of elements the ArrayList can hold before it has to grow. LinkedList has no tuning parameters and seven optional operations, one of which is clone. The other six are addFirst, getFirst, removeFirst, addLast, getLast, and removeLast. LinkedList also implements the Queue interface. Special-Purpose List ImplementationsCopyOnWriteArrayList is a List implementation backed up by a copy-on-write array. This implementation is similar in nature to CopyOnWriteArraySet. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw ConcurrentModificationException. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming. If you need synchronization, a Vector will be slightly faster than an ArrayList synchronized with Collections.synchronizedList. But Vector has loads of legacy operations, so be careful to always manipulate the Vector with the List interface or else you won’t be able to replace the implementation at a later time. If your List is fixed in size &#151; that is, you’ll never use remove, add, or any of the bulk operations other than containsAll &#151; you have a third option that’s definitely worth considering. See Arrays.asList in theConvenience Implementations section for more information.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Set Implementations","date":"2020-12-05T17:53:00.764Z","path":"wiki/2021-03-03-Set Implementations/","text":"Set ImplementationsThe Set implementations are grouped into general-purpose and special-purpose implementations. General-Purpose Set ImplementationsThere are three general-purposeSet implementations &#151;HashSet,TreeSet, andLinkedHashSet. Which of these three to use is generally straightforward. HashSet is much faster than TreeSet (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the SortedSet interface, or if value-ordered iteration is required, use TreeSet; otherwise, use HashSet. It’s a fair bet that you’ll end up using HashSet most of the time. LinkedHashSet is in some sense intermediate between HashSet and TreeSet. Implemented as a hash table with a linked list running through it, it provides insertion-ordered iteration (least recently inserted to most recently) and runs nearly as fast as HashSet. The LinkedHashSet implementation spares its clients from the unspecified, generally chaotic ordering provided by HashSet without incurring the increased cost associated with TreeSet. One thing worth keeping in mind about HashSet is that iteration is linear in the sum of the number of entries and the number of buckets (the capacity). Thus, choosing an initial capacity that’s too high can waste both space and time. On the other hand, choosing an initial capacity that’s too low wastes time by copying the data structure each time it’s forced to increase its capacity. If you don’t specify an initial capacity, the default is 16. In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. Internally, the capacity is always rounded up to a power of two. The initial capacity is specified by using the int constructor. The following line of code allocates a HashSet whose initial capacity is 64. 123Set&lt;String&gt; s &#x3D; new HashSet&lt;String&gt;(64); The HashSet class has one other tuning parameter called the load factor. If you care a lot about the space consumption of your HashSet, read the HashSet documentation for more information. Otherwise, just accept the default; it’s almost always the right thing to do. If you accept the default load factor but want to specify an initial capacity, pick a number that’s about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it’s unlikely to be a big problem. LinkedHashSet has the same tuning parameters as HashSet, but iteration time is not affected by capacity. TreeSet has no tuning parameters. Special-Purpose Set ImplementationsThere are two special-purpose Set implementations &#151;EnumSet andCopyOnWriteArraySet. EnumSet is a high-performance Set implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single long. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The EnumSet class provides a static factory that makes it easy. 1234for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY)) System.out.println(d); Enum sets also provide a rich, typesafe replacement for traditional bit flags. 123EnumSet.of(Style.BOLD, Style.ITALIC) CopyOnWriteArraySet is a Set implementation backed up by a copy-on-write array. All mutative operations, such as add, set, and remove, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most Set implementations, the add, remove, and contains methods require time proportional to the size of the set. This implementation is only appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Implementations","date":"2020-12-05T17:52:58.755Z","path":"wiki/2021-03-03-Implementations/","text":"Lesson: ImplementationsImplementations are the data objects used to store collections, which implement the interfaces described inthe Interfaces section. This lesson describes the following kinds of implementations: General-purpose implementations are the most commonly used implementations, designed for everyday use. They are summarized in the table titled General-purpose-implementations. Special-purpose implementations are designed for use in special situations and display nonstandard performance characteristics, usage restrictions, or behavior. Concurrent implementations are designed to support high concurrency, typically at the expense of single-threaded performance. These implementations are part of the java.util.concurrent package. Wrapper implementations are used in combination with other types of implementations, often the general-purpose ones, to provide added or restricted functionality. Convenience implementations are mini-implementations, typically made available via static factory methods, that provide convenient, efficient alternatives to general-purpose implementations for special collections (for example, singleton sets).**Abstract implementations** are skeletal implementations that facilitate the construction of custom implementations &#151; described later in the [Custom Collection Implementations](../custom-implementations/index.html) section. An advanced topic, it's not particularly difficult, but relatively few people will need to do it. The general-purpose implementations are summarized in thefollowing table. InterfacesHash table ImplementationsResizable array ImplementationsTree ImplementationsLinked list ImplementationsHash table + Linked list Implementations `Set``HashSet`&#160;`TreeSet`&#160;`LinkedHashSet` `List`&#160;`ArrayList`&#160;`LinkedList`&#160; `Queue`&#160;&#160;&#160;&#160;&#160; `Deque`&#160;`ArrayDeque`&#160;`LinkedList`&#160; `Map``HashMap`&#160;`TreeMap`&#160;`LinkedHashMap` As you can see from the table, the Java Collections Framework provides several general-purpose implementations of theSet,List , andMap interfaces. In each case, one implementation &#151;HashSet,ArrayList, andHashMap &#151; is clearly the one to use for most applications, all other things being equal. Note that theSortedSet and theSortedMap interfaces do not have rows in the table. Each of those interfaces has one implementation(TreeSet andTreeMap) and is listed in the Set and the Map rows. There are two general-purpose Queue implementations &#151;LinkedList, which is also a List implementation, andPriorityQueue, which is omitted from the table. These two implementations provide very different semantics: LinkedList provides FIFO semantics, while PriorityQueue orders its elements according to their values. Each of the general-purpose implementations provides all optional operations contained in its interface. All permit null elements, keys, and values. None are synchronized (thread-safe). All have fail-fast iterators, which detect illegal concurrent modification during iteration and fail quickly and cleanly rather than risking arbitrary, nondeterministic behavior at an undetermined time in the future. All are Serializable and all support a public clone method. The fact that these implementations are unsynchronized represents a break with the past: The legacy collections Vector and Hashtable are synchronized. The present approach was taken because collections are frequently used when the synchronization is of no benefit. Such uses include single-threaded use, read-only use, and use as part of a larger data object that does its own synchronization. In general, it is good API design practice not to make users pay for a feature they don’t use. Furthermore, unnecessary synchronization can result in deadlock under certain circumstances. If you need thread-safe collections, the synchronization wrappers, described in theWrapper Implementations section, allow any collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the java.util.concurrent package provides concurrent implementations of the BlockingQueue interface, which extends Queue, and of the ConcurrentMap interface, which extends Map. These implementations offer much higher concurrency than mere synchronized implementations. As a rule, you should be thinking about the interfaces, not the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in theInterfaces section, is to choose an implementation when a Collection is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details. The sections that follow briefly discuss the implementations. The performance of the implementations is described using words such as constant-time, log, linear, n log(n), and quadratic to refer to the asymptotic upper-bound on the time complexity of performing the operation. All this is quite a mouthful, and it doesn’t matter much if you don’t know what it means. If you’re interested in knowing more, refer to any good algorithms textbook. One thing to keep in mind is that this sort of performance metric has its limitations. Sometimes, the nominally slower implementation may be faster. When in doubt, measure the performance!","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Questions and Exercises  Aggregate Operations","date":"2020-12-05T17:52:57.222Z","path":"wiki/2021-03-03-Questions and Exercises  Aggregate Operations/","text":"Questions and Exercises: Aggregate OperationsQuestions A sequence of aggregate operations is known as a ___ . Each pipeline contains zero or more ___ operations. Each pipeline ends with a ___ operation. What kind of operation produces another stream as its output?Describe one way in which the `forEach` aggregate operation differs from the enhanced `for` statement or iterators. True or False: A stream is similar to a collection in that it is a data structure that stores elements. Identify the intermediate and terminal operations in this code: double average = roster .stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .mapToInt(Person::getAge) .average() .getAsDouble(); The code p -&gt; p.getGender() == Person.Sex.MALE is an example of what? The code Person::getAge is an example of what? Terminal operations that combine the contents of a stream and return one value are known as what? Name one important difference between the `Stream.reduce` method and the `Stream.collect` method. If you wanted to process a stream of names, extract the male names, and store them in a new `List`, would `Stream.reduce` or `Stream.collect` be the most appropriate operation to use? True or False: Aggregate operations make it possible to implement parallelism with non-thread-safe collections. Streams are always serial unless otherwise specified. How do you request that a stream be processed in parallel? Exercises Write the following enhanced `for` statement as a pipeline with lambda expressions. Hint: Use the `filter` intermediate operation and the `forEach` terminal operation. for (Person p : roster) &#123; if (p.getGender() == Person.Sex.MALE) &#123; System.out.println(p.getName()); &#125; &#125; Convert the following code into a new implementation that uses lambda expressions and aggregate operations instead of nested `for` loops. Hint: Make a pipeline that invokes the `filter`, `sorted`, and `collect` operations, in that order. List&lt;Album&gt; favs = new ArrayList&lt;&gt;(); for (Album a : albums) &#123; boolean hasFavorite = false; for (Track t : a.tracks) &#123; if (t.rating &gt;= 4) &#123; hasFavorite = true; break; &#125; &#125; if (hasFavorite) favs.add(a); &#125; Collections.sort(favs, new Comparator&lt;Album&gt;() &#123; public int compare(Album a1, Album a2) &#123; return a1.name.compareTo(a2.name); &#125;&#125;); Check your answers.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Parallelism","date":"2020-12-05T17:52:55.339Z","path":"wiki/2021-03-03-Parallelism/","text":"ParallelismParallel computing involves dividing a problem into subproblems, solving those problems simultaneously (in parallel, with each subproblem running in a separate thread), and then combining the results of the solutions to the subproblems. Java SE provides thefork/join framework, which enables you to more easily implement parallel computing in your applications. However, with this framework, you must specify how the problems are subdivided (partitioned). With aggregate operations, the Java runtime performs this partitioning and combining of solutions for you. One difficulty in implementing parallelism in applications that use collections is that collections are not thread-safe, which means that multiple threads cannot manipulate a collection without introducingthread interference ormemory consistency errors. The Collections Framework providessynchronization wrappers, which add automatic synchronization to an arbitrary collection, making it thread-safe. However, synchronization introducesthread contention. You want to avoid thread contention because it prevents threads from running in parallel. Aggregate operations and parallel streams enable you to implement parallelism with non-thread-safe collections provided that you do not modify the collection while you are operating on it. Note that parallelism is not automatically faster than performing operations serially, although it can be if you have enough data and processor cores. While aggregate operations enable you to more easily implement parallelism, it is still your responsibility to determine if your application is suitable for parallelism. This section covers the following topics: Executing Streams in Parallel Concurrent Reduction Ordering[Side Effects](#side_effects) - [Laziness](#laziness) - [Interference](#interference) - [Stateful Lambda Expressions](#stateful_lambda_expressions) You can find the code excerpts described in this section in the exampleParallelismExamples. Executing Streams in ParallelYou can execute streams in serial or in parallel. When a stream executes in parallel, the Java runtime partitions the stream into multiple substreams. Aggregate operations iterate over and process these substreams in parallel and then combine the results. When you create a stream, it is always a serial stream unless otherwise specified. To create a parallel stream, invoke the operationCollection.parallelStream. Alternatively, invoke the operationBaseStream.parallel. For example, the following statement calculates the average age of all male members in parallel: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Collector.Characteristics.CONCURRENT&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. To determine the characteristics of a collector, invoke the[&#96;Collector.characteristics&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Collector.Characteristics.html) method.&lt;&#x2F;li&gt; &lt;li&gt;Either the stream is unordered, or the collector has the characteristic[&#96;Collector.Characteristics.UNORDERED&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Collector.Characteristics.html#UNORDERED). To ensure that the stream is unordered, invoke the[&#96;BaseStream.unordered&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;BaseStream.html#unordered--) operation.&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;p&gt;**Note**: This example returns an instance of[&#96;ConcurrentMap&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;concurrent&#x2F;ConcurrentMap.html) instead of &#96;Map&#96; and invokes the[&#96;groupingByConcurrent&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Collectors.html#groupingByConcurrent-java.util.function.Function-) operation instead of &#96;groupingBy&#96;. (See the section[Concurrent Collections](..&#x2F;..&#x2F;essential&#x2F;concurrency&#x2F;collections.html) for more information about &#96;ConcurrentMap&#96;.) Unlike the operation &#96;groupingByConcurrent&#96;, the operation &#96;groupingBy&#96; performs poorly with parallel streams. (This is because it operates by merging two maps by key, which is computationally expensive.) Similarly, the operation[&#96;Collectors.toConcurrentMap&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-) performs better with parallel streams than the operation[&#96;Collectors.toMap&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Collectors.html#toMap-java.util.function.Function-java.util.function.Function-).&lt;&#x2F;p&gt;&lt;!-- *********************************************************************** --&gt;&lt;h2&gt;&lt;a name&#x3D;&quot;ordering&quot; id&#x3D;&quot;ordering&quot;&gt;Ordering&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;The order in which a pipeline processes the elements of a stream depends on whether the stream is executed in serial or in parallel, the source of the stream, and intermediate operations. For example, consider the following example that prints the elements of an instance of &#96;ArrayList&#96; with the &#96;forEach&#96; operation several times:&lt;pre class&#x3D;&quot;codeblock&quot;&gt;Integer[] intArray &#x3D; &#123;1, 2, 3, 4, 5, 6, 7, 8 &#125;;List&lt;Integer&gt; listOfIntegers &#x3D; new ArrayList&lt;&gt;(Arrays.asList(intArray));System.out.println(&quot;listOfIntegers:&quot;);listOfIntegers .stream() .forEach(e -&gt; System.out.print(e + &quot; &quot;));System.out.println(&quot;&quot;);System.out.println(&quot;listOfIntegers sorted in reverse order:&quot;);Comparator&lt;Integer&gt; normal &#x3D; Integer::compare;Comparator&lt;Integer&gt; reversed &#x3D; normal.reversed(); Collections.sort(listOfIntegers, reversed); listOfIntegers .stream() .forEach(e -&gt; System.out.print(e + &quot; &quot;));System.out.println(&quot;&quot;); System.out.println(&quot;Parallel stream&quot;);listOfIntegers .parallelStream() .forEach(e -&gt; System.out.print(e + &quot; &quot;));System.out.println(&quot;&quot;); System.out.println(&quot;Another parallel stream:&quot;);listOfIntegers .parallelStream() .forEach(e -&gt; System.out.print(e + &quot; &quot;));System.out.println(&quot;&quot;); System.out.println(&quot;With forEachOrdered:&quot;);listOfIntegers .parallelStream() .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;));System.out.println(&quot;&quot;); OrderingThis example consists of five pipelines. It prints output similar to the following: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Collections.sort&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt; - The third and fourth pipelines print the elements of the list in an apparently random order. Remember that stream operations use internal iteration when processing elements of a stream. Consequently, when you execute a stream in parallel, the Java compiler and runtime determine the order in which to process the stream&#39;s elements to maximize the benefits of parallel computing unless otherwise specified by the stream operation. &lt;li&gt;The fifth pipeline uses the method[&#96;forEachOrdered&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Stream.html#forEachOrdered-java.util.function.Consumer-), which processes the elements of the stream in the order specified by its source, regardless of whether you executed the stream in serial or parallel. Note that you may lose the benefits of parallelism if you use operations like &#96;forEachOrdered&#96; with parallel streams.&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;!-- *********************************************************************** --&gt;&lt;h2&gt;&lt;a name&#x3D;&quot;side_effects&quot; id&#x3D;&quot;side_effects&quot;&gt;Side Effects&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;&lt;p&gt;A method or an expression has a side effect if, in addition to returning or producing a value, it also modifies the state of the computer. Examples include mutable reductions (operations that use the &#96;collect&#96; operation; see the section[Reduction](..&#x2F;..&#x2F;collections&#x2F;streams&#x2F;reduction.html) for more information) as well as invoking the &#96;System.out.println&#96; method for debugging. The JDK handles certain side effects in pipelines well. In particular, the &#96;collect&#96; method is designed to perform the most common stream operations that have side effects in a parallel-safe manner. Operations like &#96;forEach&#96; and &#96;peek&#96; are designed for side effects; a lambda expression that returns void, such as one that invokes &#96;System.out.println&#96;, can do nothing but have side effects. Even so, you should use the &#96;forEach&#96; and &#96;peek&#96; operations with care; if you use one of these operations with a parallel stream, then the Java runtime may invoke the lambda expression that you specified as its parameter concurrently from multiple threads. In addition, never pass as parameters lambda expressions that have side effects in operations such as &#96;filter&#96; and &#96;map&#96;. The following sections discuss [interference](#interference) and [stateful lambda expressions](#stateful_lambda_expressions), both of which can be sources of side effects and can return inconsistent or unpredictable results, especially in parallel streams. However, the concept of [laziness](#laziness) is discussed first, because it has a direct effect on interference.&lt;&#x2F;p&gt;&lt;!-- *********************************************************************** --&gt;&lt;h3&gt;&lt;a name&#x3D;&quot;laziness&quot; id&#x3D;&quot;laziness&quot;&gt;Laziness&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt; &lt;p&gt;All intermediate operations are **lazy**. An expression, method, or algorithm is lazy if its value is evaluated only when it is required. (An algorithm is **eager** if it is evaluated or processed immediately.) Intermediate operations are lazy because they do not start processing the contents of the stream until the terminal operation commences. Processing streams lazily enables the Java compiler and runtime to optimize how they process streams. For example, in a pipeline such as the &#96;filter&#96;-&#96;mapToInt&#96;-&#96;average&#96; example described in the section[Aggregate Operations](..&#x2F;..&#x2F;collections&#x2F;streams&#x2F;index.html), the &#96;average&#96; operation could obtain the first several integers from the stream created by the &#96;mapToInt&#96; operation, which obtains elements from the &#96;filter&#96; operation. The &#96;average&#96; operation would repeat this process until it had obtained all required elements from the stream, and then it would calculate the average.&lt;&#x2F;p&gt;&lt;!-- *********************************************************************** --&gt;&lt;h3&gt;&lt;a name&#x3D;&quot;interference&quot; id&#x3D;&quot;interference&quot;&gt;Interference&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;Lambda expressions in stream operations should not **interfere**. Interference occurs when the source of a stream is modified while a pipeline processes the stream. For example, the following code attempts to concatenate the strings contained in the &#96;List&#96; &#96;listOfStrings&#96;. However, it throws a &#96;ConcurrentModificationException&#96;:&lt;pre class&#x3D;&quot;codeblock&quot;&gt;try &#123; List&lt;String&gt; listOfStrings &#x3D; new ArrayList&lt;&gt;(Arrays.asList(&quot;one&quot;, &quot;two&quot;)); &#x2F;&#x2F; This will fail as the peek operation will attempt to add the &#x2F;&#x2F; string &quot;three&quot; to the source after the terminal operation has &#x2F;&#x2F; commenced. String concatenatedString &#x3D; listOfStrings .stream() &#x2F;&#x2F; Don&#39;t do this! Interference occurs here. .peek(s -&gt; listOfStrings.add(&quot;three&quot;)) .reduce((a, b) -&gt; a + &quot; &quot; + b) .get(); System.out.println(&quot;Concatenated string: &quot; + concatenatedString); &#125; catch (Exception e) &#123; System.out.println(&quot;Exception caught: &quot; + e.toString());&#125; LazinessThis example concatenates the strings contained in listOfStrings into an Optional&amp;lt;String&amp;gt; value with the reduce operation, which is a terminal operation. However, the pipeline here invokes the intermediate operation peek, which attempts to add a new element to listOfStrings. Remember, all intermediate operations are lazy. This means that the pipeline in this example begins execution when the operation get is invoked, and ends execution when the get operation completes. The argument of the peek operation attempts to modify the stream source during the execution of the pipeline, which causes the Java runtime to throw a ConcurrentModificationException. Stateful Lambda ExpressionsAvoid using stateful lambda expressions as parameters in stream operations. A stateful lambda expression is one whose result depends on any state that might change during the execution of a pipeline. The following example adds elements from the List listOfIntegers to a new List instance with the map intermediate operation. It does this twice, first with a serial stream and then with a parallel stream: 123synchronizedList&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; so that the &#96;List&#96; &#96;parallelStorage&#96; is thread-safe. Remember that collections are not thread-safe. This means that multiple threads should not access a particular collection at the same time. Suppose that you do not invoke the method &#96;synchronizedList&#96; when creating &#96;parallelStorage&#96;:&lt;&#x2F;p&gt; &lt;pre class&#x3D;&quot;codeblock&quot;&gt;List&lt;Integer&gt; parallelStorage &#x3D; new ArrayList&lt;&gt;(); The example behaves erratically because multiple threads access and modify parallelStorage without a mechanism like synchronization to schedule when a particular thread may access the List instance. Consequently, the example could print output similar to the following:","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Reduction","date":"2020-12-05T17:52:53.370Z","path":"wiki/2021-03-03-Reduction/","text":"ReductionThe sectionAggregate Operations describes the following pipeline of operations, which calculates the average age of all male members in the collection roster: 12345678910111213141516171819202122232425262728average&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;,[&#96;sum&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;IntStream.html#sum--),[&#96;min&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Stream.html#min-java.util.Comparator-),[&#96;max&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Stream.html#max-java.util.Comparator-), and[&#96;count&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Stream.html#count--)) that return one value by combining the contents of a stream. These operations are called **reduction operations**. The JDK also contains reduction operations that return a collection instead of a single value. Many reduction operations perform a specific task, such as finding the average of values or grouping elements into categories. However, the JDK provides you with the general-purpose reduction operations[&#96;reduce&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Stream.html#reduce-T-java.util.function.BinaryOperator-) and[&#96;collect&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-), which this section describes in detail.&lt;&#x2F;p&gt;This section covers the following topics:&lt;ul&gt; - [The Stream.reduce Method](#reduce) - [The Stream.collect Method](#collect)&lt;&#x2F;ul&gt;&lt;p&gt;You can find the code excerpts described in this section in the example[&#96;ReductionExamples&#96;](examples&#x2F;ReductionExamples.java).&lt;&#x2F;p&gt;&lt;h2&gt;&lt;a name&#x3D;&quot;reduce&quot; id&#x3D;&quot;reduce&quot;&gt;The Stream.reduce Method&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;&lt;p&gt;The[&#96;Stream.reduce&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;Stream.html#reduce-T-java.util.function.BinaryOperator-) method is a general-purpose reduction operation. Consider the following pipeline, which calculates the sum of the male members&#39; ages in the collection &#96;roster&#96;. It uses the[&#96;Stream.sum&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;stream&#x2F;IntStream.html#sum--) reduction operation:&lt;&#x2F;p&gt;&lt;pre class&#x3D;&quot;codeblock&quot;&gt;Integer totalAge &#x3D; roster .stream() .mapToInt(Person::getAge) .sum(); Compare this with the following pipeline, which uses the Stream.reduce operation to calculate the same value: 12345identity&lt;&#x2F;code&gt;: The identity element is both the initial value of the reduction and the default result if there are no elements in the stream. In this example, the identity element is &#96;0&#96;; this is the initial value of the sum of ages and the default value if no members exist in the collection &#96;roster&#96;.&lt;&#x2F;p&gt;&lt;&#x2F;li&gt; &lt;li&gt;&#96;accumulator&#96;: The accumulator function takes two parameters: a partial result of the reduction (in this example, the sum of all processed integers so far) and the next element of the stream (in this example, an integer). It returns a new partial result. In this example, the accumulator function is a lambda expression that adds two &#96;Integer&#96; values and returns an &#96;Integer&#96; value: &lt;pre class&#x3D;&quot;codeblock&quot;&gt;(a, b) -&gt; a + b identity: The identity element is both the initial value of the reduction and the default result if there are no elements in the stream. In this example, the identity element is 0; this is the initial value of the sum of ages and the default value if no members exist in the collection roster. `accumulator`: The accumulator function takes two parameters: a partial result of the reduction (in this example, the sum of all processed integers so far) and the next element of the stream (in this example, an integer). It returns a new partial result. In this example, the accumulator function is a lambda expression that adds two `Integer` values and returns an `Integer` value: (a, b) -&gt; a + b The reduce operation always returns a new value. However, the accumulator function also returns a new value every time it processes an element of a stream. Suppose that you want to reduce the elements of a stream to a more complex object, such as a collection. This might hinder the performance of your application. If your reduce operation involves adding elements to a collection, then every time your accumulator function processes an element, it creates a new collection that includes the element, which is inefficient. It would be more efficient for you to update an existing collection instead. You can do this with theStream.collect method, which the next section describes. The Stream.collect MethodUnlike the reduce method, which always creates a new value when it processes an element, thecollect method modifies, or mutates, an existing value. Consider how to find the average of values in a stream. You require two pieces of data: the total number of values and the sum of those values. However, like the reduce method and all other reduction methods, the collect method returns only one value. You can create a new data type that contains member variables that keep track of the total number of values and the sum of those values, such as the following class,Averager: 123456789101112131415161718192021222324252627supplier&lt;&#x2F;code&gt;: The supplier is a factory function; it constructs new instances. For the &#96;collect&#96; operation, it creates instances of the result container. In this example, it is a new instance of the &#96;Averager&#96; class.&lt;&#x2F;li&gt; - &#96;accumulator&#96;: The accumulator function incorporates a stream element into a result container. In this example, it modifies the &#96;Averager&#96; result container by incrementing the &#96;count&#96; variable by one and adding to the &#96;total&#96; member variable the value of the stream element, which is an integer representing the age of a male member. - &#96;combiner&#96;: The combiner function takes two result containers and merges their contents. In this example, it modifies an &#96;Averager&#96; result container by incrementing the &#96;count&#96; variable by the &#96;count&#96; member variable of the other &#96;Averager&#96; instance and adding to the &#96;total&#96; member variable the value of the other &#96;Averager&#96; instance&#39;s &#96;total&#96; member variable.&lt;&#x2F;ul&gt; Note the following:&lt;ul&gt; - The supplier is a lambda expression (or a method reference) as opposed to a value like the identity element in the &#96;reduce&#96; operation. - The accumulator and combiner functions do not return a value. &lt;li&gt;You can use the &#96;collect&#96; operations with parallel streams; see the section[Parallelism](..&#x2F;..&#x2F;collections&#x2F;streams&#x2F;parallelism.html) for more information. (If you run the &#96;collect&#96; method with a parallel stream, then the JDK creates a new thread whenever the combiner function creates a new object, such as an &#96;Averager&#96; object in this example. Consequently, you do not have to worry about synchronization.)&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;Although the JDK provides you with the &#96;average&#96; operation to calculate the average value of elements in a stream, you can use the &#96;collect&#96; operation and a custom class if you need to calculate several values from the elements of a stream.The &#96;collect&#96; operation is best suited for collections. The following example puts the names of the male members in a collection with the &#96;collect&#96; operation:&lt;pre class&#x3D;&quot;codeblock&quot;&gt;List&lt;String&gt; namesOfMaleMembersCollect &#x3D; roster .stream() .filter(p -&gt; p.getGender() &#x3D;&#x3D; Person.Sex.MALE) .map(p -&gt; p.getName()) .collect(Collectors.toList()); The supplier is a lambda expression (or a method reference) as opposed to a value like the identity element in the reduce operation. The accumulator and combiner functions do not return a value. You can use the `collect` operations with parallel streams; see the section [Parallelism](../../collections/streams/parallelism.html) for more information. (If you run the `collect` method with a parallel stream, then the JDK creates a new thread whenever the combiner function creates a new object, such as an `Averager` object in this example. Consequently, you do not have to worry about synchronization.) This version of the collect operation takes one parameter of typeCollector. This class encapsulates the functions used as arguments in the collect operation that requires three arguments (supplier, accumulator, and combiner functions). TheCollectors class contains many useful reduction operations, such as accumulating elements into collections and summarizing elements according to various criteria. These reduction operations return instances of the class Collector, so you can use them as a parameter for the collect operation. This example uses theCollectors.toList operation, which accumulates the stream elements into a new instance of List. As with most operations in the Collectors class, the toList operator returns an instance of Collector, not a collection. The following example groups members of the collection roster by gender: 12345678910111213groupingBy&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; operation returns a map whose keys are the values that result from applying the lambda expression specified as its parameter (which is called a **classification function**). In this example, the returned map contains two keys, &#96;Person.Sex.MALE&#96; and &#96;Person.Sex.FEMALE&#96;. The keys&#39; corresponding values are instances of &#96;List&#96; that contain the stream elements that, when processed by the classification function, correspond to the key value. For example, the value that corresponds to key &#96;Person.Sex.MALE&#96; is an instance of &#96;List&#96; that contains all male members.&lt;&#x2F;p&gt;The following example retrieves the names of each member in the collection &#96;roster&#96; and groups them by gender:&lt;pre class&#x3D;&quot;codeblock&quot;&gt;Map&lt;Person.Sex, List&lt;String&gt;&gt; namesByGender &#x3D; roster .stream() .collect( Collectors.groupingBy( Person::getGender, Collectors.mapping( Person::getName, Collectors.toList()))); ThegroupingBy operation in this example takes two parameters, a classification function and an instance of Collector. The Collector parameter is called a downstream collector. This is a collector that the Java runtime applies to the results of another collector. Consequently, this groupingBy operation enables you to apply a collect method to the List values created by the groupingBy operator. This example applies the collectormapping, which applies the mapping function Person::getName to each element of the stream. Consequently, the resulting stream consists of only the names of members. A pipeline that contains one or more downstream collectors, like this example, is called a multilevel reduction. The following example retrieves the total age of members of each gender: 123456789101112131415161718reducing&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; operation takes three parameters:&lt;&#x2F;p&gt;&lt;ul&gt; - &#96;identity&#96;: Like the &#96;Stream.reduce&#96; operation, the identity element is both the initial value of the reduction and the default result if there are no elements in the stream. In this example, the identity element is &#96;0&#96;; this is the initial value of the sum of ages and the default value if no members exist. - &#96;mapper&#96;: The &#96;reducing&#96; operation applies this mapper function to all stream elements. In this example, the mapper retrieves the age of each member. - &#96;operation&#96;: The operation function is used to reduce the mapped values. In this example, the operation function adds &#96;Integer&#96; values.&lt;&#x2F;ul&gt;The following example retrieves the average age of members of each gender:&lt;pre class&#x3D;&quot;codeblock&quot;&gt;Map&lt;Person.Sex, Double&gt; averageAgeByGender &#x3D; roster .stream() .collect( Collectors.groupingBy( Person::getGender, Collectors.averagingInt(Person::getAge)));","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Aggregate Operations","date":"2020-12-05T17:52:51.764Z","path":"wiki/2021-03-03-Aggregate Operations/","text":"Lesson: Aggregate OperationsNote: To better understand the concepts in this section, review the sectionsLambda Expressions andMethod References. For what do you use collections? You don’t simply store objects in a collection and leave them there. In most cases, you use collections to retrieve items stored in them. Consider again the scenario described in the sectionLambda Expressions. Suppose that you are creating a social networking application. You want to create a feature that enables an administrator to perform any kind of action, such as sending a message, on members of the social networking application that satisfy certain criteria. As before, suppose that members of this social networking application are represented by the followingPerson class: 12345678910BulkDataOperationsExamples&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;&lt;h3&gt;&lt;a name&#x3D;&quot;pipelines&quot; id&#x3D;&quot;pipelines&quot;&gt;Pipelines and Streams&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;A **pipeline** is a sequence of aggregate operations. The following example prints the male members contained in the collection &#96;roster&#96; with a pipeline that consists of the aggregate operations &#96;filter&#96; and &#96;forEach&#96;:&lt;pre class&#x3D;&quot;codeblock&quot;&gt;roster .stream() .filter(e -&gt; e.getGender() &#x3D;&#x3D; Person.Sex.MALE) .forEach(e -&gt; System.out.println(e.getName())); Compare this example to the following that prints the male members contained in the collection roster with a for-each loop: A pipeline contains the following components: - A source: This could be a collection, an array, a generator function, or an I/O channel. In this example, the source is the collection `roster`. &lt;li&gt;Zero or more **intermediate operations**. An intermediate operation, such as `filter`, produces a new stream. A **stream** is a sequence of elements. Unlike a collection, it is not a data structure that stores elements. Instead, a stream carries values from a source through a pipeline. This example creates a stream from the collection `roster` by invoking the method `stream`. The `filter` operation returns a new stream that contains elements that match its predicate (this operation&#39;s parameter). In this example, the predicate is the lambda expression `e -&amp;gt; e.getGender() == Person.Sex.MALE`. It returns the boolean value `true` if the `gender` field of object `e` has the value `Person.Sex.MALE`. Consequently, the `filter` operation in this example returns a stream that contains all male members in the collection `roster`.&lt;/li&gt; - A **terminal operation**. A terminal operation, such as `forEach`, produces a non-stream result, such as a primitive value (like a double value), a collection, or in the case of `forEach`, no value at all. In this example, the parameter of the `forEach` operation is the lambda expression `e -&amp;gt; System.out.println(e.getName())`, which invokes the method `getName` on the object `e`. (The Java runtime and compiler infer that the type of the object `e` is `Person`.) The following example calculates the average age of all male members contained in the collection roster with a pipeline that consists of the aggregate operations filter, mapToInt, and average: The mapToInt operation returns a new stream of type IntStream (which is a stream that contains only integer values). The operation applies the function specified in its parameter to each element in a particular stream. In this example, the function is Person::getAge, which is a method reference that returns the age of the member. (Alternatively, you could use the lambda expression e -&amp;gt; e.getAge().) Consequently, the mapToInt operation in this example returns a stream that contains the ages of all male members in the collection roster. The average operation calculates the average value of the elements contained in a stream of type IntStream. It returns an object of type OptionalDouble. If the stream contains no elements, then the average operation returns an empty instance of OptionalDouble, and invoking the method getAsDouble throws a NoSuchElementException. The JDK contains many terminal operations such as average that return one value by combining the contents of a stream. These operations are called reduction operations; see the sectionReduction for more information. Differences Between Aggregate Operations and IteratorsAggregate operations, like forEach, appear to be like iterators. However, they have several fundamental differences: **They use internal iteration**: Aggregate operations do not contain a method like `next` to instruct them to process the next element of the collection. With **internal delegation**, your application determines **what** collection it iterates, but the JDK determines **how** to iterate the collection. With **external iteration**, your application determines both what collection it iterates and how it iterates it. However, external iteration can only iterate over the elements of a collection sequentially. Internal iteration does not have this limitation. It can more easily take advantage of parallel computing, which involves dividing a problem into subproblems, solving those problems simultaneously, and then combining the results of the solutions to the subproblems. See the section [Parallelism](../../collections/streams/parallelism.html) for more information. - **They process elements from a stream**: Aggregate operations process elements from a stream, not directly from a collection. Consequently, they are also called **stream operations**. **They support behavior as parameters**: You can specify [lambda expressions](../../java/javaOO/lambdaexpressions.html) as parameters for most aggregate operations. This enables you to customize the behavior of a particular aggregate operation.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Questions and Exercises  Interfaces","date":"2020-12-05T17:52:49.654Z","path":"wiki/2021-03-03-Questions and Exercises  Interfaces/","text":"Questions and Exercises: InterfacesQuestionsAt the beginning of this lesson, you learned that the core collection interfaces are organized into two distinct inheritance trees. One interface in particular is not considered to be a true `Collection`, and therefore sits at the top of its own tree. What is the name of this interface? Each interface in the collections framework is declared with the `&lt;E&gt;` syntax, which tells you that it is generic. When you declare a `Collection` instance, what is the advantage of specifying the type of objects that it will contain? What interface represents a collection that does not allow duplicate elements? What interface forms the root of the collections hierarchy? What interface represents an ordered collection that may contain duplicate elements? What interface represents a collection that holds elements prior to processing? What interface repesents a type that maps keys to values? What interface represents a double-ended queue? Name three different ways to iterate over the elements of a List. True or False: Aggregate operations are mutative operations that modify the underlying collection. ExercisesWrite a program that prints its arguments in random order. Do not make a copy of the argument array. Demonstrate how to print out the elements using both streams and the traditional enhanced for statement. Take the [`FindDups`](../examples/FindDups.java)example and modify it to use a `SortedSet` instead of a `Set`. Specify a `Comparator` so that case is ignored when sorting and identifying set elements. Write a method that takes a `List&lt;String&gt;` and applies [`String.trim`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--) to each element. Consider the four core interfaces, `Set`, `List`, `Queue`, and `Map`. For each of the following four assignments, specify which of the four core interfaces is best-suited, and explain how to use it to implement the assignment. Whimsical Toys Inc (WTI) needs to record the names of all its employees. Every month, an employee will be chosen at random from these records to receive a free toy. WTI has decided that each new product will be named after an employee but only first names will be used, and each name will be used only once. Prepare a list of unique first names. WTI decides that it only wants to use the most popular names for its toys. Count up the number of employees who have each first name. WTI acquires season tickets for the local lacrosse team, to be shared by employees. Create a waiting list for this popular sport. Check your answers.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Summary of Interfaces","date":"2020-12-05T17:52:47.569Z","path":"wiki/2021-03-03-Summary of Interfaces/","text":"Summary of InterfacesThe core collection interfaces are the foundation of the Java Collections Framework. The Java Collections Framework hierarchy consists of two distinct interface trees: The first tree starts with the Collection interface, which provides for the basic functionality used by all collections, such as add and remove methods. Its subinterfaces &#151; Set, List, and Queue &#151; provide for more specialized collections. The Set interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The Set interface has a subinterface, SortedSet, that provides for ordering of elements in the set. The List interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a List by their exact position. The Queue interface enables additional insertion, extraction, and inspection operations. Elements in a Queue are typically ordered in on a FIFO basis. The Deque interface enables insertion, deletion, and inspection operations at both the ends. Elements in a Deque can be used in both LIFO and FIFO. The second tree starts with the Map interface, which maps keys and values similar to a Hashtable.`Map`'s subinterface, `SortedMap`, maintains its key-value pairs in ascending order or in an order specified by a `Comparator`. These interfaces allow collections to be manipulated independently of the details of their representation.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"The SortedMap Interface","date":"2020-12-05T17:52:45.707Z","path":"wiki/2021-03-03-The SortedMap Interface/","text":"The SortedMap InterfaceASortedMap is aMap that maintains its entries in ascending order, sorted according to the keys’ natural ordering, or according to a Comparator provided at the time of the SortedMap creation. Natural ordering and Comparators are discussed in theObject Ordering section. The SortedMap interface provides operations for normal Map operations and for the following: Range view &#151; performs arbitrary range operations on the sorted map Endpoints &#151; returns the first or the last key in the sorted map Comparator access &#151; returns the Comparator, if any, used to sort the map The following interface is the Map analog ofSortedSet. 12345678910public interface SortedMap&lt;K, V&gt; extends Map&lt;K, V&gt;&#123; Comparator&lt;? super K&gt; comparator(); SortedMap&lt;K, V&gt; subMap(K fromKey, K toKey); SortedMap&lt;K, V&gt; headMap(K toKey); SortedMap&lt;K, V&gt; tailMap(K fromKey); K firstKey(); K lastKey();&#125; Map OperationsThe operations SortedMap inherits from Map behave identically on sorted maps and normal maps with two exceptions: The Iterator returned by the iterator operation on any of the sorted map’s Collection views traverse the collections in order. The arrays returned by the Collection views’ toArray operations contain the keys, values, or entries in order. Although it isn’t guaranteed by the interface, the toString method of the Collection views in all the Java platform’s SortedMap implementations returns a string containing all the elements of the view, in order. Standard ConstructorsBy convention, all general-purpose Map implementations provide a standard conversion constructor that takes a Map; SortedMap implementations are no exception. In TreeMap, this constructor creates an instance that orders its entries according to their keys’ natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified Map instance was a SortedMap and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because TreeMap took the approach it did, it also provides a constructor that takes a SortedMap and returns a new TreeMap containing the same mappings as the given SortedMap, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the SortedMap constructor is invoked in preference to the ordinary map constructor. SortedMap implementations also provide, by convention, a constructor that takes a Comparator and returns an empty map sorted according to the specified Comparator. If null is passed to this constructor, it returns a Map that sorts its mappings according to their keys’ natural ordering. Comparison to SortedSetBecause this interface is a precise Map analog of SortedSet, all the idioms and code examples inThe SortedSet Interface section apply to SortedMap with only trivial modifications.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"The SortedSet Interface","date":"2020-12-05T17:52:43.495Z","path":"wiki/2021-03-03-The SortedSet Interface/","text":"The SortedSet InterfaceASortedSet is aSet that maintains its elements in ascending order, sorted according to the elements’ natural ordering or according to a Comparator provided at SortedSet creation time. In addition to the normal Set operations, the SortedSet interface provides operations for the following: Range view &#151; allows arbitrary range operations on the sorted set Endpoints &#151; returns the first or last element in the sorted set Comparator access &#151; returns the Comparator, if any, used to sort the set The code for the SortedSet interface follows. 123456789101112131415public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; &#123; &#x2F;&#x2F; Range-view SortedSet&lt;E&gt; subSet(E fromElement, E toElement); SortedSet&lt;E&gt; headSet(E toElement); SortedSet&lt;E&gt; tailSet(E fromElement); &#x2F;&#x2F; Endpoints E first(); E last(); &#x2F;&#x2F; Comparator access Comparator&lt;? super E&gt; comparator();&#125; Set OperationsThe operations that SortedSet inherits from Set behave identically on sorted sets and normal sets with two exceptions: The Iterator returned by the iterator operation traverses the sorted set in order. The array returned by toArray contains the sorted set’s elements in order. Although the interface doesn’t guarantee it, the toString method of the Java platform’s SortedSet implementations returns a string containing all the elements of the sorted set, in order. Standard ConstructorsBy convention, all general-purpose Collection implementations provide a standard conversion constructor that takes a Collection; SortedSet implementations are no exception. In TreeSet, this constructor creates an instance that sorts its elements according to their natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified collection was a SortedSet instance and, if so, to sort the new TreeSet according to the same criterion (comparator or natural ordering). Because TreeSet took the approach that it did, it also provides a constructor that takes a SortedSet and returns a new TreeSet containing the same elements sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines which of these two constructors is invoked (and whether the sorting criterion is preserved). SortedSet implementations also provide, by convention, a constructor that takes a Comparator and returns an empty set sorted according to the specified Comparator. If null is passed to this constructor, it returns a set that sorts its elements according to their natural ordering. Range-view OperationsThe range-view operations are somewhat analogous to those provided by the List interface, but there is one big difference. Range views of a sorted set remain valid even if the backing sorted set is modified directly. This is feasible because the endpoints of a range view of a sorted set are absolute points in the element space rather than specific elements in the backing collection, as is the case for lists. A range-view of a sorted set is really just a window onto whatever portion of the set lies in the designated part of the element space. Changes to the range-view write back to the backing sorted set and vice versa. Thus, it’s okay to use range-views on sorted sets for long periods of time, unlike range-views on lists. Sorted sets provide three range-view operations. The first, subSet, takes two endpoints, like subList. Rather than indices, the endpoints are objects and must be comparable to the elements in the sorted set, using the Set‘s Comparator or the natural ordering of its elements, whichever the Set uses to order itself. Like subList, the range is half open, including its low endpoint but excluding the high one. Thus, the following line of code tells you how many words between &quot;doorbell&quot; and &quot;pickle&quot;, including &quot;doorbell&quot; but excluding &quot;pickle&quot;, are contained in a SortedSet of strings called dictionary: 123int count &#x3D; dictionary.subSet(&quot;doorbell&quot;, &quot;pickle&quot;).size(); In like manner, the following one-liner removes all the elements beginning with the letter f. 123dictionary.subSet(&quot;f&quot;, &quot;g&quot;).clear(); A similar trick can be used to print a table telling you how many words begin with each letter. 1234567for (char ch &#x3D; &#39;a&#39;; ch &lt;&#x3D; &#39;z&#39;; ) &#123; String from &#x3D; String.valueOf(ch++); String to &#x3D; String.valueOf(ch); System.out.println(from + &quot;: &quot; + dictionary.subSet(from, to).size());&#125; Suppose you want to view a closed interval, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the subSet from lowEndpoint to successor(highEndpoint). Although it isn’t entirely obvious, the successor of a string s in String‘s natural ordering is s + &quot;\\0&quot; &#151; that is, s with a null character appended. Thus, the following one-liner tells you how many words between &quot;doorbell&quot; and &quot;pickle&quot;, including doorbell and pickle, are contained in the dictionary. 123count &#x3D; dictionary.subSet(&quot;doorbell&quot;, &quot;pickle\\0&quot;).size(); A similar technique can be used to view an open interval, which contains neither endpoint. The open-interval view from lowEndpoint to highEndpoint is the half-open interval from successor(lowEndpoint) to highEndpoint. Use the following to calculate the number of words between &quot;doorbell&quot; and &quot;pickle&quot;, excluding both. 123count &#x3D; dictionary.subSet(&quot;doorbell\\0&quot;, &quot;pickle&quot;).size(); The SortedSet interface contains two more range-view operations &#151; headSet and tailSet, both of which take a single Object argument. The former returns a view of the initial portion of the backing SortedSet, up to but not including the specified object. The latter returns a view of the final portion of the backing SortedSet, beginning with the specified object and continuing to the end of the backing SortedSet. Thus, the following code allows you to view the dictionary as two disjoint volumes (a-m and n-z). 1234SortedSet&lt;String&gt; volume1 &#x3D; dictionary.headSet(&quot;n&quot;);SortedSet&lt;String&gt; volume2 &#x3D; dictionary.tailSet(&quot;n&quot;); Endpoint OperationsThe SortedSet interface contains operations to return the first and last elements in the sorted set, not surprisingly called first and last. In addition to their obvious uses, last allows a workaround for a deficiency in the SortedSet interface. One thing you’d like to do with a SortedSet is to go into the interior of the Set and iterate forward or backward. It’s easy enough to go forward from the interior: Just get a tailSet and iterate over it. Unfortunately, there’s no easy way to go backward. The following idiom obtains the first element that is less than a specified object o in the element space. 123Object predecessor &#x3D; ss.headSet(o).last(); This is a fine way to go one element backward from a point in the interior of a sorted set. It could be applied repeatedly to iterate backward, but this is very inefficient, requiring a lookup for each element returned. Comparator AccessorThe SortedSet interface contains an accessor method called comparator that returns the Comparator used to sort the set, or null if the set is sorted according to the natural ordering of its elements. This method is provided so that sorted sets can be copied into new sorted sets with the same ordering. It is used by the SortedSet constructor described previously.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Object Ordering","date":"2020-12-05T17:52:41.210Z","path":"wiki/2021-03-03-Object Ordering/","text":"Object OrderingA List l may be sorted as follows. 123Collections.sort(l); If the List consists of String elements, it will be sorted into alphabetical order. If it consists of Date elements, it will be sorted into chronological order. How does this happen? String and Date both implement the Comparable interface. Comparable implementations provide a natural ordering for a class, which allows objects of that class to be sorted automatically. Thefollowing table summarizes some of the more important Java platform classes that implement Comparable. ClassNatural Ordering `Byte`Signed numerical `Character`Unsigned numerical `Long`Signed numerical `Integer`Signed numerical `Short`Signed numerical `Double`Signed numerical `Float`Signed numerical `BigInteger`Signed numerical `BigDecimal`Signed numerical `Boolean``Boolean.FALSE &lt; Boolean.TRUE` `File`System-dependent lexicographic on path name `String`Lexicographic `Date`Chronological `CollationKey`Locale-specific lexicographic If you try to sort a list, the elements of which do not implement Comparable, Collections.sort(list) will throw aClassCastException. Similarly, Collections.sort(list, comparator) will throw a ClassCastException if you try to sort a list whose elements cannot be compared to one another using the comparator. Elements that can be compared to one another are called mutually comparable. Although elements of different types may be mutually comparable, none of the classes listed here permit interclass comparison. This is all you really need to know about the Comparable interface if you just want to sort lists of comparable elements or to create sorted collections of them. The next section will be of interest to you if you want to implement your own Comparable type. Writing Your Own Comparable TypesThe Comparable interface consists of the following method. 12345public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; The compareTo method compares the receiving object with the specified object and returns a negative integer, 0, or a positive integer depending on whether the receiving object is less than, equal to, or greater than the specified object. If the specified object cannot be compared to the receiving object, the method throws a ClassCastException. Thefollowing class representing a person&#39;s name implements Comparable. 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class Name implements Comparable&lt;Name&gt; &#123; private final String firstName, lastName; public Name(String firstName, String lastName) &#123; if (firstName &#x3D;&#x3D; null || lastName &#x3D;&#x3D; null) throw new NullPointerException(); this.firstName &#x3D; firstName; this.lastName &#x3D; lastName; &#125; public String firstName() &#123; return firstName; &#125; public String lastName() &#123; return lastName; &#125; public boolean equals(Object o) &#123; if (!(o instanceof Name)) return false; Name n &#x3D; (Name) o; return n.firstName.equals(firstName) &amp;&amp; n.lastName.equals(lastName); &#125; public int hashCode() &#123; return 31*firstName.hashCode() + lastName.hashCode(); &#125; public String toString() &#123; return firstName + &quot; &quot; + lastName; &#125; public int compareTo(Name n) &#123; int lastCmp &#x3D; lastName.compareTo(n.lastName); return (lastCmp !&#x3D; 0 ? lastCmp : firstName.compareTo(n.firstName)); &#125;&#125; To keep the preceding example short, the class is somewhat limited: It doesn’t support middle names, it demands both a first and a last name, and it is not internationalized in any way. Nonetheless, it illustrates the following important points: Name objects are immutable. All other things being equal, immutable types are the way to go, especially for objects that will be used as elements in Sets or as keys in Maps. These collections will break if you modify their elements or keys while they’re in the collection. The constructor checks its arguments for null. This ensures that all Name objects are well formed so that none of the other methods will ever throw a NullPointerException. The hashCode method is redefined. This is essential for any class that redefines the equals method. (Equal objects must have equal hash codes.) The equals method returns false if the specified object is null or of an inappropriate type. The compareTo method throws a runtime exception under these circumstances. Both of these behaviors are required by the general contracts of the respective methods. The toString method has been redefined so it prints the Name in human-readable form. This is always a good idea, especially for objects that are going to get put into collections. The various collection types’ toString methods depend on the toString methods of their elements, keys, and values. Since this section is about element ordering, let’s talk a bit more about Name‘s compareTo method. It implements the standard name-ordering algorithm, where last names take precedence over first names. This is exactly what you want in a natural ordering. It would be very confusing indeed if the natural ordering were unnatural! Take a look at how compareTo is implemented, because it’s quite typical. First, you compare the most significant part of the object (in this case, the last name). Often, you can just use the natural ordering of the part’s type. In this case, the part is a String and the natural (lexicographic) ordering is exactly what’s called for. If the comparison results in anything other than zero, which represents equality, you’re done: You just return the result. If the most significant parts are equal, you go on to compare the next most-significant parts. In this case, there are only two parts &#151; first name and last name. If there were more parts, you’d proceed in the obvious fashion, comparing parts until you found two that weren’t equal or you were comparing the least-significant parts, at which point you’d return the result of the comparison. Just to show that it all works, here’sa program that builds a list of names and sorts them. 123456789101112131415161718import java.util.*;public class NameSort &#123; public static void main(String[] args) &#123; Name nameArray[] &#x3D; &#123; new Name(&quot;John&quot;, &quot;Smith&quot;), new Name(&quot;Karl&quot;, &quot;Ng&quot;), new Name(&quot;Jeff&quot;, &quot;Smith&quot;), new Name(&quot;Tom&quot;, &quot;Rich&quot;) &#125;; List&lt;Name&gt; names &#x3D; Arrays.asList(nameArray); Collections.sort(names); System.out.println(names); &#125;&#125; If you run this program, here’s what it prints. 123[Karl Ng, Tom Rich, Jeff Smith, John Smith] There are four restrictions on the behavior of the compareTo method, which we won’t go into now because they’re fairly technical and boring and are better left in the API documentation. It’s really important that all classes that implement Comparable obey these restrictions, so read the documentation for Comparable if you’re writing a class that implements it. Attempting to sort a list of objects that violate the restrictions has undefined behavior. Technically speaking, these restrictions ensure that the natural ordering is a total order on the objects of a class that implements it; this is necessary to ensure that sorting is well defined. ComparatorsWhat if you want to sort some objects in an order other than their natural ordering? Or what if you want to sort some objects that don’t implement Comparable? To do either of these things, you’ll need to provide aComparator &#151; an object that encapsulates an ordering. Like the Comparable interface, the Comparator interface consists of a single method. 12345public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125; The compare method compares its two arguments, returning a negative integer, 0, or a positive integer depending on whether the first argument is less than, equal to, or greater than the second. If either of the arguments has an inappropriate type for the Comparator, the compare method throws a ClassCastException. Much of what was said about Comparable applies to Comparator as well. Writing a compare method is nearly identical to writing a compareTo method, except that the former gets both objects passed in as arguments. The compare method has to obey the same four technical restrictions as Comparable‘s compareTo method for the same reason &#151; a Comparator must induce a total order on the objects it compares. Suppose you have a class called Employee, as follows. 12345678public class Employee implements Comparable&lt;Employee&gt; &#123; public Name name() &#123; ... &#125; public int number() &#123; ... &#125; public Date hireDate() &#123; ... &#125; ...&#125; Let’s assume that the natural ordering of Employee instances is Name ordering (as defined in the previous example) on employee name. Unfortunately, the boss has asked for a list of employees in order of seniority. This means we have to do some work, but not much. The following program will produce the required list. 1234567891011121314151617181920import java.util.*;public class EmpSort &#123; static final Comparator&lt;Employee&gt; SENIORITY_ORDER &#x3D; new Comparator&lt;Employee&gt;() &#123; public int compare(Employee e1, Employee e2) &#123; return e2.hireDate().compareTo(e1.hireDate()); &#125; &#125;; &#x2F;&#x2F; Employee database static final Collection&lt;Employee&gt; employees &#x3D; ... ; public static void main(String[] args) &#123; List&lt;Employee&gt; e &#x3D; new ArrayList&lt;Employee&gt;(employees); Collections.sort(e, SENIORITY_ORDER); System.out.println(e); &#125;&#125; The Comparator in the program is reasonably straightforward. It relies on the natural ordering of Date applied to the values returned by the hireDate accessor method. Note that the Comparator passes the hire date of its second argument to its first rather than vice versa. The reason is that the employee who was hired most recently is the least senior; sorting in the order of hire date would put the list in reverse seniority order. Another technique people sometimes use to achieve this effect is to maintain the argument order but to negate the result of the comparison. 1234&#x2F;&#x2F; Don&#39;t do this!!return -r1.hireDate().compareTo(r2.hireDate()); You should always use the former technique in favor of the latter because the latter is not guaranteed to work. The reason for this is that the compareTo method can return any negative int if its argument is less than the object on which it is invoked. There is one negative int that remains negative when negated, strange as it may seem. 123-Integer.MIN_VALUE &#x3D;&#x3D; Integer.MIN_VALUE The Comparator in the preceding program works fine for sorting a List, but it does have one deficiency: It cannot be used to order a sorted collection, such as TreeSet, because it generates an ordering that is not compatible with equals. This means that this Comparator equates objects that the equals method does not. In particular, any two employees who were hired on the same date will compare as equal. When you’re sorting a List, this doesn’t matter; but when you’re using the Comparator to order a sorted collection, it’s fatal. If you use this Comparator to insert multiple employees hired on the same date into a TreeSet, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored. To fix this problem, simply tweak the Comparator so that it produces an ordering that is compatible with equals. In other words, tweak it so that the only elements seen as equal when using compare are those that are also seen as equal when compared using equals. The way to do this is to perform a two-part comparison (as for Name), where the first part is the one we’re interested in &#151; in this case, the hire date &#151; and the second part is an attribute that uniquely identifies the object. Here the employee number is the obvious attribute. This is the Comparator that results. 12345678910111213static final Comparator&lt;Employee&gt; SENIORITY_ORDER &#x3D; new Comparator&lt;Employee&gt;() &#123; public int compare(Employee e1, Employee e2) &#123; int dateCmp &#x3D; e2.hireDate().compareTo(e1.hireDate()); if (dateCmp !&#x3D; 0) return dateCmp; return (e1.number() &lt; e2.number() ? -1 : (e1.number() &#x3D;&#x3D; e2.number() ? 0 : 1)); &#125;&#125;; One last note: You might be tempted to replace the final return statement in the Comparator with the simpler: 123return e1.number() - e2.number(); Don’t do it unless you’re absolutely sure no one will ever have a negative employee number! This trick does not work in general because the signed integer type is not big enough to represent the difference of two arbitrary signed integers. If i is a large positive integer and j is a large negative integer, i - j will overflow and will return a negative integer. The resulting comparator violates one of the four technical restrictions we keep talking about (transitivity) and produces horrible, subtle bugs. This is not a purely theoretical concern; people get burned by it.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"The Map Interface","date":"2020-12-05T17:52:39.748Z","path":"wiki/2021-03-03-The Map Interface/","text":"The Map InterfaceAMap is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical function abstraction. The Map interface includes methods forbasic operations (such as put, get, remove,containsKey, containsValue, size, and empty),bulk operations (such as putAll and clear), andcollection views (such as keySet, entrySet, and values). 1234567891011121314151617181920212223242526272829public interface Map&lt;K,V&gt; &#123; &#x2F;&#x2F; Basic operations V put(K key, V value); V get(Object key); V remove(Object key); boolean containsKey(Object key); boolean containsValue(Object value); int size(); boolean isEmpty(); &#x2F;&#x2F; Bulk operations void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); &#x2F;&#x2F; Collection Views public Set&lt;K&gt; keySet(); public Collection&lt;V&gt; values(); public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); &#x2F;&#x2F; Interface for entrySet elements public interface Entry &#123; K getKey(); V getValue(); V setValue(V value); &#125;&#125; The Java platform contains three general-purpose Map implementations:HashMap,TreeMap, andLinkedHashMap. Their behavior and performance are precisely analogous to HashSet, TreeSet, and LinkedHashSet, as described inThe Set Interface section. The remainder of this page discusses the Map interface in detail.But first, here are some more examples of collecting to Maps using JDK 8 aggregate operations. Modeling real-world objects is a common task in object-oriented programming, so it is reasonable to think that some programs might, for example, group employees by department: 12345&#x2F;&#x2F; Group employees by departmentMap&lt;Department, List&lt;Employee&gt;&gt; byDept &#x3D; employees.stream().collect(Collectors.groupingBy(Employee::getDepartment)); Or compute the sum of all salaries by department: 123456&#x2F;&#x2F; Compute sum of salaries by departmentMap&lt;Department, Integer&gt; totalByDept &#x3D; employees.stream().collect(Collectors.groupingBy(Employee::getDepartment,Collectors.summingInt(Employee::getSalary))); Or perhaps group students by passing or failing grades: 12345&#x2F;&#x2F; Partition students into passing and failingMap&lt;Boolean, List&lt;Student&gt;&gt; passingFailing &#x3D; students.stream().collect(Collectors.partitioningBy(s -&gt; s.getGrade()&gt;&#x3D; PASS_THRESHOLD)); You could also group people by city: 12345&#x2F;&#x2F; Classify Person objects by cityMap&lt;String, List&lt;Person&gt;&gt; peopleByCity &#x3D; personStream.collect(Collectors.groupingBy(Person::getCity)); Or even cascade two collectors to classify people by state and city: 123456&#x2F;&#x2F; Cascade Collectors Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; peopleByStateAndCity &#x3D; personStream.collect(Collectors.groupingBy(Person::getState, Collectors.groupingBy(Person::getCity))) Again, these are but a few examples of how to use the new JDK 8 APIs. For in-depthcoverage of lambda expressions and aggregate operations see the lesson entitled Aggregate Operations. Comparison to HashtableIf you&#39;ve used Hashtable, you&#39;re already familiar with the general basics of Map. (Of course, Map is an interface, while Hashtable is a concrete implementation.) The following are the major differences: Map provides Collection views instead of direct support for iteration via Enumeration objects. Collection views greatly enhance the expressiveness of the interface, as discussed later in this section. Map allows you to iterate over keys, values, or key-value pairs; Hashtable does not provide the third option. Map provides a safe way to remove entries in the midst of iteration; Hashtable did not. Finally, Map fixes a minor deficiency in the Hashtable interface. Hashtable has a method called contains, which returns true if the Hashtable contains a given value. Given its name, you&#39;d expect this method to return true if the Hashtable contained a given key, because the key is the primary access mechanism for a Hashtable. The Map interface eliminates this source of confusion by renaming the method containsValue. Also, this improves the interface&#39;s consistency &#151; containsValue parallels containsKey. Map Interface Basic OperationsThe basic operations of Map (put, get, containsKey, containsValue, size, and isEmpty) behave exactly like their counterparts in Hashtable. Thefollowing program generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list. 123456789101112131415161718import java.util.*;public class Freq &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; m &#x3D; new HashMap&lt;String, Integer&gt;(); &#x2F;&#x2F; Initialize frequency table from command line for (String a : args) &#123; Integer freq &#x3D; m.get(a); m.put(a, (freq &#x3D;&#x3D; null) ? 1 : freq + 1); &#125; System.out.println(m.size() + &quot; distinct words:&quot;); System.out.println(m); &#125;&#125; The only tricky thing about this program is the second argument of the put statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command: 123java Freq if it is to be it is up to me to delegate The program yields the following output. 12348 distinct words:&#123;to&#x3D;3, delegate&#x3D;1, be&#x3D;1, it&#x3D;2, up&#x3D;1, if&#x3D;1, me&#x3D;1, is&#x3D;2&#125; Suppose you’d prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the Map from HashMap to TreeMap. Making this four-character change causes the program to generate the following output from the same command line. 12348 distinct words:&#123;be&#x3D;1, delegate&#x3D;1, if&#x3D;1, is&#x3D;2, it&#x3D;2, me&#x3D;1, to&#x3D;3, up&#x3D;1&#125; Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to LinkedHashMap. Doing so results in the following output. 12348 distinct words:&#123;if&#x3D;1, it&#x3D;2, is&#x3D;2, to&#x3D;3, be&#x3D;1, up&#x3D;1, me&#x3D;1, delegate&#x3D;1&#125; This flexibility provides a potent illustration of the power of an interface-based framework. Like theSetandListinterfaces, Map strengthens the requirements on the equals and hashCode methods so that two Map objects can be compared for logical equality without regard to their implementation types. Two Map instances are equal if they represent the same key-value mappings. By convention, all general-purpose Map implementations provide constructors that take a Map object and initialize the new Map to contain all the key-value mappings in the specified Map. This standard Map conversion constructor is entirely analogous to the standard Collection constructor: It allows the caller to create a Map of a desired implementation type that initially contains all of the mappings in another Map, regardless of the other Map‘s implementation type. For example, suppose you have a Map, named m. The following one-liner creates a new HashMap initially containing all of the same key-value mappings as m. 123Map&lt;K, V&gt; copy &#x3D; new HashMap&lt;K, V&gt;(m); Map Interface Bulk OperationsThe clear operation does exactly what you would think it could do: It removes all the mappings from the Map. The putAll operation is the Map analogue of the Collection interface’s addAll operation. In addition to its obvious use of dumping one Map into another, it has a second, more subtle use. Suppose a Map is used to represent a collection of attribute-value pairs; the putAll operation, in combination with the Map conversion constructor, provides a neat way to implement attribute map creation with default values. The following is a static factory method that demonstrates this technique. 1234567static &lt;K, V&gt; Map&lt;K, V&gt; newAttributeMap(Map&lt;K, V&gt;defaults, Map&lt;K, V&gt; overrides) &#123; Map&lt;K, V&gt; result &#x3D; new HashMap&lt;K, V&gt;(defaults); result.putAll(overrides); return result;&#125; Collection ViewsThe Collection view methods allow a Map to be viewed as a Collection in these three ways: keySet &#151; the Set of keys contained in the Map. values &#151; The Collection of values contained in the Map. This Collection is not a Set, because multiple keys can map to the same value. entrySet &#151; the Set of key-value pairs contained in the Map. The Map interface provides a small nested interface called Map.Entry, the type of the elements in this Set. The Collection views provide the only means to iterate over a Map. This example illustrates the standard idiom for iterating over the keys in a Map with a for-each construct: 1234for (KeyType key : m.keySet()) System.out.println(key); and with an iterator: 1234567&#x2F;&#x2F; Filter a map based on some &#x2F;&#x2F; property of its keys.for (Iterator&lt;Type&gt; it &#x3D; m.keySet().iterator(); it.hasNext(); ) if (it.next().isBogus()) it.remove(); The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs. 1234for (Map.Entry&lt;KeyType, ValType&gt; e : m.entrySet()) System.out.println(e.getKey() + &quot;: &quot; + e.getValue()); At first, many people worry that these idioms may be slow because the Map has to create a new Collection instance each time a Collection view operation is called. Rest easy: There’s no reason that a Map cannot always return the same object each time it is asked for a given Collection view. This is precisely what all the Map implementations in java.util do. With all three Collection views, calling an Iterator‘s remove operation removes the associated entry from the backing Map, assuming that the backing Map supports element removal to begin with. This is illustrated by the preceding filtering idiom. With the entrySet view, it is also possible to change the value associated with a key by calling a Map.Entry‘s setValue method during iteration (again, assuming the Map supports value modification to begin with). Note that these are the only safe ways to modify a Map during iteration; the behavior is unspecified if the underlying Map is modified in any other way while the iteration is in progress. The Collection views support element removal in all its many forms &#151; remove, removeAll, retainAll, and clear operations, as well as the Iterator.remove operation. (Yet again, this assumes that the backing Map supports element removal.) The Collection views do not support element addition under any circumstances. It would make no sense for the keySet and values views, and it’s unnecessary for the entrySet view, because the backing Map‘s put and putAll methods provide the same functionality. Fancy Uses of Collection Views: Map AlgebraWhen applied to the Collection views, bulk operations (containsAll, removeAll, and retainAll) are surprisingly potent tools. For starters, suppose you want to know whether one Map is a submap of another &#151; that is, whether the first Map contains all the key-value mappings in the second. The following idiom does the trick. 12345if (m1.entrySet().containsAll(m2.entrySet())) &#123; ...&#125; Along similar lines, suppose you want to know whether two Map objects contain mappings for all of the same keys. 12345if (m1.keySet().equals(m2.keySet())) &#123; ...&#125; Suppose you have a Map that represents a collection of attribute-value pairs, and two Sets representing required attributes and permissible attributes. (The permissible attributes include the required attributes.) The following snippet determines whether the attribute map conforms to these constraints and prints a detailed error message if it doesn’t. 1234567891011121314151617181920static &lt;K, V&gt; boolean validate(Map&lt;K, V&gt; attrMap, Set&lt;K&gt; requiredAttrs, Set&lt;K&gt;permittedAttrs) &#123; boolean valid &#x3D; true; Set&lt;K&gt; attrs &#x3D; attrMap.keySet(); if (! attrs.containsAll(requiredAttrs)) &#123; Set&lt;K&gt; missing &#x3D; new HashSet&lt;K&gt;(requiredAttrs); missing.removeAll(attrs); System.out.println(&quot;Missing attributes: &quot; + missing); valid &#x3D; false; &#125; if (! permittedAttrs.containsAll(attrs)) &#123; Set&lt;K&gt; illegal &#x3D; new HashSet&lt;K&gt;(attrs); illegal.removeAll(permittedAttrs); System.out.println(&quot;Illegal attributes: &quot; + illegal); valid &#x3D; false; &#125; return valid;&#125; Suppose you want to know all the keys common to two Map objects. 1234Set&lt;KeyType&gt;commonKeys &#x3D; new HashSet&lt;KeyType&gt;(m1.keySet());commonKeys.retainAll(m2.keySet()); A similar idiom gets you the common values. All the idioms presented thus far have been nondestructive; that is, they don’t modify the backing Map. Here are a few that do. Suppose you want to remove all of the key-value pairs that one Map has in common with another. 123m1.entrySet().removeAll(m2.entrySet()); Suppose you want to remove from one Map all of the keys that have mappings in another. 123m1.keySet().removeAll(m2.keySet()); What happens when you start mixing keys and values in the same bulk operation? Suppose you have a Map, managers, that maps each employee in a company to the employee’s manager. We’ll be deliberately vague about the types of the key and the value objects. It doesn’t matter, as long as they’re the same. Now suppose you want to know who all the “individual contributors” (or nonmanagers) are. The following snippet tells you exactly what you want to know. 1234Set&lt;Employee&gt; individualContributors &#x3D; new HashSet&lt;Employee&gt;(managers.keySet());individualContributors.removeAll(managers.values()); Suppose you want to fire all the employees who report directly to some manager, Simon. 1234Employee simon &#x3D; ... ;managers.values().removeAll(Collections.singleton(simon)); Note that this idiom makes use of Collections.singleton, a static factory method that returns an immutable Set with the single, specified element. Once you’ve done this, you may have a bunch of employees whose managers no longer work for the company (if any of Simon’s direct-reports were themselves managers). The following code will tell you which employees have managers who no longer works for the company. 12345Map&lt;Employee, Employee&gt; m &#x3D; new HashMap&lt;Employee, Employee&gt;(managers);m.values().removeAll(managers.keySet());Set&lt;Employee&gt; slackers &#x3D; m.keySet(); This example is a bit tricky. First, it makes a temporary copy of the Map, and it removes from the temporary copy all entries whose (manager) value is a key in the original Map. Remember that the original Map has an entry for each employee. Thus, the remaining entries in the temporary Map comprise all the entries from the original Map whose (manager) values are no longer employees. The keys in the temporary copy, then, represent precisely the employees that we’re looking for. There are many more idioms like the ones contained in this section, but it would be impractical and tedious to list them all. Once you get the hang of it, it’s not that difficult to come up with the right one when you need it. MultimapsA multimap is like a Map but it can map each key to multiple values. The Java Collections Framework doesn’t include an interface for multimaps because they aren’t used all that commonly. It’s a fairly simple matter to use a Map whose values are List instances as a multimap. This technique is demonstrated in the next code example, which reads a word list containing one word per line (all lowercase) and prints out all the anagram groups that meet a size criterion. An anagram group is a bunch of words, all of which contain exactly the same letters but in a different order. The program takes two arguments on the command line: (1) the name of the dictionary file and (2) the minimum size of anagram group to print out. Anagram groups containing fewer words than the specified minimum are not printed. There is a standard trick for finding anagram groups: For each word in the dictionary, alphabetize the letters in the word (that is, reorder the word’s letters into alphabetical order) and put an entry into a multimap, mapping the alphabetized word to the original word. For example, the word bad causes an entry mapping abd into bad to be put into the multimap. A moment’s reflection will show that all the words to which any given key maps form an anagram group. It’s a simple matter to iterate over the keys in the multimap, printing out each anagram group that meets the size constraint. The following program is a straightforward implementation of this technique. 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;import java.io.*;public class Anagrams &#123; public static void main(String[] args) &#123; int minGroupSize &#x3D; Integer.parseInt(args[1]); &#x2F;&#x2F; Read words from file and put into a simulated multimap Map&lt;String, List&lt;String&gt;&gt; m &#x3D; new HashMap&lt;String, List&lt;String&gt;&gt;(); try &#123; Scanner s &#x3D; new Scanner(new File(args[0])); while (s.hasNext()) &#123; String word &#x3D; s.next(); String alpha &#x3D; alphabetize(word); List&lt;String&gt; l &#x3D; m.get(alpha); if (l &#x3D;&#x3D; null) m.put(alpha, l&#x3D;new ArrayList&lt;String&gt;()); l.add(word); &#125; &#125; catch (IOException e) &#123; System.err.println(e); System.exit(1); &#125; &#x2F;&#x2F; Print all permutation groups above size threshold for (List&lt;String&gt; l : m.values()) if (l.size() &gt;&#x3D; minGroupSize) System.out.println(l.size() + &quot;: &quot; + l); &#125; private static String alphabetize(String s) &#123; char[] a &#x3D; s.toCharArray(); Arrays.sort(a); return new String(a); &#125;&#125; Running this program on a 173,000-word dictionary file with a minimum anagram group size of eight produces the following output. 12345678910111213141516171819202122232425262728299: [estrin, inerts, insert, inters, niters, nitres, sinter, triens, trines]8: [lapse, leaps, pales, peals, pleas, salep, sepal, spale]8: [aspers, parses, passer, prases, repass, spares, sparse, spears]10: [least, setal, slate, stale, steal, stela, taels, tales, teals, tesla]8: [enters, nester, renest, rentes, resent, tenser, ternes, treens]8: [arles, earls, lares, laser, lears, rales, reals, seral]8: [earings, erasing, gainers, reagins, regains, reginas, searing, seringa]8: [peris, piers, pries, prise, ripes, speir, spier, spire]12: [apers, apres, asper, pares, parse, pears, prase, presa, rapes, reaps, spare, spear]11: [alerts, alters, artels, estral, laster, ratels, salter, slater, staler, stelar, talers]9: [capers, crapes, escarp, pacers, parsec, recaps, scrape, secpar, spacer]9: [palest, palets, pastel, petals, plates, pleats, septal, staple, tepals]9: [anestri, antsier, nastier, ratines, retains, retinas, retsina, stainer, stearin]8: [ates, east, eats, etas, sate, seat, seta, teas]8: [carets, cartes, caster, caters, crates, reacts, recast, traces] Many of these words seem a bit bogus, but that’s not the program’s fault; they’re in the dictionary file.Here’s thedictionary file we used.It was derived from the Public Domain ENABLE benchmark reference word list.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"The Deque Interface","date":"2020-12-05T17:52:38.237Z","path":"wiki/2021-03-03-The Deque Interface/","text":"The Deque InterfaceUsually pronounced as deck, a deque is a double-ended-queue. A double-ended-queue is a linear collectionof elements that supports the insertion and removal of elements at both end points. The Deque interface is a richer abstract data type than both Stack and Queue because it implements both stacks and queues at the same time. TheDeque interface, defines methods to access the elements at both ends of the Deque instance. Methods are provided to insert, remove,and examine the elements. Predefined classes likeArrayDeque and LinkedList implement the Deque interface. Note that the Deque interface can be used both as last-in-first-out stacks and first-in-first-out queues.The methods given in the Deque interface are divided into three parts: InsertThe addfirst and offerFirst methods insert elements at the beginning of the Deque instance. The methods addLast and offerLast insert elements at the end of the Deque instance. When the capacity of the Deque instance is restricted, the preferred methods are offerFirst and offerLast because addFirst might fail to throw an exception if it is full. RemoveThe removeFirst and pollFirst methods remove elementsfrom the beginning of the Deque instance. The removeLast and pollLast methodsremove elements from the end. The methods pollFirstand pollLast return null if the Deque is empty whereas the methodsremoveFirst and removeLast throw an exception if the Deque instance is empty. RetrieveThe methods getFirst and peekFirst retrieve the first element of the Deque instance.These methods dont remove the value from the Deque instance. Similarly, the methods getLastand peekLast retrieve the last element.The methods getFirst and getLast throw an exception if thedeque instance is empty whereas the methods peekFirst and peekLastreturn NULL. The 12 methods for insertion, removal and retieval of Deque elements are summarized in the following table: &lt;th id=&quot;h1&quot;&gt;Type of Operation&lt;/th&gt; &lt;th id=&quot;h2&quot;&gt;First Element (Beginning of the `Deque` instance)&lt;/th&gt; &lt;th id=&quot;h3&quot;&gt;Last Element (End of the `Deque` instance)&lt;/th&gt; &lt;td headers=&quot;h1&quot;&gt;**Insert**&lt;/td&gt; &lt;td headers=&quot;h2&quot;&gt;`addFirst(e)`&lt;br /&gt;`offerFirst(e)`&lt;/td&gt; &lt;td headers=&quot;h3&quot;&gt;`addLast(e)`&lt;br /&gt;`offerLast(e)`&lt;/td&gt; &lt;td headers=&quot;h1&quot;&gt;**Remove**&lt;/td&gt; &lt;td headers=&quot;h2&quot;&gt;`removeFirst()`&lt;br /&gt;`pollFirst()`&lt;/td&gt; &lt;td headers=&quot;h3&quot;&gt;`removeLast()`&lt;br /&gt;`pollLast()`&lt;/td&gt; &lt;td headers=&quot;h1&quot;&gt;**Examine**&lt;/td&gt; &lt;td headers=&quot;h2&quot;&gt;`getFirst()`&lt;br /&gt;`peekFirst()`&lt;/td&gt; &lt;td headers=&quot;h3&quot;&gt;`getLast()`&lt;br /&gt;`peekLast()`&lt;/td&gt; In addition to these basic methods to insert,remove and examine a Deque instance, the Deque interface also hassome more predefined methods. One of these is removeFirstOccurence, this method removes thefirst occurence of the specified element if it exists in the Deque instance. If the element does not exist then the Deque instance remains unchanged.Another similar method is removeLastOccurence; this method removes the last occurence of the specified element in the Deque instance.The return type of these methods is boolean, and they return true if the element exists in the Deque instance.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"The Queue Interface","date":"2020-12-05T17:52:36.747Z","path":"wiki/2021-03-03-The Queue Interface/","text":"The Queue InterfaceAQueue is a collection for holding elements prior to processing. Besides basic Collection operations, queues provide additional insertion, removal, and inspection operations. The Queue interface follows. 123456789public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; E element(); boolean offer(E e); E peek(); E poll(); E remove();&#125; Each Queue method exists in two forms: (1) one throws an exception if the operation fails, and (2) the other returns a special value if the operation fails (either null or false, depending on the operation). The regular structure of the interface is illustrated inthe following table. Type of OperationThrows exceptionReturns special value Insert`add(e)``offer(e)` Remove`remove()``poll()` Examine`element()``peek()` Queues typically, but not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to their values &#151; see theObject Ordering section for details). Whatever ordering is used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. It is possible for a Queue implementation to restrict the number of elements that it holds; such queues are known as bounded. Some Queue implementations in java.util.concurrent are bounded, but the implementations in java.util are not. The add method, which Queue inherits from Collection, inserts an element unless it would violate the queue’s capacity restrictions, in which case it throws IllegalStateException. The offer method, which is intended solely for use on bounded queues, differs from add only in that it indicates failure to insert an element by returning false. The remove and poll methods both remove and return the head of the queue. Exactly which element gets removed is a function of the queue’s ordering policy. The remove and poll methods differ in their behavior only when the queue is empty. Under these circumstances, remove throws NoSuchElementException, while poll returns null. The element and peek methods return, but do not remove, the head of the queue. They differ from one another in precisely the same fashion as remove and poll: If the queue is empty, element throws NoSuchElementException, while peek returns null. Queue implementations generally do not allow insertion of null elements. The LinkedList implementation, which was retrofitted to implement Queue, is an exception. For historical reasons, it permits null elements, but you should refrain from taking advantage of this, because null is used as a special return value by the poll and peek methods. Queue implementations generally do not define element-based versions of the equals and hashCode methods but instead inherit the identity-based versions from Object. The Queue interface does not define the blocking queue methods, which are common in concurrent programming. These methods, which wait for elements to appear or for space to become available, are defined in the interfacejava.util.concurrent.BlockingQueue, which extends Queue. In the following example program, a queue is used to implement a countdown timer. The queue is preloaded with all the integer values from a number specified on the command line to zero, in descending order. Then, the values are removed from the queue and printed at one-second intervals. The program is artificial in that it would be more natural to do the same thing without using a queue, but it illustrates the use of a queue to store elements prior to subsequent processing. 123456789101112131415161718import java.util.*;public class Countdown &#123; public static void main(String[] args) throws InterruptedException &#123; int time &#x3D; Integer.parseInt(args[0]); Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;Integer&gt;(); for (int i &#x3D; time; i &gt;&#x3D; 0; i--) queue.add(i); while (!queue.isEmpty()) &#123; System.out.println(queue.remove()); Thread.sleep(1000); &#125; &#125;&#125; In the following example, a priority queue is used to sort a collection of elements. Again this program is artificial in that there is no reason to use it in favor of the sort method provided in Collections, but it illustrates the behavior of priority queues. 1234567891011static &lt;E&gt; List&lt;E&gt; heapSort(Collection&lt;E&gt; c) &#123; Queue&lt;E&gt; queue &#x3D; new PriorityQueue&lt;E&gt;(c); List&lt;E&gt; result &#x3D; new ArrayList&lt;E&gt;(); while (!queue.isEmpty()) result.add(queue.remove()); return result;&#125;","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"The List Interface","date":"2020-12-05T17:52:34.546Z","path":"wiki/2021-03-03-The List Interface/","text":"The List InterfaceAList is an orderedCollection (sometimes called a sequence). Lists may contain duplicate elements. In addition to the operations inherited from Collection, the List interface includes operations for the following: `Positional access` &#151; manipulates elements based on their numerical position in the list. This includes methods such as `get`, `set`, `add`, `addAll`, and `remove`. `Search` &#151; searches for a specified object in the list and returns its numerical position. Search methods include `indexOf` and `lastIndexOf`. `Iteration` &#151; extends `Iterator` semantics to take advantage of the list's sequential nature. The `listIterator` methods provide this behavior. - `Range-view` &#151; The `sublist` method performs arbitrary *range operations* on the list. The List interface follows. 123456789101112131415161718192021222324252627public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; &#x2F;&#x2F; Positional access E get(int index); &#x2F;&#x2F; optional E set(int index, E element); &#x2F;&#x2F; optional boolean add(E element); &#x2F;&#x2F; optional void add(int index, E element); &#x2F;&#x2F; optional E remove(int index); &#x2F;&#x2F; optional boolean addAll(int index, Collection&lt;? extends E&gt; c); &#x2F;&#x2F; Search int indexOf(Object o); int lastIndexOf(Object o); &#x2F;&#x2F; Iteration ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); &#x2F;&#x2F; Range-view List&lt;E&gt; subList(int from, int to);&#125; The Java platform contains two general-purpose List implementations.ArrayList, which is usually the better-performing implementation, andLinkedList which offers better performance under certain circumstances. Collection OperationsThe operations inherited from Collection all do about what you’d expect them to do, assuming you’re already familiar with them. If you’re not familiar with them from Collection, now would be a good time to readThe Collection Interface section. The remove operation always removes the first occurrence of the specified element from the list. The add and addAll operations always append the new element(s) to the end of the list. Thus, the following idiom concatenates one list to another. 123list1.addAll(list2); Here’s a nondestructive form of this idiom, which produces a third List consisting of the second list appended to the first. 1234List&lt;Type&gt; list3 &#x3D; new ArrayList&lt;Type&gt;(list1);list3.addAll(list2); Note that the idiom, in its nondestructive form, takes advantage of ArrayList‘s standard conversion constructor. And here’s an example (JDK 8 and later) that aggregates some names into a List: 12345List&lt;String&gt; list &#x3D; people.stream().map(Person::getName).collect(Collectors.toList()); Like theSet interface, List strengthens the requirements on the equals and hashCode methods so that two List objects can be compared for logical equality without regard to their implementation classes. Two List objects are equal if they contain the same elements in the same order. Positional Access and Search OperationsThe basic positional access operations are get, set, add and remove. (The set and remove operations return the old value that is being overwritten or removed.) Other operations (indexOf and lastIndexOf) returnthe first or last index of the specified element in the list. The addAll operation inserts all the elements of the specified Collection starting at the specified position. The elements are inserted in the order they are returned by the specified Collection‘s iterator. This call is the positional access analog of Collection‘s addAll operation. Here’s a little method to swap two indexed values in a List. 1234567public static &lt;E&gt; void swap(List&lt;E&gt; a, int i, int j) &#123; E tmp &#x3D; a.get(i); a.set(i, a.get(j)); a.set(j, tmp);&#125; Of course, there’s one big difference. This is a polymorphic algorithm: It swaps two elements in any List, regardless of its implementation type. Here’s another polymorphic algorithm that uses the preceding swap method. 123456public static void shuffle(List&lt;?&gt; list, Random rnd) &#123; for (int i &#x3D; list.size(); i &gt; 1; i--) swap(list, i - 1, rnd.nextInt(i));&#125; This algorithm, which is included in the Java platform’sCollections class, randomly permutes the specified list using the specified source of randomness. It’s a bit subtle: It runs up the list from the bottom, repeatedly swapping a randomly selected element into the current position. Unlike most naive attempts at shuffling, it’s fair (all permutations occur with equal likelihood, assuming an unbiased source of randomness) and fast (requiring exactly list.size()-1 swaps). The following program uses this algorithm to print the words in its argument list in random order. 12345678910111213import java.util.*;public class Shuffle &#123; public static void main(String[] args) &#123; List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(); for (String a : args) list.add(a); Collections.shuffle(list, new Random()); System.out.println(list); &#125;&#125; In fact, this program can be made even shorter and faster. TheArrays class has a static factory method called asList, which allows an array to be viewed as a List. This method does not copy the array. Changes in the List write through to the array and vice versa. The resulting List is not a general-purpose List implementation, because it doesn’t implement the (optional) add and remove operations: Arrays are not resizable. Taking advantage of Arrays.asList and calling the library version of shuffle, which uses a default source of randomness, you get the followingtiny program whose behavior is identical to the previous program. 1234567891011import java.util.*;public class Shuffle &#123; public static void main(String[] args) &#123; List&lt;String&gt; list &#x3D; Arrays.asList(args); Collections.shuffle(list); System.out.println(list); &#125;&#125; IteratorsAs you’d expect, the Iterator returned by List‘s iterator operation returns the elements of the list in proper sequence. List also provides a richer iterator, called a ListIterator, which allows you to traverse the list in either direction, modify the list during iteration, and obtain the current position of the iterator. The ListIterator interface follows. 12345678910111213public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void remove(); &#x2F;&#x2F;optional void set(E e); &#x2F;&#x2F;optional void add(E e); &#x2F;&#x2F;optional&#125; The three methods that ListIterator inherits from Iterator (hasNext, next, and remove) do exactly the same thing in both interfaces. The hasPrevious and the previous operations are exact analogues of hasNext and next. The former operations refer to the element before the (implicit) cursor, whereas the latter refer to the element after the cursor. The previous operation moves the cursor backward, whereas next moves it forward. Here’s the standard idiom for iterating backward through a list. 123456for (ListIterator&lt;Type&gt; it &#x3D; list.listIterator(list.size()); it.hasPrevious(); ) &#123; Type t &#x3D; it.previous(); ...&#125; Note the argument to listIterator in the preceding idiom. The List interface has two forms of the listIterator method. The form with no arguments returns a ListIterator positioned at the beginning of the list; the form with an int argument returns a ListIterator positioned at the specified index. The index refers to the element that would be returned by an initial call to next. An initial call to previous would return the element whose index was index-1. In a list of length n, there are n+1 valid values for index, from 0 to n, inclusive. Intuitively speaking, the cursor is always between two elements &#151; the one that would be returned by a call to previous and the one that would be returned by a call to next. The n+1 valid index values correspond to the n+1 gaps between elements, from the gap before the first element to the gap after the last one.The following figure shows the five possible cursor positions in a list containing four elements. The five possible cursor positions. Calls to next and previous can be intermixed, but you have to be a bit careful. The first call to previous returns the same element as the last call to next. Similarly, the first call to next after a sequence of calls to previous returns the same element as the last call to previous. It should come as no surprise that the nextIndex method returns the index of the element that would be returned by a subsequent call to next, and previousIndex returns the index of the element that would be returned by a subsequent call to previous. These calls are typically used either to report the position where something was found or to record the position of the ListIterator so that another ListIterator with identical position can be created. It should also come as no surprise that the number returned by nextIndex is always one greater than the number returned by previousIndex. This implies the behavior of the two boundary cases: (1) a call to previousIndex when the cursor is before the initial element returns -1 and (2) a call to nextIndex when the cursor is after the final element returns list.size(). To make all this concrete, the following is a possible implementation of List.indexOf. 123456789public int indexOf(E e) &#123; for (ListIterator&lt;E&gt; it &#x3D; listIterator(); it.hasNext(); ) if (e &#x3D;&#x3D; null ? it.next() &#x3D;&#x3D; null : e.equals(it.next())) return it.previousIndex(); &#x2F;&#x2F; Element not found return -1;&#125; Note that the indexOf method returns it.previousIndex() even though it is traversing the list in the forward direction. The reason is that it.nextIndex() would return the index of the element we are about to examine, and we want to return the index of the element we just examined. The Iterator interface provides the remove operation to remove the last element returned by next from the Collection. For ListIterator, this operation removes the last element returned by next or previous. The ListIterator interface provides two additional operations to modify the list &#151; set and add. The set method overwrites the last element returned by next or previous with the specified element. The following polymorphic algorithm uses set to replace all occurrences of one specified value with another. 1234567public static &lt;E&gt; void replace(List&lt;E&gt; list, E val, E newVal) &#123; for (ListIterator&lt;E&gt; it &#x3D; list.listIterator(); it.hasNext(); ) if (val &#x3D;&#x3D; null ? it.next() &#x3D;&#x3D; null : val.equals(it.next())) it.set(newVal);&#125; The only bit of trickiness in this example is the equality test between val and it.next. You need to special-case a val value of null to prevent a NullPointerException. The add method inserts a new element into the list immediately before the current cursor position. This method is illustrated in the following polymorphic algorithm to replace all occurrences of a specified value with the sequence of values contained in the specified list. 123456789101112public static &lt;E&gt; void replace(List&lt;E&gt; list, E val, List&lt;? extends E&gt; newVals) &#123; for (ListIterator&lt;E&gt; it &#x3D; list.listIterator(); it.hasNext(); )&#123; if (val &#x3D;&#x3D; null ? it.next() &#x3D;&#x3D; null : val.equals(it.next())) &#123; it.remove(); for (E e : newVals) it.add(e); &#125; &#125;&#125; Range-View OperationThe range-view operation, subList(int fromIndex, int toIndex), returns a List view of the portion of this list whose indices range from fromIndex, inclusive, to toIndex, exclusive. This half-open range mirrors the typical for loop. 12345for (int i &#x3D; fromIndex; i &lt; toIndex; i++) &#123; ...&#125; As the term view implies, the returned List is backed up by the List on which subList was called, so changes in the former are reflected in the latter. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a List can be used as a range operation by passing a subList view instead of a whole List. For example, the following idiom removes a range of elements from a List. 123list.subList(fromIndex, toIndex).clear(); Similar idioms can be constructed to search for an element in a range. 1234int i &#x3D; list.subList(fromIndex, toIndex).indexOf(o);int j &#x3D; list.subList(fromIndex, toIndex).lastIndexOf(o); Note that the preceding idioms return the index of the found element in the subList, not the index in the backing List. Any polymorphic algorithm that operates on a List, such as the replace and shuffle examples, works with the List returned by subList. Here’s a polymorphic algorithm whose implementation uses subList to deal a hand from a deck. That is, it returns a new List (the “hand”) containing the specified number of elements taken from the end of the specified List (the “deck”). The elements returned in the hand are removed from the deck. 123456789public static &lt;E&gt; List&lt;E&gt; dealHand(List&lt;E&gt; deck, int n) &#123; int deckSize &#x3D; deck.size(); List&lt;E&gt; handView &#x3D; deck.subList(deckSize - n, deckSize); List&lt;E&gt; hand &#x3D; new ArrayList&lt;E&gt;(handView); handView.clear(); return hand;&#125; Note that this algorithm removes the hand from the end of the deck. For many common List implementations, such as ArrayList, the performance of removing elements from the end of the list is substantially better than that of removing elements from the beginning. The following isa program that uses the dealHand method in combination with Collections.shuffle to generate hands from a normal 52-card deck. The program takes two command-line arguments: (1) the number of hands to deal and (2) the number of cards in each hand. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;public class Deal &#123; public static void main(String[] args) &#123; if (args.length &lt; 2) &#123; System.out.println(&quot;Usage: Deal hands cards&quot;); return; &#125; int numHands &#x3D; Integer.parseInt(args[0]); int cardsPerHand &#x3D; Integer.parseInt(args[1]); &#x2F;&#x2F; Make a normal 52-card deck. String[] suit &#x3D; new String[] &#123; &quot;spades&quot;, &quot;hearts&quot;, &quot;diamonds&quot;, &quot;clubs&quot; &#125;; String[] rank &#x3D; new String[] &#123; &quot;ace&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;jack&quot;, &quot;queen&quot;, &quot;king&quot; &#125;; List&lt;String&gt; deck &#x3D; new ArrayList&lt;String&gt;(); for (int i &#x3D; 0; i &lt; suit.length; i++) for (int j &#x3D; 0; j &lt; rank.length; j++) deck.add(rank[j] + &quot; of &quot; + suit[i]); &#x2F;&#x2F; Shuffle the deck. Collections.shuffle(deck); if (numHands * cardsPerHand &gt; deck.size()) &#123; System.out.println(&quot;Not enough cards.&quot;); return; &#125; for (int i &#x3D; 0; i &lt; numHands; i++) System.out.println(dealHand(deck, cardsPerHand)); &#125; public static &lt;E&gt; List&lt;E&gt; dealHand(List&lt;E&gt; deck, int n) &#123; int deckSize &#x3D; deck.size(); List&lt;E&gt; handView &#x3D; deck.subList(deckSize - n, deckSize); List&lt;E&gt; hand &#x3D; new ArrayList&lt;E&gt;(handView); handView.clear(); return hand; &#125;&#125; Running the program produces output like the following. 123456789101112% java Deal 4 5[8 of hearts, jack of spades, 3 of spades, 4 of spades, king of diamonds][4 of diamonds, ace of clubs, 6 of clubs, jack of hearts, queen of hearts][7 of spades, 5 of spades, 2 of diamonds, queen of diamonds, 9 of clubs][8 of spades, 6 of diamonds, ace of spades, 3 of hearts, ace of hearts] Although the subList operation is extremely powerful, some care must be exercised when using it. The semantics of the List returned by subList become undefined if elements are added to or removed from the backing List in any way other than via the returned List. Thus, it’s highly recommended that you use the List returned by subList only as a transient object &#151; to perform one or a sequence of range operations on the backing List. The longer you use the subList instance, the greater the probability that you’ll compromise it by modifying the backing List directly or through another subList object. Note that it is legal to modify a sublist of a sublist and to continue using the original sublist (though not concurrently). List AlgorithmsMost polymorphic algorithms in the Collections class apply specifically to List. Having all these algorithms at your disposal makes it very easy to manipulate lists. Here’s a summary of these algorithms, which are described in more detail in theAlgorithms section. sort &#151; sorts a List using a merge sort algorithm, which provides a fast, stable sort. (A stable sort is one that does not reorder equal elements.) shuffle &#151; randomly permutes the elements in a List. reverse &#151; reverses the order of the elements in a List. rotate &#151; rotates all the elements in a List by a specified distance. swap &#151; swaps the elements at specified positions in a List. replaceAll &#151; replaces all occurrences of one specified value with another. fill &#151; overwrites every element in a List with the specified value. copy &#151; copies the source List into the destination List. binarySearch &#151; searches for an element in an ordered List using the binary search algorithm. indexOfSubList &#151; returns the index of the first sublist of one List that is equal to another. lastIndexOfSubList &#151; returns the index of the last sublist of one List that is equal to another.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"The Set Interface","date":"2020-12-05T17:52:33.053Z","path":"wiki/2021-03-03-The Set Interface/","text":"The Set InterfaceASet is aCollection that cannot contain duplicate elements. It models the mathematical set abstraction. The Set interface contains only methods inherited from Collection and adds the restriction that duplicate elements are prohibited. Set also adds a stronger contract on the behavior of the equals and hashCode operations, allowing Set instances to be compared meaningfully even if their implementation types differ. Two Set instances are equal if they contain the same elements. The following is the Set interface. 12345678910111213141516171819202122232425262728public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; &#x2F;&#x2F; Basic operations int size(); boolean isEmpty(); boolean contains(Object element); &#x2F;&#x2F; optional boolean add(E element); &#x2F;&#x2F; optional boolean remove(Object element); Iterator&lt;E&gt; iterator(); &#x2F;&#x2F; Bulk operations boolean containsAll(Collection&lt;?&gt; c); &#x2F;&#x2F; optional boolean addAll(Collection&lt;? extends E&gt; c); &#x2F;&#x2F; optional boolean removeAll(Collection&lt;?&gt; c); &#x2F;&#x2F; optional boolean retainAll(Collection&lt;?&gt; c); &#x2F;&#x2F; optional void clear(); &#x2F;&#x2F; Array Operations Object[] toArray(); &lt;T&gt; T[] toArray(T[] a);&#125; The Java platform contains three general-purpose Set implementations: HashSet, TreeSet, and LinkedHashSet.HashSet, which stores its elements in a hash table, is the best-performing implementation; however it makes no guarantees concerning the order of iteration.TreeSet, which stores its elements in a red-black tree, orders its elements based on their values; it is substantially slower than HashSet.LinkedHashSet, which is implemented as a hash table with a linked list running through it, orders its elements based on the order in which they were inserted into the set (insertion-order). LinkedHashSet spares its clients from the unspecified, generally chaotic ordering provided by HashSet at a cost that is only slightly higher. Here’s a simple but useful Set idiom. Suppose you have a Collection, c, and you want to create another Collection containing the same elements but with all duplicates eliminated. The following one-liner does the trick. 123Collection&lt;Type&gt; noDups &#x3D; new HashSet&lt;Type&gt;(c); It works by creating a Set (which, by definition, cannot contain duplicates), initially containing all the elements in c. It uses the standard conversion constructor described in theThe Collection Interface section. Or, if using JDK 8 or later, you could easily collect into a Set using aggregate operations: 1234c.stream().collect(Collectors.toSet()); &#x2F;&#x2F; no duplicates Here’s a slightly longer example that accumulates a Collection of names into aTreeSet: 12345Set&lt;String&gt; set &#x3D; people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new)); And the following is a minor variant of the first idiom that preserves the order of the original collection while removing duplicate elements: 123Collection&lt;Type&gt; noDups &#x3D; new LinkedHashSet&lt;Type&gt;(c); The following is a generic method that encapsulates the preceding idiom, returning a Set of the same generic type as the one passed. 12345public static &lt;E&gt; Set&lt;E&gt; removeDups(Collection&lt;E&gt; c) &#123; return new LinkedHashSet&lt;E&gt;(c);&#125; Set Interface Basic OperationsThe size operation returns the number of elements in the Set (its cardinality). The isEmpty method does exactly what you think it would. The add method adds the specified element to the Set if it is not already present and returns a boolean indicating whether the element was added. Similarly, the remove method removes the specified element from the Set if it is present and returns a boolean indicating whether the element was present. The iterator method returns an Iterator over the Set. The followingprogram prints out all distinct words in its argument list.Two versions of this program are provided. The first uses JDK 8 aggregate operations. The second uses the for-each construct. Using JDK 8 Aggregate Operations: 1234567891011121314import java.util.*;import java.util.stream.*;public class FindDups &#123; public static void main(String[] args) &#123; Set&lt;String&gt; distinctWords &#x3D; Arrays.asList(args).stream() .collect(Collectors.toSet()); System.out.println(distinctWords.size()+ &quot; distinct words: &quot; + distinctWords); &#125;&#125; Using the for-each Construct: 12345678910111213import java.util.*;public class FindDups &#123; public static void main(String[] args) &#123; Set&lt;String&gt; s &#x3D; new HashSet&lt;String&gt;(); for (String a : args) s.add(a); System.out.println(s.size() + &quot; distinct words: &quot; + s); &#125;&#125; Now run either version of the program. 123java FindDups i came i saw i left The following output is produced: 1234 distinct words: [left, came, saw, i] Note that the code always refers to the Collection by its interface type (Set) rather than by its implementation type. This is a strongly recommended programming practice because it gives you the flexibility to change implementations merely by changing the constructor. If either of the variables used to store a collection or the parameters used to pass it around are declared to be of the Collection‘s implementation type rather than its interface type, all such variables and parameters must be changed in order to change its implementation type. Furthermore, there’s no guarantee that the resulting program will work. If the program uses any nonstandard operations present in the original implementation type but not in the new one, the program will fail. Referring to collections only by their interface prevents you from using any nonstandard operations. The implementation type of the Set in the preceding example is HashSet, which makes no guarantees as to the order of the elements in the Set. If you want the program to print the word list in alphabetical order, merely change the Set‘s implementation type from HashSet to TreeSet. Making this trivial one-line change causes the command line in the previous example to generate the following output. 12345java FindDups i came i saw i left4 distinct words: [came, i, left, saw] Set Interface Bulk OperationsBulk operations are particularly well suited to Sets; when applied, they perform standard set-algebraic operations. Suppose s1 and s2 are sets. Here’s what bulk operations do: s1.containsAll(s2) &#151; returns true if s2 is a subset of s1. (s2 is a subset of s1 if set s1 contains all of the elements in s2.) s1.addAll(s2) &#151; transforms s1 into the union of s1 and s2. (The union of two sets is the set containing all of the elements contained in either set.) s1.retainAll(s2) &#151; transforms s1 into the intersection of s1 and s2. (The intersection of two sets is the set containing only the elements common to both sets.) s1.removeAll(s2) &#151; transforms s1 into the (asymmetric) set difference of s1 and s2. (For example, the set difference of s1 minus s2 is the set containing all of the elements found in s1 but not in s2.) To calculate the union, intersection, or set difference of two sets nondestructively (without modifying either set), the caller must copy one set before calling the appropriate bulk operation. The following are the resulting idioms. 12345678910Set&lt;Type&gt; union &#x3D; new HashSet&lt;Type&gt;(s1);union.addAll(s2);Set&lt;Type&gt; intersection &#x3D; new HashSet&lt;Type&gt;(s1);intersection.retainAll(s2);Set&lt;Type&gt; difference &#x3D; new HashSet&lt;Type&gt;(s1);difference.removeAll(s2); The implementation type of the result Set in the preceding idioms is HashSet, which is, as already mentioned, the best all-around Set implementation in the Java platform. However, any general-purpose Set implementation could be substituted. Let’s revisit the FindDups program. Suppose you want to know which words in the argument list occur only once and which occur more than once, but you do not want any duplicates printed out repeatedly. This effect can be achieved by generating two sets &#151; one containing every word in the argument list and the other containing only the duplicates. The words that occur only once are the set difference of these two sets, which we know how to compute. Here’s how the resulting program looks. 123456789101112131415161718192021import java.util.*;public class FindDups2 &#123; public static void main(String[] args) &#123; Set&lt;String&gt; uniques &#x3D; new HashSet&lt;String&gt;(); Set&lt;String&gt; dups &#x3D; new HashSet&lt;String&gt;(); for (String a : args) if (!uniques.add(a)) dups.add(a); &#x2F;&#x2F; Destructive set-difference uniques.removeAll(dups); System.out.println(&quot;Unique words: &quot; + uniques); System.out.println(&quot;Duplicate words: &quot; + dups); &#125;&#125; When run with the same argument list used earlier (i came i saw i left), the program yields the following output. 1234Unique words: [left, saw, came]Duplicate words: [i] A less common set-algebraic operation is the symmetric set difference &#151; the set of elements contained in either of two specified sets but not in both. The following code calculates the symmetric set difference of two sets nondestructively. 1234567Set&lt;Type&gt; symmetricDiff &#x3D; new HashSet&lt;Type&gt;(s1);symmetricDiff.addAll(s2);Set&lt;Type&gt; tmp &#x3D; new HashSet&lt;Type&gt;(s1);tmp.retainAll(s2);symmetricDiff.removeAll(tmp); Set Interface Array OperationsThe array operations don’t do anything special for Sets beyond what they do for any other Collection. These operations are described inThe Collection Interface section.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"The Collection Interface","date":"2020-12-05T17:52:31.059Z","path":"wiki/2021-03-03-The Collection Interface/","text":"The Collection InterfaceACollection represents a group of objects known as its elements. The Collection interface is used to pass around collections of objects where maximum generality is desired. For example, by convention all general-purpose collection implementations have a constructor that takes a Collection argument. This constructor, known as a conversion constructor, initializes the new collection to contain all of the elements in the specified collection, whatever the given collection’s subinterface or implementation type. In other words, it allows you to convert the collection’s type. Suppose, for example, that you have a Collection&amp;lt;String&amp;gt; c, which may be a List, a Set, or another kind of Collection. This idiom creates a new ArrayList (an implementation of the List interface), initially containing all the elements in c. 123List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(c); 123List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;(c); The following shows the Collection interface. 12345678910111213141516171819202122232425262728public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; &#x2F;&#x2F; Basic operations int size(); boolean isEmpty(); boolean contains(Object element); &#x2F;&#x2F; optional boolean add(E element); &#x2F;&#x2F; optional boolean remove(Object element); Iterator&lt;E&gt; iterator(); &#x2F;&#x2F; Bulk operations boolean containsAll(Collection&lt;?&gt; c); &#x2F;&#x2F; optional boolean addAll(Collection&lt;? extends E&gt; c); &#x2F;&#x2F; optional boolean removeAll(Collection&lt;?&gt; c); &#x2F;&#x2F; optional boolean retainAll(Collection&lt;?&gt; c); &#x2F;&#x2F; optional void clear(); &#x2F;&#x2F; Array operations Object[] toArray(); &lt;T&gt; T[] toArray(T[] a);&#125; The Collection interface contains methods that perform basic operations, such as int size(), boolean isEmpty(),boolean contains(Object element), boolean add(E element), boolean remove(Object element), andIterator&amp;lt;E&amp;gt; iterator(). It also containsmethods that operate on entire collections, such as boolean containsAll(Collection&amp;lt;?&amp;gt; c),boolean addAll(Collection&amp;lt;? extends E&amp;gt; c), boolean removeAll(Collection&amp;lt;?&amp;gt; c), boolean retainAll(Collection&amp;lt;?&amp;gt; c), andvoid clear(). Additional methods for array operations(such as Object[] toArray() and &amp;lt;T&amp;gt; T[] toArray(T[] a) exist as well. In JDK 8 and later, the Collection interface also exposes methods Stream&amp;lt;E&amp;gt; stream() and Stream&amp;lt;E&amp;gt; parallelStream(), for obtaining sequential or parallel streams from the underlying collection. (See the lesson entitledAggregate Operations for more information about using streams.) The Collection interface does about what you’d expect given that a Collection represents a group of objects. It has methods that tell you how many elements are in the collection (size, isEmpty), methods that check whether a given object is in the collection (contains), methods that add and remove an element from the collection (add, remove), and methods that provide an iterator over the collection (iterator). The add method is defined generally enough so that it makes sense for collections that allow duplicates as well as those that don’t. It guarantees that the Collection will contain the specified element after the call completes, and returns true if the Collection changes as a result of the call. Similarly, the remove method is designed to remove a single instance of the specified element from the Collection, assuming that it contains the element to start with, and to return true if the Collection was modified as a result. Traversing CollectionsThere are three ways to traverse collections: (1) using aggregate operations (2) with the for-each construct and (3) by using Iterators. Aggregate OperationsIn JDK 8 and later, the preferred method of iterating over a collection is to obtain a streamand perform aggregate operations on it.Aggregate operations are often used in conjunction with lambda expressionsto make programming more expressive, using less lines of code. The following code sequentially iterates through a collection of shapes and printsout the red objects: 12345myShapesCollection.stream().filter(e -&gt; e.getColor() &#x3D;&#x3D; Color.RED).forEach(e -&gt; System.out.println(e.getName())); Likewise, you could easily request a parallel stream, which might make senseif the collection is large enough and your computer has enough cores: 12345myShapesCollection.parallelStream().filter(e -&gt; e.getColor() &#x3D;&#x3D; Color.RED).forEach(e -&gt; System.out.println(e.getName())); There are many different ways to collect data with this API. For example, you might want to convertthe elements of a Collection to String objects, then join them, separated by commas: 12345String joined &#x3D; elements.stream().map(Object::toString).collect(Collectors.joining(&quot;, &quot;)); Or perhaps sum the salaries of all employees: 1234int total &#x3D; employees.stream().collect(Collectors.summingInt(Employee::getSalary))); These are but a few examples of what you can do with streams andaggregate operations.For more information and examples, see the lesson entitledAggregate Operations. The Collections framework has always provided a number of so-called “bulk operations” as part of its API.These include methods that operate on entire collections, such as containsAll, addAll, removeAll, etc.Do not confuse those methods with the aggregate operations that were introduced in JDK 8.The key difference between the new aggregate operations and the existing bulk operations (containsAll, addAll, etc.) is that the old versions are all mutative, meaning that they all modify the underlying collection. In contrast, the new aggregate operations do notmodify the underlying collection. When using the new aggregate operations and lambda expressions, you musttake care to avoid mutation so as not to introduce problems in the future, should your code be run later from a parallel stream. for-each ConstructThe for-each construct allows you to concisely traverse a collection or array using a for loop &#151; seeThe for Statement. The following code uses the for-each construct to print out each element of a collection on a separate line. 1234for (Object o : collection) System.out.println(o); IteratorsAnIterator is an object that enables you to traverse through a collection and to remove elements from the collection selectively, if desired. You get an Iterator for a collection by calling its iterator method. The following is the Iterator interface. 1234567public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove(); &#x2F;&#x2F;optional&#125; The hasNext method returns true if the iteration has more elements, and the next method returns the next element in the iteration. The remove method removes the last element that was returned by next from the underlying Collection. The remove method may be called only once per call to next and throws an exception if this rule is violated. Note that Iterator.remove is the only safe way to modify a collection during iteration; the behavior is unspecified if the underlying collection is modified in any other way while the iteration is in progress. Use Iterator instead of the for-each construct when you need to: Remove the current element. The for-each construct hides the iterator, so you cannot call remove. Therefore, the for-each construct is not usable for filtering. Iterate over multiple collections in parallel. The following method shows you how to use an Iterator to filter an arbitrary Collection &#151; that is, traverse the collection removing specific elements. 1234567static void filter(Collection&lt;?&gt; c) &#123; for (Iterator&lt;?&gt; it &#x3D; c.iterator(); it.hasNext(); ) if (!cond(it.next())) it.remove();&#125; This simple piece of code is polymorphic, which means that it works for any Collection regardless of implementation. This example demonstrates how easy it is to write a polymorphic algorithm using the Java Collections Framework. Collection Interface Bulk OperationsBulk operations perform an operation on an entire Collection. You could implement these shorthand operations using the basic operations, though in most cases such implementations would be less efficient. The following are the bulk operations: containsAll &#151; returns true if the target Collection contains all of the elements in the specified Collection. addAll &#151; adds all of the elements in the specified Collection to the target Collection. removeAll &#151; removes from the target Collection all of its elements that are also contained in the specified Collection. retainAll &#151; removes from the target Collection all its elements that are not also contained in the specified Collection. That is, it retains only those elements in the target Collection that are also contained in the specified Collection. clear &#151; removes all elements from the Collection. The addAll, removeAll, and retainAll methods all return true if the target Collection was modified in the process of executing the operation. As a simple example of the power of bulk operations, consider the following idiom to remove all instances of a specified element, e, from a Collection, c. 123c.removeAll(Collections.singleton(e)); More specifically, suppose you want to remove all of the null elements from a Collection. 123c.removeAll(Collections.singleton(null)); This idiom uses Collections.singleton, which is a static factory method that returns an immutable Set containing only the specified element. Collection Interface Array OperationsThe toArray methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a Collection to be translated into an array. The simple form with no arguments creates a new array of Object. The more complex form allows the caller to provide an array or to choose the runtime type of the output array. For example, suppose that c is a Collection. The following snippet dumps the contents of c into a newly allocated array of Object whose length is identical to the number of elements in c. 123Object[] a &#x3D; c.toArray(); Suppose that c is known to contain only strings (perhaps because c is of type Collection&amp;lt;String&amp;gt;). The following snippet dumps the contents of c into a newly allocated array of String whose length is identical to the number of elements in c. 123String[] a &#x3D; c.toArray(new String[0]);","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Interfaces","date":"2020-12-05T17:52:29.542Z","path":"wiki/2021-03-03-Interfaces/","text":"Lesson: InterfacesThe core collection interfaces encapsulate different types of collections, which are shown in the figure below. These interfaces allow collections to be manipulated independently of the details of their representation. Core collection interfaces are the foundation of the Java Collections Framework. As you can see inthe following figure, the core collection interfaces form a hierarchy. The core collection interfaces. A Set is a special kind of Collection, a SortedSet is a special kind of Set, and so forth. Note also that the hierarchy consists of two distinct trees &#151; a Map is not a true Collection. Note that all the core collection interfaces are generic. For example, this is the declaration of the Collection interface. 123public interface Collection&lt;E&gt;... The &amp;lt;E&amp;gt; syntax tells you that the interface is generic. When you declare a Collection instance you can and should specify the type of object contained in the collection. Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime. For information on generic types, see theGenerics (Updated) lesson. When you understand how to use these interfaces, you will know most of what there is to know about the Java Collections Framework. This chapter discusses general guidelines for effective use of the interfaces, including when to use which interface. You’ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn’t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional &#151; a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws anUnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform’s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: `Collection` &#151; the root of the collection hierarchy. A collection represents a group of objects known as its *elements*. The `Collection` interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn't provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as `Set` and `List`. Also see [The Collection Interface](collection.html) section. `Set` &#151; a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student's schedule, or the processes running on a machine. See also [The Set Interface](set.html) section. `List` &#151; an ordered collection (sometimes called a *sequence*). `List`s can contain duplicate elements. The user of a `List` generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you've used `Vector`, you're familiar with the general flavor of `List`. Also see [The List Interface](list.html) section. `Queue` &#151; a collection used to hold multiple elements prior to processing. Besides basic `Collection` operations, a `Queue` provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to `remove` or `poll`. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every `Queue` implementation must specify its ordering properties. Also see [The Queue Interface](queue.html) section. `Deque` &#151; a collection used to hold multiple elements prior to processing. Besides basic `Collection` operations, a `Deque` provides additional insertion, extraction, and inspection operations. Deques can be used both as FIFO (first-in, first-out) and LIFO (last-in, first-out). In a deque all new elements can be inserted, retrieved and removed at both ends. Also see [The Deque Interface](deque.html) section. `Map` &#151; an object that maps keys to values. A `Map` cannot contain duplicate keys; each key can map to at most one value. If you've used `Hashtable`, you're already familiar with the basics of `Map`. Also see [The Map Interface](map.html) section. The last two core collection interfaces are merely sorted versions of Set and Map: `SortedSet` &#151; a `Set` that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see [The SortedSet Interface](sorted-set.html) section. `SortedMap` &#151; a `Map` that maintains its mappings in ascending key order. This is the `Map` analog of `SortedSet`. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see [The SortedMap Interface](sorted-map.html) section. To understand how the sorted interfaces maintain the order of their elements, see theObject Ordering section.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Introduction to Collections","date":"2020-12-05T17:52:27.480Z","path":"wiki/2021-03-03-Introduction to Collections/","text":"Lesson: Introduction to CollectionsA collection &#151; sometimes called a container &#151; is simply an object that groups multiple elements into a single unit. Collections are used to store, retrieve, manipulate, and communicate aggregate data. Typically, they represent data items that form a natural group, such as a poker hand (a collection of cards), a mail folder (a collection of letters), or a telephone directory (a mapping of names to phone numbers). If you have used the Java programming language &#151; or just about any other programming language &#151; you are already familiar with collections. What Is a Collections Framework?A collections framework is a unified architecture for representing and manipulating collections. All collections frameworks contain the following: Interfaces: These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy. Implementations: These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures. Algorithms: These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be polymorphic: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality. Apart from the Java Collections Framework, the best-known examples of collections frameworks are the C++ Standard Template Library (STL) and Smalltalk’s collection hierarchy. Historically, collections frameworks have been quite complex, which gave them a reputation for having a steep learning curve. We believe that the Java Collections Framework breaks with this tradition, as you will learn for yourself in this chapter. Benefits of the Java Collections FrameworkThe Java Collections Framework provides the following benefits: Reduces programming effort: By providing useful data structures and algorithms, the Collections Framework frees you to concentrate on the important parts of your program rather than on the low-level “plumbing” required to make it work. By facilitating interoperability among unrelated APIs, the Java Collections Framework frees you from writing adapter objects or conversion code to connect APIs. Increases program speed and quality: This Collections Framework provides high-performance, high-quality implementations of useful data structures and algorithms. The various implementations of each interface are interchangeable, so programs can be easily tuned by switching collection implementations. Because you’re freed from the drudgery of writing your own data structures, you’ll have more time to devote to improving programs’ quality and performance. Allows interoperability among unrelated APIs: The collection interfaces are the vernacular by which APIs pass collections back and forth. If my network administration API furnishes a collection of node names and if your GUI toolkit expects a collection of column headings, our APIs will interoperate seamlessly, even though they were written independently. Reduces effort to learn and to use new APIs: Many APIs naturally take collections on input and furnish them as output. In the past, each such API had a small sub-API devoted to manipulating its collections. There was little consistency among these ad hoc collections sub-APIs, so you had to learn each one from scratch, and it was easy to make mistakes when using them. With the advent of standard collection interfaces, the problem went away. Reduces effort to design new APIs: This is the flip side of the previous advantage. Designers and implementers don’t have to reinvent the wheel each time they create an API that relies on collections; instead, they can use standard collection interfaces. Fosters software reuse: New data structures that conform to the standard collection interfaces are by nature reusable. The same goes for new algorithms that operate on objects that implement these interfaces.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Collections","date":"2020-12-05T17:52:26.038Z","path":"wiki/2021-03-03-Collections/","text":"Trail: CollectionsThis section describes the Java Collections Framework. Here, you will learn what collections are and how they can make your job easier and programs better. You’ll learn about the core elements &#151; interfaces, implementations, aggregate operations, and algorithms &#151; that comprise the Java Collections Framework. **Introduction** tells you what collections are, and how they'll make your job easier and your programs better. You'll learn about the core elements that comprise the Collections Framework: *interfaces*, *implementations* and *algorithms*. **Interfaces** describes the *core collection interfaces*, which are the heart and soul of the Java Collections Framework. You'll learn general guidelines for effective use of these interfaces, including when to use which interface. You'll also learn idioms for each interface that will help you get the most out of the interfaces. **Aggregate Operations** iterate over collections on your behalf, which enable you to write more concise and efficient code that process elements stored in collections. **Implementations** describes the JDK's *general-purpose collection implementations* and tells you when to use which implementation. You'll also learn about the *wrapper implementations*, which add functionality to general-purpose implementations. **Algorithms** describes the *polymorphic algorithms* provided by the JDK to operate on collections. With any luck you'll never have to write your own sort routine again! **Custom Implementations** tells you why you might want to write your own collection implementation (instead of using one of the general-purpose implementations provided by the JDK), and how you'd go about it. It's easy with the JDK's abstract collection implementations! **Interoperability** tells you how the Collections Framework interoperates with older APIs that predate the addition of Collections to Java. Also, it tells you how to design new APIs so that they'll interoperate seamlessly with other new APIs.","tags":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"}],"categories":[{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"}]},{"title":"Installing a Custom Resource Bundle as an Extension","date":"2020-12-05T17:51:44.126Z","path":"wiki/2021-03-03-Installing a Custom Resource Bundle as an Extension/","text":"Installing a Custom Resource Bundle as an ExtensionThe sectionCustomizing Resource Bundle Loading shows you how to change how resource bundles are loaded. This involves deriving a new class from the classResourceBundle.Control, then retrieving the resource bundle by invoking the following method: 123456ResourceBundle getBundle( String baseName, Locale targetLocale, ResourceBundle.Control control) The parameter control is your implementation of ResourceBundle.Control. Thejava.util.spi.ResourceBundleControlProvider interface enables you to change how the following method loads resource bundles: 12345ResourceBundle getBundle( String baseName, Locale targetLocale) Note that this version of theResourceBundle.getBundle method does not require an instance of the ResourceBundle.Control class. ResourceBundleControlProvider is a service provider interface (SPI). SPIs enable you to create extensible applications, which are those that you can extend easily without modifying their original code base. SeeCreating Extensible Applications for more information. To use SPIs, you first create a service provider by implementing an SPI like ResourceBundleControlProvider. When you implement an SPI, you specify how it will provide the service. The service that the ResourceBundleControlProvider SPI provides is to obtain an appropriate ResourceBundle.Control instance when your application invokes the method ResourceBundle.getBundle(String baseName, Locale targetLocale). You package the service provider with theJava Extension Mechanism as an installed extension. When you run your application, you do not name your extensions in your class path; the runtime environment finds and loads these extensions. An installed implementation of the ResourceBundleControlProvider SPI replaces the default ResourceBundle.Control class (which defines the default bundle loading process). Consequently, the ResourceBundleControlProvider interface enables you to use any of the custom ResourceBundle.Control classes without any additional changes to the source code of your application. In addition, this interface enables you to write applications without having to refer to any of your custom ResourceBundle.Control classes. The&lt;code&gt;RBCPTest.java sample shows how to implement the ResourceBundleControlProvider interface and how to package it as an installed extension. This sample, which is packaged in the zip file [RBCPTest.zip](examples/rbcpsample/RBCPTest.zip), consists of the following files: `src` [`java.util.spi.ResourceBundleControlProvider`](examples/rbcpsample/src/java.util.spi.ResourceBundleControlProvider) [`RBCPTest.java`](examples/rbcpsample/src/RBCPTest.java) `rbcp` [`PropertiesResourceBundleControl.java`](examples/rbcpsample/src/rbcp/PropertiesResourceBundleControl.java) [`PropertiesResourceBundleControlProvider.java`](examples/rbcpsample/src/rbcp/PropertiesResourceBundleControlProvider.java) [`XMLResourceBundleControl.java`](examples/rbcpsample/src/rbcp/XMLResourceBundleControl.java) [`XMLResourceBundleControlProvider.java`](examples/rbcpsample/src/rbcp/XMLResourceBundleControlProvider.java) [`RBControl.properties`](examples/rbcpsample/src/resources/RBControl.properties) [`RBControl_zh.properties`](examples/rbcpsample/src/resources/RBControl_zh.properties) [`RBControl_zh_CN.properties`](examples/rbcpsample/src/resources/RBControl_zh_CN.properties) [`RBControl_zh_HK.properties`](examples/rbcpsample/src/resources/RBControl_zh_HK.properties) [`RBControl_zh_TW.properties`](examples/rbcpsample/src/resources/RBControl_zh_TW.properties) [`XmlRB.xml`](examples/rbcpsample/src/resources/XmlRB.xml) [`XmlRB_ja.xml`](examples/rbcpsample/src/resources/XmlRB_ja.xml) - [`rbcontrolprovider.jar`](#package-provider) The following steps show you how to re-create the contents of the file `RBCPTest.zip`, how the `RBCPTest` sample works, and how to run it: Create implementations of the ResourceBundle.Control class. Implement the ResourceBundleControlProvider interface. In your application, invoke the method ResourceBundle.getBundle. Register the service provider by creating a configuration file. Package the provider, its required classes, and the configuration file in a JAR file. Run the RBCPTest program. 1. Create implementations of the ResourceBundle.Control class.The&lt;code&gt;RBCPTest.java sample uses two implementations of ResourseBundle.Control: [`PropertiesResourceBundleControlProvider.java`](examples/rbcpsample/src/rbcp/PropertiesResourceBundleControlProvider.java): This is the same `ResourceBundle.Control` implementation that is defined in [Customizing Resource Bundle Loading](../resbundle/control.html). [`XMLResourceBundleControl.java`](examples/rbcpsample/src/rbcp/XMLResourceBundleControl.java): This `ResourceBundle.Control` implementation loads XML-based bundles with the method [`Properties.loadFromXML`](https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#loadFromXML-java.io.InputStream-). XML Properties FilesAs described in the sectionBacking a ResourceBundle with Properties Files, properties files are simple text files. They contain one key-value pair on each line. XML properties files are just like properties files: they contain key-value pairs except they have an XML structure. The following is the XML properties file XmlRB.xml: 1234567891011121314151617181920212223242526272829303132333435363738394041Properties&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; class for more information about XML properties files.&lt;&#x2F;p&gt; &lt;!-- ********************************************************************* --&gt;&lt;h2&gt;&lt;a name&#x3D;&quot;implement-resourcebundlecontrolprovider&quot; id&#x3D;&quot;implement-resourcebundlecontrolprovider&quot;&gt;2. Implement the ResourceBundleControlProvider interface.&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;&lt;p&gt;This interface contains one method, the[&#96;ResourceBundle.Control getControl(String baseName)&#96;](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;spi&#x2F;ResourceBundleControlProvider.html#getControl-java.lang.String-) method. The parameter &#96;baseName&#96; is the name of the resource bundle. In the method definition of &#96;getBundle&#96;, specify the instance of &#96;ResourceBundle.Control&#96; that should be returned given the name of the resource bundle.&lt;&#x2F;p&gt;&lt;p&gt;The &#96;RBCPTest&#96; sample contains two implementations of the &#96;ResourceBundleControlProvider&#96; interface,[&#96;&lt;code&gt;PropertiesResourceBundleControlProvider.java&#96;&lt;&#x2F;code&gt;](examples&#x2F;rbcpsample&#x2F;src&#x2F;rbcp&#x2F;PropertiesResourceBundleControlProvider.java) and[&#96;&lt;code&gt;XMLResourceBundleControlProvider.java&#96;&lt;&#x2F;code&gt;](examples&#x2F;rbcpsample&#x2F;src&#x2F;rbcp&#x2F;XMLResourceBundleControlProvider.java). The method &#96;PropertiesResourceBundleControlProvider.getBundle&#96; returns an instance of &#96;PropertiesResourceBundleControl&#96; if the base name of the resource bundle starts with &#96;resources.RBControl&#96; (in this example, all the resource files are contained in the package &#96;resources&#96;):&lt;&#x2F;p&gt;&lt;pre class&#x3D;&quot;codeblock&quot;&gt;package rbcp;import java.util.ResourceBundle;import java.util.spi.ResourceBundleControlProvider;public class PropertiesResourceBundleControlProvider implements ResourceBundleControlProvider &#123; static final ResourceBundle.Control PROPERTIESCONTROL &#x3D; new PropertiesResourceBundleControl(); public ResourceBundle.Control getControl(String baseName) &#123; System.out.println(&quot;Class: &quot; + getClass().getName() + &quot;.getControl&quot;); System.out.println(&quot; called for &quot; + baseName); &#x2F;&#x2F; Throws a NPE if baseName is null. if (baseName.startsWith(&quot;resources.RBControl&quot;)) &#123; System.out.println(&quot; returns &quot; + PROPERTIESCONTROL); return PROPERTIESCONTROL; &#125; System.out.println(&quot; returns null&quot;); System.out.println(); return null; &#125;&#125; Similarly, the method XMLResourceBundleControlProvider.getControl returns an instance of XMLResourceBundleControl if the base name of the resource bundle starts with resources.Xml. Note: You can create one implementation of the ResourceBundleControlProvider interface that returns either an instance of PropertiesResourceBundleControl or XMLResourceBundleControl depending on the base name. 3. In your application, invoke the method ResourceBundle.getBundle.The class RBCPTest retrieves resource bundles with the methodResourceBundle.getBundle: 12345678910111213ServiceLoader&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;class. Using this class means that you have to register the service provider with a configuration file, which is described in the next step.&lt;&#x2F;p&gt;&lt;!-- ********************************************************************* --&gt;&lt;h2&gt;&lt;a name&#x3D;&quot;register-service-provider&quot; id&#x3D;&quot;register-service-provider&quot;&gt;4. Register the service provider by creating a configuration file.&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;&lt;p&gt;The name of the configuration file is the fully qualified name of the interface or class that the provider implemented. The configuration file contains the fully qualified class name of your provider. The file [&#96;&lt;code&gt;java.util.spi.ResourceBundleControlProvider&#96;&lt;&#x2F;code&gt;](examples&#x2F;rbcpsample&#x2F;src&#x2F;java.util.spi.ResourceBundleControlProvider) contains the fully qualified names of &#96;PropertiesResourceBundleControlProvider&#96; and &#96;XMLResourceBundleControlProvider&#96;, one name per line:&lt;&#x2F;p&gt;&lt;pre class&#x3D;&quot;codeblock&quot;&gt;rbcp.XMLResourceBundleControlProviderrbcp.PropertiesResourceBundleControlProvider 5. Package the provider, its required classes, and the configuration file in a JAR file.Compile the source files. From the directory that contains the file build.xml, run the following command: 123456789101112131415161718192021222324252627282930313233343536373839404142META-INF&lt;&#x2F;code&gt; &lt;ul&gt; &lt;li&gt;&#96;services&#96; &lt;ul&gt; - &#96;java.util.spi.ResourceBundleControlProvider&#96; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;li&gt;&#96;rbcp&#96; &lt;ul&gt; - &#96;PropertiesResourceBundleControl.class&#96; - &#96;PropertiesResourceBundleControlProvider.class&#96; - &#96;XMLResourceBundleControl.class&#96; - &#96;XMLResourceBundleControlProvider.class&#96; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;li&gt;&#96;resources&#96; &lt;ul&gt; - &#96;RBControl.properties&#96; - &#96;RBControl_zh.properties&#96; - &#96;RBControl_zh_CN.properties&#96; - &#96;RBControl_zh_HK.properties&#96; - &#96;RBControl_zh_TW.properties&#96; - &#96;XmlRB.xml&#96; - &#96;XmlRB_ja.xml&#96; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;Note that the configuration file &#96;java.util.spi.ResourceBundleControlProvider&#96; must be packaged in the directory &#96;&#x2F;META-INF&#x2F;services&#96;. This sample packages these files in the JAR file &#96;rbcontrolprovider.jar&#96; in the &#96;lib&#96; directory.&lt;p&gt;See[Packaging Programs in JAR Files](..&#x2F;..&#x2F;deployment&#x2F;jar&#x2F;index.html) for more information about creating JAR files.&lt;&#x2F;p&gt; Alternatively, download and install [Apache Ant](http:&#x2F;&#x2F;ant.apache.org&#x2F;), which is a tool that enables you to automate build processes, such as compiling Java files and creating JAR files. Ensure that the Apache Ant executable file is in your &#96;PATH&#96; environment variable so that you can run it from any directory. Once you have installed Apache Ant, follow these steps:&lt;ol&gt; &lt;li&gt;&lt;p&gt;Edit the file[&#96;&lt;code&gt;build.xml&#96;&lt;&#x2F;code&gt;](examples&#x2F;rbcpsample&#x2F;build.xml) and change &#96;$&#123;JAVAC&#125;&#96; to the full path name of your Java compiler, &#96;javac&#96;, and &#96;$&#123;JAVA&#125;&#96; to the full path name of your Java runtime executable, &#96;java&#96;.&lt;&#x2F;p&gt;&lt;&#x2F;li&gt; &lt;li&gt;Run the following command from the same directory that contains the file &#96;build.xml&#96;: &lt;pre class&#x3D;&quot;codeblock&quot;&gt;ant jar - `PropertiesResourceBundleControl.class` - `PropertiesResourceBundleControlProvider.class` - `XMLResourceBundleControl.class` - `XMLResourceBundleControlProvider.class` Edit the file [`build.xml`](examples/rbcpsample/build.xml) and change `${JAVAC}` to the full path name of your Java compiler, `javac`, and `${JAVA}` to the full path name of your Java runtime executable, `java`. Run the following command from the same directory that contains the file `build.xml`: ant jar This command compiles the Java source files and packages them, along with the required resource and configuration files, into the JAR file `rbcontrolprovider.jar` in the `lib` directory. 6. Run the RBCPTest program.At a command prompt, run the following command from the directory that contains the build.xml file: This command assumes the following: The JAR file that contains the compiled code of the RBCPTest sample is in the directory lib. The compiled class, RBCPTest.class, is in the build directory. Alternatively, use Apache Ant and run the following command from the directory that contains the build.xml file: When you install a Java extension, you typically put the JAR file of the extension in the lib/ext directory of your JRE. However, this command specifies the directory that contains Java extensions with the system property java.ext.dirs. The RBCPTest program first attempts to retrieve resource bundles with the base name resources.XmlRB and the locales Locale.ROOT and Local.JAPAN. The output of the program retrieving these resource bundles is similar to the following: The program successfully obtains an instance of XMLResourceBundleControl and accesses the properties files XmlRB.xml and XmlRB_ja.xml. When the RBCPTest program tries to retrieve a resource bundle, it calls all the classes defined in the configuration file java.util.spi.ResourceBundleControlProvider. For example, when the program retrieves the resource bundle with the base name resources.RBControl and the locale Locale.CHINA, it prints the following output:","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Service Providers for Internationalization","date":"2020-12-05T17:51:42.162Z","path":"wiki/2021-03-03-Service Providers for Internationalization/","text":"Lesson: Service Providers for InternationalizationService providers for internationalization enable the plug-in of locale-dependent data and services. Because locale-dependent data and services can be plugged-in, third parties are able to provide implementations of most locale-sensitive classes in the java.text and java.util packages. A service is a set of programming interfaces and classes that provide access to a specific application’s functionality or feature. A service provider interface (SPI) is the set of public interfaces and abstract classes that a service defines. A service provider implements the SPI. Service providers enable you to create extensible applications, which you can extend without modifying its original code base. You can enhance their functionality with new plug-ins or modules. For more information about service providers and extensible applications, seeCreating Extensible Applications. You can use service providers for internationalization to provide custom implementations of the following locale-sensitive classes: [`BreakIterator`](https://docs.oracle.com/javase/8/docs/api/java/text/BreakIterator.html) objects [`Collator`](https://docs.oracle.com/javase/8/docs/api/java/text/Collator.html) objects Language code, country code, and variant name for the [`Locale`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html) class - Time zone names - Currency symbols [`DateFormat`](https://docs.oracle.com/javase/8/docs/api/java/text/DateFormat.html) objects [`DateFormatSymbols`](https://docs.oracle.com/javase/8/docs/api/java/text/DateFormatSymbols.html) objects [`NumberFormat`](https://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html) objects [`DecimalFormatSymbols`](https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormatSymbols.html) objects The corresponding SPIs are contained both in java.text.spi and in java.util.spi packages: [`CurrencyNameProvider`](https://docs.oracle.com/javase/8/docs/api/java/util/spi/CurrencyNameProvider.html) [`LocaleServiceProvider`](https://docs.oracle.com/javase/8/docs/api/java/util/spi/LocaleServiceProvider.html) [`TimeZoneNameProvider`](https://docs.oracle.com/javase/8/docs/api/java/util/spi/TimeZoneNameProvider.html) [`BreakIteratorProvider`](https://docs.oracle.com/javase/8/docs/api/java/text/spi/BreakIteratorProvider.html) [`CollatorProvider`](https://docs.oracle.com/javase/8/docs/api/java/text/spi/CollatorProvider.html) [`DateFormatProvider`](https://docs.oracle.com/javase/8/docs/api/java/text/spi/DateFormatProvider.html) [`DateFormatSymbolsProvider`](https://docs.oracle.com/javase/8/docs/api/java/text/spi/DateFormatSymbolsProvider.html) [`DecimalFormatSymbolsProvider`](https://docs.oracle.com/javase/8/docs/api/java/text/spi/DecimalFormatSymbolsProvider.html) [`NumberFormatProvider`](https://docs.oracle.com/javase/8/docs/api/java/text/spi/NumberFormatProvider.html) For example, if you want to provide a NumberFormat object for a new locale, implement the java.text.spi.NumberFormatProvider class and implement these methods: getCurrencyInstance(Locale locale) getIntegerInstance(Locale locale) getNumberInstance(Locale locale) getPercentInstance(Locale locale) 1234Locale loc &#x3D; new Locale(&quot;da&quot;, &quot;DK&quot;);NumberFormat nf &#x3D; NumberFormatProvider.getNumberInstance(loc); These methods first check whether the Java runtime environment supports the requested locale; if so, the methods use that support. Otherwise, the methods invoke the getAvailableLocales methods of installed providers for the appropriate interface to find a provider that supports the requested locale. For an in-depth example of how to use service providers for internationalization, seeInstalling a Custom Resource Bundle as an Extension. This section shows you how to implement theResourceBundleControlProvider interface, which enables you to use any custom ResourceBundle.Control classes without any additional changes to the source code of your application.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Internationalized Domain Name","date":"2020-12-05T17:51:39.938Z","path":"wiki/2021-03-03-Internationalized Domain Name/","text":"Internationalized Domain NameHistorically, an Internet domain name contained ASCII symbols only.As the Internet gained popularity and was adopted across the world, it became necessary to support internationalization of domain names, specifically to support domain names that include Unicode characters. The Internationalizing Domain Names in Applications (IDNA) mechanism was adopted as the standard to convert Unicode characters to standard ASCII domain names and thus preserve the stability of the domain name system. This system performs a lookup service to translate user-friendly names into network addresses. Examples of internationalized domain names: http://&#28165;&#21326;&#22823;&#23398;.cn http://www.&#1090;&#1088;&#1072;&#1085;&#1089;&#1087;&#1086;&#1088;&#1090;.com If you follow these links you will see that the Unicode domain name represented in the address bar is substituted with the ASCII string. To implement similar functionality in your application, thejava.net.IDN class provides methods to convert domain names between ASCII and non ASCII formats. MethodPurpose [toASCII(String)](https://docs.oracle.com/javase/8/docs/api/java/net/IDN.html#toASCII-java.lang.String-)[toASCII(String, flag)](https://docs.oracle.com/javase/8/docs/api/java/net/IDN.html#toASCII-java.lang.String-int-)Used before sending an IDN to the domain name resolving system or writing an IDN to a file where ASCII characters are expected, such as a DNS master file. If the input string doesn't conform to [RFC 3490](http://www.ietf.org/rfc/rfc3490.txt), these methods throw an IllegalArgumentException. [toUnicode(String)](https://docs.oracle.com/javase/8/docs/api/java/net/IDN.html#toUnicode-java.lang.String-)[toUnicode(String, flag)](https://docs.oracle.com/javase/8/docs/api/java/net/IDN.html#toUnicode-java.lang.String-int-)Used when displaying names to users, for example names obtained from a DNS zone. This method translates a string from ASCII Compatible Encoding (ACE) to Unicode code points. This method never fails; in case of an error the input string remains the same and is returned unmodified. The optional flag parameter specifies the behavior of the conversion process. The ALLOW_UNASSIGNED flag allows including code points that are unassigned in Unicode 3.2. The USE_STD3_ASCII_RULES flag ensures that the STD-3 ASCII rules are observed. You can use these flags separately or logically OR’ed together. If neither flag is desired, use the single-parameter version of the method.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Internationalization of Network Resources","date":"2020-12-05T17:51:37.228Z","path":"wiki/2021-03-03-Internationalization of Network Resources/","text":"Lesson: Internationalization of Network ResourcesIn a modern Internet community, many users are no longer satisfied with using only ASCII symbols to identify a domain name or a web resource. For example, they would like to be able to register a new domain using their native characters in Arabic or Chinese. That is why the internationalization of network resources is a cornerstone in widening horizons for the World Wide Web. This lesson describes the internationalization of the network Domain Name resources. Internationalized Domain Name","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Working with Bidirectional Text with the JTextComponent Class","date":"2020-12-05T17:51:35.038Z","path":"wiki/2021-03-03-Working with Bidirectional Text with the JTextComponent Class/","text":"Working with Bidirectional Text with the JTextComponent ClassThis section discusses how to work with bidirectional text with theJTextComponent class. Bidirectional text is text that contains text that runs in two directions, left-to-right and right-to-left. An example of bidirectional text is Arabic text (which runs right-to-left) that contain numbers (which run left-to-right). It is more difficult to display and manage bidirectional text; however theJTextComponent handles these issues for you. The following topics are covered: Determining Directionality of Bidirectional Text Displaying and Moving Carets Hit Testing Highlighting Selections Setting Component Orientation For more information about these issues, or if you want more control in handling these issues, seeWorking with Bidirectional Text in the2D Graphics trail. Determining Directionality of Bidirectional TextThe sampleBidiTextComponentDemo.java, which is based onTextComponentDemo.java, displays bidirectional text in aJTextPane object. In most cases, the Java platform can determine the directionality of bidirectional Unicode text: Explicitly Specifying Text Run Direction in JTextComponent ObjectsYou can specify the run direction of theDocument object of aJTextComponent object. For example, the following statement specifies that the text in theJTextPane object textPane runs right-to-left: 12345textPane.getDocument().putProperty( TextAttribute.RUN_DIRECTION, TextAttribute.RUN_DIRECTION_RTL); Alternatively, you can specify the component orientation of a particular Swing component based on locale. For example, the following statements specify that the component orientation of the object textPane is based on the ar-SA locale: 1234567Locale arabicSaudiArabia &#x3D; new Locale.Builder().setLanguage(&quot;ar&quot;).setRegion(&quot;SA&quot;).build();textPane.setComponentOrientation( ComponentOrientation.getOrientation(arabicSaudiArabia)); Because the run direction of the Arabic language is right-to-left, the run direction of the text contained in the textPane object is right-to-left also. See the section Setting Component Orientation for more information. Displaying and Moving CaretsIn editable text, a caret is used to graphically represent the current insertion point, the position in the text where new characters will be inserted. In theBidiTextComponentDemo.java sample, the caret contains a small triangle that points toward the direction where an inserted character will be displayed. By default, aJTextComponent object creates a keymap (of typeKeymap) that is shared by allJTextComponent instances as the default keymap. A keymap lets an application bind key strokes to action. A default keymap (forJTextComponent objects that support caret movement) includes the binding between caret movement forward and backward with the left and right arrow keys, which supports caret movement through bidirectional text. Hit TestingOften, a location in device space must be converted to a text offset. For example, when a user clicks the mouse on selectable text, the location of the mouse is converted to a text offset and used as one end of the selection range. Logically, this is the inverse of positioning a caret. You can attach a caret listener to an instance of anJTextComponent. A caret listener enables you to handle caret events, which occur when the caret moves or when the selection in a text component changes. You attach a caret listener with theaddCaretListener method. SeeHow to Write a Caret Listener for more information. Highlighting SelectionsA selected range of characters is represented graphically by a highlight region, an area in which glyphs are displayed with inverse video or against a different background color. JTextComponent objects implement logical highlighting. This means that the selected characters are always contiguous in the text model, and the highlight region is allowed to be discontiguous. The following is an example of logical highlighting: Setting Component OrientationSwing’s layout managers understand how locale affects a UI; it is not necessary to create a new layout for each locale. For example, in a locale where text flows right to left, the layout manager will arrange components in the same orientation. The sampleInternationalizedMortgageCalculator.java has been localized for English, United States; English, United Kingdom; French, France; French, Canada; and Arabic, Saudi Arabia. The following uses the en-US locale: The following uses the ar-SA locale: Note that the components have been laid out in the same direction as the corresponding locale: left-to-right for en-US and right-to-left for ar-SA. TheInternationalizedMortgageCalculator.java sample calls the methodsapplyComponentOrientation andgetOrientation to specify the direction of its components by locale: 12345678910111213141516private static JFrame frame;&#x2F;&#x2F; ...private static void createAndShowGUI(Locale currentLocale) &#123; &#x2F;&#x2F; Create and set up the window. &#x2F;&#x2F; ... &#x2F;&#x2F; Add contents to the window. &#x2F;&#x2F; ... frame.applyComponentOrientation( ComponentOrientation.getOrientation(currentLocale)); &#x2F;&#x2F; ... &#125; The sampleInternationalizedMortgageCalculator.java requires the following resource files: [`resources/Resources.properties`](../format/examples/resources/Resources.properties) [`resources/Resources_ar.properties`](../format/examples/resources/Resources_ar.properties) [`resources/Resources_fr.properties`](../format/examples/resources/Resources_fr.properties)","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Normalizing Text","date":"2020-12-05T17:51:32.836Z","path":"wiki/2021-03-03-Normalizing Text/","text":"Normalizing TextNormalization is the process by which you can perform certain transformations of text to make it reconcilable in a way which it may not have been before. Let’s say, you would like searching or sorting text, in this case you need to normalize that text to account for code points that should be represented as the same text. What can be normalized? The normalization is applicable when you need to convert characters with diacritical marks, change all letters case, decompose ligatures, or convert half-width katakana characters to full-width characters and so on. In accordance with theUnicode Standard Annex #15 the Normalizer’s API supports all of the following four Unicode text normalization forms that are defined in thejava.text.Normalizer.Form: Normalization Form D (NFD): Canonical Decomposition Normalization Form C (NFC): Canonical Decomposition, followed by Canonical Composition Normalization Form KD (NFKD): Compatibility Decomposition Normalization Form KC (NFKC): Compatibility Decomposition, followed by Canonical Composition Let’s examine how the latin small letter “o” with diaeresis can be normalized by using these normalization forms: Original wordNFCNFDNFKCNFKD \"sch&#246;n\"\"sch&#246;n\"\"scho\\u0308n\"\"sch&#246;n\"\"scho\\u0308n\" You can notice that an original word is left unchanged in NFC and NFKC. This is because with NFD and NFKD, composite characters are mapped to their canonical decompositions. But with NFC and NFKC, combining character sequences are mapped to composites, if possible. There is no composite for diaeresis, so it is left decomposed in NFC and NFKC. In the code example,NormSample.java, which is represented later, you can also notice another normalization feature. The half-width and full-width katakana characters will have the same compatibility decomposition and are thus compatibility equivalents. However, they are not canonical equivalents. To be sure that you really need to normalize the text you may use the isNormalized method to determine if the given sequence of char values is normalized. If this method returns false, it means that you have to normalize this sequence and you should use the normalize method which normalizes a char values according to the specified normalization form. For example, to transform text into the canonical decomposed form you will have to use the following normalize method: 123normalized_string &#x3D; Normalizer.normalize(target_chars, Normalizer.Form.NFD); Also, the normalize method rearranges accents into the proper canonical order, so that you do not have to worry about accent rearrangement on your own. The following example represents an application that enables you to select a normalization form and a template to normalize: The complete code for this applet is inNormSample.java","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Character and Byte Streams","date":"2020-12-05T17:51:30.160Z","path":"wiki/2021-03-03-Character and Byte Streams/","text":"Character and Byte StreamsThe java.io package provides classes that allow you to convert between Unicode character streams and byte streams of non-Unicode text. With theInputStreamReader class, you can convert byte streams to character streams. You use theOutputStreamWriter class to translate character streams into byte streams. The following figure illustrates the conversion process: When you create InputStreamReader and OutputStreamWriter objects, you specify the byte encoding that you want to convert. For example, to translate a text file in the UTF-8 encoding into Unicode, you create an InputStreamReader as follows: 1234FileInputStream fis &#x3D; new FileInputStream(&quot;test.txt&quot;);InputStreamReader isr &#x3D; new InputStreamReader(fis, &quot;UTF8&quot;); If you omit the encoding identifier, InputStreamReader and OutputStreamWriter rely on the default encoding. You can determine which encoding an InputStreamReader or OutputStreamWriter uses by invoking the getEncoding method, as follows: 1234InputStreamReader defaultReader &#x3D; new InputStreamReader(fis);String defaultEncoding &#x3D; defaultReader.getEncoding(); The example that follows shows you how to perform character-set conversions with the InputStreamReader and OutputStreamWriter classes. The full source code for this example is inStreamConverter.java. This program displays Japanese characters. Before trying it out, verify that the appropriate fonts have been installed on your system. If you are using the JDK software that is compatible with version 1.1, make a copy of the font.properties file and then replace it with the font.properties.ja file. The StreamConverter program converts a sequence of Unicode characters from a String object into a FileOutputStream of bytes encoded in UTF-8. The method that performs the conversion is called writeOutput: 12345678910111213static void writeOutput(String str) &#123; try &#123; FileOutputStream fos &#x3D; new FileOutputStream(&quot;test.txt&quot;); Writer out &#x3D; new OutputStreamWriter(fos, &quot;UTF8&quot;); out.write(str); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; The readInput method reads the bytes encoded in UTF-8 from the file created by the writeOutput method. An InputStreamReader object converts the bytes from UTF-8 into Unicode and returns the result in a String. The readInput method is as follows: 1234567891011121314151617181920static String readInput() &#123; StringBuffer buffer &#x3D; new StringBuffer(); try &#123; FileInputStream fis &#x3D; new FileInputStream(&quot;test.txt&quot;); InputStreamReader isr &#x3D; new InputStreamReader(fis, &quot;UTF8&quot;); Reader in &#x3D; new BufferedReader(isr); int ch; while ((ch &#x3D; in.read()) &gt; -1) &#123; buffer.append((char)ch); &#125; in.close(); return buffer.toString(); &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125;&#125; The main method of the StreamConverter program invokes the writeOutput method to create a file of bytes encoded in UTF-8. The readInput method reads the same file, converting the bytes back into Unicode. Here is the source code for the main method: 123456789public static void main(String[] args) &#123; String jaString &#x3D; new String(&quot;\\u65e5\\u672c\\u8a9e\\u6587\\u5b57\\u5217&quot;); writeOutput(jaString); String inputString &#x3D; readInput(); String displayString &#x3D; jaString + &quot; &quot; + inputString; new ShowString(displayString, &quot;Conversion Demo&quot;);&#125; The original string (jaString) should be identical to the newly created string (inputString). To show that the two strings are the same, the program concatenates them and displays them with a ShowString object. The ShowString class displays a string with the Graphics.drawString method. The source code for this class is inShowString.java. When the StreamConverter program instantiates ShowString, the following window appears. The repetition of the characters displayed verifies that the two strings are identical:","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Byte Encodings and Strings","date":"2020-12-05T17:51:28.679Z","path":"wiki/2021-03-03-Byte Encodings and Strings/","text":"Byte Encodings and StringsIf a byte array contains non-Unicode text, you can convert the text to Unicode with one of the String constructor methods. Conversely, you can convert a String object into a byte array of non-Unicode characters with the String.getBytes method. When invoking either of these methods, you specify the encoding identifier as one of the parameters. The example that follows converts characters between UTF-8 and Unicode. UTF-8 is a transmission format for Unicode that is safe for UNIX file systems. The full source code for the example is in the fileStringConverter.java. The StringConverter program starts by creating a String containing Unicode characters: 123String original &#x3D; new String(&quot;A&quot; + &quot;\\u00ea&quot; + &quot;\\u00f1&quot; + &quot;\\u00fc&quot; + &quot;C&quot;); When printed, the String named original appears as: 123A&amp;#234;&amp;#241;&amp;#252;C To convert the String object to UTF-8, invoke the getBytes method and specify the appropriate encoding identifier as a parameter. The getBytes method returns an array of bytes in UTF-8 format. To create a String object from an array of non-Unicode bytes, invoke the String constructor with the encoding parameter. The code that makes these calls is enclosed in a try block, in case the specified encoding is unsupported: 12345678910111213141516try &#123; byte[] utf8Bytes &#x3D; original.getBytes(&quot;UTF8&quot;); byte[] defaultBytes &#x3D; original.getBytes(); String roundTrip &#x3D; new String(utf8Bytes, &quot;UTF8&quot;); System.out.println(&quot;roundTrip &#x3D; &quot; + roundTrip); System.out.println(); printBytes(utf8Bytes, &quot;utf8Bytes&quot;); System.out.println(); printBytes(defaultBytes, &quot;defaultBytes&quot;);&#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace();&#125; The StringConverter program prints out the values in the utf8Bytes and defaultBytes arrays to demonstrate an important point: The length of the converted text might not be the same as the length of the source text. Some Unicode characters translate into single bytes, others into pairs or triplets of bytes. The printBytes method displays the byte arrays by invoking the byteToHex method, which is defined in the source file,UnicodeFormatter.java. Here is the printBytes method: 12345678public static void printBytes(byte[] array, String name) &#123; for (int k &#x3D; 0; k &lt; array.length; k++) &#123; System.out.println(name + &quot;[&quot; + k + &quot;] &#x3D; &quot; + &quot;0x&quot; + UnicodeFormatter.byteToHex(array[k])); &#125;&#125; The output of the printBytes method follows. Note that only the first and last bytes, the A and C characters, are the same in both arrays: 123456789101112131415utf8Bytes[0] &#x3D; 0x41utf8Bytes[1] &#x3D; 0xc3utf8Bytes[2] &#x3D; 0xaautf8Bytes[3] &#x3D; 0xc3utf8Bytes[4] &#x3D; 0xb1utf8Bytes[5] &#x3D; 0xc3utf8Bytes[6] &#x3D; 0xbcutf8Bytes[7] &#x3D; 0x43defaultBytes[0] &#x3D; 0x41defaultBytes[1] &#x3D; 0xeadefaultBytes[2] &#x3D; 0xf1defaultBytes[3] &#x3D; 0xfcdefaultBytes[4] &#x3D; 0x43","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Converting Non-Unicode Text","date":"2020-12-05T17:51:26.698Z","path":"wiki/2021-03-03-Converting Non-Unicode Text/","text":"Converting Non-Unicode TextIn the Java programming language char values represent Unicode characters. Unicode is a 16-bit character encoding that supports the world’s major languages. You can learn more about the Unicode standard at theUnicode Consortium Web site . Few text editors currently support Unicode text entry. The text editor we used to write this section’s code examples supports only ASCII characters, which are limited to 7 bits. To indicate Unicode characters that cannot be represented in ASCII, such as &#246;, we used the \\uXXXX escape sequence. Each X in the escape sequence is a hexadecimal digit. The following example shows how to indicate the &#246; character with an escape sequence: 12345String str &#x3D; &quot;\\u00F6&quot;;char c &#x3D; &#39;\\u00F6&#39;;Character letter &#x3D; new Character(&#39;\\u00F6&#39;); A variety of character encodings are used by systems around the world. Currently few of these encodings conform to Unicode. Because your program expects characters in Unicode, the text data it gets from the system must be converted into Unicode, and vice versa. Data in text files is automatically converted to Unicode when its encoding matches the default file encoding of the Java Virtual Machine. You can identify the default file encoding by creating an OutputStreamWriter using it and asking for its canonical name: 1234OutputStreamWriter out &#x3D; new OutputStreamWriter(new ByteArrayOutputStream());System.out.println(out.getEncoding()); If the default file encoding differs from the encoding of the text data you want to process, then you must perform the conversion yourself. You might need to do this when processing text from another country or computing platform. This section discusses the APIs you use to translate non-Unicode text into Unicode. Before using these APIs, you should verify that the character encoding you wish to convert into Unicode is supported. The list of supported character encodings is not part of the Java programming language specification. Therefore the character encodings supported by the APIs may vary with platform. To see which encodings the Java Development Kit supports, see theSupported Encodings document. The material that follows describes two techniques for converting non-Unicode text to Unicode. You can convert non-Unicode byte arrays into String objects, and vice versa. Or you can translate between streams of Unicode characters and byte streams of non-Unicode text. Byte Encodings and StringsThis section shows you how to convert non-Unicode byte arrays into String objects, and vice versa. Character and Byte StreamsIn this section you’ll learn how to translate between streams of Unicode characters and byte streams of non-Unicode text.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Converting Latin Digits to Other Unicode Digits","date":"2020-12-05T17:51:24.440Z","path":"wiki/2021-03-03-Converting Latin Digits to Other Unicode Digits/","text":"Converting Latin Digits to Other Unicode DigitsBy default, when text contains numeric values, those values are displayed using Latin (European) digits. When other Unicode digit shapes are preferred, use thejava.awt.font.NumericShaper class. The NumericShaper API enables you to display a numeric value represented internally as an ASCII value in any Unicode digit shape. The following code snippet, from theArabicDigits example, shows how to use a NumericShaper instance to convert Latin digits to Arabic digits. The line that determines the shaping action is bolded. 12345678910111213141516171819ArabicDigitsPanel(String fontname) &#123; HashMap map &#x3D; new HashMap(); Font font &#x3D; new Font(fontname, Font.PLAIN, 60); map.put(TextAttribute.FONT, font); &lt;strong&gt;map.put(TextAttribute.NUMERIC_SHAPING, NumericShaper.getShaper(NumericShaper.ARABIC));&lt;&#x2F;strong&gt; FontRenderContext frc &#x3D; new FontRenderContext(null, false, false); layout &#x3D; new TextLayout(text, map, frc);&#125;&#x2F;&#x2F; ...public void paint(Graphics g) &#123; Graphics2D g2d &#x3D; (Graphics2D)g; layout.draw(g2d, 10, 50);&#125; The NumericShaper instance for Arabic digits is fetched and placed into a HashMap for theTextLayout.NUMERIC_SHAPING attribute key. The hash map is passed to the TextLayout instance. After rendering the text in the paint method, the digits are displayed in the desired script. In this example, the Latin digits, 0 through 9, are drawn as Arabic digits. The previous example uses the NumericShaper.ARABIC constant to retrieve the desired shaper, but theNumericShaper class provides constants for many languages. These constants are defined as bit masks and are referred to as the NumericShaper bit mask-based constants. Enum-Based Range ConstantsAn alternative way to specify a particular set of digits is to use theNumericShaper.Range enumerated type (enum). This enum, introduced in the Java SE 7 release, also provides a set ofconstants. Although these constants are defined using different mechanisms, the NumericShaper.ARABIC bit mask is functionally equivalent to the NumericShaper.Range.ARABIC enum, and there is a corresponding getShaper method for each constant type: [`getShaper(int singleRange)`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getShaper-int-) [`getShaper(NumericShaper.Range singleRange)`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getShaper-java.awt.font.NumericShaper.Range-) TheArabicDigitsEnum example is identical to the ArabicDigits example, except it uses the NumericShaper.Range enum to specify the language script: 1234567891011ArabicDigitsEnumPanel(String fontname) &#123; HashMap map &#x3D; new HashMap(); Font font &#x3D; new Font(fontname, Font.PLAIN, 60); map.put(TextAttribute.FONT, font); &lt;strong&gt;map.put(TextAttribute.NUMERIC_SHAPING, NumericShaper.getShaper(NumericShaper.Range.ARABIC));&lt;&#x2F;strong&gt; FontRenderContext frc &#x3D; new FontRenderContext(null, false, false); layout &#x3D; new TextLayout(text, map, frc);&#125; Both getShaper methods accept a singleRange parameter. With either constant type, you can specify a range of script-specific digits. The bit mask-based constants can be combined using the OR operand, or you can create a set of NumericShaper.Range enums. The following shows how to define a range using each constant type: 12345678NumericShaper.MONGOLIAN | NumericShaper.THAI |NumericShaper.TIBETANEnumSet.of( NumericShaper.Range.MONGOLIAN, NumericShaper.Range.THAI, NumericShaper.Range.TIBETAN) You can query the NumericShaper object to determine which ranges it supports using either thegetRanges method for bit mask-based shapers or thegetRangeSet method for enum-based shapers. You can use either the traditional bit masked-based constants or the Range enum-based constants. Here are some considerations when deciding which to use: The Range API requires JDK 7 or later. The Range API covers more Unicode ranges than the bit-masked API. The bit-mask API is a bit faster than the Range API. Rendering Digits According to Language ContextTheArabicDigits example was designed to use the shaper for a specific language, but sometimes the digits must be rendered according to the language context. For example, if the text that precedes the digits uses the Thai script, Thai digits are preferred. If the text is displayed in Tibetan, Tibetan digits are preferred. You can accomplish this using one of the getContextualShaper methods: [getContextualShaper(int ranges)](https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getContextualShaper-int-) [getContextualShaper(int ranges, int defaultContext)](https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getContextualShaper-int-int-) [getContextualShaper(Set&lt;NumericShaper.Range&gt; ranges)](https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getContextualShaper-java.util.Set-) [getContextualShaper(Set&lt;NumericShaper.Range&gt; ranges, NumericShaper.Range defaultContext)](https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getContextualShaper-java.util.Set-java.awt.font.NumericShaper.Range-) The first two methods use the bit-mask constants, and the last two use the enum constants. The methods that accept a defaultContext parameter enable you to specify the initial shaper that is used when numeric values are displayed before text. When no default context is defined, any leading digits are displayed using Latin shapes. TheShapedDigits example shows how shapers work. Five text layouts are displayed: The first layout uses no shaper; all digits are displayed as Latin. The second layout shapes all digits as Arabic digits, regardless of language context. The third layout employs a contextual shaper that uses Arabic digits. The default context is defined to be Arabic. The fourth layout employs a contextual shaper that uses Arabic digits, but the shaper does not specify a default context. The fifth layout employs a contextual shaper that uses the ALL_RANGES bit mask, but the shaper does not specify a default context. The following lines of code show how the shapers, if used, are defined: No shaper is used. NumericShaper arabic = NumericShaper.getShaper(NumericShaper.ARABIC); NumericShaper contextualArabic = NumericShaper.getContextualShaper(NumericShaper.ARABIC, NumericShaper.ARABIC); NumericShaper contextualArabicASCII = NumericShaper.getContextualShaper(NumericShaper.ARABIC); NumericShaper contextualAll = NumericShaper.getContextualShaper(NumericShaper.ALL_RANGES); See theShapedDigits.java example for further implementation details.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Line Boundaries","date":"2020-12-05T17:51:22.106Z","path":"wiki/2021-03-03-Line Boundaries/","text":"Line BoundariesApplications that format text or that perform line wrapping must locate potential line breaks. You can find these line breaks, or boundaries, with a BreakIterator that has been created with the getLineInstance method: 1234BreakIterator lineIterator &#x3D; BreakIterator.getLineInstance(currentLocale); This BreakIterator determines the positions in a string where text can break to continue on the next line. The positions detected by the BreakIterator are potential line breaks. The actual line breaks displayed on the screen may not be the same. The two examples that follow use the markBoundaries method ofBreakIteratorDemo.java to show the line boundaries detected by a BreakIterator. The markBoundaries method indicates line boundaries by printing carets (^) beneath the target string. According to a BreakIterator, a line boundary occurs after the termination of a sequence of whitespace characters (space, tab, new line). In the following example, note that you can break the line at any of the boundaries detected: 1234She stopped. She said, &quot;Hello there,&quot; and then went on.^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ Potential line breaks also occur immediately after a hyphen: 1234There are twenty-four hours in a day.^ ^ ^ ^ ^ ^ ^ ^ ^ The next example breaks a long string of text into fixed-length lines with a method called formatLines. This method uses a BreakIterator to locate the potential line breaks. The formatLines method is short, simple, and, thanks to the BreakIterator, locale-independent. Here is the source code: 12345678910111213141516171819202122232425static void formatLines( String target, int maxLength, Locale currentLocale) &#123; BreakIterator boundary &#x3D; BreakIterator. getLineInstance(currentLocale); boundary.setText(target); int start &#x3D; boundary.first(); int end &#x3D; boundary.next(); int lineLength &#x3D; 0; while (end !&#x3D; BreakIterator.DONE) &#123; String word &#x3D; target.substring(start,end); lineLength &#x3D; lineLength + word.length(); if (lineLength &gt;&#x3D; maxLength) &#123; System.out.println(); lineLength &#x3D; word.length(); &#125; System.out.print(word); start &#x3D; end; end &#x3D; boundary.next(); &#125;&#125; The BreakIteratorDemo program invokes the formatLines method as follows: 1234567891011String moreText &#x3D; &quot;She said, \\&quot;Hello there,\\&quot; and then &quot; + &quot;went on down the street. When she stopped &quot; + &quot;to look at the fur coats in a shop + &quot; &quot;window, her dog growled. \\&quot;Sorry Jake,\\&quot; &quot; + &quot;she said. \\&quot;I didn&#39;t know you would take &quot; + &quot;it personally.\\&quot;&quot;;formatLines(moreText, 30, currentLocale); The output from this call to formatLines is: 12345678910She said, &quot;Hello there,&quot; andthen went on down thestreet. When she stopped tolook at the fur coats in ashop window, her doggrowled. &quot;Sorry Jake,&quot; shesaid. &quot;I didn&#39;t know youwould take it personally.&quot;","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Sentence Boundaries","date":"2020-12-05T17:51:19.826Z","path":"wiki/2021-03-03-Sentence Boundaries/","text":"Sentence BoundariesYou can use a BreakIterator to determine sentence boundaries. You start by creating a BreakIterator with the getSentenceInstance method: 1234BreakIterator sentenceIterator &#x3D; BreakIterator.getSentenceInstance(currentLocale); To show the sentence boundaries, the program uses the markBoundaries method, which is discussed in the section Word Boundaries. The markBoundaries method prints carets (^) beneath a string to indicate boundary positions. Here are some examples: 12345678910She stopped. She said, &quot;Hello there,&quot; and then went on.^ ^ ^He&#39;s vanished! What will we do? It&#39;s up to us.^ ^ ^ ^Please add 1.5 liters to the tank.^ ^","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Word Boundaries","date":"2020-12-05T17:51:17.099Z","path":"wiki/2021-03-03-Word Boundaries/","text":"Word BoundariesYou invoke the getWordIterator method to instantiate a BreakIterator that detects word boundaries: 1234BreakIterator wordIterator &#x3D; BreakIterator.getWordInstance(currentLocale); You’ll want to create such a BreakIterator when your application needs to perform operations on individual words. These operations might be common word- processing functions, such as selecting, cutting, pasting, and copying. Or, your application may search for words, and it must be able to distinguish entire words from simple strings. When a BreakIterator analyzes word boundaries, it differentiates between words and characters that are not part of words. These characters, which include spaces, tabs, punctuation marks, and most symbols, have word boundaries on both sides. The example that follows, which is from the programBreakIteratorDemo, marks the word boundaries in some text. The program creates the BreakIterator and then calls the markBoundaries method: 123456789101112Locale currentLocale &#x3D; new Locale (&quot;en&quot;,&quot;US&quot;);BreakIterator wordIterator &#x3D; BreakIterator.getWordInstance(currentLocale);String someText &#x3D; &quot;She stopped. &quot; + &quot;She said, \\&quot;Hello there,\\&quot; and then went &quot; + &quot;on.&quot;;markBoundaries(someText, wordIterator); The markBoundaries method is defined in BreakIteratorDemo.java. This method marks boundaries by printing carets (^) beneath the target string. In the code that follows, notice the while loop where markBoundaries scans the string by calling the next method: 123456789101112131415161718192021static void markBoundaries(String target, BreakIterator iterator) &#123; StringBuffer markers &#x3D; new StringBuffer(); markers.setLength(target.length() + 1); for (int k &#x3D; 0; k &lt; markers.length(); k++) &#123; markers.setCharAt(k,&#39; &#39;); &#125; iterator.setText(target); int boundary &#x3D; iterator.first(); while (boundary !&#x3D; BreakIterator.DONE) &#123; markers.setCharAt(boundary,&#39;^&#39;); boundary &#x3D; iterator.next(); &#125; System.out.println(target); System.out.println(markers);&#125; The output of the markBoundaries method follows. Note where the carets (^) occur in relation to the punctuation marks and spaces: 1234567She stopped. She said, &quot;Hello there,&quot; and then^ ^^ ^^ ^ ^^ ^^^^ ^^ ^^^^ ^^ ^went on.^ ^^ ^^ The BreakIterator class makes it easy to select words from within text. You don’t have to write your own routines to handle the punctuation rules of various languages; the BreakIterator class does this for you. The extractWords method in the following example extracts and prints words for a given string. Note that this method uses Character.isLetterOrDigit to avoid printing “words” that contain space characters. 1234567891011121314151617static void extractWords(String target, BreakIterator wordIterator) &#123; wordIterator.setText(target); int start &#x3D; wordIterator.first(); int end &#x3D; wordIterator.next(); while (end !&#x3D; BreakIterator.DONE) &#123; String word &#x3D; target.substring(start,end); if (Character.isLetterOrDigit(word.charAt(0))) &#123; System.out.println(word); &#125; start &#x3D; end; end &#x3D; wordIterator.next(); &#125;&#125; The BreakIteratorDemo program invokes extractWords, passing it the same target string used in the previous example. The extractWords method prints out the following list of words: 123456789101112ShestoppedShesaidHellothereandthenwenton","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Character Boundaries","date":"2020-12-05T17:51:14.303Z","path":"wiki/2021-03-03-Character Boundaries/","text":"Character BoundariesYou need to locate character boundaries if your application allows the end user to highlight individual characters or to move a cursor through text one character at a time. To create a BreakIterator that locates character boundaries, you invoke the getCharacterInstance method, as follows: 1234BreakIterator characterIterator &#x3D; BreakIterator.getCharacterInstance(currentLocale); This type of BreakIterator detects boundaries between user characters, not just Unicode characters. A user character may be composed of more than one Unicode character. For example, the user character &#252; can be composed by combining the Unicode characters \\u0075 (u) and \\u00a8 (&#168;). This isn’t the best example, however, because the character &#252; may also be represented by the single Unicode character \\u00fc. We’ll draw on the Arabic language for a more realistic example. In Arabic the word for house is: This word contains three user characters, but it is composed of the following six Unicode characters: 123String house &#x3D; &quot;\\u0628&quot; + &quot;\\u064e&quot; + &quot;\\u064a&quot; + &quot;\\u0652&quot; + &quot;\\u067a&quot; + &quot;\\u064f&quot;; The Unicode characters at positions 1, 3, and 5 in the house string are diacritics. Arabic requires diacritics because they can alter the meanings of words. The diacritics in the example are nonspacing characters, since they appear above the base characters. In an Arabic word processor you cannot move the cursor on the screen once for every Unicode character in the string. Instead you must move it once for every user character, which may be composed by more than one Unicode character. Therefore you must use a BreakIterator to scan the user characters in the string. The sample programBreakIteratorDemo, creates a BreakIterator to scan Arabic characters. The program passes this BreakIterator, along with the String object created previously, to a method named listPositions: 12345BreakIterator arCharIterator &#x3D; BreakIterator.getCharacterInstance( new Locale (&quot;ar&quot;,&quot;SA&quot;));listPositions (house, arCharIterator); The listPositions method uses a BreakIterator to locate the character boundaries in the string. Note that the BreakIteratorDemo assigns a particular string to the BreakIterator with the setText method. The program retrieves the first character boundary with the first method and then invokes the next method until the constant BreakIterator.DONE is returned. The code for this routine is as follows: 123456789101112static void listPositions(String target, BreakIterator iterator) &#123; iterator.setText(target); int boundary &#x3D; iterator.first(); while (boundary !&#x3D; BreakIterator.DONE) &#123; System.out.println (boundary); boundary &#x3D; iterator.next(); &#125;&#125; The listPositions method prints out the following boundary positions for the user characters in the string house. Note that the positions of the diacritics (1, 3, 5) are not listed: 1234560246","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"About the BreakIterator Class","date":"2020-12-05T17:51:11.873Z","path":"wiki/2021-03-03-About the BreakIterator Class/","text":"About the BreakIterator ClassThe BreakIterator class is locale-sensitive, because text boundaries vary with language. For example, the syntax rules for line breaks are not the same for all languages. To determine which locales the BreakIterator class supports, invoke the getAvailableLocales method, as follows: 123Locale[] locales &#x3D; BreakIterator.getAvailableLocales(); You can analyze four kinds of boundaries with the BreakIterator class: character, word, sentence, and potential line break. When instantiating a BreakIterator, you invoke the appropriate factory method: getCharacterInstance getWordInstance getSentenceInstance getLineInstance Each instance of BreakIterator can detect just one type of boundary. If you want to locate both character and word boundaries, for example, you create two separate instances. A BreakIterator has an imaginary cursor that points to the current boundary in a string of text. You can move this cursor within the text with the previous and the next methods. For example, if you’ve created a BreakIterator with getWordInstance, the cursor moves to the next word boundary in the text every time you invoke the next method. The cursor-movement methods return an integer indicating the position of the boundary. This position is the index of the character in the text string that would follow the boundary. Like string indexes, the boundaries are zero-based. The first boundary is at 0, and the last boundary is the length of the string. The following figure shows the word boundaries detected by the next and previous methods in a line of text: You should use the BreakIterator class only with natural-language text. To tokenize a programming language, use the StreamTokenizer class. The sections that follow give examples for each type of boundary analysis. The coding examples are from the source code file namedBreakIteratorDemo.java.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Detecting Text Boundaries","date":"2020-12-05T17:51:09.673Z","path":"wiki/2021-03-03-Detecting Text Boundaries/","text":"Detecting Text BoundariesApplications that manipulate text need to locate boundaries within the text. For example, consider some of the common functions of a word processor: highlighting a character, cutting a word, moving the cursor to the next sentence, and wrapping a word at a line ending. To perform each of these functions, the word processor must be able to detect the logical boundaries in the text. Fortunately you don’t have to write your own routines to perform boundary analysis. Instead, you can take advantage of the methods provided by theBreakIterator class. About the BreakIterator ClassThis section discusses the instantiation methods and the imaginary cursor of the BreakIterator class. Character BoundariesIn this section you’ll learn about the difference between user and Unicode characters, and how to locate user characters with a BreakIterator. Word BoundariesIf your application needs to select or locate words within text, you’ll find it helpful to use a BreakIterator. Sentence BoundariesDetermining sentence boundaries can be problematic, because of the ambiguous use of sentence terminators in many written languages. This section examines some of the problems you may encounter, and how the BreakIterator deals with them. Line BoundariesThis section describes how to locate potential line breaks in a text string with a BreakIterator.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"More Information","date":"2020-12-05T17:51:07.510Z","path":"wiki/2021-03-03-More Information/","text":"More InformationFor more information about supplementary characters, see the following resources. [Supplementary Characters in the Java Platform](http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html) - [Unicode Consortion](http://unicode.org/) - [Glossary of Unicode Terms](http://unicode.org/glossary/)","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Design Considerations","date":"2020-12-05T17:51:05.684Z","path":"wiki/2021-03-03-Design Considerations/","text":"Design ConsiderationsTo write code that works seamlessly for any language using any script, there are a few things to keep in mind. ConsiderationReason Avoid methods that use the `char` data type.Avoid using the `char` primitive data type or methods that use the `char` data type, because code that uses that data type does not work for supplementary characters. For methods that take a `char` type parameter, use the corresponding `int` method, where available. For example, use the `Character.isDigit(int)` method rather than `Character.isDigit(char)` method. Use the `isValidCodePoint` method to verify code point values.A code point is defined as an `int` data type, which allows for values outside of the valid range of code point values from 0x0000 to 0x10FFFF. For performance reasons, the methods that take a code point value as a parameter do not check the validity of the parameter, but you can use the `isValidCodePoint` method to check the value. Use the `codePointCount` method to count characters.The `String.length()` method returns the number of code units, or 16-bit `char` values, in the string. If the string contains supplementary characters, the count can be misleading because it will not reflect the true number of code points. To get an accurate count of the number of characters (including supplementary characters), use the `codePointCount` method. Use the `String.toUpperCase(int codePoint)` and `String.toLowerCase(int codePoint)` methods rather than the `Character.toUpperCase(int codePoint)` or `Character.toLowerCase(int codePoint)` methods.While the `Character.toUpperCase(int)` and `Character.toLowerCase(int)` methods do work with code point values, there are some characters that cannot be converted on a one-to-one basis. The lowercase German character &#223;, for example, becomes two characters, SS, when converted to uppercase. Likewise, the small Greek Sigma character is different depending on the position in the string. The `Character.toUpperCase(int)` and `Character.toLowerCase(int)` methods cannot handle these types of cases; however, the `String.toUpperCase` and `String.toLowerCase` methods handle these cases correctly. Be careful when deleting characters.When invoking the `StringBuilder.deleteCharAt(int index)` or `StringBuffer.deleteCharAt(int index)` methods where the index points to a supplementary character, only the first half of that character (the first `char` value) is removed. First, invoke the `Character.charCount` method on the character to determine if one or two `char` values must be removed. Be careful when reversing characters in a sequence.When invoking the `StringBuffer.reverse()` or `StringBuilder.reverse()` methods on text that contains supplementary characters, the high and low surrogate pairs are reversed which results in incorrect and possibly invalid surrogate pairs.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Sample Usage","date":"2020-12-05T17:51:03.574Z","path":"wiki/2021-03-03-Sample Usage/","text":"Sample UsageThis page contains some code snippets that show you several commono scenarios. Creating a String from a Code Point12345String newString(int codePoint) &#123; return new String(Character.toChars(codePoint));&#125; Creating a String from a Code Point - Optimized for BMP CharactersThe Character.toChars method creates an temporary array that is used once and then discarded. If this negatively affects performance, you can use the following approach that is optimizied for BMP characters (characters that are represented by a single char value). In this method, toChars is invoked only for supplementary characters. 123456789String newString(int codePoint) &#123; if (Character.charCount(codePoint) &#x3D;&#x3D; 1) &#123; return String.valueOf(codePoint); &#125; else &#123; return new String(Character.toChars(codePoint)); &#125;&#125; Creating String Objects in BulkTo create a large number of strings, the bulk version of the previous snippet reuses the array used by the toChars method. This method creates a separate String instance for each code point and is optimized for BMP characters. 1234567891011String[] newStrings(int[] codePoints) &#123; String[] result &#x3D; new String[codePoints.length]; char[] codeUnits &#x3D; new char[2]; for (int i &#x3D; 0; i &lt; codePoints.length; i++) &#123; int count &#x3D; Character.toChars(codePoints[i], codeUnits, 0); result[i] &#x3D; new String(codeUnits, 0, count); &#125; return result;&#125; Generating MessagesThe formatting API supports supplementary characters. The following example is a simple way to generate a message. 1234&#x2F;&#x2F; recommendedSystem.out.printf(&quot;Character %c is invalid.%n&quot;, codePoint); This following approach is simple and avoids concatenation, which makes the text more difficult to localize as not all languages insert numeric values into a string in the same order as English. 1234&#x2F;&#x2F; not recommendedSystem.out.println(&quot;Character &quot; + String.valueOf(char) + &quot; is invalid.&quot;);","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Character and String APIs","date":"2020-12-05T17:51:01.229Z","path":"wiki/2021-03-03-Character and String APIs/","text":"Character and String APIsThe Character class encapsulates the char data type. For the J2SE release 5, many methods were added to the Character class to support supplementary characters. This API falls into two categories: methods that convert between char and code point values and methods that verifiy the validity of or map code points. This section describes a subset of the available methods in the Character class. For the complete list of available APIs, see theCharacter class specification. Conversion Methods and the Character ClassThe following table includes the most useful conversion methods, or methods that facilitate conversion, in the Character class. The codePointAt and codePointBefore methods are included in this list because text is generally found in a sequence, such as a String, and these methods can be used to extract the desired substring. Method(s)Description [`toChars(int codePoint, char[] dst, int dstIndex)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toChars-int-char:A-int-)[`toChars(int codePoint)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toChars-int-)Converts the specified Unicode code point to its UTF-16 representation and places it in a `char` array. Sample usage: `Character.toChars(0x10400)` [`toCodePoint(char high, char low)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toCodePoint-char-char-)[`toCodePoint(CharSequence, int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toCodePoint-java.lang.CharSequence-int-)[`toCodePoint(char[], int, int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toCodePoint-char:A-int-int-)Converts the specified parameters to its supplementary code point value. The different methods accept different input formats. [`codePointAt(char[] a, int index)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointAt-char:A-int-)[`codePointAt(char[] a, int index, int limit)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointAt-char:A-int-int-)[`codePointAt(CharSequence seq, int index)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointAt-java.lang.CharSequence-int-)Returns the Unicode code point at the specified index. The third method takes a `CharSequence` and the second method enforces an upper limit on the index. [`codePointBefore(char[] a, int index)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointBefore-char:A-int-)[`codePointBefore(char[] a, int index, int start)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointBefore-char:A-int-int-)[`codePointBefore(CharSequence seq, int index)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointBefore-java.lang.CharSequence-int-)[`codePointBefore(char[], int, int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointBefore-char:A-int-int-)Returns the Unicode code point before the specified index. The third method accepts a `CharSequence` and the other methods accept a `char` array. The second method enforces a lower limit on the index. [`charCount(int codePoint)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#charCount-int-)Returns the value 1 for characters that can be represented by a single `char`. Returns the value 2 for supplementary characters that require two `char`s. Verification and Mapping Methods in the Character ClassSome of the previous methods that used the char primitive data type, such as isLowerCase(char) and isDigit(char), were supplanted by methods that support supplementary characters, such as isLowerCase(int) and isDigit(int). The previous methods are supported but do not work with supplementary characters. To create a global application and ensure that your code works seamlessly with any language, it is recommended that you use the newer forms of these methods. Note that, for performance reasons, most methods that accept a code point do not verify the validity of the code point parameter. You can use the isValidCodePoint method for that purpose. The following table lists some of the verification and mapping methods in the Character class. Method(s)Description [`isValidCodePoint(int codePoint)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isValidCodePoint-int-)Returns true if the code point is within the range of 0x0000 to 0x10FFFF, inclusive. [`isSupplementaryCodePoint(int codePoint)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isSupplementaryCodePoint-int-)Returns true if the code point is within the range of 0x10000 to 0x10FFFF, inclusive. [`isHighSurrogate(char)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isHighSurrogate-char-)Returns true if the specified `char` is within the high surrogate range of \\uD800 to \\uDBFF, inclusive. [`isLowSurrogate(char)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isLowSurrogate-char-)Returns true if the specified `char` is within the low surrogate range of \\uDC00 to \\uDFFF, inclusive. [`isSurrogatePair(char high, char low)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isSurrogatePair-char-char-)Returns true if the specified high and low surrogate code values represent a valid surrogate pair. [`codePointCount(CharSequence, int, int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointCount-java.lang.CharSequence-int-int-)[`codePointCount(char[], int, int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointCount-char:A-int-int-)Returns the number of Unicode code points in the `CharSequence`, or `char` array. [`isLowerCase(int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isLowerCase-int-)[`isUpperCase(int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isUpperCase-int-)Returns true if the specified Unicode code point is a lowercase or uppercase character. [`isDefined(int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isDefined-int-)Returns true if the specified Unicode code point is defined in the Unicode standard. [`isJavaIdentifierStart(char)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isJavaIdentifierStart-char-)[`isJavaIdentifierStart(int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isJavaIdentifierStart-int-)Returns true if the specified character or Unicode code point is permissible as the first character in a Java identifier. [`isLetter(int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isLetter-int-)[`isDigit(int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isDigit-int-)[`isLetterOrDigit(int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isLetterOrDigit-int-)Returns true if the specified Unicode code point is a letter, a digit, or a letter or digit. [`getDirectionality(int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#getDirectionality-int-)Returns the Unicode directionality property for the given Unicode code point. [`Character.UnicodeBlock.of(int codePoint)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.UnicodeBlock.html#of-int-)Returns the object representing the Unicode block that contains the given Unicode code point or returns `null` if the code point is not a member of a defined block. Methods in the String ClassesThe String, StringBuffer, and StringBuilder classes also have contructors and methods that work with supplementary characters. The following table lists some of the commonly used methods. For the complete list of available APIs, see the javadoc for theString,StringBuffer, andStringBuilder classes. Constructor or MethodsDescription [`String(int[] codePoints, int offset, int count)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#String-int:A-int-int-)Allocates a new `String` instance that contains characters from a subarray of a Unicode code point array. [`String.codePointAt(int index)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#codePointAt-int-)[`StringBuffer.codePointAt(int index)`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#codePointAt-int-)[`StringBuilder.codePointAt(int index)`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#codePointAt-int-)Returns the Unicode code point at the specified index. [`String.codePointBefore(int index)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#codePointBefore-int-)[`StringBuffer.codePointBefore(int index)`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#codePointBefore-int-)[`StringBuilder.codePointBefore(int index)`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#codePointBefore-int-)Returns the Unicode code point before the specified index. [`String.codePointCount(int beginIndex, int endIndex)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#codePointCount-int-int-)[`StringBuffer.codePointCount(int beginIndex, int endIndex)`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#codePointCount-int-int-)[`StringBuilder.codePointCount(int beginIndex, int endIndex)`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#codePointCount-int-int-)Returns the number of Unicode code points in the specified range. [`StringBuffer.appendCodePoint(int codePoint)`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#appendCodePoint-int-)[`StringBuilder.appendCodePoint(int codePoint)`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#appendCodePoint-int-)Appends the string representation of the specified code point to the sequence. [`String.offsetByCodePoints(int index, int codePointOffset)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#offsetByCodePoints-int-int-)[`StringBuffer.offsetByCodePoints(int index, int codePointOffset)`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#offsetByCodePoints-int-int-)[`StringBuilder.offsetByCodePoints(int index, int codePointOffset)`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#offsetByCodePoints-int-int-)Returns the index that is offset from the given index by the given number of code points.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Supplementary Characters as Surrogates","date":"2020-12-05T17:50:59.622Z","path":"wiki/2021-03-03-Supplementary Characters as Surrogates/","text":"Supplementary Characters as SurrogatesTo support supplementary characters without changing the char primitive data type and causing incompatibility with previous Java programs, supplementary characters are defined by a pair of code point values that are called surrogates. The first code point is from the high surrogates range of U+D800 to U+DBFF, and the second code point is from the low surrogates range of U+DC00 to U+DFFF. For example, the Deseret character LONG I, U+10400, is defined with this pair of surrogate values: U+D801 and U+DC00.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Terminology","date":"2020-12-05T17:50:57.837Z","path":"wiki/2021-03-03-Terminology/","text":"TerminologyA character is a minimal unit of text that has semantic value. A character set is a collection of characters that might be used by multiple languages. For example, the Latin character set is used by English and most European languages, though the Greek character set is used only by the Greek language. A coded character set is a character set where each character is assigned a unique number. A code point is a value that can be used in a coded character set. A code point is a 32-bit int data type, where the lower 21 bits represent a valid code point value and the upper 11 bits are 0. A Unicode code unit is a 16-bit char value. For example, imagine a String that contains the letters “abc” followed by the Deseret LONG I, which is represented with two char values. That string contains four characters, four code points, but five code units. To express a character in Unicode, the hexadecimal value is prefixed with the string U+. The valid code point range for the Unicode standard is U+0000 to U+10FFFF, inclusive. The code point value for the Latin character A is U+0041. The character &#8364; which represents the Euro currency, has the code point value U+20AC. The first letter in the Deseret alphabet, the LONG I, has the code point value U+10400. The following table shows code point values for several characters: CharacterUnicode Code PointGlyph Latin AU+0041 Latin sharp SU+00DF Han for EastU+6771 Deseret, LONG IU+10400 As previously described, characters that are in the range U+10000 to U+10FFFF are called supplementary characters. The set of characters from U+0000 to U+FFFF are sometimes referred to as the Basic Multilingual Plane (BMP). More terminology can be found in the Glossary of Unicode Terms, listed on the More Information page.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Unicode","date":"2020-12-05T17:50:55.841Z","path":"wiki/2021-03-03-Unicode/","text":"UnicodeUnicode is a computing industry standard designed to consistently and uniquely encode characters used in written languages throughout the world. The Unicode standard uses hexadecimal to express a character. For example, the value 0x0041 represents the Latin character A. The Unicode standard was initially designed using 16 bits to encode characters because the primary machines were 16-bit PCs. When the specification for the Java language was created, the Unicode standard was accepted and the char primitive was defined as a 16-bit data type, with characters in the hexadecimal range from 0x0000 to 0xFFFF. Because 16-bit encoding supports 216 (65,536) characters, which is insufficient to define all characters in use throughout the world, the Unicode standard was extended to 0x10FFFF, which supports over one million characters. The definition of a character in the Java programming language could not be changed from 16 bits to 32 bits without causing millions of Java applications to no longer run properly. To correct the definition, a scheme was developed to handle characters that could not be encoded in 16 bits. The characters with values that are outside of the 16-bit range, and within the range from 0x10000 to 0x10FFFF, are called supplementary characters and are defined as a pair of char values. This lesson includes the following sections: Terminology &#150; Code points and other terms are explained. Supplementary Characters as Surrogates &#150; 16-bit surrogates are used to implement supplementary characters, which cannot be implemented as a single primitive char data type. Character and String API &#150; A listing of related API for the Character, String, and related classes. Sample Usage &#150; Several useful code snippets are provided. Design Considerations &#150; Design considerations to keep in mind to ensure that your application will work with any language script. More Information &#150; A list of further resources are provided.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Improving Collation Performance","date":"2020-12-05T17:50:54.430Z","path":"wiki/2021-03-03-Improving Collation Performance/","text":"Improving Collation PerformanceSorting long lists of strings is often time consuming. If your sort algorithm compares strings repeatedly, you can speed up the process by using the CollationKey class. ACollationKey object represents a sort key for a given String and Collator. Comparing two CollationKey objects involves a bitwise comparison of sort keys and is faster than comparing String objects with the Collator.compare method. However, generating CollationKey objects requires time. Therefore if a String is to be compared just once, Collator.compare offers better performance. The example that follows uses a CollationKey object to sort an array of words. Source code for this example is inKeysDemo.java. The KeysDemo program creates an array of CollationKey objects in the main method. To create a CollationKey, you invoke the getCollationKey method on a Collator object. You cannot compare two CollationKey objects unless they originate from the same Collator. The main method is as follows: 1234567891011121314151617181920static public void main(String[] args) &#123; Collator enUSCollator &#x3D; Collator.getInstance(new Locale(&quot;en&quot;,&quot;US&quot;)); String [] words &#x3D; &#123; &quot;peach&quot;, &quot;apricot&quot;, &quot;grape&quot;, &quot;lemon&quot; &#125;; CollationKey[] keys &#x3D; new CollationKey[words.length]; for (int k &#x3D; 0; k &lt; keys.length; k ++) &#123; keys[k] &#x3D; enUSCollator. getCollationKey(words[k]); &#125; sortArray(keys); printArray(keys);&#125; The sortArray method invokes the CollationKey.compareTo method. The compareTo method returns an integer less than, equal to, or greater than zero if the keys[i] object is less than, equal to, or greater than the keys[j] object. Note that the program compares the CollationKey objects, not the String objects from the original array of words. Here is the code for the sortArray method: 123456789101112131415public static void sortArray(CollationKey[] keys) &#123; CollationKey tmp; for (int i &#x3D; 0; i &lt; keys.length; i++) &#123; for (int j &#x3D; i + 1; j &lt; keys.length; j++) &#123; if (keys[i].compareTo(keys[j]) &gt; 0) &#123; tmp &#x3D; keys[i]; keys[i] &#x3D; keys[j]; keys[j] &#x3D; tmp; &#125; &#125; &#125;&#125; The KeysDemo program sorts an array of CollationKey objects, but the original goal was to sort an array of String objects. To retrieve the String representation of each CollationKey, the program invokes getSourceString in the displayWords method, as follows: 1234567static void displayWords(CollationKey[] keys) &#123; for (int i &#x3D; 0; i &lt; keys.length; i++) &#123; System.out.println(keys[i].getSourceString()); &#125;&#125; The displayWords method prints the following lines: 123456apricotgrapelemonpeach","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Customizing Collation Rules","date":"2020-12-05T17:50:52.532Z","path":"wiki/2021-03-03-Customizing Collation Rules/","text":"Customizing Collation RulesThe previous section discussed how to use the predefined rules for a locale to compare strings. These collation rules determine the sort order of strings. If the predefined collation rules do not meet your needs, you can design your own rules and assign them to a RuleBasedCollator object. Customized collation rules are contained in a String object that is passed to the RuleBasedCollator constructor. Here’s a simple example: 1234String simpleRule &#x3D; &quot;&lt; a &lt; b &lt; c &lt; d&quot;;RuleBasedCollator simpleCollator &#x3D; new RuleBasedCollator(simpleRule); For the simpleCollator object in the previous example, a is less than b, which is less that c, and so forth. The simpleCollator.compare method references these rules when comparing strings. The full syntax used to construct a collation rule is more flexible and complex than this simple example. For a full description of the syntax, refer to the API documentation for theRuleBasedCollator class. The example that follows sorts a list of Spanish words with two collators. Full source code for this example is inRulesDemo.java. The RulesDemo program starts by defining collation rules for English and Spanish. The program will sort the Spanish words in the traditional manner. When sorting by the traditional rules, the letters ch and ll and their uppercase equivalents each have their own positions in the sort order. These character pairs compare as if they were one character. For example, ch sorts as a single letter, following cz in the sort order. Note how the rules for the two collators differ: 1234567891011121314151617181920212223String englishRules &#x3D; ( &quot;&lt; a,A &lt; b,B &lt; c,C &lt; d,D &lt; e,E &lt; f,F &quot; + &quot;&lt; g,G &lt; h,H &lt; i,I &lt; j,J &lt; k,K &lt; l,L &quot; + &quot;&lt; m,M &lt; n,N &lt; o,O &lt; p,P &lt; q,Q &lt; r,R &quot; + &quot;&lt; s,S &lt; t,T &lt; u,U &lt; v,V &lt; w,W &lt; x,X &quot; + &quot;&lt; y,Y &lt; z,Z&quot;);String smallnTilde &#x3D; new String(&quot;\\u00F1&quot;); &#x2F;&#x2F; &amp;#241;String capitalNTilde &#x3D; new String(&quot;\\u00D1&quot;); &#x2F;&#x2F; &amp;#209;String traditionalSpanishRules &#x3D; ( &quot;&lt; a,A &lt; b,B &lt; c,C &quot; + &quot;&lt; ch, cH, Ch, CH &quot; + &quot;&lt; d,D &lt; e,E &lt; f,F &quot; + &quot;&lt; g,G &lt; h,H &lt; i,I &lt; j,J &lt; k,K &lt; l,L &quot; + &quot;&lt; ll, lL, Ll, LL &quot; + &quot;&lt; m,M &lt; n,N &quot; + &quot;&lt; &quot; + smallnTilde + &quot;,&quot; + capitalNTilde + &quot; &quot; + &quot;&lt; o,O &lt; p,P &lt; q,Q &lt; r,R &quot; + &quot;&lt; s,S &lt; t,T &lt; u,U &lt; v,V &lt; w,W &lt; x,X &quot; + &quot;&lt; y,Y &lt; z,Z&quot;); The following lines of code create the collators and invoke the sort routine: 12345678910111213141516try &#123; RuleBasedCollator enCollator &#x3D; new RuleBasedCollator(englishRules); RuleBasedCollator spCollator &#x3D; new RuleBasedCollator(traditionalSpanishRules); sortStrings(enCollator, words); printStrings(words); System.out.println(); sortStrings(spCollator, words); printStrings(words);&#125; catch (ParseException pe) &#123; System.out.println(&quot;Parse exception for rules&quot;);&#125; The sort routine, called sortStrings, is generic. It will sort any array of words according to the rules of any Collator object: 1234567891011121314public static void sortStrings(Collator collator, String[] words) &#123; String tmp; for (int i &#x3D; 0; i &lt; words.length; i++) &#123; for (int j &#x3D; i + 1; j &lt; words.length; j++) &#123; if (collator.compare(words[i], words[j]) &gt; 0) &#123; tmp &#x3D; words[i]; words[i] &#x3D; words[j]; words[j] &#x3D; tmp; &#125; &#125; &#125;&#125; When sorted with the English collation rules, the array of words is as follows: 123456chalinacuriosollamaluz Compare the preceding list with the following, which is sorted according to the traditional Spanish rules of collation: 123456curiosochalinaluzllama","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Performing Locale-Independent Comparisons","date":"2020-12-05T17:50:50.645Z","path":"wiki/2021-03-03-Performing Locale-Independent Comparisons/","text":"Performing Locale-Independent ComparisonsCollation rules define the sort sequence of strings. These rules vary with locale, because various natural languages sort words differently. You can use the predefined collation rules provided by the Collator class to sort strings in a locale-independent manner. To instantiate the Collator class invoke the getInstance method. Usually, you create a Collator for the default Locale, as in the following example: 123Collator myDefaultCollator &#x3D; Collator.getInstance(); You can also specify a particular Locale when you create a Collator, as follows: 123Collator myFrenchCollator &#x3D; Collator.getInstance(Locale.FRENCH); The getInstance method returns a RuleBasedCollator, which is a concrete subclass of Collator. The RuleBasedCollator contains a set of rules that determine the sort order of strings for the locale you specify. These rules are predefined for each locale. Because the rules are encapsulated within the RuleBasedCollator, your program won’t need special routines to deal with the way collation rules vary with language. You invoke the Collator.compare method to perform a locale-independent string comparison. The compare method returns an integer less than, equal to, or greater than zero when the first string argument is less than, equal to, or greater than the second string argument. The following table contains some sample calls to Collator.compare: ExampleReturn ValueExplanation `myCollator.compare(\"abc\", \"def\")``-1``\"abc\"` is less than \"def\" `myCollator.compare(\"rtf\", \"rtf\")``0`the two strings are equal `myCollator.compare(\"xyz\", \"abc\")``1`\"xyz\" is greater than \"abc\" You use the compare method when performing sort operations. The sample program calledCollatorDemo uses the compare method to sort an array of English and French words. This program shows what can happen when you sort the same list of words with two different collators: 1234Collator fr_FRCollator &#x3D; Collator.getInstance(new Locale(&quot;fr&quot;,&quot;FR&quot;));Collator en_USCollator &#x3D; Collator.getInstance(new Locale(&quot;en&quot;,&quot;US&quot;)); The method for sorting, called sortStrings, can be used with any Collator. Notice that the sortStrings method invokes the compare method: 1234567891011121314public static void sortStrings(Collator collator, String[] words) &#123; String tmp; for (int i &#x3D; 0; i &lt; words.length; i++) &#123; for (int j &#x3D; i + 1; j &lt; words.length; j++) &#123; if (collator.compare(words[i], words[j]) &gt; 0) &#123; tmp &#x3D; words[i]; words[i] &#x3D; words[j]; words[j] &#x3D; tmp; &#125; &#125; &#125;&#125; The English Collator sorts the words as follows: 123456peachp&amp;#233;ch&amp;#233;p&amp;#234;chesin According to the collation rules of the French language, the preceding list is in the wrong order. In French p&#233;ch&#233; should follow p&#234;che in a sorted list. The French Collator sorts the array of words correctly, as follows: 123456peachp&amp;#234;chep&amp;#233;ch&amp;#233;sin","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Comparing Strings","date":"2020-12-05T17:50:48.517Z","path":"wiki/2021-03-03-Comparing Strings/","text":"Comparing StringsApplications that sort through text perform frequent string comparisons. For example, a report generator performs string comparisons when sorting a list of strings in alphabetical order. If your application audience is limited to people who speak English, you can probably perform string comparisons with the String.compareTo method. The String.compareTo method performs a binary comparison of the Unicode characters within the two strings. For most languages, however, this binary comparison cannot be relied on to sort strings, because the Unicode values do not correspond to the relative order of the characters. Fortunately theCollator class allows your application to perform string comparisons for different languages. In this section, you’ll learn how to use the Collator class when sorting text. Performing Locale-Independent ComparisonsCollation rules define the sort sequence of strings. These rules vary with locale, because various natural languages sort words differently. Using the predefined collation rules provided by the Collator class, you can sort strings in a locale-independent manner. Customizing Collation RulesIn some cases, the predefined collation rules provided by the Collator class may not work for you. For example, you may want to sort strings in a language whose locale is not supported by Collator. In this situation, you can define your own collation rules, and assign them to a RuleBasedCollator object. Improving Collation PerformanceWith the CollationKey class, you may increase the efficiency of string comparisons. This class converts String objects to sort keys that follow the rules of a given Collator.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Checking Character Properties","date":"2020-12-05T17:50:46.361Z","path":"wiki/2021-03-03-Checking Character Properties/","text":"Checking Character PropertiesYou can categorize characters according to their properties. For instance, X is an uppercase letter and 4 is a decimal digit. Checking character properties is a common way to verify the data entered by end users. If you are selling books online, for example, your order entry screen should verify that the characters in the quantity field are all digits. Developers who aren’t used to writing global software might determine a character’s properties by comparing it with character constants. For instance, they might write code like this: 123456789101112131415161718char ch;&#x2F;&#x2F;...&#x2F;&#x2F; This code is WRONG!&#x2F;&#x2F; check if ch is a letterif ((ch &gt;&#x3D; &#39;a&#39; &amp;&amp; ch &lt;&#x3D; &#39;z&#39;) || (ch &gt;&#x3D; &#39;A&#39; &amp;&amp; ch &lt;&#x3D; &#39;Z&#39;)) &#x2F;&#x2F; ...&#x2F;&#x2F; check if ch is a digitif (ch &gt;&#x3D; &#39;0&#39; &amp;&amp; ch &lt;&#x3D; &#39;9&#39;) &#x2F;&#x2F; ...&#x2F;&#x2F; check if ch is a whitespaceif ((ch &#x3D;&#x3D; &#39; &#39;) || (ch &#x3D;&#x3D;&#39;\\n&#39;) || (ch &#x3D;&#x3D; &#39;\\t&#39;)) &#x2F;&#x2F; ... The preceding code is wrong because it works only with English and a few other languages. To internationalize the previous example, replace it with the following statements: 123456789101112131415char ch;&#x2F;&#x2F; ...&#x2F;&#x2F; This code is OK!if (Character.isLetter(ch)) &#x2F;&#x2F; ...if (Character.isDigit(ch)) &#x2F;&#x2F; ...if (Character.isSpaceChar(ch)) &#x2F;&#x2F; ... TheCharacter methods rely on the Unicode Standard for determining the properties of a character. Unicode is a 16-bit character encoding that supports the world’s major languages. In the Java programming language char values represent Unicode characters. If you check the properties of a char with the appropriate Character method, your code will work with all major languages. For example, the Character.isLetter method returns true if the character is a letter in Chinese, German, Arabic, or another language. The following list gives some of the most useful Character comparison methods. The Character API documentation fully specifies the methods. isDigit isLetter isLetterOrDigit isLowerCase isUpperCase isSpaceChar isDefined The Character.getType method returns the Unicode category of a character. Each category corresponds to a constant defined in the Character class. For instance, getType returns the Character.UPPERCASE_LETTER constant for the character A. For a complete list of the category constants returned by getType, see theCharacter API documentation. The following example shows how to use getType and the Character category constants. All of the expressions in these if statements are true: 12345678910111213if (Character.getType(&#39;a&#39;) &#x3D;&#x3D; Character.LOWERCASE_LETTER) &#x2F;&#x2F; ...if (Character.getType(&#39;R&#39;) &#x3D;&#x3D; Character.UPPERCASE_LETTER) &#x2F;&#x2F; ...if (Character.getType(&#39;&gt;&#39;) &#x3D;&#x3D; Character.MATH_SYMBOL) &#x2F;&#x2F; ...if (Character.getType(&#39;_&#39;) &#x3D;&#x3D; Character.CONNECTOR_PUNCTUATION) &#x2F;&#x2F; ...","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Working with Text","date":"2020-12-05T17:50:44.416Z","path":"wiki/2021-03-03-Working with Text/","text":"Lesson: Working with TextNearly all programs with user interfaces manipulate text. In an international market the text your programs display must conform to the rules of languages from around the world. The Java programming language provides a number of classes that help you handle text in a locale-independent manner. Checking Character PropertiesThis section explains how to use the Character comparison methods to check character properties for all major languages. Comparing StringsIn this section you’ll learn how to perform locale-independent string comparisons with the Collator class. Detecting Text BoundariesThis section shows how the BreakIterator class can detect character, word, sentence, and line boundaries. Converting Non-Unicode TextDifferent computer systems around the world store text in a variety of encoding schemes. This section describes the classes that help you convert text between Unicode and other encodings. Normalizer’s APIThis section explains how to use the Normalizer’s API to transform text applying different normalization forms. Working with Bidirectional Text with JTextComponent ClassThis section discusses how to work with bidirectional text, which is text that contains text that runs in two directions, left-to-right and right-to-left.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Handling Plurals","date":"2020-12-05T17:50:42.396Z","path":"wiki/2021-03-03-Handling Plurals/","text":"Handling PluralsThe words in a message may vary if both plural and singular word forms are possible. With the ChoiceFormat class, you can map a number to a word or a phrase, allowing you to construct grammatically correct messages. In English the plural and singular forms of a word are usually different. This can present a problem when you are constructing messages that refer to quantities. For example, if your message reports the number of files on a disk, the following variations are possible: 12345There are no files on XDisk.There is one file on XDisk.There are 2 files on XDisk. The fastest way to solve this problem is to create a MessageFormat pattern like this: 123There are &#123;0,number&#125; file(s) on &#123;1&#125;. Unfortunately the preceding pattern results in incorrect grammar: 123There are 1 file(s) on XDisk. You can do better than that, provided that you use theChoiceFormat class. In this section you’ll learn how to deal with plurals in a message by stepping through a sample program calledChoiceFormatDemo. This program also uses the MessageFormat class, which is discussed in the previous section, Dealing with Compound Messages. 1. Define the Message PatternFirst, identify the variables in the message: Next, replace the variables in the message with arguments, creating a pattern that can be applied to a MessageFormat object: 123There &#123;0&#125; on &#123;1&#125;. The argument for the disk name, which is represented by&#123;1&#125;, is easy enough to deal with. You just treat it like any other String variable in a MessageFormat pattern. This argument matches the element at index 1 in the array of argument values. (See step 7.) Dealing with argument&#123;0&#125; is more complex, for a couple of reasons: The phrase that this argument replaces varies with the number of files. To construct this phrase at run time, you need to map the number of files to a particular String. For example, the number 1 will map to the String containing the phrase is one file. The ChoiceFormat class allows you to perform the necessary mapping. If the disk contains multiple files, the phrase includes an integer. The MessageFormat class lets you insert a number into a phrase. 2. Create a ResourceBundleBecause the message text must be translated, isolate it in a ResourceBundle: 1234ResourceBundle bundle &#x3D; ResourceBundle.getBundle( &quot;ChoiceBundle&quot;, currentLocale); The sample program backs the ResourceBundle with properties files. TheChoiceBundle_en_US.propertiescontains the following lines: 123456pattern &#x3D; There &#123;0&#125; on &#123;1&#125;.noFiles &#x3D; are no filesoneFile &#x3D; is one filemultipleFiles &#x3D; are &#123;2&#125; files The contents of this properties file show how the message will be constructed and formatted. The first line contains the pattern for MessageFormat . (See step 1.) The other lines contain phrases that will replace argument &#123;0&#125; in the pattern. The phrase for the multipleFiles key contains the argument &#123;2&#125;, which will be replaced by a number. Here is the French version of the properties file,ChoiceBundle_fr_FR.properties 123456pattern &#x3D; Il &#123;0&#125; sur &#123;1&#125;.noFiles &#x3D; n&#39;y a pas de fichiersoneFile &#x3D; y a un fichiermultipleFiles &#x3D; y a &#123;2&#125; fichiers 3. Create a Message FormatterIn this step you instantiate MessageFormat and set its Locale: 1234MessageFormat messageForm &#x3D; new MessageFormat(&quot;&quot;);messageForm.setLocale(currentLocale); 4. Create a Choice FormatterThe ChoiceFormat object allows you to choose, based on a double number, a particular String. The range of double numbers, and the String objects to which they map, are specified in arrays: 12345678double[] fileLimits &#x3D; &#123;0,1,2&#125;;String [] fileStrings &#x3D; &#123; bundle.getString(&quot;noFiles&quot;), bundle.getString(&quot;oneFile&quot;), bundle.getString(&quot;multipleFiles&quot;)&#125;; ChoiceFormat maps each element in the double array to the element in the String array that has the same index. In the sample code the 0 maps to the String returned by calling bundle.getString(&quot;noFiles&quot;). By coincidence the index is the same as the value in the fileLimits array. If the code had set fileLimits[0] to seven, ChoiceFormat would map the number 7 to fileStrings[0]. You specify the double and String arrays when instantiating ChoiceFormat: 123ChoiceFormat choiceForm &#x3D; new ChoiceFormat(fileLimits, fileStrings); 5. Apply the PatternRemember the pattern you constructed in step 1? It’s time to retrieve the pattern from the ResourceBundle and apply it to the MessageFormat object: 1234String pattern &#x3D; bundle.getString(&quot;pattern&quot;);messageForm.applyPattern(pattern); 6. Assign the FormatsIn this step you assign to the MessageFormat object the ChoiceFormat object created in step 4: 1234Format[] formats &#x3D; &#123;choiceForm, null, NumberFormat.getInstance()&#125;;messageForm.setFormats(formats); The setFormats method assigns Format objects to the arguments in the message pattern. You must invoke the applyPattern method before you call the setFormats method. The following table shows how the elements of the Format array correspond to the arguments in the message pattern: The Format Array of the ChoiceFormatDemo ProgramArray ElementPattern Argument `choiceForm``{0}` `null``{1}` `NumberFormat.getInstance()``{2}` 7. Set the Arguments and Format the MessageAt run time the program assigns the variables to the array of arguments it passes to the MessageFormat object. The elements in the array correspond to the arguments in the pattern. For example, messageArgument[1] maps to pattern argument &#123;1&#125;, which is a String containing the name of the disk. In the previous step the program assigned a ChoiceFormat object to argument &#123;0&#125; of the pattern. Therefore the number assigned to messageArgument[0] determines which String the ChoiceFormat object selects. If messageArgument[0] is greater than or equal to 2, the String containing the phrase are &#123;2&#125; files replaces argument &#123;0&#125; in the pattern. The number assigned to messageArgument[2] will be substituted in place of pattern argument &#123;2&#125;. Here’s the code that tries this out: 12345678910Object[] messageArguments &#x3D; &#123;null, &quot;XDisk&quot;, null&#125;;for (int numFiles &#x3D; 0; numFiles &lt; 4; numFiles++) &#123; messageArguments[0] &#x3D; new Integer(numFiles); messageArguments[2] &#x3D; new Integer(numFiles); String result &#x3D; messageForm.format(messageArguments); System.out.println(result);&#125; 8. Run the Demo ProgramCompare the messages displayed by the program with the phrases in the ResourceBundle of step 2. Notice that the ChoiceFormat object selects the correct phrase, which the MessageFormat object uses to construct the proper message. The output of the ChoiceFormatDemo program is as follows: 12345678910111213currentLocale &#x3D; en_USThere are no files on XDisk.There is one file on XDisk.There are 2 files on XDisk.There are 3 files on XDisk.currentLocale &#x3D; fr_FRIl n&#39;y a pas des fichiers sur XDisk.Il y a un fichier sur XDisk.Il y a 2 fichiers sur XDisk.Il y a 3 fichiers sur XDisk.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Dealing with Compound Messages","date":"2020-12-05T17:50:39.993Z","path":"wiki/2021-03-03-Dealing with Compound Messages/","text":"Dealing with Compound MessagesA compound message may contain several kinds of variables: dates, times, strings, numbers, currencies, and percentages. To format a compound message in a locale-independent manner, you construct a pattern that you apply to a MessageFormat object, and store this pattern in a ResourceBundle. By stepping through a sample program, this section demonstrates how to internationalize a compound message. The sample program makes use of theMessageFormat class. The full source code for this program is in the file calledMessageFormatDemo.java. The German locale properties are in the file calledMessageBundle_de_DE.properties. 1. Identify the Variables in the MessageSuppose that you want to internationalize the following message: Notice that we’ve underlined the variable data and have identified what kind of objects will represent this data. 2. Isolate the Message Pattern in a ResourceBundleStore the message in a ResourceBundle named MessageBundle, as follows: 1234ResourceBundle messages &#x3D; ResourceBundle.getBundle(&quot;MessageBundle&quot;, currentLocale); This ResourceBundle is backed by a properties file for each Locale. Since the ResourceBundle is called MessageBundle, the properties file for U.S. English is named MessageBundle_en_US.properties. The contents of this file is as follows: 123456template &#x3D; At &#123;2,time,short&#125; on &#123;2,date,long&#125;, \\ we detected &#123;1,number,integer&#125; spaceships on \\ the planet &#123;0&#125;.planet &#x3D; Mars The first line of the properties file contains the message pattern. If you compare this pattern with the message text shown in step 1, you’ll see that an argument enclosed in braces replaces each variable in the message text. Each argument starts with a digit called the argument number, which matches the index of an element in an Object array that holds the argument values. Note that in the pattern the argument numbers are not in any particular order. You can place the arguments anywhere in the pattern. The only requirement is that the argument number have a matching element in the array of argument values. The next step discusses the argument value array, but first let’s look at each of the arguments in the pattern. The following table provides some details about the arguments: ArgumentDescription `{2,time,short}`The time portion of a `Date` object. The `short` style specifies the `DateFormat.SHORT` formatting style. `{2,date,long}`The date portion of a `Date` object. The same `Date` object is used for both the date and time variables. In the `Object` array of arguments the index of the element holding the `Date` object is 2. (This is described in the next step.) `{1,number,integer}`A `Number` object, further qualified with the `integer` number style. `{0}`The `String` in the `ResourceBundle` that corresponds to the `planet` key. For a full description of the argument syntax, see the API documentation for theMessageFormat class. 3. Set the Message ArgumentsThe following lines of code assign values to each argument in the pattern. The indexes of the elements in the messageArguments array match the argument numbers in the pattern. For example, the Integer element at index 1 corresponds to the &#123;1,number,integer&#125; argument in the pattern. Because it must be translated, the String object at element 0 will be fetched from the ResourceBundle with the getString method. Here is the code that defines the array of message arguments: 1234567Object[] messageArguments &#x3D; &#123; messages.getString(&quot;planet&quot;), new Integer(7), new Date()&#125;; 4. Create the FormatterNext, create a MessageFormat object. You set the Locale because the message contains Date and Number objects, which should be formatted in a locale-sensitive manner. 1234MessageFormat formatter &#x3D; new MessageFormat(&quot;&quot;);formatter.setLocale(currentLocale); 5. Format the Message Using the Pattern and the ArgumentsThis step shows how the pattern, message arguments, and formatter all work together. First, fetch the pattern String from the ResourceBundle with the getString method. The key to the pattern is template. Pass the pattern String to the formatter with the applyPattern method. Then format the message using the array of message arguments, by invoking the format method. The String returned by the format method is ready to be displayed. All of this is accomplished with just two lines of code: 1234formatter.applyPattern(messages.getString(&quot;template&quot;));String output &#x3D; formatter.format(messageArguments); 6. Run the Demo ProgramThe demo program prints the translated messages for the English and German locales and properly formats the date and time variables. Note that the English and German verbs (“detected” and “entdeckt”) are in different locations relative to the variables: 12345678currentLocale &#x3D; en_USAt 10:16 AM on July 31, 2009, we detected 7spaceships on the planet Mars.currentLocale &#x3D; de_DEUm 10:16 am 31. Juli 2009 haben wir 7 Raumschiffeauf dem Planeten Mars entdeckt.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Messages","date":"2020-12-05T17:50:37.805Z","path":"wiki/2021-03-03-Messages/","text":"MessagesWe all like to use programs that let us know what’s going on. Programs that keep us informed often do so by displaying status and error messages. Of course, these messages need to be translated so they can be understood by end users around the world. The sectionIsolating Locale-Specific Data discusses translatable text messages. Usually, you’re done after you move a message String into a ResourceBundle. However, if you’ve embedded variable data in a message, you’ll have to take some extra steps to prepare it for translation. A compound message contains variable data. In the following list of compound messages, the variable data is underlined: 123456The disk named &lt;u&gt;MyDisk&lt;&#x2F;u&gt; contains &lt;u&gt;300&lt;&#x2F;u&gt; files.The current balance of account &lt;u&gt;#34-09-222&lt;&#x2F;u&gt; is &lt;u&gt;$2,745.72&lt;&#x2F;u&gt;.&lt;u&gt;405,390&lt;&#x2F;u&gt; people have visited your website since &lt;u&gt;January 1, 2009&lt;&#x2F;u&gt;.Delete all files older than &lt;u&gt;120&lt;&#x2F;u&gt; days. You might be tempted to construct the last message in the preceding list by concatenating phrases and variables as follows: 123456789double numDays;ResourceBundle msgBundle;&#x2F;&#x2F; ...String message &#x3D; msgBundle.getString( &quot;deleteolder&quot; + numDays.toString() + msgBundle.getString(&quot;days&quot;)); This approach works fine in English, but it won’t work for languages in which the verb appears at the end of the sentence. Because the word order of this message is hardcoded, your localizers won’t be able to create grammatically correct translations for all languages. How can you make your program localizable if you need to use compound messages? You can do so by using the MessageFormat class, which is the topic of this section. Compound messages are difficult to translate because the message text is fragmented. If you use compound messages, localization will take longer and cost more. Therefore you should use compound messages only when necessary. Dealing with Compound MessagesA compound message may contain several kinds of variables: dates, times, strings, numbers, currencies, and percentages. To format a compound message in a locale-independent manner, you construct a pattern that you apply to a MessageFormat object. Handling PluralsThe words in a message usually vary if both plural and singular word forms are possible. With the ChoiceFormat class, you can map a number to a word or phrase, allowing you to construct messages that are grammatically correct.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Changing Date Format Symbols","date":"2020-12-05T17:50:35.613Z","path":"wiki/2021-03-03-Changing Date Format Symbols/","text":"Changing Date Format SymbolsThe format method of the SimpleDateFormat class returns a String composed of digits and symbols. For example, in the String “Friday, April 10, 2009,” the symbols are “Friday” and “April.” If the symbols encapsulated in SimpleDateFormat don’t meet your needs, you can change them with theDateFormatSymbols. You can change symbols that represent names for months, days of the week, and time zones, among others. The following table lists the DateFormatSymbols methods that allow you to modify the symbols: Setter MethodExample of a Symbol the Method Modifies `setAmPmStrings`PM `setEras`AD `setMonths`December `setShortMonths`Dec `setShortWeekdays`Tue `setWeekdays`Tuesday `setZoneStrings`PST The following example invokes setShortWeekdays to change the short names of the days of the week from lowercase to uppercase characters. The full source code for this example is inDateFormatSymbolsDemo. The first element in the array argument of setShortWeekdays is a null String. Therefore the array is one-based rather than zero-based. The SimpleDateFormat constructor accepts the modified DateFormatSymbols object as an argument. Here is the source code: 1234567891011121314151617181920212223242526272829303132333435Date today;String result;SimpleDateFormat formatter;DateFormatSymbols symbols;String[] defaultDays;String[] modifiedDays;symbols &#x3D; new DateFormatSymbols( new Locale(&quot;en&quot;, &quot;US&quot;));defaultDays &#x3D; symbols.getShortWeekdays();for (int i &#x3D; 0; i &lt; defaultDays.length; i++) &#123; System.out.print(defaultDays[i] + &quot; &quot;);&#125;System.out.println();String[] capitalDays &#x3D; &#123; &quot;&quot;, &quot;SUN&quot;, &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;&#125;;symbols.setShortWeekdays(capitalDays);modifiedDays &#x3D; symbols.getShortWeekdays();for (int i &#x3D; 0; i &lt; modifiedDays.length; i++) &#123; System.out.print(modifiedDays[i] + &quot; &quot;);&#125;System.out.println();System.out.println();formatter &#x3D; new SimpleDateFormat(&quot;E&quot;, symbols);today &#x3D; new Date();result &#x3D; formatter.format(today);System.out.println(&quot;Today&#39;s day of the week: &quot; + result); The preceding code generates this output: 123456 Sun Mon Tue Wed Thu Fri Sat SUN MON TUE WED THU FRI SAT Today&#39;s day of the week: MON","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Customizing Formats","date":"2020-12-05T17:50:32.727Z","path":"wiki/2021-03-03-Customizing Formats/","text":"Customizing FormatsThe previous section, Using Predefined Formats, described the formatting styles provided by the DateFormat class. In most cases these predefined formats are adequate. However, if you want to create your own customized formats, you can use theSimpleDateFormat class. The code examples that follow demonstrate the methods of the SimpleDateFormat class. You can find the full source code for the examples in the file namedSimpleDateFormatDemo. About PatternsWhen you create a SimpleDateFormat object, you specify a pattern String. The contents of the pattern String determine the format of the date and time. For a full description of the pattern’s syntax, see the tables in Date Format Pattern Syntax. The following code formats a date and time according to the pattern String passed to the SimpleDateFormat constructor. The String returned by the format method contains the formatted date and time that are to be displayed. 12345678910Date today;String output;SimpleDateFormat formatter;formatter &#x3D; new SimpleDateFormat(pattern, currentLocale);today &#x3D; new Date();output &#x3D; formatter.format(today);System.out.println(pattern + &quot; &quot; + output); The following table shows the output generated by the previous code example when the U.S. Locale is specified: PatternOutput dd.MM.yy30.06.09 yyyy.MM.dd G 'at' hh:mm:ss z2009.06.30 AD at 08:29:36 PDT EEE, MMM d, ''yyTue, Jun 30, '09 h:mm a8:29 PM H:mm8:29 H:mm:ss:SSS8:28:36:249 K:mm a,z8:29 AM,PDT yyyy.MMMMM.dd GGG hh:mm aaa2009.June.30 AD 08:29 AM Patterns and LocaleThe SimpleDateFormat class is locale-sensitive. If you instantiate SimpleDateFormat without a Locale parameter, it will format the date and time according to the default Locale. Both the pattern and the Locale determine the format. For the same pattern, SimpleDateFormat may format a date and time differently if the Locale varies. In the example code that follows, the pattern is hardcoded in the statement that creates the SimpleDateFormat object: 1234567891011Date today;String result;SimpleDateFormat formatter;formatter &#x3D; new SimpleDateFormat(&quot;EEE d MMM yy&quot;, currentLocale);today &#x3D; new Date();result &#x3D; formatter.format(today);System.out.println(&quot;Locale: &quot; + currentLocale.toString());System.out.println(&quot;Result: &quot; + result); When the currentLocale is set to different values, the preceding code example generates this output: 12345678Locale: fr_FRResult: mar. 30 juin 09Locale: de_DEResult: Di 30 Jun 09Locale: en_USResult: Tue 30 Jun 09 Date Format Pattern SyntaxYou can design your own format patterns for dates and times from the list of symbols in the following table: SymbolMeaningPresentationExample Gera designatorTextAD yyearNumber2009 Mmonth in yearText &amp; NumberJuly &amp; 07 dday in monthNumber10 hhour in am/pm (1-12)Number12 Hhour in day (0-23)Number0 mminute in hourNumber30 ssecond in minuteNumber55 SmillisecondNumber978 Eday in weekTextTuesday Dday in yearNumber189 Fday of week in monthNumber2 (2nd Wed in July) wweek in yearNumber27 Wweek in monthNumber2 aam/pm markerTextPM khour in day (1-24)Number24 Khour in am/pm (0-11)Number0 ztime zoneTextPacific Standard Time 'escape for textDelimiter(none) 'single quoteLiteral' Characters that are not letters are treated as quoted text. That is, they will appear in the formatted text even if they are not enclosed within single quotes. The number of symbol letters you specify also determines the format. For example, if the “zz” pattern results in “PDT,” then the “zzzz” pattern generates “Pacific Daylight Time.” The following table summarizes these rules: PresentationNumber of SymbolsResult Text1 - 3abbreviated form, if one exists Text&gt;= 4full form Numberminimum number of digits is requiredshorter numbers are padded with zeros (for a year, if the count of 'y' is 2, then the year is truncated to 2 digits) Text &amp; Number1 - 2number form Text &amp; Number3text form","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Using Predefined Formats","date":"2020-12-05T17:50:30.503Z","path":"wiki/2021-03-03-Using Predefined Formats/","text":"Using Predefined FormatsTheDateFormat class allows you to format dates and times with predefined styles in a locale-sensitive manner. The sections that follow demonstrate how to use the DateFormat class with a program calledDateFormatDemo.java. DatesFormatting dates with the DateFormat class is a two-step process. First, you create a formatter with the getDateInstance method. Second, you invoke the format method, which returns a String containing the formatted date. The following example formats today’s date by calling these two methods: 1234567891011Date today;String dateOut;DateFormat dateFormatter;dateFormatter &#x3D; DateFormat.getDateInstance(DateFormat.DEFAULT, currentLocale);today &#x3D; new Date();dateOut &#x3D; dateFormatter.format(today);System.out.println(dateOut + &quot; &quot; + currentLocale.toString()); The output generated by this code follows. Notice that the formats of the dates vary with Locale. Since DateFormat is locale-sensitive, it takes care of the formatting details for each Locale. 1234530 juin 2009 fr_FR30.06.2009 de_DEJun 30, 2009 en_US The preceding code example specified the DEFAULT formatting style. The DEFAULT style is just one of the predefined formatting styles that the DateFormat class provides, as follows: DEFAULT SHORT MEDIUM LONG FULL The following table shows how dates are formatted for each style with the U.S. and French locales: StyleU.S. LocaleFrench Locale `DEFAULT`Jun 30, 200930 juin 2009 `SHORT`6/30/0930/06/09 `MEDIUM`Jun 30, 200930 juin 2009 `LONG`June 30, 200930 juin 2009 `FULL`Tuesday, June 30, 2009mardi 30 juin 2009 TimesDate objects represent both dates and times. Formatting times with the DateFormat class is similar to formatting dates, except that you create the formatter with the getTimeInstance method, as follows: 1234DateFormat timeFormatter &#x3D; DateFormat.getTimeInstance(DateFormat.DEFAULT, currentLocale); The table that follows shows the various predefined format styles for the U.S. and German locales: StyleU.S. LocaleGerman Locale `DEFAULT`7:03:47 AM7:03:47 `SHORT`7:03 AM07:03 `MEDIUM`7:03:47 AM07:03:07 `LONG`7:03:47 AM PDT07:03:45 PDT `FULL`7:03:47 AM PDT7.03 Uhr PDT Both Dates and TimesTo display a date and time in the same String, create the formatter with the getDateTimeInstance method. The first parameter is the date style, and the second is the time style. The third parameter is the Locale . Here’s a quick example: 123456DateFormat formatter &#x3D; DateFormat.getDateTimeInstance( DateFormat.LONG, DateFormat.LONG, currentLocale); The following table shows the date and time formatting styles for the U.S. and French locales: StyleU.S. LocaleFrench Locale `DEFAULT`Jun 30, 2009 7:03:47 AM30 juin 2009 07:03:47 `SHORT`6/30/09 7:03 AM30/06/09 07:03 `MEDIUM`Jun 30, 2009 7:03:47 AM30 juin 2009 07:03:47 `LONG`June 30, 2009 7:03:47 AM PDT30 juin 2009 07:03:47 PDT `FULL`Tuesday, June 30, 2009 7:03:47 AM PDTmardi 30 juin 2009 07 h 03 PDT","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Dates and Times","date":"2020-12-05T17:50:28.803Z","path":"wiki/2021-03-03-Dates and Times/","text":"Dates and TimesDate objects represent dates and times. You cannot display or print a Date object without first converting it to a String that is in the proper format. Just what is the “proper” format? First, the format should conform to the conventions of the end user’s Locale. For example, Germans recognize 20.4.09 as a valid date, but Americans expect that same date to appear as 4/20/09. Second, the format should include the necessary information. For instance, a program that measures network performance may report on elapsed milliseconds. An online appointment calendar probably won’t display milliseconds, but it will show the days of the week. This section explains how to format dates and times in various ways and in a locale-sensitive manner. If you follow these techniques your programs will display dates and times in the appropriate Locale, but your source code will remain independent of any specific Locale. Using Predefined FormatsThe DateFormat class provides predefined formatting styles that are locale-specific and easy to use. Customizing FormatsWith the SimpleDateFormat class, you can create customized, locale-specific formats. Changing Date Format SymbolsUsing the DateFormatSymbols class, you can change the symbols that represent the names of months, days of the week, and other formatting elements.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Numbers and Currencies","date":"2020-12-05T17:50:20.898Z","path":"wiki/2021-03-03-Numbers and Currencies/","text":"Numbers and CurrenciesPrograms store and operate on numbers in a locale-independent way. Before displaying or printing a number, a program must convert it to a String that is in a locale-sensitive format. For example, in France the number 123456.78 should be formatted as 123 456,78, and in Germany it should appear as 123.456,78. In this section, you will learn how to make your programs independent of the locale conventions for decimal points, thousands-separators, and other formatting properties. Using Predefined FormatsUsing the factory methods provided by the NumberFormat class, you can get locale-specific formats for numbers, currencies, and percentages. Formatting with PatternsWith the DecimalFormat class you specify a number’s format with a String pattern. The DecimalFormatSymbols class allows you to modify formatting symbols such as decimal separators and minus signs.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Formatting","date":"2020-12-05T17:50:18.715Z","path":"wiki/2021-03-03-Formatting/","text":"Lesson: FormattingThis lesson explains how to format numbers, currencies, dates, times, and text messages. Because end users can see these data elements, their format must conform to various cultural conventions. Following the examples in this lesson will teach you how to: Format data elements in a locale-sensitive manner Keep your code locale-independent Avoid the need to write formatting routines for specific locales Numbers and CurrenciesThis section explains how to use the NumberFormat, DecimalFormat, and DecimalFormatSymbols classes. Dates and TimesThis section focuses on the DateFormat, SimpleDateFormat, and DateFormatSymbols classes. MessagesThis section shows how the MessageFormat and ChoiceFormat classes can help you solve some of the problems you might encounter when formatting text messages.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Customizing Resource Bundle Loading","date":"2020-12-05T17:50:14.268Z","path":"wiki/2021-03-03-Customizing Resource Bundle Loading/","text":"Customizing Resource Bundle LoadingEarlier in this lesson you have learned how to create and access objects of the ResourceBundle class. This section extents your knowledge and explains how to take an advantage from theResourceBundle.Control class capabilities. The ResourceBundle.Control was created to specify how to locate and instantiate resource bundles. It defines a set of callback methods that are invoked by theResourceBundle.getBundle factory methods during the bundle loading process. Unlike aResourceBundle.getBundle method described earlier, this ResourceBundle.getBundle method defines a resource bundle using the specified base name, the default locale and the specified control. 123456public static final ResourceBundle getBundle( String baseName, ResourceBundle.Control cont &#x2F;&#x2F; ... The specified control provide information for the resource bundle loading process. The following sample program calledRBControl.java illustrates how to define your own search paths for Chinese locales. 1. Create the properties Files.As it was described before you can load your resources either from classes or from properties files. These files contain descriptions for the following locales: [`RBControl.properties`](examples/RBControl.properties) &#150; Global [`RBControl_zh.properties`](examples/RBControl_zh.properties) &#150; Language only: Simplified Chinese [`RBControl_zh_cn.properties`](examples/RBControl_zh_CN.properties) &#150; Region only: China [`RBControl_zh_hk.properties`](examples/RBControl_zh_HK.properties) &#150; Region only: Hong Kong [`RBControl_zh_tw.properties`](examples/RBControl_zh_TW.properties) &#150; Taiwan In this example an application creates a new locale for the Hong Kong region. 2. Create a ResourceBundle instance.As in the example in the previous section, this application creates a ResourceBundle instance by invoking the getBundle method: 12345678910private static void test(Locale locale) &#123; ResourceBundle rb &#x3D; ResourceBundle.getBundle( &quot;RBControl&quot;, locale, new ResourceBundle.Control() &#123; &#x2F;&#x2F; ... &#125; ); The getBundle method searches for properties files with the RBControl prefix. However, this method contains a Control parameter, which drives the process of searching the Chineese locales. 3. Invoke the getCandidateLocales methodThe getCandidateLocales method returns a list of the Locales objects as candidate locales for the base name and locale. 12345678910new ResourceBundle.Control() &#123; @Override public List&lt;Locale&gt; getCandidateLocales( String baseName, Locale locale) &#123; &#x2F;&#x2F; ... &#125;&#125; The default implementation returns a list of the Locale objects as follows: Locale(language, country). However, this method is overriden to implement the following specific behavior: 1234567891011121314151617if (baseName &#x3D;&#x3D; null) throw new NullPointerException();if (locale.equals(new Locale(&quot;zh&quot;, &quot;HK&quot;))) &#123; return Arrays.asList( locale, Locale.TAIWAN, &#x2F;&#x2F; no Locale.CHINESE here Locale.ROOT);&#125; else if (locale.equals(Locale.TAIWAN)) &#123; return Arrays.asList( locale, &#x2F;&#x2F; no Locale.CHINESE here Locale.ROOT);&#125; Note, that the last element of the sequence of candidate locales must be a root locale. 4. Call the test classCall the test class for the following four different locales: 12345678public static void main(String[] args) &#123; test(Locale.CHINA); test(new Locale(&quot;zh&quot;, &quot;HK&quot;)); test(Locale.TAIWAN); test(Locale.CANADA);&#125; 5. Run the Sample ProgramYou will see the program output as follows: 1234567891011121314locale: zh_CN region: China language: Simplified Chineselocale: zh_HK region: Hong Kong language: Traditional Chineselocale: zh_TW region: Taiwan language: Traditional Chineselocale: en_CA region: global language: English Note that the newly created was assigned the Hong Kong region, because it was specified in an appropriate properties file. Traditional Chinese was assigned as the language for the Taiwan locale. Two other interesting methods of the ResourceBundle.Control class were not used in the RBControl example, but they deserved to be mentioned. The getTimeToLive method is used to determine how long the resource bundle can exist in the cache. If the time limit for a resource bundle in the cache has expired, the needsReload method is invoked to determine whether the resource bundle needs to be reloaded.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Using a ListResourceBundle","date":"2020-12-05T17:50:12.091Z","path":"wiki/2021-03-03-Using a ListResourceBundle/","text":"Using a ListResourceBundleThis section illustrates the use of a ListResourceBundle object with a sample program called&lt;code&gt;ListDemo. The text that follows explains each step involved in creating the ListDemo program, along with the ListResourceBundle subclasses that support it. 1. Create the ListResourceBundle SubclassesA ListResourceBundle is backed up by a class file. Therefore the first step is to create a class file for every supported Locale. In the ListDemo program the base name of the ListResourceBundle is StatsBundle. Since ListDemo supports three Locale objects, it requires the following three class files: 12345StatsBundle_en_CA.classStatsBundle_fr_FR.classStatsBundle_ja_JP.class The StatsBundle class for Japan is defined in the source code that follows. Note that the class name is constructed by appending the language and country codes to the base name of the ListResourceBundle. Inside the class the two-dimensional contents array is initialized with the key-value pairs. The keys are the first element in each pair: GDP, Population, and Literacy. The keys must be String objects and they must be the same in every class in the StatsBundle set. The values can be any type of object. In this example the values are two Integer objects and a Double object. 1234567891011121314import java.util.*;public class StatsBundle_ja_JP extends ListResourceBundle &#123; public Object[][] getContents() &#123; return contents; &#125; private Object[][] contents &#x3D; &#123; &#123; &quot;GDP&quot;, new Integer(21300) &#125;, &#123; &quot;Population&quot;, new Integer(125449703) &#125;, &#123; &quot;Literacy&quot;, new Double(0.99) &#125;, &#125;;&#125; 2. Specify the LocaleThe ListDemo program defines the Locale objects as follows: 1234567Locale[] supportedLocales &#x3D; &#123; new Locale(&quot;en&quot;, &quot;CA&quot;), new Locale(&quot;ja&quot;, &quot;JP&quot;), new Locale(&quot;fr&quot;, &quot;FR&quot;)&#125;; Each Locale object corresponds to one of the StatsBundle classes. For example, the Japanese Locale, which was defined with the ja and JP codes, matches StatsBundle_ja_JP.class. 3. Create the ResourceBundleTo create the ListResourceBundle, invoke the getBundle method. The following line of code specifies the base name of the class (StatsBundle) and the Locale: 123ResourceBundle stats &#x3D; ResourceBundle.getBundle(&quot;StatsBundle&quot;, currentLocale); The getBundle method searches for a class whose name begins with StatsBundle and is followed by the language and country codes of the specified Locale. If the currentLocale is created with the ja and JP codes, getBundle returns a ListResourceBundle corresponding to the class StatsBundle_ja_JP, for example. 4. Fetch the Localized ObjectsNow that the program has a ListResourceBundle for the appropriate Locale, it can fetch the localized objects by their keys. The following line of code retrieves the literacy rate by invoking getObject with the Literacy key parameter. Since getObject returns an object, cast it to a Double: 123Double lit &#x3D; (Double)stats.getObject(&quot;Literacy&quot;); 5. Run the Demo ProgramListDemo program prints the data it fetched with the getBundle method: 12345678910111213141516Locale &#x3D; en_CAGDP &#x3D; 24400Population &#x3D; 28802671Literacy &#x3D; 0.97Locale &#x3D; ja_JPGDP &#x3D; 21300Population &#x3D; 125449703Literacy &#x3D; 0.99Locale &#x3D; fr_FRGDP &#x3D; 20200Population &#x3D; 58317450Literacy &#x3D; 0.99","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Backing a ResourceBundle with Properties Files","date":"2020-12-05T17:50:10.080Z","path":"wiki/2021-03-03-Backing a ResourceBundle with Properties Files/","text":"Backing a ResourceBundle with Properties FilesThis section steps through a sample program named&lt;code&gt;PropertiesDemo. 1. Create the Default Properties FileA properties file is a simple text file. You can create and maintain a properties file with just about any text editor. You should always create a default properties file. The name of this file begins with the base name of your ResourceBundle and ends with the .properties suffix. In the PropertiesDemo program the base name is LabelsBundle. Therefore the default properties file is called LabelsBundle.properties. This file contains the following lines: 1234567# This is the default LabelsBundle.properties files1 &#x3D; computers2 &#x3D; disks3 &#x3D; monitors4 &#x3D; keyboard Note that in the preceding file the comment lines begin with a pound sign (#). The other lines contain key-value pairs. The key is on the left side of the equal sign and the value is on the right. For instance, s2 is the key that corresponds to the value disk. The key is arbitrary. We could have called s2 something else, like msg5 or diskID. Once defined, however, the key should not change because it is referenced in the source code. The values may be changed. In fact, when your localizers create new properties files to accommodate additional languages, they will translate the values into various languages. 2. Create Additional Properties Files as NeededTo support an additional Locale, your localizers will create a new properties file that contains the translated values. No changes to your source code are required, because your program references the keys, not the values. For example, to add support for the German language, your localizers would translate the values in LabelsBundle.properties and place them in a file named LabelsBundle_de.properties. Notice that the name of this file, like that of the default file, begins with the base name LabelsBundle and ends with the .properties suffix. However, since this file is intended for a specific Locale, the base name is followed by the language code (de). The contents of LabelsBundle_de.properties are as follows: 1234567# This is the LabelsBundle_de.properties files1 &#x3D; Computers2 &#x3D; Plattes3 &#x3D; Monitors4 &#x3D; Tastatur The PropertiesDemo sample program ships with three properties files: 12345LabelsBundle.propertiesLabelsBundle_de.propertiesLabelsBundle_fr.properties 3. Specify the LocaleThe PropertiesDemo program creates the Locale objects as follows: 1234567Locale[] supportedLocales &#x3D; &#123; Locale.FRENCH, Locale.GERMAN, Locale.ENGLISH&#125;; These Locale objects should match the properties files created in the previous two steps. For example, the Locale.FRENCH object corresponds to the LabelsBundle_fr.properties file. The Locale.ENGLISH has no matching LabelsBundle_en.properties file, so the default file will be used. 4. Create the ResourceBundleThis step shows how the Locale, the properties files, and the ResourceBundle are related. To create the ResourceBundle, invoke the getBundlemethod, specifying the base name and Locale: 123ResourceBundle labels &#x3D; ResourceBundle.getBundle(&quot;LabelsBundle&quot;, currentLocale); The getBundle method first looks for a class file that matches the base name and the Locale. If it can’t find a class file, it then checks for properties files. In the PropertiesDemo program we’re backing the ResourceBundle with properties files instead of class files. When the getBundle method locates the correct properties file, it returns a PropertyResourceBundle object containing the key-value pairs from the properties file. 5. Fetch the Localized TextTo retrieve the translated value from the ResourceBundle, invoke the getString method as follows: 123String value &#x3D; labels.getString(key); The String returned by getString corresponds to the key specified. The String is in the proper language, provided that a properties file exists for the specified Locale. 6. Iterate through All the KeysThis step is optional. When debugging your program, you might want to fetch values for all of the keys in a ResourceBundle. The getKeys method returns an Enumeration of all the keys in a ResourceBundle. You can iterate through the Enumeration and fetch each value with the getString method. The following lines of code, which are from the PropertiesDemo program, show how this is done: 12345678910ResourceBundle labels &#x3D; ResourceBundle.getBundle(&quot;LabelsBundle&quot;, currentLocale);Enumeration bundleKeys &#x3D; labels.getKeys();while (bundleKeys.hasMoreElements()) &#123; String key &#x3D; (String)bundleKeys.nextElement(); String value &#x3D; labels.getString(key); System.out.println(&quot;key &#x3D; &quot; + key + &quot;, &quot; + &quot;value &#x3D; &quot; + value);&#125; 7. Run the Demo ProgramRunning the PropertiesDemo program generates the following output. The first three lines show the values returned by getString for various Locale objects. The program displays the last four lines when iterating through the keys with the getKeys method. 12345678910Locale &#x3D; fr, key &#x3D; s2, value &#x3D; Disque durLocale &#x3D; de, key &#x3D; s2, value &#x3D; PlatteLocale &#x3D; en, key &#x3D; s2, value &#x3D; diskkey &#x3D; s4, value &#x3D; Clavierkey &#x3D; s3, value &#x3D; Moniteurkey &#x3D; s2, value &#x3D; Disque durkey &#x3D; s1, value &#x3D; Ordinateur","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Preparing to Use a ResourceBundle","date":"2020-12-05T17:50:08.043Z","path":"wiki/2021-03-03-Preparing to Use a ResourceBundle/","text":"Preparing to Use a ResourceBundleIdentifying the Locale-Specific ObjectsIf your application has a user interface, it contains many locale-specific objects. To get started, you should go through your source code and look for objects that vary with Locale. Your list might include objects instantiated from the following classes: String Image Color AudioClip You’ll notice that this list doesn’t contain objects representing numbers, dates, times, or currencies. The display format of these objects varies with Locale, but the objects themselves do not. For example, you format a Date according to Locale, but you use the same Date object regardless of Locale. Instead of isolating these objects in a ResourceBundle, you format them with special locale-sensitive formatting classes. You’ll learn how to do this in theDates and Times section of theFormatting lesson. In general, the objects stored in a ResourceBundle are predefined and ship with the product. These objects are not modified while the program is running. For instance, you should store a Menu label in a ResourceBundle because it is locale-specific and will not change during the program session. However, you should not isolate in a ResourceBundle a String object the end user enters in a TextField. Data such as this String may vary from day to day. It is specific to the program session, not to the Locale in which the program runs. Usually most of the objects you need to isolate in a ResourceBundle are String objects. However, not all String objects are locale-specific. For example, if a String is a protocol element used by interprocess communication, it doesn’t need to be localized, because the end users never see it. The decision whether to localize some String objects is not always clear. Log files are a good example. If a log file is written by one program and read by another, both programs are using the log file as a buffer for communication. Suppose that end users occasionally check the contents of this log file. Shouldn’t the log file be localized? On the other hand, if end users rarely check the log file, the cost of translation may not be worthwhile. Your decision to localize this log file depends on a number of factors: program design, ease of use, cost of translation, and supportability. Organizing ResourceBundle ObjectsYou can organize your ResourceBundle objects according to the category of objects they contain. For example, you might want to load all of the GUI labels for an order entry window into a ResourceBundle called OrderLabelsBundle. Using multiple ResourceBundle objects offers several advantages: Your code is easier to read and to maintain. You’ll avoid huge ResourceBundle objects, which may take too long to load into memory. You can reduce memory usage by loading each ResourceBundle only when needed.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"About the ResourceBundle Class","date":"2020-12-05T17:50:06.263Z","path":"wiki/2021-03-03-About the ResourceBundle Class/","text":"About the ResourceBundle ClassHow a ResourceBundle is Related to a LocaleConceptually each ResourceBundle is a set of related subclasses that share the same base name. The list that follows shows a set of related subclasses. ButtonLabel is the base name. The characters following the base name indicate the language code, country code, and variant of a Locale. ButtonLabel_en_GB, for example, matches the Locale specified by the language code for English (en) and the country code for Great Britain (GB). 123456ButtonLabelButtonLabel_deButtonLabel_en_GBButtonLabel_fr_CA_UNIX To select the appropriate ResourceBundle, invoke the ResourceBundle.getBundle method. The following example selects the ButtonLabel ResourceBundle for the Locale that matches the French language, the country of Canada, and the UNIX platform. 12345Locale currentLocale &#x3D; new Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;UNIX&quot;);ResourceBundle introLabels &#x3D; ResourceBundle.getBundle( &quot;ButtonLabel&quot;, currentLocale); If a ResourceBundle class for the specified Locale does not exist, getBundle tries to find the closest match. For example, if ButtonLabel_fr_CA_UNIX is the desired class and the default Locale is en_US, getBundle will look for classes in the following order: 12345678ButtonLabel_fr_CA_UNIXButtonLabel_fr_CAButtonLabel_frButtonLabel_en_USButtonLabel_enButtonLabel Note that getBundle looks for classes based on the default Locale before it selects the base class (ButtonLabel). If getBundle fails to find a match in the preceding list of classes, it throws a MissingResourceException. To avoid throwing this exception, you should always provide a base class with no suffixes. The ListResourceBundle and PropertyResourceBundle SubclassesThe abstract class ResourceBundle has two subclasses: PropertyResourceBundle and ListResourceBundle. A PropertyResourceBundle is backed by a properties file. A properties file is a plain-text file that contains translatable text. Properties files are not part of the Java source code, and they can contain values for String objects only. If you need to store other types of objects, use a ListResourceBundle instead. The section Backing a ResourceBundle with Properties Files shows you how to use a PropertyResourceBundle. The ListResourceBundle class manages resources with a convenient list. Each ListResourceBundle is backed by a class file. You can store any locale-specific object in a ListResourceBundle. To add support for an additional Locale, you create another source file and compile it into a class file. The section Using a ListResource Bundle has a coding example you may find helpful. The ResourceBundle class is flexible. If you first put your locale-specific String objects in a PropertyResourceBundle and then later decided to use ListResourceBundle instead, there is no impact on your code. For example, the following call to getBundle will retrieve a ResourceBundle for the appropriate Locale, whether ButtonLabel is backed up by a class or by a properties file: 1234ResourceBundle introLabels &#x3D; ResourceBundle.getBundle( &quot;ButtonLabel&quot;, currentLocale); Key-Value PairsResourceBundle objects contain an array of key-value pairs. You specify the key, which must be a String, when you want to retrieve the value from the ResourceBundle. The value is the locale-specific object. The keys in the following example are the OkKey and CancelKey strings: 123456789101112class ButtonLabel_en extends ListResourceBundle &#123; &#x2F;&#x2F; English version public Object[][] getContents() &#123; return contents; &#125; static final Object[][] contents &#x3D; &#123; &#123;&quot;OkKey&quot;, &quot;OK&quot;&#125;, &#123;&quot;CancelKey&quot;, &quot;Cancel&quot;&#125;, &#125;;&#125; To retrieve the OK String from the ResourceBundle, you would specify the appropriate key when invoking getString: 123String okLabel &#x3D; ButtonLabel.getString(&quot;OkKey&quot;); A properties file contains key-value pairs. The key is on the left side of the equal sign, and the value is on the right. Each pair is on a separate line. The values may represent String objects only. The following example shows the contents of a properties file named ButtonLabel.properties: 1234OkKey &#x3D; OKCancelKey &#x3D; Cancel","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Isolating Locale-Specific Data","date":"2020-12-05T17:50:04.108Z","path":"wiki/2021-03-03-Isolating Locale-Specific Data/","text":"Lesson: Isolating Locale-Specific DataLocale-specific data must be tailored according to the conventions of the end user’s language and region. The text displayed by a user interface is the most obvious example of locale-specific data. For example, an application with a Cancel button in the U.S. will have an Abbrechen button in Germany. In other countries this button will have other labels. Obviously you don’t want to hardcode this button label. Wouldn’t it be nice if you could automatically get the correct label for a given Locale? Fortunately you can, provided that you isolate the locale-specific objects in a ResourceBundle. In this lesson you’ll learn how to create and access ResourceBundle objects. If you’re in a hurry to examine some coding examples, go ahead and check out the last two sections in this lesson. Then you can come back to the first two sections to get some conceptual information about ResourceBundle objects. About the ResourceBundle ClassResourceBundle objects contain locale-specific objects. When you need a locale-specific object, you fetch it from a ResourceBundle, which returns the object that matches the end user’s Locale. This section explains how a ResourceBundle is related to a Locale, and describes the ResourceBundle subclasses. Preparing to Use a ResourceBundleBefore you create your ResourceBundle objects, you should do a little planning. First, identify the locale-specific objects in your program. Then organize them into categories and store them in different ResourceBundle objects accordingly. Backing a ResourceBundle with Properties FilesIf your application contains String objects that need to be translated into various languages, you can store these String objects in a PropertyResourceBundle, which is backed up by a set of properties files. Since the properties files are simple text files, they can be created and maintained by your translators. You don’t have to change the source code. In this section you’ll learn how to set up the properties files that back up a PropertyResourceBundle. Using a ListResourceBundleThe ListResourceBundle class, which is a subclass of ResourceBundle, manages locale-specific objects with a list. A ListResourceBundle is backed by a class file, which means that you must code and compile a new source file each time support for an additional Locale is needed. However, ListResourceBundle objects are useful because unlike properties files, they can store any type of locale-specific object. By stepping through a sample program, this section demonstrates how to use a ListResourceBundle. Customizing Resource Bundle LoadingThis section represents new capabilities to improve the ResourceBundle.getBundle factory flexibility. The ResourceBundle.Control class collaborates with the factory methods for loading resource bundles. This allows to consider every substantial step of the resource bundle-loading process and its cache control as a separate method.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Locale-Sensitive Services SPI","date":"2020-12-05T17:50:02.061Z","path":"wiki/2021-03-03-Locale-Sensitive Services SPI/","text":"Locale-Sensitive Services SPIThis feature enables the plug-in of locale-dependent data and services. In this way, third parties are able to provide implementations of most locale-sensitive classes in the java.text and java.util packages. The implementation of SPIs (Service Provider Interface) is based on abstract classes and Java interfaces that are implemented by the service provider. At runtime the Java class loading mechanism is used to dynamically locate and load classes that implement the SPI. You can use the locale-sensitive services SPI to provide the following locale sensitive implementations: BreakIterator objects Collator objects Language code, Country code, and Variant name for the Locale class Time Zone names Currency symbols DateFormat objects DateFormatSymbol objects NumberFormat objects DecimalFormatSymbols objects The corresponding SPIs are contained both in java.text.spi and in java.util.spi packages: CurrencyNameProvider LocaleServiceProvider TimeZoneNameProvider CalendarDataProvider BreakIteratorProvider CollatorProvider DateFormatProvider DateFormatSymbolsProvider DecimalFormatSymbolsProvider NumberFormatProvider For example, if you would like to provide a NumberFormat object for a new locale, you have to implement the java.text.spi.NumberFormatProvider class. You need to extend this class and implement its methods: getCurrencyInstance(Locale locale) getIntegerInstance(Locale locale) getNumberInstance(Locale locale) getPercentInstance(Locale locale) 1234Locale loc &#x3D; new Locale(&quot;da&quot;, &quot;DK&quot;);NumberFormat nf &#x3D; NumberFormatProvider.getNumberInstance(loc); These methods first check whether the Java runtime environment supports the requested locale; if so, they use that support. Otherwise, the methods call the getAvailableLocales() methods of installed providers for the appropriate interface to find a provider that supports the requested locale.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"The Scope of a Locale","date":"2020-12-05T17:49:59.791Z","path":"wiki/2021-03-03-The Scope of a Locale/","text":"The Scope of a LocaleThe Java platform does not require you to use the same Locale throughout your program. If you wish, you can assign a different Locale to every locale-sensitive object in your program. This flexibility allows you to develop multilingual applications, which can display information in multiple languages. However, most applications are not multi-lingual and their locale-sensitive objects rely on the default Locale. Set by the Java Virtual Machine when it starts up, the default Locale corresponds to the locale of the host platform. To determine the default Locale of your Java Virtual Machine, invoke the Locale.getDefault method. It is possible to independently set the default locale for two types of uses: the format setting is used for formatting resources, and the display setting is used in menus and dialogs. Introduced in the Java SE 7 release, theLocale.getDefault(Locale.Category) method takes aLocale.Category parameter. Passing the FORMAT enum to the getDefault(Locale.Category) method returns the default locale for formatting resources. Similarly, passing the DISPLAY enum returns the default locale used by the UI. The correspondingsetDefault(Locale.Category, Locale) method allows setting the locale for the desired category. The no-argument getDefault method returns the DISPLAY default value. On the Windows platform, these default values are initialized according to the “Standards and Formats” and “Display Language” settings in the Windows control panel. You should not set the default Locale programmatically because it is shared by all locale-sensitive classes. Distributed computing raises some interesting issues. For example, suppose you are designing an application server that will receive requests from clients in various countries. If the Locale for each client is different, what should be the Locale of the server? Perhaps the server is multithreaded, with each thread set to the Locale of the client it services. Or perhaps all data passed between the server and the clients should be locale-independent. Which design approach should you take? If possible, the data passed between the server and the clients should be locale-independent. This simplifies the design of the server by making the clients responsible for displaying the data in a locale-sensitive manner. However, this approach won’t work if the server must store the data in a locale-specific form. For example, the server might store Spanish, English, and French versions of the same data in different database columns. In this case, the server might want to query the client for its Locale, since the Locale may have changed since the last request.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Language Tag Filtering and Lookup","date":"2020-12-05T17:49:57.477Z","path":"wiki/2021-03-03-Language Tag Filtering and Lookup/","text":"Language Tag Filtering and LookupThe Java Programming language contains internationalization support for language tags, language tag filtering, and language tag lookup. These features are specified by IETF BCP 47, which contains RFC 5646 “Tags for Identifying Languages”and RFC 4647 “Matching of Language Tags.”This lesson describes how this support is provided in the JDK. What Are Language Tags?Language tags are specially formatted strings that provide information about a particular language. A language tag might be something simple (such as “en” for English), something complex (such as “zh-cmn-Hans-CN” for Chinese, Mandarin, Simplified script, as used in China), or something in between (such as “sr-Latn”, for Serbian written using Latin script). Language tags consist of “subtags” separated by hyphens; this terminology is used throughout the API documentation. The java.util.Locale class provides support for language tags. A Locale contains several different fields: language (such as “en” for English, or “ja” for Japanese), script (such as “Latn” for Latin or “Cyrl” for Cyrillic), country (such as “US” for United States or “FR” for France), variant (which indicates some variant of a locale), and extensions (which provides a map of single character keys to String values, indicating extensions apart from language identification).To create a Locale object from a language tag String, invoke Locale.forLanguageTag(String), passing in the language tag as its only argument. Doing so creates and returns a new Locale object for use in your application. Example 1: 1234567891011package languagetagdemo;import java.util.Locale;public class LanguageTagDemo &#123; public static void main(String[] args) &#123; Locale l &#x3D; Locale.forLanguageTag(&quot;en-US&quot;); &#125;&#125; Note that the Locale API only requires that your language tag be syntactically well-formed. It does not perform any extra validation (such as checking to see if the tag is registered in the IANA Language Subtag Registry). What Are Language Ranges?Language ranges (represented by class java.util.Locale.LanguageRange) identify sets of language tags that share specific attributes. Language ranges are classified as either basic or extended, and are similar to language tags in that they consist of subtags separated by hyphens. Examples of basic language ranges include “en” (English), “ja-JP” (Japanese, Japan), and ““ (a special language range which matches any language tag). Examples of extended language ranges include “-CH” (any language, Switzerland), “es-“ (Spanish, any regions), and “zh-Hant-“ (Traditional Chinese, any region). Furthermore, language ranges may be stored in Language Priority Lists, which enable users to prioritize their language preferences in a weighted list. Language Priority Lists are expressed by placing LanguageRange objects into a java.util.List, which can then be passed to the Locale methods that accept a List of LanguageRange objects. Creating a Language RangeTheLocale.LanguageRange class provides two different constructors for creating language ranges: public Locale.LanguageRange(String range) public Locale.LanguageRange(String range, double weight) The only difference between them is that the second version allows a weight to be specified; this weight will be considered if the range is placed into a Language Priority List. Locale.LanguageRange also specifies some constants to be used with these constructors: - `public static final double MAX_WEIGHT` - `public static final double MIN_WEIGHT` The MAX_WEIGHT constant holds a value of 1.0, which indicates that it is a good fit for the user. The MIN_WEIGHT constant holds a value of 0.0, indicating that it is not. Example 2: 123456789101112131415161718package languagetagdemo;import java.util.Locale;public class LanguageTagDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; Create Locale Locale l &#x3D; Locale.forLanguageTag(&quot;en-US&quot;); &#x2F;&#x2F; Define Some LanguageRange Objects Locale.LanguageRange range1 &#x3D; new Locale.LanguageRange(&quot;en-US&quot;,Locale.LanguageRange.MAX_WEIGHT); Locale.LanguageRange range2 &#x3D; new Locale.LanguageRange(&quot;en-GB*&quot;,0.5); Locale.LanguageRange range3 &#x3D; new Locale.LanguageRange(&quot;fr-FR&quot;,Locale.LanguageRange.MIN_WEIGHT); &#125;&#125; Example 2 creates three language ranges: English (United States), English (Great Britain), and French (France). These ranges are weighted to express the user’s preferences, in order from most preferred to least preferred. Creating a Language Priority ListYou can create a Language Priority List from a list of language rangesby using theLanguageRange.parse(String) method. This method accepts alist of comma-separated language ranges, performs a syntactic check foreach language range in the given ranges, and then returns the newlycreated Language Priority List. For detailed information about the required format of the “ranges”parameter, see the API specification for this method. Example 3: 123456789101112131415161718192021222324package languagetagdemo;import java.util.Locale;import java.util.List;public class LanguageTagDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; Create Locale Locale l &#x3D; Locale.forLanguageTag(&quot;en-US&quot;); &#x2F;&#x2F; Create a Language Priority List String ranges &#x3D; &quot;en-US;q&#x3D;1.0,en-GB;q&#x3D;0.5,fr-FR;q&#x3D;0.0&quot;; List&lt;Locale.LanguageRange&gt; languageRanges &#x3D; Locale.LanguageRange.parse(ranges) &#125;&#125; Example 3 creates the same three language ranges as Example 2, butstores them in a String object, which is passed to the parse(String)method. The returned List of LanguageRange objects is the LanguagePriority List. Filtering Language TagsLanguage tag filtering is the process of matching a set of language tags against a user’s Language Priority List. The result of filtering will be a complete list of all matching results. The Locale class defines two filter methods that return a list of Locale objects. Their signatures are as follows: &lt;li&gt; public static List&amp;lt;Locale&amp;gt; filter (List&amp;lt;Locale.LanguageRange&amp;gt; priorityList, Collection&amp;lt;Locale&amp;gt; locales) public static List&amp;lt;Locale&amp;gt; filter (List&amp;lt;Locale.LanguageRange&amp;gt; priorityList, Collection&amp;lt;Locale&amp;gt; locales, Locale.FilteringMode mode) In both methods, the first argument specifies the user’s Language Priority List as described in the previous section. The second argument specifies a Collection of Locale objects to match against.The match itself will take place according to the rules specified by RFC 4647. The third argument (if provided) specifies the “filtering mode” to use. TheLocale.FilteringMode enum provides a number of different values to choose from, such as AUTOSELECT_FILTERING (for basic language range filtering) or EXTENDED_FILTERING (for extended language range filtering). Example 4 provides a demonstration of language tag filtering. Example 4: 123456789101112131415161718192021222324252627282930313233package languagetagdemo;import java.util.Locale;import java.util.Collection;import java.util.List;import java.util.ArrayList;public class LanguageTagDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; Create a collection of Locale objects to filter Collection&lt;Locale&gt; locales &#x3D; new ArrayList&lt;&gt;(); locales.add(Locale.forLanguageTag(&quot;en-GB&quot;)); locales.add(Locale.forLanguageTag(&quot;ja&quot;)); locales.add(Locale.forLanguageTag(&quot;zh-cmn-Hans-CN&quot;)); locales.add(Locale.forLanguageTag(&quot;en-US&quot;)); &#x2F;&#x2F; Express the user&#39;s preferences with a Language Priority List String ranges &#x3D; &quot;en-US;q&#x3D;1.0,en-GB;q&#x3D;0.5,fr-FR;q&#x3D;0.0&quot;; List&lt;Locale.LanguageRange&gt; languageRanges &#x3D; Locale.LanguageRange.parse(ranges); &#x2F;&#x2F; Now filter the Locale objects, returning any matches List&lt;Locale&gt; results &#x3D; Locale.filter(languageRanges,locales); &#x2F;&#x2F; Print out the matches for(Locale l : results)&#123; System.out.println(l.toString()); &#125; &#125;&#125; The output of this program is: en_USen_GB This returned list is ordered according to the weights specified in the user’s Language Priority List. The Locale class also defines filterTags methods for filtering language tags as String objects. The method signatures are as follows: [`public static List&lt;String&gt; filterTags (List&lt;Locale.LanguageRange&gt; priorityList, Collection&lt;String&gt; tags)`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#filterTags-java.util.List-java.util.Collection-) [`public static List&lt;String&gt; filterTags (List&lt;Locale.LanguageRange&gt; priorityList, Collection&lt;String&gt; tags, Locale.FilteringMode mode)`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#filterTags-java.util.List-java.util.Collection-java.util.Locale.FilteringMode-) Example 5 provides the same search as Example 4, but uses String objects instead of Locale objects. Example 5: 1234567891011121314151617181920212223242526272829303132333435package languagetagdemo;import java.util.Locale;import java.util.Collection;import java.util.List;import java.util.ArrayList;public class LanguageTagDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; Create a collection of String objects to match against Collection&lt;String&gt; tags &#x3D; new ArrayList&lt;&gt;(); tags.add(&quot;en-GB&quot;); tags.add(&quot;ja&quot;); tags.add(&quot;zh-cmn-Hans-CN&quot;); tags.add(&quot;en-US&quot;); &#x2F;&#x2F; Express user&#39;s preferences with a Language Priority List String ranges &#x3D; &quot;en-US;q&#x3D;1.0,en-GB;q&#x3D;0.5,fr-FR;q&#x3D;0.0&quot;; List&lt;Locale.LanguageRange&gt; languageRanges &#x3D; Locale.LanguageRange.parse(ranges); &#x2F;&#x2F; Now search the locales for the best match List&lt;String&gt; results &#x3D; Locale.filterTags(languageRanges,tags); &#x2F;&#x2F; Print out the matches for(String s : results)&#123; System.out.println(s); &#125; &#125;&#125; As before, the search will match and return “en-US” and “en-GB” (in that order). Performing Language Tag LookupIn contrast to language tag filtering, language tag lookup is the process of matching language ranges to sets of language tags and returning the one language tag that best matches the range. RFC4647 states that: “Lookup produces the single result that best matches the user’s preferences from the list of available tags, so it is useful in cases in which a single item is required (and for which only a single item can be returned). For example, if a process were to insert a human-readable error message into a protocol header, it might select the text based on the user’s language priority list. Since the process can return only one item, it is forced to choose a single item and it has to return some item, even if none of the content’s language tags match the language priority list supplied by the user.” Example 6: 123456789101112131415161718192021222324252627282930package languagetagdemo;import java.util.Locale;import java.util.Collection;import java.util.List;import java.util.ArrayList;public class LanguageTagDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; Create a collection of Locale objects to search Collection&lt;Locale&gt; locales &#x3D; new ArrayList&lt;&gt;(); locales.add(Locale.forLanguageTag(&quot;en-GB&quot;)); locales.add(Locale.forLanguageTag(&quot;ja&quot;)); locales.add(Locale.forLanguageTag(&quot;zh-cmn-Hans-CN&quot;)); locales.add(Locale.forLanguageTag(&quot;en-US&quot;)); &#x2F;&#x2F; Express the user&#39;s preferences with a Language Priority List String ranges &#x3D; &quot;en-US;q&#x3D;1.0,en-GB;q&#x3D;0.5,fr-FR;q&#x3D;0.0&quot;; List&lt;Locale.LanguageRange&gt; languageRanges &#x3D; Locale.LanguageRange.parse(ranges); &#x2F;&#x2F; Find the BEST match, and return just one result Locale result &#x3D; Locale.lookup(languageRanges,locales); System.out.println(result.toString()); &#125;&#125; In contrast to the filtering examples, the lookup demo in Example 6 returns the one object that is the best match (en-US in this case). For completenes, Example 7 shows how to perform the same lookup using String objects. Example 7: 12345678910111213141516171819202122232425262728package languagetagdemo;import java.util.Locale;import java.util.Collection;import java.util.List;import java.util.ArrayList;public class LanguageTagDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; Create a collection of String objects to match against Collection&lt;String&gt; tags &#x3D; new ArrayList&lt;&gt;(); tags.add(&quot;en-GB&quot;); tags.add(&quot;ja&quot;); tags.add(&quot;zh-cmn-Hans-CN&quot;); tags.add(&quot;en-US&quot;); &#x2F;&#x2F; Express user&#39;s preferences with a Language Priority List String ranges &#x3D; &quot;en-US;q&#x3D;1.0,en-GB;q&#x3D;0.5,fr-FR;q&#x3D;0.0&quot;; List&lt;Locale.LanguageRange&gt; languageRanges &#x3D; Locale.LanguageRange.parse(ranges); &#x2F;&#x2F; Find the BEST match, and return just one result String result &#x3D; Locale.lookupTag(languageRanges, tags); System.out.println(result); &#125;&#125; This example returns the single object that best matches the user’s Language Priority List.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Identifying Available Locales","date":"2020-12-05T17:49:55.347Z","path":"wiki/2021-03-03-Identifying Available Locales/","text":"Identifying Available LocalesYou can create a Locale with any combination of valid language and country codes, but that doesn’t mean that you can use it. Remember, a Locale object is only an identifier. You pass the Locale object to other objects, which then do the real work. These other objects, which we call locale-sensitive, do not know how to deal with all possible Locale definitions. To find out which types of Locale definitions a locale-sensitive class recognizes, you invoke the getAvailableLocales method. For example, to find out which Locale definitions are supported by the DateFormat class, you could write a routine such as the following: 12345678910111213import java.util.*;import java.text.*;public class Available &#123; static public void main(String[] args) &#123; Locale list[] &#x3D; DateFormat.getAvailableLocales(); for (Locale aLocale : list) &#123; System.out.println(aLocale.toString()); &#125; &#125;&#125; Note that the String returned by toString contains the language and country codes, separated by an underscore: 12345678910ar_EGbe_BYbg_BGca_EScs_CZda_DKde_DE... If you want to display a list of Locale names to end users, you should show them something easier to understand than the language and country codes returned by toString. Instead you can invoke the Locale.getDisplayName method, which retrieves a localized String of a Locale object. For example, when toString is replaced by getDisplayName in the preceding code, the program prints the following lines: 12345678910Arabic (Egypt)Belarussian (Belarus)Bulgarian (Bulgaria)Catalan (Spain)Czech (Czech Republic)Danish (Denmark)German (Germany)... You may see different locale lists depending on the Java Platform implementations.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"BCP 47 Extensions","date":"2020-12-05T17:49:53.307Z","path":"wiki/2021-03-03-BCP 47 Extensions/","text":"BCP 47 ExtensionsThe Java SE 7 release conforms to the IETF BCP 47 standard, which supports adding extensions to a Locale. Any single character can be used to denote an extension, but there are two predefined extension codes: &#39;u&#39; specifies a Unicode locale extension, and &#39;x&#39; specifies a private use extension. Unicode locale extensions are defined by the Unicode Common Locale Data Repository (CLDR) project. They are used to specify information that is non-language-specific such as calendars or currency. A private use extension may be used to specify any other information, such as platform (for example, Windows, UNIX, or Linux), or release information (for example, 6u23 or JDK 7). An extension is specified as a key/value pair, where the key is a single character (typically &#39;u&#39; or &#39;x&#39;). A well-formed value has the following format: 123SUBTAG (&#39;-&#39; SUBTAG)* In this format: 1234SUBTAG &#x3D; [0-9a-zA-Z]&#123;2,8&#125; **For key&#x3D;&#39;u&#39;**SUBTAG &#x3D; [0-9a-zA-Z]&#123;1,8&#125; **For key&#x3D;&#39;x&#39;** Note that a single-character value is allowed for the private use extension. However, there is a 2-character minimum for values in the Unicode locale extension. Extension strings are case-insensitive, but the Locale class maps all keys and values to lowercase. ThegetExtensionKeys() method returns the set of extension keys, if any, for a Locale. ThegetExtension(key) method returns the value string for the specified key, if any. Unicode Locale ExtensionsAs previously mentioned, a Unicode locale extension is specified by the &#39;u&#39; key code or the UNICODE_LOCALE_EXTENSION constant. The value itself is also specified by a key/type pair. Legal values are defined in the Key/Type Definitions table on the Unicode website. A key code is specified by two alphabetic characters. The following table lists the Unicode locale extension keys: Key CodeDescription cacalendar algorithm cocollation type kacollation parameters cucurrency type nunumber type vacommon variant type Specifying a Unicode locale extension, such as number format, does not guarantee that the locale services for the underlying platform will honor that request. The following table shows some examples of key/type pairs for a Unicode locale extension. Key/Type pairDescription ca-buddhistThai Buddhist calendar co-pinyinPinyin ordering for Latin cu-usdU.S. dollars nu-jpanfinJapanese financial numerals tz-aldavEurope/Andorra The following string represents the German language locale for the country of Germany using a phonebook style of ordering for the Linux platform. This example also contains an attribute named &quot;email&quot;. 123de-DE-u-email-co-phonebk-x-linux The following Locale methods can be used to access information about the Unicode locale extensionss. These methods are described using the previous German locale example. [`getUnicodeLocaleKeys()`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#getUnicodeLocaleKeys--) &#150; Returns the Unicode locale key codes or an empty set if the locale has none. For the German example, this would return a set containing the single string `\"co\"`. [`getUnicodeLocaleType(String)`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#getUnicodeLocaleType-java.lang.String-) &#150; Returns the Unicode locale type associated with the Unicode locale key code. Invoking `getUnicodeLocaleType(\"co\")` for the German example would return the string `\"phonebk\"`. [`getUnicodeLocaleAttributes()`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#getUnicodeLocaleAttributes--) &#150; Returns the set of Unicode locale attributes associated with this locale, if any. In the German example, this would return a set containing the single string `\"email\"`. Private Use ExtensionsThe private use extension, specified by the &#39;x&#39; key code or the PRIVATE_USE_EXTENSION constant, can be anything, as long as the value is well formed. The following are examples of possible private use extensions: 1234x-jdk-1-7x-linux","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Creating a Locale","date":"2020-12-05T17:49:51.184Z","path":"wiki/2021-03-03-Creating a Locale/","text":"Creating a LocaleThere are several ways to create a Locale object. Regardless of the technique used, creation can be as simple as specifying the language code. However, you can further distinguish the locale by setting the region (also referred to as “country”) and variant codes. If you are using the JDK 7 release or later, you can also specify the script code and Unicode locale extensions. The four ways to create a Locale object are: Locale.Builder Class Locale Constructors Locale.forLanguageTag Factory Method Locale Constants LocaleBuilder ClassTheLocale.Builder utility class can be used to construct a Locale object that conforms to the IETF BCP 47 syntax. For example, to specify the French language and the country of Canada, you could invoke the Locale.Builder constructor and then chain the setter methods as follows: 123Locale aLocale &#x3D; new Locale.Builder().setLanguage(&quot;fr&quot;).setRegion(&quot;CA&quot;).build(); The next example creates Locale objects for the English language in the United States and Great Britain: 1234Locale bLocale &#x3D; new Locale.Builder().setLanguage(&quot;en&quot;).setRegion(&quot;US&quot;).build();Locale cLocale &#x3D; new Locale.Builder().setLanguage(&quot;en&quot;).setRegion(&quot;GB&quot;).build(); The final example creates a Locale object for the Russian language: 123Locale dLocale &#x3D; new Locale.Builder().setLanguage(&quot;ru&quot;).setScript(&quot;Cyrl&quot;).build(); Locale ConstructorsThere are three constructors available in the Locale class for creating a Locale object: [`Locale(String language)`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#Locale-java.lang.String-) [`Locale(String language, String country)`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#Locale-java.lang.String-java.lang.String-) [`Locale(String language, String country, String variant)`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#Locale-java.lang.String-java.lang.String-java.lang.String-) The following examples create Locale objects for the French language in Canada, the English language in the U.S. and Great Britain, and the Russian language. 123456aLocale &#x3D; new Locale(&quot;fr&quot;, &quot;CA&quot;);bLocale &#x3D; new Locale(&quot;en&quot;, &quot;US&quot;);cLocale &#x3D; new Locale(&quot;en&quot;, &quot;GB&quot;);dLocale &#x3D; new Locale(&quot;ru&quot;); It is not possible to set a script code on a Locale object in a release earlier than JDK 7. forLanguageTag Factory MethodIf you have a language tag string that conforms to the IETF BCP 47 standard, you can use theforLanguageTag(String) factory method, which was introduced in the Java SE 7 release. For example: 1234Locale aLocale &#x3D; Locale.forLanguageTag(&quot;en-US&quot;);Locale bLocale &#x3D; Locale.forLanguageTag(&quot;ja-JP-u-ca-japanese&quot;); Locale ConstantsFor your convenience the Locale class providesconstants for some languages and countries. For example: 1234cLocale &#x3D; Locale.JAPAN;dLocale &#x3D; Locale.CANADA_FRENCH; When you specify a language constant, the region portion of the Locale is undefined. The next three statements create equivalent Locale objects: 12345j1Locale &#x3D; Locale.JAPANESE;j2Locale &#x3D; new Locale.Builder().setLanguage(&quot;ja&quot;).build();j3Locale &#x3D; new Locale(&quot;ja&quot;); The Locale objects created by the following three statements are also equivalent: 12345j4Locale &#x3D; Locale.JAPAN;j5Locale &#x3D; new Locale.Builder().setLanguage(&quot;ja&quot;).setRegion(&quot;JP&quot;).build();j6Locale &#x3D; new Locale(&quot;ja&quot;, &quot;JP&quot;); CodesThe following sections discuss the language code and the optional script, region, and variant codes. Language CodeThe language code is either two or three lowercase letters that conform to the ISO 639 standard. You can find a full list of the ISO 639 codes athttp://www.loc.gov/standards/iso639-2/php/code_list.php. The following table lists a few of the language codes. Language CodeDescription |------ `de`German `en`English `fr`French `ru`Russian `ja`Japanese `jv`Javanese `ko`Korean `zh`Chinese Script CodeThe script code begins with an uppercase letter followed by three lowercase letters and conforms to the ISO 15924 standard. You can find a full list of the ISO 15924 codes athttp://unicode.org/iso15924/iso15924-codes.html. The following table lists a few of the script codes. Script CodeDescription |------ `Arab`Arabic `Cyrl`Cyrillic `Kana`Katakana `Latn`Latin There are three methods for retrieving the script information for a Locale: [`getScript()`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#getScript--) &#150; returns the 4-letter script code for a `Locale` object. If no script is defined for the locale, an empty string is returned. [`getDisplayScript()`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#getDisplayScript--) &#150; returns a name for the locale's script that is appropriate for display to the user. If possible, the name will be localized for the default locale. So, for example, if the script code is \"Latn,\" the diplay script name returned would be the string \"Latin\" for an English language locale. [`getDisplayScript(Locale)`](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#getDisplayScript-java.util.Locale-) &#150; returns the display name of the specified `Locale` localized, if possible, for the locale. Region CodeThe region (country) code consists of either two or three uppercase letters that conform to the ISO 3166 standard, or three numbers that conform to the UN M.49 standard. A copy of the codes can be found athttp://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html. The following table contains several sample country and region codes. A-2 CodeA-3 CodeNumeric CodeDescription `AU``AUS``036`Australia `BR``BRA``076`Brazil `CA``CAN``124`Canada `CN``CHN``156`China `DE``DEU``276`Germany `FR``FRA``250`France `IN``IND``356`India `RU``RUS``643`Russian Federation `US``USA``840`United States Variant CodeThe optional variant code can be used to further distinguish your Locale. For example, the variant code can be used to indicate dialectical differences that are not covered by the region code. As of the Java SE 7 release, which conforms to the IETF BCP 47 standard, the variant code is used specifically to indicate additional variations that define a language or its dialects. The IETF BCP 47 standard imposes syntactic restrictions on the variant subtag. You can see a list of variant codes (search for variant) athttp://www.iana.org/assignments/language-subtag-registry. For example, Java SE uses the variant code to support the Thai language. By convention, a NumberFormat object for the th and th_TH locales will use common Arabic digit shapes, or Arabic numerals, to format Thai numbers. However, a NumberFormat for the th_TH_TH locale uses Thai digit shapes. The excerpt fromThaiDigits.java demonstrates this: 1234567891011121314String outputString &#x3D; new String();Locale[] thaiLocale &#x3D; &#123; new Locale(&quot;th&quot;), new Locale(&quot;th&quot;, &quot;TH&quot;), new Locale(&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) &#125;;for (Locale locale : thaiLocale) &#123; NumberFormat nf &#x3D; NumberFormat.getNumberInstance(locale); outputString &#x3D; outputString + locale.toString() + &quot;: &quot;; outputString &#x3D; outputString + nf.format(573.34) + &quot;\\n&quot;;&#125; The following is a screenshot of this sample:","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Setting the Locale","date":"2020-12-05T17:49:49.301Z","path":"wiki/2021-03-03-Setting the Locale/","text":"Lesson: Setting the LocaleAn internationalized program can display information differently throughout the world. For example, the program will display different messages in Paris, Tokyo, and New York. If the localization process has been fine-tuned, the program will display different messages in New York and London to account for the differences between American and British English. How does an internationalized program identify the appropriate language and region of its end users? Easy. It references a Locale object. A Locale object is an identifier for a particular combination of language and region. If a class varies its behavior according to Locale, it is said to be locale-sensitive. For example, the NumberFormat class is locale-sensitive; the format of the number it returns depends on the Locale. Thus NumberFormat may return a number as 902 300 (France), or 902.300 (Germany), or 902,300 (United States). Locale objects are only identifiers. The real work, such as formatting and detecting word boundaries, is performed by the methods of the locale-sensitive classes. The following sections explain how to work with Locale objects: Creating a LocaleWhen creating a Locale object, you usually specify a language code and a country code. A third parameter, the variant, is optional. BCP 47 ExtensionsThis section shows you how to add a Unicode locale extension or a private use extension to a Locale. Identifying Available LocalesLocale-sensitive classes support only certain Locale definitions. This section shows you how to determine which Locale definitions are supported. Language Tag Filtering and LookupThis section describes the internationalization support for language tags, language tags filtering, and language tags lookup. The Scope of a LocaleOn the Java platform you do not specify a global Locale by setting an environment variable before running the application. Instead you either rely on the default Locale or assign a Locale to each locale-sensitive object. Locale-Sensitive Services SPIThis section explains how to enable plug-in of locale-dependent data and services. These SPIs (Service Provider Interface) provides support of more locales in addition to the currently available locales.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Checklist","date":"2020-12-05T17:49:47.306Z","path":"wiki/2021-03-03-Checklist/","text":"ChecklistMany programs are not internationalized when first written. These programs may have started as prototypes, or perhaps they were not intended for international distribution. If you must internationalize an existing program, take the following steps: Identify Culturally Dependent DataText messages are the most obvious form of data that varies with culture. However, other types of data may vary with region or language. The following list contains examples of culturally dependent data: Messages Labels on GUI components Online help Sounds Colors Graphics Icons Dates Times Numbers Currencies Measurements Phone numbers Honorifics and personal titles Postal addresses Page layouts Isolate Translatable Text in Resource BundlesTranslation is costly. You can help reduce costs by isolating the text that must be translated in ResourceBundle objects. Translatable text includes status messages, error messages, log file entries, and GUI component labels. This text is hardcoded into programs that haven’t been internationalized. You need to locate all occurrences of hardcoded text that is displayed to end users. For example, you should clean up code like this: 12345String buttonLabel &#x3D; &quot;OK&quot;;&#x2F;&#x2F; ...JButton okButton &#x3D; new JButton(buttonLabel); See the sectionIsolating Locale-Specific Data for details. Deal with Compound MessagesCompound messages contain variable data. In the message “The disk contains 1100 files.” the integer 1100 may vary. This message is difficult to translate because the position of the integer in the sentence is not the same in all languages. The following message is not translatable, because the order of the sentence elements is hardcoded by concatenation: 12345Integer fileCount;&#x2F;&#x2F; ...String diskStatus &#x3D; &quot;The disk contains &quot; + fileCount.toString() + &quot; files&quot;; Whenever possible, you should avoid constructing compound messages, because they are difficult to translate. However, if your application requires compound messages, you can handle them with the techniques described in the sectionMessages. Format Numbers and CurrenciesIf your application displays numbers and currencies, you must format them in a locale-independent manner. The following code is not yet internationalized, because it will not display the number correctly in all countries: 1234567Double amount;TextField amountField;&#x2F;&#x2F; ...String displayAmount &#x3D; amount.toString();amountField.setText(displayAmount); You should replace the preceding code with a routine that formats the number correctly. The Java programming language provides several classes that format numbers and currencies. These classes are discussed in the sectionNumbers and Currencies. Format Dates and TimesDate and time formats differ with region and language. If your code contains statements like the following, you need to change it: 1234567Date currentDate &#x3D; new Date();TextField dateField;&#x2F;&#x2F; ...String dateString &#x3D; currentDate.toString();dateField.setText(dateString); If you use the date-formatting classes, your application can display dates and times correctly around the world. For examples and instructions, see the sectionDates and Times. Use Unicode Character PropertiesThe following code tries to verify that a character is a letter: 12345char ch;&#x2F;&#x2F; This code is incorrectif ((ch &gt;&#x3D; &#39;a&#39; &amp;&amp; ch &lt;&#x3D; &#39;z&#39;) || (ch &gt;&#x3D; &#39;A&#39; &amp;&amp; ch &lt;&#x3D; &#39;Z&#39;)) Watch out for code like this, because it won’t work with languages other than English. For example, the if statement misses the character &#252; in the German word Gr&#252;n. The Character comparison methods use the Unicode standard to identify character properties. Thus you should replace the previous code with the following: 12345char ch;&#x2F;&#x2F; ...if (Character.isLetter(ch)) For more information on the Character comparison methods, see the sectionChecking Character Properties. Compare Strings ProperlyWhen sorting text you often compare strings. If the text is displayed, you shouldn’t use the comparison methods of the String class. A program that hasn’t been internationalized might compare strings as follows: 123456789String target;String candidate;&#x2F;&#x2F; ...if (target.equals(candidate)) &#123;&#x2F;&#x2F; ...if (target.compareTo(candidate) &lt; 0) &#123;&#x2F;&#x2F; ... The String.equals and String.compareTo methods perform binary comparisons, which are ineffective when sorting in most languages. Instead you should use the Collator class, which is described in the sectionComparing Strings. Convert Non-Unicode TextCharacters in the Java programming language are encoded in Unicode. If your application handles non-Unicode text, you might need to translate it into Unicode. For more information, see the sectionConverting Non-Unicode Text.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Internationalizing the Sample Program","date":"2020-12-05T17:49:45.267Z","path":"wiki/2021-03-03-Internationalizing the Sample Program/","text":"Internationalizing the Sample ProgramIf you look at the internationalized source code, you’ll notice that the hardcoded English messages have been removed. Because the messages are no longer hardcoded and because the language code is specified at run time, the same executable can be distributed worldwide. No recompilation is required for localization. The program has been internationalized. You may be wondering what happened to the text of the messages or what the language and country codes mean. Don’t worry. You’ll learn about these concepts as you step through the process of internationalizing the sample program. 1. Create the Properties FilesA properties file stores information about the characteristics of a program or environment. A properties file is in plain-text format. You can create the file with just about any text editor. In the example the properties files store the translatable text of the messages to be displayed. Before the program was internationalized, the English version of this text was hardcoded in the System.out.println statements. The default properties file, which is called MessagesBundle.properties, contains the following lines: 12345greetings &#x3D; Hellofarewell &#x3D; Goodbyeinquiry &#x3D; How are you? Now that the messages are in a properties file, they can be translated into various languages. No changes to the source code are required. The French translator has created a properties file called MessagesBundle_fr_FR.properties, which contains these lines: 12345greetings &#x3D; Bonjour.farewell &#x3D; Au revoir.inquiry &#x3D; Comment allez-vous? Notice that the values to the right side of the equal sign have been translated but that the keys on the left side have not been changed. These keys must not change, because they will be referenced when your program fetches the translated text. The name of the properties file is important. For example, the name of the MessagesBundle_fr_FR.properties file contains the fr language code and the FR country code. These codes are also used when creating a Locale object. 2. Define the LocaleThe Locale object identifies a particular language and country. The following statement defines a Locale for which the language is English and the country is the United States: 123aLocale &#x3D; new Locale(&quot;en&quot;,&quot;US&quot;); The next example creates Locale objects for the French language in Canada and in France: 1234caLocale &#x3D; new Locale(&quot;fr&quot;,&quot;CA&quot;);frLocale &#x3D; new Locale(&quot;fr&quot;,&quot;FR&quot;); The program is flexible. Instead of using hardcoded language and country codes, the program gets them from the command line at run time: 12345String language &#x3D; new String(args[0]);String country &#x3D; new String(args[1]);currentLocale &#x3D; new Locale(language, country); Locale objects are only identifiers. After defining a Locale, you pass it to other objects that perform useful tasks, such as formatting dates and numbers. These objects are locale-sensitive because their behavior varies according to Locale. A ResourceBundle is an example of a locale-sensitive object. 3. Create a ResourceBundleResourceBundle objects contain locale-specific objects. You use ResourceBundle objects to isolate locale-sensitive data, such as translatable text. In the sample program the ResourceBundle is backed by the properties files that contain the message text we want to display. The ResourceBundle is created as follows: 123messages &#x3D; ResourceBundle.getBundle(&quot;MessagesBundle&quot;, currentLocale); The arguments passed to the getBundle method identify which properties file will be accessed. The first argument, MessagesBundle, refers to this family of properties files: 12345MessagesBundle_en_US.propertiesMessagesBundle_fr_FR.propertiesMessagesBundle_de_DE.properties The Locale, which is the second argument of getBundle, specifies which of the MessagesBundle files is chosen. When the Locale was created, the language code and the country code were passed to its constructor. Note that the language and country codes follow MessagesBundle in the names of the properties files. Now all you have to do is get the translated messages from the ResourceBundle. 4. Fetch the Text from the ResourceBundleThe properties files contain key-value pairs. The values consist of the translated text that the program will display. You specify the keys when fetching the translated messages from the ResourceBundle with the getString method. For example, to retrieve the message identified by the greetings key, you invoke getString as follows: 123String msg1 &#x3D; messages.getString(&quot;greetings&quot;); The sample program uses the key greetings because it reflects the content of the message, but it could have used another String, such as s1 or msg1. Just remember that the key is hardcoded in the program and it must be present in the properties files. If your translators accidentally modify the keys in the properties files, getString won’t be able to find the messages. ConclusionThat’s it. As you can see, internationalizing a program isn’t too difficult. It requires some planning and a little extra coding, but the benefits are enormous. To provide you with an overview of the internationalization process, the sample program in this lesson was intentionally kept simple. As you read the lessons that follow, you’ll learn about the more advanced internationalization features of the Java programming language.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Running the Sample Program","date":"2020-12-05T17:49:43.261Z","path":"wiki/2021-03-03-Running the Sample Program/","text":"Running the Sample ProgramThe internationalized program is flexible; it allows the end user to specify a language and a country on the command line. In the following example the language code is fr (French) and the country code is FR (France), so the program displays the messages in French: 123456% java I18NSample fr FRBonjour.Comment allez-vous?Au revoir. In the next example the language code is en (English) and the country code is US (United States) so the program displays the messages in English: 123456% java I18NSample en USHello.How are you?Goodbye.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"After Internationalization","date":"2020-12-05T17:49:41.218Z","path":"wiki/2021-03-03-After Internationalization/","text":"After InternationalizationThe source code for the internationalized program follows. Notice that the text of the messages is not hardcoded. 123456789101112131415161718192021222324252627282930import java.util.*;public class I18NSample &#123; static public void main(String[] args) &#123; String language; String country; if (args.length !&#x3D; 2) &#123; language &#x3D; new String(&quot;en&quot;); country &#x3D; new String(&quot;US&quot;); &#125; else &#123; language &#x3D; new String(args[0]); country &#x3D; new String(args[1]); &#125; Locale currentLocale; ResourceBundle messages; currentLocale &#x3D; new Locale(language, country); messages &#x3D; ResourceBundle.getBundle(&quot;MessagesBundle&quot;, currentLocale); System.out.println(messages.getString(&quot;greetings&quot;)); System.out.println(messages.getString(&quot;inquiry&quot;)); System.out.println(messages.getString(&quot;farewell&quot;)); &#125;&#125; To compile and run this program, you need these source files: [`I18NSample.java`](examples/I18NSample.java) [`MessagesBundle.properties`](examples/MessagesBundle.properties) [`MessagesBundle_de_DE.properties`](examples/MessagesBundle_de_DE.properties) [`MessagesBundle_en_US.properties`](examples/MessagesBundle_en_US.properties) [`MessagesBundle_fr_FR.properties`](examples/MessagesBundle_fr_FR.properties)","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Before Internationalization","date":"2020-12-05T17:49:39.050Z","path":"wiki/2021-03-03-Before Internationalization/","text":"Before InternationalizationSuppose that you’ve written a program that displays three messages, as follows: 1234567891011public class NotI18N &#123; static public void main(String[] args) &#123; System.out.println(&quot;Hello.&quot;); System.out.println(&quot;How are you?&quot;); System.out.println(&quot;Goodbye.&quot;); &#125;&#125; You’ve decided that this program needs to display these same messages for people living in France and Germany. Unfortunately your programming staff is not multilingual, so you’ll need help translating the messages into French and German. Since the translators aren’t programmers, you’ll have to move the messages out of the source code and into text files that the translators can edit. Also, the program must be flexible enough so that it can display the messages in other languages, but right now no one knows what those languages will be. It looks like the program needs to be internationalized.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"A Quick Example","date":"2020-12-05T17:49:36.814Z","path":"wiki/2021-03-03-A Quick Example/","text":"A Quick ExampleIf you’re new to internationalizing software, this lesson is for you. This lesson uses a simple example to demonstrate how to internationalize a program so that it displays text messages in the appropriate language. You’ll learn how Locale and ResourceBundle objects work together and how to use properties files. Before InternationalizationThe first version of the source code contained hardcoded English versions of the messages we want to display. This is NOT how you write internationalized software. After InternationalizationThis is a sneak preview of what our source code will look like after internationalization. Running the Sample ProgramTo run the sample program, you specify the language and country on the command line. This section shows you a few examples. Internationalizing the Sample ProgramInternationalizing the program required just a few steps. You’ll be surprised at how easy it was.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Introduction","date":"2020-12-05T17:49:34.148Z","path":"wiki/2021-03-03-Introduction/","text":"Lesson: IntroductionInternationalization is the process of designing an application so that it can be adapted to various languages and regions without engineering changes. Sometimes the term internationalization is abbreviated as i18n, because there are 18 letters between the first “i” and the last “n.” An internationalized program has the following characteristics: With the addition of localized data, the same executable can run worldwide. Textual elements, such as status messages and the GUI component labels, are not hardcoded in the program. Instead they are stored outside the source code and retrieved dynamically. Support for new languages does not require recompilation. Culturally-dependent data, such as dates and currencies, appear in formats that conform to the end user’s region and language. It can be localized quickly. Localization is the process of adapting software for a specific region or language by adding locale-specific components and translating text. The term localization is often abbreviated as l10n, because there are 10 letters between the “l” and the “n.” The primary task of localization is translating the user interface elements and documentation. Localization involves not only changing the language interaction, but also other relevant changes such as display of numbers, dates, currency, and so on. Other types of data, such as sounds and images, may require localization if they are culturally sensitive. The better internationalized an application is, the easier it is to localize it for a particular language and character encoding scheme. Internationalization may seem a bit daunting at first. Reading the following sections will help ease you into the subject. A Quick ExampleThis section shows you how to internationalize a simple program, step by step. ChecklistSo you’ve inherited a program that needs to be internationalized or you are planning to determine the requirements for a newly-developed software. You probably don’t know where to start? Check out this checklist. It summarizes the necessary internationalization tasks and provides links to the relevant lessons in this chapter.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Internationalization","date":"2020-12-05T17:49:31.984Z","path":"wiki/2021-03-03-Internationalization/","text":"Trail: InternationalizationThe lessons in this trail teach you how to internationalize Java applications. Internationalized applications are easy to tailor to the customs and languages of end users around the world. Introduction defines the term internationalization, gives a quick sample program, and provides a checklist you can use to internationalize an existing program. Setting the Locale explains how to create and how to use Locale objects. Isolating Locale-Specific Data shows how to dynamically access objects that vary with Locale. Formatting explains how to format numbers, dates, and text messages according to Locale, and how to create customized formats with patterns. Working with Text provides techniques for manipulating text in a locale-independent manner. Internationalization of Network Resources explains how to provide internationalization for IDN’s. Service Providers for Internationalization explains how to enable the plug-in of locale-dependent data and services.","tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"}],"categories":[{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"}]},{"title":"Providing MIDI Services","date":"2020-12-05T17:48:04.257Z","path":"wiki/2021-03-03-Providing MIDI Services/","text":"Providing MIDI ServicesIntroduction to the Service Provider Interfaces explained that the javax.sound.sampled.spi and javax.sound.midi.spi packages define abstract classes to be used by developers of sound services. By implementing a subclass of one of these abstract classes, a service provider can create a new service that extends the functionality of the runtime system. The previous section covered the use of the javax.sound.sampled.spi package. This section discusses how to use the javax.sound.midi.spi package to provide new services for handling MIDI devices and files. There are four abstract classes in the javax.sound.midi.spi package, which represent four different types of services that you can provide for the MIDI system: [`MidiFileWriter`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/spi/MidiFileWriter.html) provides MIDI file-writing services. These services make it possible for an application program to save, to a MIDI file, a MIDI `Sequence` that it has generated or processed. [`MidiFileReader`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/spi/MidiFileReader.html) provides file-reading services that return a MIDI `Sequence` from a MIDI file for use in an application program. [`MidiDeviceProvider`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/spi/MidiDeviceProvider.html) supplies instances of one or more specific types of MIDI device, possibly including hardware devices. [`SoundbankReader`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/spi/SoundbankReader.html) supplies soundbank file-reading services. Concrete subclasses of `SoundbankReader` parse a given soundbank file, producing a `Soundbank` object that can be loaded into a `Synthesizer`. An application program will not directly create an instance of a service object&#226;&#128;&#148;whether a provider object, such as a MidiDeviceProvider, or an object, such as a Synthesizer, that is supplied by the provider object. Nor will the program directly refer to the SPI classes. Instead, the application program makes requests to the MidiSystem object in the javax.sound.midi package, and MidiSystem in turn uses concrete subclasses of the javax.sound.midi.spi classes to process these requests. Providing MIDI File-Writing Services There are three standard MIDI file formats, all of which an implementation of the Java Sound API can support: Type 0, Type 1, and Type 2. These file formats differ in their internal representation of the MIDI sequence data in the file, and are appropriate for different kinds of sequences. If an implementation doesn’t itself support all three types, a service provider can supply the support for the unimplemented ones. There are also variants of the standard MIDI file formats, some of them proprietary, which similarly could be supported by a third-party vendor. The ability to write MIDI files is provided by concrete subclasses of MidiFileWriter. This abstract class is directly analogous to javax.sampled.spi.AudioFileWriter. Again, the methods are grouped into query methods for learning what types of files can be written, and methods for actually writing a file. As with AudioFileWriter, two of the query methods are concrete: 1234boolean isFileTypeSupported(int fileType)boolean isFileTypeSupported(int fileType, Sequence sequence) The first of these provides general information about whether the file writer can ever write the specified type of MIDI file type. The second method is more specific: it asks whether a particular Sequence can be written to the specified type of MIDI file. Generally, you don’t need to override either of these two concrete methods. In the default implementation, each invokes one of two other corresponding query methods and iterates over the results returned. Being abstract, these other two query methods need to be implemented in the subclass: 1234abstract int[] getMidiFileTypes() abstract int[] getMidiFileTypes(Sequence sequence) The first of these returns an array of all the file types that are supported in general. A typical implementation might initialize the array in the file writer’s constructor and return the array from this method. From that set of file types, the second method finds the subset to which the file writer can write the given Sequence. In accordance with the MIDI specification, not all types of sequences can be written to all types of MIDI files. The write methods of a MidiFileWriter subclass perform the encoding of the data in a given Sequence into the correct data format for the requested type of MIDI file, writing the coded stream to either a file or an output stream: 123456abstract int write(Sequence in, int fileType, java.io.File out) abstract int write(Sequence in, int fileType, java.io.OutputStream out) To do this, the write method must parse the Sequence by iterating over its tracks, construct an appropriate file header, and write the header and tracks to the output. The MIDI file’s header format is, of course, defined by the MIDI specification. It includes such information as a “magic number” identifying this as a MIDI file, the header’s length, the number of tracks, and the sequence’s timing information (division type and resolution). The rest of the MIDI file consists of the track data, in the format defined by the MIDI specification. Let’s briefly look at how the application program, MIDI system, and service provider cooperate in writing a MIDI file. In a typical situation, an application program has a particular MIDI Sequence to save to a file. The program queries the MidiSystem object to see what MIDI file formats, if any, are supported for the particular Sequence at hand, before attempting to write the file. The MidiSystem.getMidiFileTypes(Sequence) method returns an array of all the MIDI file types to which the system can write a particular sequence. It does this by invoking the corresponding getMidiFileTypes method for each of the installed MidiFileWriter services, and collecting and returning the results in an array of integers that can be thought of as a master list of all file types compatible with the given Sequence. When it comes to writing the Sequence to a file, the call to MidiSystem.write is passed an integer representing a file type, along with the Sequence to be written and the output file; MidiSystem uses the supplied type to decide which installed MidiFileWriter should handle the write request, and dispatches a corresponding write to the appropriate MidiFileWriter. Providing MIDI File-Reading Services The MidiFileReader abstract class is directly analogous to javax.sampled.spi.AudioFileReader class. Both consist of two overloaded methods, each of which can take a File, URL, or InputStream argument. The first of the overloaded methods returns the file format of a specified file. In the case of MidiFileReader, the API is: 123456abstract MidiFileFormat getMidiFileFormat(java.io.File file) abstract MidiFileFormat getMidiFileFormat( java.io.InputStream stream) abstract MidiFileFormat getMidiFileFormat(java.net.URL url) Concrete subclasses must implement these methods to return a filled-out MidiFileFormat object describing the format of the specified MIDI file (or stream or URL), assuming that the file is of a type supported by the file reader and that it contains valid header information. Otherwise, an InvalidMidiDataException should be thrown. The other overloaded method returns a MIDI Sequence from a given file, stream, or URL : 12345abstract Sequence getSequence(java.io.File file) abstract Sequence getSequence(java.io.InputStream stream) abstract Sequence getSequence(java.net.URL url) The getSequence method performs the actual work of parsing the bytes in the MIDI input file and constructing a corresponding Sequence object. This is essentially the inverse of the process used by MidiFileWriter.write. Because there is a one-to-one correspondence between the contents of a MIDI file as defined by the MIDI specification and a Sequence object as defined by the Java Sound API, the details of the parsing are straightforward. If the file passed to getSequence contains data that the file reader can’t parse (for example, because the file has been corrupted or doesn’t conform to the MIDI specification), an InvalidMidiDataException should be thrown. Providing Particular MIDI Devices A MidiDeviceProvider can be considered a factory that supplies one or more particular types of MIDI device. The class consists of a method that returns an instance of a MIDI device, as well as query methods to learn what kinds of devices this provider can supply. As with the other javax.sound.midi.spi services, application developers get indirect access to a MidiDeviceProvider service through a call to MidiSystem methods, in this case MidiSystem.getMidiDevice and MidiSystem.getMidiDeviceInfo. The purpose of subclassing MidiDeviceProvider is to supply a new kind of device, so the service developer must also create an accompanying class for the device being returned&#226;&#128;&#148;just as we saw with MixerProvider in the javax.sound.sampled.spi package. There, the returned device’s class implemented the javax.sound.sampled.Mixer interface; here it implements the javax.sound.midi.MidiDevice interface. It might also implement a subinterface of MidiDevice, such as Synthesizer or Sequencer. Because a single subclass of MidiDeviceProvider can provide more than one type of MidiDevice, the getDeviceInfo method of the class returns an array of MidiDevice.Info objects enumerating the different MidiDevices available: 123abstract MidiDevice.Info[] getDeviceInfo() The returned array can contain a single element, of course. A typical implementation of the provider might initialize an array in its constructor and return it here. This allows MidiSystem to iterate over all installed MidiDeviceProviders to construct a list of all installed devices. MidiSystem can then return this list (MidiDevice.Info[] array) to an application program. MidiDeviceProvider also includes a concrete query method: 123boolean isDeviceSupported(MidiDevice.Info info) This method permits the system to query the provider about a specific kind of device. Generally, you don’t need to override this convenience method. The default implementation iterates over the array returned by getDeviceInfo and compares the argument to each element. The third and final MidiDeviceProvider method returns the requested device: 123abstract MidiDevice getDevice(MidiDevice.Info info) This method should first test the argument to make sure it describes a device that this provider can supply. If it doesn’t, it should throw an IllegalArgumentException. Otherwise, it returns the device. Providing Soundbank File-Reading Services A SoundBank is a set of Instruments that can be loaded into a Synthesizer. An Instrument is an implementation of a sound-synthesis algorithm that produces a particular sort of sound, and includes accompanying name and information strings. A SoundBank roughly corresponds to a bank in the MIDI specification, but it’s a more extensive and addressable collection; it can perhaps better be thought of as a collection of MIDI banks. SoundbankReader consists of a single overloaded method, which the system invokes to read a Soundbank object from a soundbank file: 12345abstract Soundbank getSoundbank(java.io.File file) abstract Soundbank getSoundbank(java.io.InputStream stream) abstract Soundbank getSoundbank(java.net.URL url) Concrete subclasses of SoundbankReader will work in tandem with particular provider-defined implementations of SoundBank, Instrument, and Synthesizer to allow the system to load a SoundBank from a file into an instance of a particular Synthesizer class. Synthesis techniques may differ wildly from one Synthesizer to another, and, as a consequence, the data stored in an Instrument or SoundBank providing control or specification data for the synthesis process of a Synthesizer can take a variety of forms. One synthesis technique may require only a few bytes of parameter data; another may be based on extensive sound samples. The resources present in a SoundBank will depend upon the nature of the Synthesizer into which they get loaded, and therefore the implementation of the getSoundbank method of a SoundbankReader subclass has access to knowledge of a particular kind of SoundBank. In addition, a particular subclass of SoundbankReader understands a particular file format for storing the SoundBank data. That file format may be vendor-specific and proprietary. SoundBank is just an interface, with only weak constraints on the contents of a SoundBank object. The methods an object must support to implement this interface (getResources, getInstruments, getVendor, getName, etc.) impose loose requirements on the data that the object contains. For example, getResources and getInstruments can return empty arrays. The actual contents of a subclassed SoundBank object, in particular its instruments and its non-instrument resources, are defined by the service provider. Thus, the mechanism of parsing a soundbank file depends entirely on the specification of that particular kind of soundbank file. Soundbank files are created outside the Java Sound API, typically by the vendor of the synthesizer that can load that kind of soundbank. Some vendors might supply end-user tools for creating such files. &#160;","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Providing Sampled-Audio Services","date":"2020-12-05T17:48:02.434Z","path":"wiki/2021-03-03-Providing Sampled-Audio Services/","text":"Providing Sampled-Audio Services As you know, the Java Sound API includes two packages, javax.sound.sampled.spi and javax.sound.midi.spi, that define abstract classes to be used by developers of sound services. By implementing and installing a subclass of one of these abstract classes, a service provider registers the new service, extending the functionality of the runtime system. This page tells you how to go about using the javax.sound.sampled.spi package to provide new services for handling sampled audio. There are four abstract classes in the javax.sound.sampled.spi package, representing four different types of services that you can provide for the sampled-audio system: [`AudioFileWriter`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/spi/AudioFileWriter.html) provides sound file-writing services. These services make it possible for an application program to write a stream of audio data to a file of a particular type. [`AudioFileReader`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/spi/AudioFileReader.html) provides file-reading services. These services enable an application program to ascertain a sound file's characteristics, and to obtain a stream from which the file's audio data can be read. [`FormatConversionProvider`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/spi/FormatConversionProvider.html) provides services for converting audio data formats. These services allow an application program to translate audio streams from one data format to another. [`MixerProvider`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/spi/MixerProvider.html) provides management of a particular kind of mixer. This mechanism allows an application program to obtain information about, and access instances of, a given kind of mixer. To recapitulate earlier discussions, service providers can extend the functionality of the runtime system. A typical SPI class has two types of methods: ones that respond to queries about the types of services available from a particular provider, and ones that either perform the new service directly, or return instances of objects that actually provide the service. The runtime environment’s service-provider mechanism provides registration of installed services with the audio system, and management of the new service provider classes. In essence there is a double isolation of the service instances from the application developer. An application program never directly creates instances of the service objects, such as mixers or format converters, that it needs for its audio processing tasks. Nor does the program even directly request these objects from the SPI classes that administer them. The application program makes requests to the AudioSystem object in the javax.sound.sampled package, and AudioSystem in turn uses the SPI objects to process these queries and service requests. The existence of new audio services might be completely transparent to both the user and the application programmer. All application references are through standard objects of the javax.sound.sampled package, primarily AudioSystem, and the special handling that new services might be providing is often completely hidden. In this discussion, we’ll continue the previous convention of referring to new SPI subclasses by names like AcmeMixer and AcmeMixerProvider. Providing Audio File-Writing Services Let’s start with AudioFileWriter, one of the simpler SPI classes. A subclass that implements the methods of AudioFileWriter must provide implementations of a set of methods to handle queries about the file formats and file types supported by the class, as well as provide methods that actually write out a supplied audio data stream to a File or OutputStream. AudioFileWriter includes two methods that have concrete implementations in the base class: 1234boolean isFileTypeSupported(AudioFileFormat.Type fileType) boolean isFileTypeSupported(AudioFileFormat.Type fileType, AudioInputStream stream) The first of these methods informs the caller whether this file writer can write sound files of the specified type. This method is a general inquiry, it will return true if the file writer can write that kind of file, assuming the file writer is handed appropriate audio data. However, the ability to write a file can depend on the format of the specific audio data that’s handed to the file writer. A file writer might not support every audio data format, or the constraint might be imposed by the file format itself. (Not all kinds of audio data can be written to all kinds of sound files.) The second method is more specific, then, asking whether a particular AudioInputStream can be written to a particular type of file. Generally, you won’t need to override these two concrete methods. Each is simply a wrapper that invokes one of two other query methods and iterates over the results returned. These other two query methods are abstract and therefore need to be implemented in the subclass: 1234abstract AudioFileFormat.Type[] getAudioFileTypes() abstract AudioFileFormat.Type[] getAudioFileTypes(AudioInputStream stream) These methods correspond directly to the previous two. Each returns an array of all the supported file types-all that are supported in general, in the case of the first method, and all that are supported for a specific audio stream, in the case of the second method. A typical implementation of the first method might simply return an array that the file writer’s constructor initializes. An implementation of the second method might test the stream’s AudioFormat object to see whether it’s a data format that the requested type of file supports. The final two methods of AudioFileWriter do the actual file-writing work: 123456abstract int write(AudioInputStream stream, AudioFileFormat.Type fileType, java.io.File out) abstract int write(AudioInputStream stream, AudioFileFormat.Type fileType, java.io.OutputStream out) These methods write a stream of bytes representing the audio data to the stream or file specified by the third argument. The details of how this is done depend on the structure of the specified type of file. The write method must write the file’s header and the audio data in the manner prescribed for sound files of this format (whether it’s a standard type of sound file or a new, possibly proprietary one). Providing Audio File-Reading Services The AudioFileReader class consists of six abstract methods that your subclass needs to implement-actually, two different overloaded methods, each of which can take a File, URL, or InputStream argument. The first of these overloaded methods accepts queries about the file format of a specified file: 12345abstract AudioFileFormat getAudioFileFormat(java.io.File file) abstract AudioFileFormat getAudioFileFormat(java.io.InputStream stream) abstract AudioFileFormat getAudioFileFormat(java.net.URL url) A typical implementation of getAudioFileFormat method reads and parses the sound file’s header to ascertain its file format. See the description of the AudioFileFormat class to see what fields need to be read from the header, and refer to the specification for the particular file type to figure out how to parse the header. Because the caller providing a stream as an argument to this method expects the stream to be unaltered by the method, the file reader should generally start by marking the stream. After reading to the end of the header, it should reset the stream to its original position. The other overloaded AudioFileReader method provides file-reading services, by returning an AudioInputStream from which the file’s audio data can be read: 12345abstract AudioInputStream getAudioInputStream(java.io.File file) abstract AudioInputStream getAudioInputStream(java.io.InputStream stream) abstract AudioInputStream getAudioInputStream(java.net.URL url) Typically, an implementation of getAudioInputStream returns an AudioInputStream wound to the beginning of the file’s data chunk (after the header), ready for reading. It would be conceivable, though, for a file reader to return an AudioInputStream whose audio format represents a stream of data that is in some way decoded from what is contained in the file. The important thing is that the method return a formatted stream from which the audio data contained in the file can be read. The AudioFormat encapsulated in the returned AudioInputStream object will inform the caller about the stream’s data format, which is usually, but not necessarily, the same as the data format in the file itself. Generally, the returned stream is an instance of AudioInputStream; it’s unlikely you would ever need to subclass AudioInputStream. Providing Format-Conversion Services A FormatConversionProvider subclass transforms an AudioInputStream that has one audio data format into one that has another format. The former (input) stream is referred to as the source stream, and the latter (output) stream is referred to as the target stream. Recall that an AudioInputStream contains an AudioFormat, and the AudioFormat in turn contains a particular type of data encoding, represented by an AudioFormat.Encoding object. The format and encoding in the source stream are called the source format and source encoding, and those in the target stream are likewise called the target format and target encoding. The work of conversion is performed in the overloaded abstract method of FormatConversionProvider called getAudioInputStream. The class also has abstract query methods for learning about all the supported target and source formats and encodings. There are concrete wrapper methods for querying about a specific conversion. The two variants of getAudioInputStream are: 1234abstract AudioInputStream getAudioInputStream(AudioFormat.Encoding targetEncoding, AudioInputStream sourceStream) and 1234abstract AudioInputStream getAudioInputStream(AudioFormat targetFormat, AudioInputStream sourceStream) These differ in the first argument, according to whether the caller is specifying a complete target format or just the format’s encoding. A typical implementation of getAudioInputStream works by returning a new subclass of AudioInputStream that wraps around the original (source) AudioInputStream and applies a data format conversion to its data whenever a read method is invoked. For example, consider the case of a new FormatConversionProvider subclass called AcmeCodec, which works with a new AudioInputStream subclass called AcmeCodecStream. The implementation of AcmeCodec&#39;s second getAudioInputStream method might be: 123456789101112131415public AudioInputStream getAudioInputStream (AudioFormat outputFormat, AudioInputStream stream) &#123; AudioInputStream cs &#x3D; null; AudioFormat inputFormat &#x3D; stream.getFormat(); if (inputFormat.matches(outputFormat) ) &#123; cs &#x3D; stream; &#125; else &#123; cs &#x3D; (AudioInputStream) (new AcmeCodecStream(stream, outputFormat)); tempBuffer &#x3D; new byte[tempBufferSize]; &#125; return cs; &#125; The actual format conversion takes place in new read methods of the returned AcmeCodecStream, a subclass of AudioInputStream. Again, application programs that access this returned AcmeCodecStream simply operate on it as an AudioInputStream, and don’t need to know the details of its implementation. The other methods of a FormatConversionProvider all permit queries about the input and output encodings and formats that the object supports. The following four methods, being abstract, need to be implemented: 123456789abstract AudioFormat.Encoding[] getSourceEncodings() abstract AudioFormat.Encoding[] getTargetEncodings() abstract AudioFormat.Encoding[] getTargetEncodings( AudioFormat sourceFormat) abstract AudioFormat[] getTargetFormats( AudioFormat.Encoding targetEncoding, AudioFormat sourceFormat) As in the query methods of the AudioFileReader class discussed above, these queries are typically handled by checking private data of the object and, for the latter two methods, comparing them against the argument(s). The remaining four FormatConversionProvider methods are concrete and generally don’t need to be overridden: 1234567891011boolean isConversionSupported( AudioFormat.Encoding targetEncoding, AudioFormat sourceFormat) boolean isConversionSupported(AudioFormat targetFormat, AudioFormat sourceFormat) boolean isSourceEncodingSupported( AudioFormat.Encoding sourceEncoding) boolean isTargetEncodingSupported( AudioFormat.Encoding targetEncoding) As with AudioFileWriter.isFileTypeSupported(), the default implementation of each of these methods is essentially a wrapper that invokes one of the other query methods and iterates over the results returned. Providing New Types of Mixers As its name implies, a MixerProvider supplies instances of mixers. Each concrete MixerProvider subclass acts as a factory for the Mixer objects used by an application program. Of course, defining a new MixerProvider only makes sense if one or more new implementations of the Mixer interface are also defined. As in the FormatConversionProvider example above, where our getAudioInputStream method returned a subclass of AudioInputStream that performed the conversion, our new class AcmeMixerProvider has a method getMixer that returns an instance of another new class that implements the Mixer interface. We’ll call the latter class AcmeMixer. Particularly if the mixer is implemented in hardware, the provider might support only one static instance of the requested device. If so, it should return this static instance in response to each invocation of getMixer. Since AcmeMixer supports the Mixer interface, application programs don’t require any additional information to access its basic functionality. However, if AcmeMixer supports functionality not defined in the Mixer interface, and the vendor wants to make this extended functionality accessible to application programs, the mixer should of course be defined as a public class with additional, well-documented public methods, so that a program that wishes to make use of this extended functionality can import AcmeMixer and cast the object returned by getMixer to this type. The other two methods of MixerProvider are: 123abstract Mixer.Info[] getMixerInfo() and 123boolean isMixerSupported(Mixer.Info info) These methods allow the audio system to determine whether this particular provider class can produce a device that an application program needs. In other words, the AudioSystem object can iterate over all the installed MixerProviders to see which ones, if any, can supply the device that the application program has requested of the AudioSystem. The getMixerInfo method returns an array of objects containing information about the kinds of mixer available from this provider object. The system can pass these information objects, along with those from other providers, to an application program. A single MixerProvider can provide more than one kind of mixer. When the system invokes the MixerProvider&#39;s getMixerInfo method, it gets a list of information objects identifying the different kinds of mixer that this provider supports. The system can then invoke MixerProvider.getMixer(Mixer.Info) to obtain each mixer of interest. Your subclass needs to implement getMixerInfo, as it’s abstract. The isMixerSupported method is concrete and doesn’t generally need to be overridden. The default implementation simply compares the provided Mixer.Info to each one in the array returned by getMixerInfo. &#160;","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Introduction to the Service Provider Interfaces","date":"2020-12-05T17:48:00.398Z","path":"wiki/2021-03-03-Introduction to the Service Provider Interfaces/","text":"Introduction to the Service Provider InterfacesWhat Are Services?Services are units of sound-handling functionality that are automatically available when an application program makes use of an implementation of the Java Sound API. They consist of objects that do the work of reading, writing, mixing, processing, and converting audio and MIDI data. An implementation of the Java Sound API generally supplies a basic set of services, but mechanisms are also included in the API to support the development of new sound services by third-party developers (or by the vendor of the implementation itself). These new services can be “plugged into” an existing installed implementation to expand its functionality without requiring a new release. In the Java Sound API architecture, third-party services are integrated into the system in such a way that an application program’s interface to them is the same as the interface to the “built-in” services. In some cases, application developers who use the javax.sound.sampled and javax.sound.midi packages might not even be aware that they are employing third-party services. Examples of potential third-party, sampled-audio services include: Sound file readers and writers Converters that translate between different audio data formats New audio mixers and input/output devices, whether implemented purely in software, or in hardware with a software interface Third-party MIDI services might consist of: MIDI file readers and writers Readers for various types of soundbank files (which are often specific to particular synthesizers) MIDI-controlled sound synthesizers, sequencers, and I/O ports, whether implemented purely in software, or in hardware with a software interface How Services WorkThe javax.sound.sampled and javax.sound.midi packages provide functionality to application developers who wish to include sound services in their application programs. These packages are for consumers of sound services, providing interfaces to get information about, control, and access audio and MIDI services. In addition, the Java Sound API also supplies two packages that define abstract classes to be used by providers of sound services: the javax.sound.sampled.spi and javax.sound.midi.spi packages. Developers of new sound services implement concrete subclasses of the appropriate classes in the SPI packages. These subclasses, along with any additional classes required to support the new service, are placed in a Java Archive (JAR) archive file with a description of the included service or services. When this JAR file is installed in the user’s CLASSPATH, the runtime system automatically makes the new service available, extending the functionality of the Java platform’s runtime system. Once the new service is installed, it can be accessed just like any previously installed service. Consumers of services can get information about the new service, or obtain instances of the new service class itself, by invoking methods of the AudioSystem and MidiSystem classes (in the javax.sound.sampled and javax.sound.midi packages, respectively) to return information about the new services, or to return instances of new or existing service classes themselves. Application programs need not&#226;&#128;&#148;and should not&#226;&#128;&#148;reference the classes in the SPI packages (and their subclasses) directly to make use of the installed services. For example, suppose a hypothetical service provider called Acme Software, Inc. is interested in supplying a package that allows application programs to read a new format of sound file (but one whose audio data is in a standard data format). The SPI class AudioFileReader can be subclassed into a class called, say, AcmeAudioFileReader. In the new subclass, Acme would supply implementations of all the methods defined in AudioFileReader; in this case there are only two methods (with argument variants), getAudioFileFormat and getAudioInputStream. Then when an application program attempted to read a sound file that happened to be in Acme’s file format, it would invoke methods of the AudioSystem class in javax.sound.sampled to access the file and information about it. The methods AudioSystem.getAudioInputStream and AudioSystem.getAudioFileFormat provide a standard API to read audio streams; with the AcmeAudioFileReader class installed, this interface is extended to support the new file type transparently. Application developers don’t need direct access to the newly registered SPI classes: the AudioSystem object methods pass the query on to the installed AcmeAudioFileReader class. What’s the point of having these “factory” classes? Why not permit the application developer to get access directly to newly provided services? That is a possible approach, but having all management and instantiation of services pass through gatekeeper system objects shields the application developer from having to know anything about the identity of installed services. Application developers just use services of value to them, perhaps without even realizing it. At the same time this architecture permits service providers to effectively manage the available resources in their packages. Often the use of new sound services is transparent to the application program. For example, imagine a situation where an application developer wants to read in a stream of audio from a file. Assuming that thePathName identifies an audio input file, the program does this: 1234File theInFile &#x3D; new File(thePathName);AudioInputStream theInStream &#x3D; AudioSystem.getAudioInputStream(theInFile); Behind the scenes, the AudioSystem determines what installed service can read the file and asks it to supply the audio data as an AudioInputStream object. The developer might not know or even care that the input audio file is in some new file format (such as Acme’s), supported by installed third-party services. The program’s first contact with the stream is through the AudioSystem object, and all its subsequent access to the stream and its properties are through the methods of AudioInputStream. Both of these are standard objects in the javax.sound.sampled API; the special handling that the new file format may require is completely hidden. How Providers Prepare New ServicesService providers supply their new services in specially formatted JAR files, which are to be installed in a directory on the user’s system where the Java runtime will find them. JAR files are archive files, each containing sets of files that might be organized in hierarchical directory structures within the archive. Details about the preparation of the class files that go into these archives are discussed in the next few pages, which describe the specifics of the audio and MIDI SPI packages; here we’ll just give an overview of the process of JAR file creation. The JAR file for a new service or services should contain a class file for each service supported in the JAR file. Following the Java platform’s convention, each class file has the name of the newly defined class, which is a concrete subclass of one of the abstract service provider classes. The JAR file also must include any supporting classes required by the new service implementation. So that the new service or services can be located by the runtime system’s service provider mechanism, the JAR file must also contain special files (described below) that map the SPI class names to the new subclasses being defined. To continue from our example above, say Acme Software, Inc. is distributing a package of new sampled-audio services. Let’s suppose this package consists of two new services: The AcmeAudioFileReader class, which was mentioned above, and which is a subclass of AudioFileReader A subclass of AudioFileWriter called AcmeAudioFileWriter, which will write sound files in Acme’s new format Starting from an arbitrary directory&#226;&#128;&#148;let’s call it /devel&#226;&#128;&#148;where we want to do the build, we create subdirectories and put the new class files in them, organized in such a manner as to give the desired pathname by which the new classes will be referenced: 1234com&#x2F;acme&#x2F;AcmeAudioFileReader.classcom&#x2F;acme&#x2F;AcmeAudioFileWriter.class In addition, for each new SPI class being subclassed, we create a mapping file in a specially named directory META-INF/services. The name of the file is the name of the SPI class being subclassed, and the file contains the names of the new subclasses of that SPI abstract class. We create the file 123META-INF&#x2F;services&#x2F;javax.sound.sampled.spi.AudioFileReader which consists of 12345# Providers of sound file-reading services # (a comment line begins with a pound sign)com.acme.AcmeAudioFileReader and also the file 123META-INF&#x2F;services&#x2F;javax.sound.sampled.spi.AudioFileWriter which consists of 1234# Providers of sound file-writing services com.acme.AcmeAudioFileWriter Now we run jar from any directory with the command line: 123jar cvf acme.jar -C &#x2F;devel . The -C option causes jar to switch to the /devel directory, instead of using the directory in which the command is executed. The final period argument instructs jar to archive all the contents of that directory (namely, /devel), but not the directory itself. This run will create the file acme.jar with the contents: 1234567com&#x2F;acme&#x2F;AcmeAudioFileReader.classcom&#x2F;acme&#x2F;AcmeAudioFileWriter.classMETA-INF&#x2F;services&#x2F;javax.sound.sampled.spi.AudioFileReaderMETA-INF&#x2F;services&#x2F;javax.sound.sampled.spi.AudioFileWriterMETA-INF&#x2F;Manifest.mf The file Manifest.mf, which is generated by the jar utility itself, is a list of all the files contained in the archive. How Users Install New ServicesFor end users (or system administrators) who wish to get access to a new service through their application programs, installation is simple. They place the provided JAR file in a directory in their CLASSPATH. Upon execution, the Java runtime will find the referenced classes when needed. It’s not an error to install more than one provider for the same service. For example, two different service providers might supply support for reading the same type of sound file. In such a case, the system arbitrarily chooses one of the providers. Users who care which provider is chosen should install only the desired one. &#160;","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Synthesizing Sound","date":"2020-12-05T17:47:59.227Z","path":"wiki/2021-03-03-Synthesizing Sound/","text":"Synthesizing Sound Most programs that avail themselves of the Java Sound API’s MIDI package do so to synthesize sound. The entire apparatus of MIDI files, events, sequences, and sequencers, which was previously discussed, nearly always has the goal of eventually sending musical data to a synthesizer to convert into audio. (Possible exceptions include programs that convert MIDI into musical notation that can be read by a musician, and programs that send messages to external MIDI-controlled devices such as mixing consoles.) The Synthesizer interface is therefore fundamental to the MIDI package. This page shows how to manipulate a synthesizer to play sound. Many programs will simply use a sequencer to send MIDI file data to the synthesizer, and won’t need to invoke many Synthesizer methods directly. However, it’s possible to control a synthesizer directly, without using sequencers or even MidiMessage objects, as explained near the end of this page. The synthesis architecture might seem complex for readers who are unfamiliar with MIDI. Its API includes three interfaces: [`Synthesizer`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/Synthesizer.html) [`MidiChannel`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/MidiChannel.html) [`Soundbank`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/Soundbank.html) and four classes: [`Instrument`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/Instrument.html) [`Patch`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/Patch.html) [`SoundbankResource`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/SoundbankResource.html) [`VoiceStatus`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/VoiceStatus.html) As orientation for all this API, the next section explains some of the basics of MIDI synthesis and how they’re reflected in the Java Sound API. Subsequent sections give a more detailed look at the API. Understanding MIDI Synthesis How does a synthesizer generate sound? Depending on its implementation, it may use one or more sound-synthesis techniques. For example, many synthesizers use wavetable synthesis. A wavetable synthesizer reads stored snippets of audio from memory, playing them at different sample rates and looping them to create notes of different pitches and durations. For example, to synthesize the sound of a saxophone playing the note C#4 (MIDI note number 61), the synthesizer might access a very short snippet from a recording of a saxophone playing the note Middle C (MIDI note number 60), and then cycle repeatedly through this snippet at a slightly faster sample rate than it was recorded at, which creates a long note of a slightly higher pitch. Other synthesizers use techniques such as frequency modulation (FM), additive synthesis, or physical modeling, which don’t make use of stored audio but instead generate audio from scratch using different algorithms. Instruments What all synthesis techniques have in common is the ability to create many sorts of sounds. Different algorithms, or different settings of parameters within the same algorithm, create different-sounding results. An instrument is a specification for synthesizing a certain type of sound. That sound may emulate a traditional musical instrument, such as a piano or violin; it may emulate some other kind of sound source, for instance, a telephone or helicopter; or it may emulate no “real-world” sound at all. A specification called General MIDI defines a standard list of 128 instruments, but most synthesizers allow other instruments as well. Many synthesizers provide a collection of built-in instruments that are always available for use; some synthesizers also support mechanisms for loading additional instruments. An instrument may be vendor-specific&#226;&#128;&#148;in other words, applicable to only one synthesizer or several models from the same vendor. This incompatibility results when two different synthesizers use different sound-synthesis techniques, or different internal algorithms and parameters even if the fundamental technique is the same. Because the details of the synthesis technique are often proprietary, incompatibility is common. The Java Sound API includes ways to detect whether a given synthesizer supports a given instrument. An instrument can usually be considered a preset; you don’t have to know anything about the details of the synthesis technique that produces its sound. However, you can still vary aspects of its sound. Each Note On message specifies the pitch and volume of an individual note. You can also alter the sound through other MIDI commands such as controller messages or system-exclusive messages. Channels Many synthesizers are multimbral (sometimes called polytimbral), meaning that they can play the notes of different instruments simultaneously. (Timbre is the characteristic sound quality that enables a listener to distinguish one kind of musical instrument from other kinds.) Multimbral synthesizers can emulate an entire ensemble of real-world instruments, instead of only one instrument at a time. MIDI synthesizers normally implement this feature by taking advantage of the different MIDI channels on which the MIDI specification allows data to be transmitted. In this case, the synthesizer is actually a collection of sound-generating units, each emulating a different instrument and responding independently to messages that are received on a different MIDI channel. Since the MIDI specification provides only 16 channels, a typical MIDI synthesizer can play up to 16 different instruments at once. The synthesizer receives a stream of MIDI commands, many of which are channel commands. (Channel commands are targeted to a particular MIDI channel; for more information, see the MIDI specification.) If the synthesizer is multitimbral, it routes each channel command to the correct sound-generating unit, according to the channel number indicated in the command. In the Java Sound API, these sound-generating units are instances of classes that implement the MidiChannel interface. A synthesizer object has at least one MidiChannel object. If the synthesizer is multimbral, it has more than one, normally 16. Each MidiChannel represents an independent sound-generating unit. Because a synthesizer’s MidiChannel objects are more or less independent, the assignment of instruments to channels doesn’t have to be unique. For example, all 16 channels could be playing a piano timbre, as though there were an ensemble of 16 pianos. Any grouping is possible&#226;&#128;&#148;for instance, channels 1, 5, and 8 could be playing guitar sounds, while channels 2 and 3 play percussion and channel 12 has a bass timbre. The instrument being played on a given MIDI channel can be changed dynamically; this is known as a program change. Even though most synthesizers allow only 16 or fewer instruments to be active at a given time, these instruments can generally be chosen from a much larger selection and assigned to particular channels as required. Soundbanks and Patches Instruments are organized hierarchically in a synthesizer, by bank number and program number. Banks and programs can be thought of as rows and columns in a two-dimensional table of instruments. A bank is a collection of programs. The MIDI specification allows up to 128 programs in a bank, and up to 128 banks. However, a particular synthesizer might support only one bank, or a few banks, and might support fewer than 128 programs per bank. In the Java Sound API, there’s a higher level to the hierarchy: a soundbank. Soundbanks can contain up to 128 banks, each containing up to 128 instruments. Some synthesizers can load an entire soundbank into memory. To select an instrument from the current soundbank, you specify a bank number and a program number. The MIDI specification accomplishes this with two MIDI commands: bank select and program change. In the Java Sound API, the combination of a bank number and program number is encapsulated in a Patch object. You change a MIDI channel’s current instrument by specifying a new patch. The patch can be considered the two-dimensional index of the instruments in the current soundbank. You might be wondering if soundbanks, too, are indexed numerically. The answer is no; the MIDI specification does not provide for this. In the Java Sound API, a Soundbank object can be obtained by reading a soundbank file. If the soundbank is supported by the synthesizer, its instruments can be loaded into the synthesizer individually as desired, or all at once. Many synthesizers have a built-in or default soundbank; the instruments contained in this soundbank are always available to the synthesizer. Voices It’s important to distinguish between the number of timbres a synthesizer can play simultaneously and the number of notes it can play simultaneously. The former was described above under “Channels.” The ability to play multiple notes at once is referred to as polyphony. Even a synthesizer that isn’t multitimbral can generally play more than one note at a time (all having the same timbre, but different pitches). For example, playing any chord, such as a G major triad or a B minor seventh chord, requires polyphony. Any synthesizer that generates sound in real time has a limitation on the number of notes it can synthesize at once. In the Java Sound API, the synthesizer reports this limitation through the getMaxPolyphony method. A voice is a succession of single notes, such as a melody that a person can sing. Polyphony consists of multiple voices, such as the parts sung by a choir. A 32-voice synthesizer, for example, can play 32 notes simultaneously. (However, some MIDI literature uses the word “voice” in a different sense, similar to the meaning of “instrument” or “timbre.”) The process of assigning incoming MIDI notes to specific voices is known as voice allocation. A synthesizer maintains a list of voices, keeping track of which ones are active (meaning that they currently have notes sounding). When a note stops sounding, the voice becomes inactive, meaning that it’s now free to accept the next note-on request that the synthesizer receives. An incoming stream of MIDI commands can easily request more simultaneous notes than the synthesizer is capable of generating. When all the synthesizer’s voices are active, how should the next Note On request be handled? Synthesizers can implement different strategies: the most recently requested note can be ignored; or it can be played by discontinuing another note, such as the least recently started one. Although the MIDI specification does not require it, a synthesizer can make public the contents of each of its voices. The Java Sound API includes a VoiceStatus class for this purpose. A VoiceStatus reports on the voice’s current active or inactive status, MIDI channel, bank and program number, MIDI note number, and MIDI volume. With this background, let’s examine the specifics of the Java Sound API for synthesis. Managing Instruments and Soundbanks In many cases, a program can make use of a Synthesizer object without explicitly invoking almost any of the synthesis API. For example, suppose you’re playing a standard MIDI file. You load it into a Sequence object, which you play by having a sequencer send the data to the default synthesizer. The data in the sequence controls the synthesizer as intended, playing all the right notes at the right times. However, there are cases when this simple scenario is inadequate. The sequence contains the right music, but the instruments sound all wrong! This unfortunate situation probably arose because the creator of the MIDI file had different instruments in mind than the ones that are currently loaded into the synthesizer. The MIDI 1.0 Specification provides for bank-select and program-change commands, which affect which instrument is currently playing on each MIDI channel. However, the specification does not define what instrument should reside in each patch location (bank and program number). The more recent General MIDI specification addresses this problem by defining a bank containing 128 programs that correspond to specific instrument sounds. A General MIDI synthesizer uses 128 instruments that match this specified set. Different General MIDI synthesizers can sound quite different, even when playing what’s supposed to be the same instrument. However, a MIDI file should for the most part sound similar (even if not identical), no matter which General MIDI synthesizer is playing it. Nonetheless, not all creators of MIDI files want to be limited to the set of 128 timbres defined by General MIDI. This section shows how to change the instruments from the default set that the synthesizer comes with. (If there is no default, meaning that no instruments are loaded when you access the synthesizer, you’ll have to use this API to start with in any case.) Learning What Instruments Are Loaded To learn whether the instruments currently loaded into the synthesizer are the ones you want, you can invoke this Synthesizer method: 123Instrument[] getLoadedInstruments() and iterate over the returned array to see exactly which instruments are currently loaded. Most likely, you would display the instruments’ names in the user interface (using the getName method of Instrument), and let the user decide whether to use those instruments or load others. The Instrument API includes a method that reports which soundbank the instrument belongs to. The soundbank’s name might help your program or the user ascertain exactly what the instrument is. This Synthesizer method: 123Soundbank getDefaultSoundbank() gives you the default soundbank. The Soundbank API includes methods to retrieve the soundbank’s name, vendor, and version number, by which the program or the user can verify the bank’s identity. However, you can’t assume when you first get a synthesizer that the instruments from the default soundbank have been loaded into the synthesizer. For example, a synthesizer might have a large assortment of built-in instruments available for use, but because of its limited memory it might not load them automatically. Loading Different Instruments The user might decide to load instruments that are different from the current ones (or you might make that decision programmatically). The following method tells you which instruments come with the synthesizer (versus having to be loaded from soundbank files): 123Instrument[] getAvailableInstruments() You can load any of these instruments by invoking: 123boolean loadInstrument(Instrument instrument) The instrument gets loaded into the synthesizer in the location specified by the instrument’s Patch object (which can be retrieved using the getPatch method of Instrument). To load instruments from other soundbanks, first invoke Synthesizer&#39;s isSupportedSoundbank method to make sure that the soundbank is compatible with this synthesizer (if it isn’t, you can iterate over the system’s synthesizers to try to find one that supports the soundbank). You can then invoke one of these methods to load instruments from the soundbank: 12345boolean loadAllInstruments(Soundbank soundbank) boolean loadInstruments(Soundbank soundbank, Patch[] patchList) As the names suggest, the first of these loads the entire set of instruments from a given soundbank, and the second loads selected instruments from the soundbank. You could also use Soundbank&#39;s getInstruments method to access all the instruments, then iterate over them and load selected instruments one at a time using loadInstrument. It’s not necessary for all the instruments you load to be from the same soundbank. You could use loadInstrument or loadInstruments to load certain instruments from one soundbank, another set from a different soundbank, and so on. Each instrument has its own Patch object that specifies the location on the synthesizer where the instrument should be loaded. The location is defined by a bank number and a program number. There’s no API to change the location by changing the patch’s bank or program number. However, it is possible to load an instrument into a location other than the one specified by its patch, using the following method of Synthesizer: 123boolean remapInstrument(Instrument from, Instrument to) This method unloads its first argument from the synthesizer, and places its second argument in whatever synthesizer patch location had been occupied by the first argument. Unloading Instruments Loading an instrument into a program location automatically unloads whatever instrument was already at that location, if any. You can also explicitly unload instruments without necessarily replacing them with new ones. Synthesizer includes three unloading methods that correspond to the three loading methods. If the synthesizer receives a program-change message that selects a program location where no instrument is currently loaded, there won’t be any sound from the MIDI channel on which the program-change message was sent. Accessing Soundbank Resources Some synthesizers store other information besides instruments in their soundbanks. For example, a wavetable synthesizer stores audio samples that one or more instruments can access. Because the samples might be shared by multiple instruments, they’re stored in the soundbank independently of any instrument. Both the Soundbank interface and the Instrument class provide a method call getSoundbankResources, which returns a list of SoundbankResource objects. The details of these objects are specific to the synthesizer for which the soundbank is designed. In the case of wavetable synthesis, a resource might be an object that encapsulates a series of audio samples, taken from one snippet of a sound recording. Synthesizers that use other synthesis techniques might store other kinds of objects in the synthesizer’s SoundbankResources array. Querying the Synthesizer’s Capabilities and Current State The Synthesizer interface includes methods that return information about the synthesizer’s capabilities: 1234public long getLatency()public int getMaxPolyphony() The latency measures the worst-case delay between the time a MIDI message is delivered to the synthesizer and the time that the synthesizer actually produces the corresponding result. For example, it might take a synthesizer a few milliseconds to begin generating audio after receiving a note-on event. Voices. As mentioned in the same discussion, a synthesizer can provide information about its voices. This is accomplished through the following method: 123public VoiceStatus[] getVoiceStatus() Each VoiceStatus in the returned array reports the voice’s current active or inactive status, MIDI channel, bank and program number, MIDI note number, and MIDI volume. The array’s length should normally be the same number returned by getMaxPolyphony. If the synthesizer isn’t playing, all its VoiceStatus objects have their active field set to false. You can learn additional information about the current status of a synthesizer by retrieving its MidiChannel objects and querying their state. This is discussed more in the next section. Using Channels Sometimes it’s useful or necessary to access a synthesizer’s MidiChannel objects directly. This section discusses such situations. Controlling the Synthesizer without Using a Sequencer When using a sequence, such as one read from a MIDI file, you don’t need to send MIDI commands to the synthesizer yourself. Instead, you just load the sequence into a sequencer, connect the sequencer to the synthesizer, and let it run. The sequencer takes care of scheduling the events, and the result is a predictable musical performance. This scenario works fine when the desired music is known in advance, which is true when it’s read from a file. In some situations, however, the music is generated on the fly as it’s playing. For example, the user interface might display a musical keyboard or a guitar fretboard and let the user play notes at will by clicking with the mouse. As another example, an application might use a synthesizer not to play music per se, but to generate sound effects in response to the user’s actions. This scenario is typical of games. As a final example, the application might indeed be playing music that’s read from a file, but the user interface allows the user to interact with the music, altering it dynamically. In all these cases, the application sends commands directly to the synthesizer, since the MIDI messages need to be delivered immediately, instead of being scheduled for some determinate point in the future. There are at least two ways of sending a MIDI message to the synthesizer without using a sequencer. The first is to construct a MidiMessage and pass it to the synthesizer using the send method of Receiver. For example, to produce a Middle C (MIDI note number 60) on MIDI channel 5 (one-based) immediately, you could do the following: 123456789ShortMessage myMsg &#x3D; new ShortMessage();&#x2F;&#x2F; Play the note Middle C (60) moderately loud&#x2F;&#x2F; (velocity &#x3D; 93)on channel 4 (zero-based).myMsg.setMessage(ShortMessage.NOTE_ON, 4, 60, 93); Synthesizer synth &#x3D; MidiSystem.getSynthesizer();Receiver synthRcvr &#x3D; synth.getReceiver();synthRcvr.send(myMsg, -1); &#x2F;&#x2F; -1 means no time stamp The second way is to bypass the message-passing layer (that is, the MidiMessage and Receiver API) altogether, and interact with the synthesizer’s MidiChannel objects directly. You first need to retrieve the synthesizer’s MidiChannel objects, using the following Synthesizer method: 123public MidiChannel[] getChannels() after which you can invoke the desired MidiChannel methods directly. This is a more immediate route than sending the corresponding MidiMessages to the synthesizer’s Receiver and letting the synthesizer handle the communication with its own MidiChannels. For example, the code corresponding to the preceding example would be: 12345678Synthesizer synth &#x3D; MidiSystem.getSynthesizer();MidiChannel chan[] &#x3D; synth.getChannels(); &#x2F;&#x2F; Check for null; maybe not all 16 channels exist.if (chan[4] !&#x3D; null) &#123; chan[4].noteOn(60, 93); &#125; Getting a Channel’s Current State The MidiChannel interface provides methods that correspond one-to-one to each of the “channel voice” or “channel mode” messages defined by the MIDI specification. We saw one case with the use of the noteOn method in the previous example. However, in addition to these canonical methods, the Java Sound API’s MidiChannel interface adds some “get” methods to retrieve the value most recently set by corresponding voice or mode “set” methods: 123456789int getChannelPressure()int getController(int controller)boolean getMono()boolean getOmni() int getPitchBend() int getPolyPressure(int noteNumber)int getProgram() These methods might be useful for displaying channel state to the user, or for deciding what values to send subsequently to the channel. Muting and Soloing a Channel The Java Sound API adds the notions of per-channel solo and mute, which are not required by the MIDI specification. These are similar to the solo and mute on the tracks of a MIDI sequence. If mute is on, this channel will not sound, but other channels are unaffected. If solo is on, this channel, and any other soloed channel, will sound (if it isn’t muted), but no other channels will sound. A channel that is both soloed and muted will not sound. The MidiChannel API includes four methods: 123456boolean getMute() boolean getSolo()void setMute(boolean muteState) void setSolo(boolean soloState) Permission to Play Synthesized Sound The audio produced by any installed MIDI synthesizer is typically routed through the sampled-audio system. If your program doesn’t have permission to play audio, the synthesizer’s sound won’t be heard, and a security exception will be thrown. For more information on audio permissions, see the previous discussion of Permission to Use Audio ResourcesPermission to Use Audio Resources.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Using Advanced Sequencer Features","date":"2020-12-05T17:47:57.140Z","path":"wiki/2021-03-03-Using Advanced Sequencer Features/","text":"Using Advanced Sequencer Features So far, we’ve focused on simple playback and recording of MIDI data. This section will briefly describe some of the more advanced features available through methods of the Sequencer interface and the Sequence class. Moving to an Arbitrary Position in the Sequence There are two Sequencer methods that obtain the sequencer’s current position in the sequence. The first of these: 123long getTickPosition() returns the position measured in MIDI ticks from the beginning of the sequence. The second method: 123long getMicrosecondPosition() returns the current position in microseconds. This method assumes that the sequence is being played at the default rate as stored in the MIDI file or in the Sequence. It does not return a different value if you’ve changed the playback speed as described below. You can similarly set the sequencer’s current position according to one unit or the other: 123void setTickPosition(long tick) or 123void setMicrosecondPosition(long microsecond) Changing the Playback Speed As indicated earlier, a sequence’s speed is indicated by its tempo, which can vary over the course of the sequence. A sequence can contain events that encapsulate standard MIDI tempo-change messages. When the sequencer processes such an event, it changes the speed of playback to reflect the indicated tempo. In addition, you can programmatically change the tempo by invoking any of these Sequencer methods: 12345public void setTempoInBPM(float bpm)public void setTempoInMPQ(float mpq)public void setTempoFactor(float factor) The first two of these methods set the tempo in beats per minute or microseconds per quarter note, respectively. The tempo will stay at the specified value until one of these methods is invoked again, or until a tempo-change event is encountered in the sequence, at which point the current tempo is overridden by the newly specified one. The third method, setTempoFactor, is different in nature. It scales whatever tempo is set for the sequencer (whether by tempo-change events or by one of the first two methods above). The default scalar is 1.0 (no change). Although this method causes the playback or recording to be faster or slower than the nominal tempo (unless the factor is 1.0), it doesn’t alter the nominal tempo. In other words, the tempo values returned by getTempoInBPM and getTempoInMPQ are unaffected by the tempo factor, even though the tempo factor does affect the actual rate of playback or recording. Also, if the tempo is changed by a tempo-change event or by one of the first two methods, it still gets scaled by whatever tempo factor was last set. If you load a new sequence, however, the tempo factor is reset to 1.0. Note that all these tempo-change directives are ineffectual when the sequence’s division type is one of the SMPTE types, instead of PPQ. Muting or Soloing Individual Tracks in the Sequence It’s often convenient for users of sequencers to be able to turn off certain tracks, to hear more clearly exactly what is happening in the music. A full-featured sequencer program lets the user choose which tracks should sound during playback. (Speaking more precisely, since sequencers don’t actually create sound themselves, the user chooses which tracks will contribute to the stream of MIDI messages that the sequencer produces.) Typically, there are two types of graphical controls on each track: a mute button and a solo button. If the mute button is activated, that track will not sound under any circumstances, until the mute button is deactivated. Soloing is a less well-known feature. It’s roughly the opposite of muting. If the solo button on any track is activated, only tracks whose solo buttons are activated will sound. This feature lets the user quickly audition a small number of tracks without having to mute all the other tracks. The mute button typically takes priority over the solo button: if both are activated, the track doesn’t sound. Using Sequencer methods, muting or soloing tracks (as well as querying a track’s current mute or solo state) is easily accomplished. Let’s assume we have obtained the default Sequencer and that we’ve loaded sequence data into it. Muting the fifth track in the sequence would be accomplished as follows: 1234567sequencer.setTrackMute(4, true);boolean muted &#x3D; sequencer.getTrackMute(4);if (!muted) &#123; return; &#x2F;&#x2F; muting failed&#125; There are a couple of things to note about the above code snippet. First, tracks of a sequence are numbered starting with 0 and ending with the total number of tracks minus 1. Also, the second argument to setTrackMute is a boolean. If it’s true, the request is to mute the track; otherwise the request is to unmute the specified track. Lastly, in order to test that the muting took effect, we invoke the Sequencer getTrackMute method, passing it the track number we’re querying. If it returns true, as we’d expect in this case, then the mute request worked. If it returns false, then it failed. Mute requests may fail for various reasons. For example, the track number specified in the setTrackMute call might exceed the total number of tracks, or the sequencer might not support muting. By calling getTrackMute, we can determine if our request succeeded or failed. As an aside, the boolean that’s returned by getTrackMute can, indeed, tell us if a failure occurred, but it can’t tell us why it occurred. We could test to see if a failure was caused by passing an invalid track number to the setTrackMute method. To do this, we would call the getTracks method of Sequence, which returns an array containing all of the tracks in the sequence. If the track number specified in the setTrackMute call exceeds the length of this array, then we know we specified an invalid track number. If the mute request succeeded, then in our example, the fifth track will not sound when the sequence is playing, nor will any other tracks that are currently muted. The method and techniques for soloing a track are very similar to those for muting. To solo a track, invoke the setTrackSolo method of Sequence: 123void setTrackSolo(int track, boolean bSolo) As in setTrackMute, the first argument specifies the zero-based track number, and the second argument, if true, specifies that the track should be in solo mode; otherwise the track should not be soloed. By default, a track is neither muted nor soloed. Synchronizing with Other MIDI Devices Sequencer has an inner class called Sequencer.SyncMode. A SyncMode object represents one of the ways in which a MIDI sequencer’s notion of time can be synchronized with a master or slave device. If the sequencer is being synchronized to a master, the sequencer revises its current time in response to certain MIDI messages from the master. If the sequencer has a slave, the sequencer similarly sends MIDI messages to control the slave’s timing. There are three predefined modes that specify possible masters for a sequencer: INTERNAL_CLOCK, MIDI_SYNC, and MIDI_TIME_CODE. The latter two work if the sequencer receives MIDI messages from another device. In these two modes, the sequencer’s time gets reset based on system real-time timing clock messages or MIDI time code (MTC) messages, respectively. (See the MIDI specification for more information about these types of message.) These two modes can also be used as slave modes, in which case the sequencer sends the corresponding types of MIDI messages to its receiver. A fourth mode, NO_SYNC, is used to indicate that the sequencer should not send timing information to its receivers. By calling the setMasterSyncMode method with a supported SyncMode object as the argument, you can specify how the sequencer’s timing is controlled. Likewise, the setSlaveSyncMode method determines what timing information the sequencer will send to its receivers. This information controls the timing of devices that use the sequencer as a master timing source. Specifying Special Event Listeners Each track of a sequence can contain many different kinds of MidiEvents. Such events include Note On and Note Off messages, program changes, control changes, and meta events. The Java Sound API specifies “listener” interfaces for the last two of these event types (control change events and meta events). You can use these interfaces to receive notifications when such events occur during playback of a sequence. Objects that support the ControllerEventListener interface can receive notification when a Sequencer processes particular control-change messages. A control-change message is a standard type of MIDI message that represents a change in the value of a MIDI controller, such as a pitch-bend wheel or a data slider. (See the MIDI specification for the complete list of control-change messages.) When such a message is processed during playback of a sequence, the message instructs any device (probably a synthesizer) that’s receiving the data from the sequencer to update the value of some parameter. The parameter usually controls some aspect of sound synthesis, such as the pitch of the currently sounding notes if the controller was the pitch-bend wheel. When a sequence is being recorded, the control-change message means that a controller on the external physical device that created the message has been moved, or that such a move has been simulated in software. Here’s how the ControllerEventListener interface is used. Let’s assume that you’ve developed a class that implements the ControllerEventListener interface, meaning that your class contains the following method: 123void controlChange(ShortMessage msg) Let’s also assume that you’ve created an instance of your class and assigned it to a variable called myListener. If you include the following statements somewhere within your program: 12345int[] controllersOfInterest &#x3D; &#123; 1, 2, 4 &#125;;sequencer.addControllerEventListener(myListener, controllersOfInterest); then your class’s controlChange method will be invoked every time the sequencer processes a control-change message for MIDI controller numbers 1, 2, or 4. In other words, when the Sequencer processes a request to set the value of any of the registered controllers, the Sequencer will invoke your class’s controlChange method. (Note that the assignments of MIDI controller numbers to specific control devices is detailed in the MIDI 1.0 Specification.) The controlChange method is passed a ShortMessage containing the controller number affected, and the new value to which the controller was set. You can obtain the controller number using the ShortMessage.getData1 method, and the new setting of the controller’s value using the ShortMessage.getData2 method. The other kind of special event listener is defined by the MetaEventListener interface. Meta messages, according to the Standard MIDI Files 1.0 specification, are messages that are not present in MIDI wire protocol but that can be embedded in a MIDI file. They are not meaningful to a synthesizer, but can be interpreted by a sequencer. Meta messages include instructions (such as tempo change commands), lyrics or other text, and other indicators (such as end-of-track). The MetaEventListener mechanism is analogous to ControllerEventListener. Implement the MetaEventListener interface in any class whose instances need to be notified when a MetaMessage is processed by the sequencer. This involves adding the following method to the class: 123void meta(MetaMessage msg) You register an instance of this class by passing it as the argument to the Sequencer addMetaEventListener method: 1234boolean b &#x3D; sequencer.addMetaEventListener (myMetaListener); This is slightly different from the approach taken by the ControllerEventListener interface, because you have to register to receive all MetaMessages, not just selected ones of interest. If the sequencer encounters a MetaMessage in its sequence, it will invoke myMetaListener.meta, passing it the MetaMessage encountered. The meta method can invoke getType on its MetaMessage argument to obtain an integer from 0 to 127 that indicates the message type, as defined by the Standard MIDI Files 1.0 specification. &#160;","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Using Sequencer Methods","date":"2020-12-05T17:47:55.110Z","path":"wiki/2021-03-03-Using Sequencer Methods/","text":"Using Sequencer MethodsTheSequencer interface provides methods in several categories: Methods to load sequence data from a MIDI file or a Sequence object, and to save the currently loaded sequence data to a MIDI file. Methods analogous to the transport functions of a tape recorder, for stopping and starting playback and recording, enabling and disabling recording on specific tracks, and shuttling the current playback or recording position in a Sequence. Advanced methods for querying and setting the synchronization and timing parameters of the object. A Sequencer may play at different tempos, with some Tracks muted, and in various synchronization states with other objects. Advanced methods for registering “listener” objects that are notified when the Sequencer processes certain kinds of MIDI events. Regardless of which Sequencer methods you’ll invoke, the first step is to obtain a Sequencer device from the system and reserve it for your program’s use. Obtaining a Sequencer An application program doesn’t instantiate a Sequencer; after all, Sequencer is just an interface. Instead, like all devices in the Java Sound API’s MIDI package, a Sequencer is accessed through the static MidiSystem object. As previously mentioned inAccessing MIDI System Resources, the following MidiSystem method can be used to obtain the default Sequencer: 123static Sequencer getSequencer() The following code fragment obtains the default Sequencer, acquires any system resources it needs, and makes it operational: 123456789101112Sequencer sequencer;&#x2F;&#x2F; Get default sequencer.sequencer &#x3D; MidiSystem.getSequencer(); if (sequencer &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Error -- sequencer device is not supported. &#x2F;&#x2F; Inform user and return...&#125; else &#123; &#x2F;&#x2F; Acquire resources and make operational. sequencer.open();&#125; The invocation of open reserves the sequencer device for your program’s use. It doesn’t make much sense to imagine sharing a sequencer, because it can play only one sequence at a time. When you’re done using the sequencer, you can make it available to other programs by invoking close. Non-default sequencers can be obtained as described inAccessing MIDI System Resources. Loading a Sequence Having obtained a sequencer from the system and reserved it, you then need load the data that the sequencer should play. There are three typical ways of accomplishing this: Reading the sequence data from a MIDI file Recording it in real time by receiving MIDI messages from another device, such as a MIDI input port Building it programmatically “from scratch” by adding tracks to an empty sequence and adding MidiEvent objects to those tracks Recording and Saving Sequences and Editing a Sequence, respectively.) This first way actually encompasses two slightly different approaches. One approach is to feed MIDI file data to an InputStream that you then read directly to the sequencer by means of Sequencer.setSequence(InputStream). With this approach, you don’t explicitly create a Sequence object. In fact, the Sequencer implementation might not even create a Sequence behind the scenes, because some sequencers have a built-in mechanism for handling data directly from a file. The other approach is to create a Sequence explicitly. You’ll need to use this approach if you’re going to edit the sequence data before playing it. With this approach, you invoke MidiSystem&#39;s overloaded method getSequence. The method is able to get the sequence from an InputStream, a File, or a URL. The method returns a Sequence object that can then be loaded into a Sequencer for playback. Expanding on the previous code excerpt, here’s an example of obtaining a Sequence object from a File and loading it into our sequencer: 1234567891011try &#123; File myMidiFile &#x3D; new File(&quot;seq1.mid&quot;); &#x2F;&#x2F; Construct a Sequence object, and &#x2F;&#x2F; load it into my sequencer. Sequence mySeq &#x3D; MidiSystem.getSequence(myMidiFile); sequencer.setSequence(mySeq);&#125; catch (Exception e) &#123; &#x2F;&#x2F; Handle error and&#x2F;or return&#125; Like MidiSystem&#39;s getSequence method, setSequence may throw an InvalidMidiDataException&#226;&#128;&#148;and, in the case of the InputStream variant, an IOException&#226;&#128;&#148;if it runs into any trouble. Playing a Sequence Starting and stopping a Sequencer is accomplished using the following methods: 123void start() and 123void stop() The Sequencer.start method begins playback of the sequence. Note that playback starts at the current position in a sequence. Loading an existing sequence using the setSequence method, described above, initializes the sequencer’s current position to the very beginning of the sequence. The stop method stops the sequencer, but it does not automatically rewind the current Sequence. Starting a stopped Sequence without resetting the position simply resumes playback of the sequence from the current position. In this case, the stop method has served as a pause operation. However, there are various Sequencer methods for setting the current sequence position to an arbitrary value before playback is started. (We’ll discuss these methods below.) As mentioned earlier, a Sequencer typically has one or more Transmitter objects, through which it sends MidiMessages to a Receiver. It is through these Transmitters that a Sequencer plays the Sequence, by emitting appropriately timed MidiMessages that correspond to the MidiEvents contained in the current Sequence. Therefore, part of the setup procedure for playing back a Sequence is to invoke the setReceiver method on the Sequencer&#39;s Transmitter object, in effect wiring its output to the device that will make use of the played-back data. For more details on Transmitters and Receivers, refer back toTransmitting and Receiving MIDI Messages. Recording and Saving Sequences To capture MIDI data to a Sequence, and subsequently to a file, you need to perform some additional steps beyond those described above. The following outline shows the steps necessary to set up for recording to a Track in a Sequence: Use MidiSystem.getSequencer to get a new sequencer to use for recording, as above. Set up the “wiring” of the MIDI connections. The object that is transmitting the MIDI data to be recorded should be configured, through its setReceiver method, to send data to a Receiver associated with the recording Sequencer.Create a new `Sequence` object, which will store the recorded data. When you create the `Sequence` object, you must specify the global timing information for the sequence. For example: Sequence mySeq; try&#123; mySeq = new Sequence(Sequence.PPQ, 10); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; The constructor for `Sequence` takes as arguments a `divisionType` and a timing resolution. The `divisionType` argument specifies the units of the resolution argument. In this case, we've specified that the timing resolution of the `Sequence` we're creating will be 10 pulses per quarter note. An additional optional argument to the `Sequence` constructor is a number of tracks argument, which would cause the initial sequence to begin with the specified number of (initially empty) `Tracks`. Otherwise the `Sequence` will be created with no initial `Tracks`; they can be added later as needed. Create an empty Track in the Sequence, with Sequence.createTrack. This step is unnecessary if the Sequence was created with initial Tracks. Using Sequencer.setSequence, select our new Sequence to receive the recording. The setSequence method ties together an existing Sequence with the Sequencer, which is somewhat analogous to loading a tape onto a tape recorder. Invoke Sequencer.recordEnable for each Track to be recorded. If necessary, get a reference to the available Tracks in the Sequence by invoking Sequence.getTracks. Invoke startRecording on the Sequencer. When done recording, invoke Sequencer.stop or Sequencer.stopRecording. Save the recorded Sequence to a MIDI file with MidiSystem.write. The write method of MidiSystem takes a Sequence as one of its arguments, and will write that Sequence to a stream or file. Editing a Sequence Many application programs allow a sequence to be created by loading it from a file, and quite a few also allow a sequence to be created by capturing it from live MIDI input (that is, recording). Some programs, however, will need to create MIDI sequences from scratch, whether programmatically or in response to user input. Full-featured sequencer programs permit the user to manually construct new sequences, as well as to edit existing ones. These data-editing operations are achieved in the Java Sound API not by Sequencer methods, but by methods of the data objects themselves: Sequence, Track, and MidiEvent. You can create an empty sequence using one of the Sequence constructors, and then add tracks to it by invoking the following Sequence method: 123Track createTrack() If your program allows the user to edit sequences, you’ll need this Sequence method to remove tracks: 123boolean deleteTrack(Track track) Once the sequence contains tracks, you can modify the contents of the tracks by invoking methods of the Track class. The MidiEvents contained in the Track are stored as a java.util.Vector in the Track object, and Track provides a set of methods for accessing, adding, and removing the events in the list. The methods add and remove are fairly self-explanatory, adding or removing a specified MidiEvent from a Track. A get method is provided, which takes an index into the Track&#39;s event list and returns the MidiEvent stored there. In addition, there are size and tick methods, which respectively return the number of MidiEvents in the track, and the track’s duration, expressed as a total number of Ticks. To create a new event before adding it to the track, you’ll of course use the MidiEvent constructor. To specify or modify the MIDI message embedded in the event, you can invoke the setMessage method of the appropriate MidiMessage subclass (ShortMessage, SysexMessage, or MetaMessage). To modify the time that the event should occur, invoke MidiEvent.setTick. In combination, these low-level methods provide the basis for the editing functionality needed by a full-featured sequencer program.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Introduction to Sequencers","date":"2020-12-05T17:47:52.989Z","path":"wiki/2021-03-03-Introduction to Sequencers/","text":"Introduction to Sequencers In the world of MIDI, a sequencer is any hardware or software device that can precisely play or record a sequence of time-stamped MIDI messages. Similarly, in the Java Sound API, theSequencer abstract interface defines the properties of an object that can play and record sequences ofMidiEvent objects. A Sequencer typically loads these MidiEvent sequences from a standard MIDI file or saves them to such a file. Sequences can also be edited. The following pages explain how to use Sequencer objects, along with related classes and interfaces, to accomplish such tasks. To develop an intuitive understanding of what a Sequencer is, think of it by analogy with a tape recorder, which a sequencer resembles in many respects. Whereas a tape recorder plays audio, a sequencer plays MIDI data. A sequence is a multi-track, linear, time-ordered recording of MIDI musical data, which a sequencer can play at various speeds, rewind, shuttle to particular points, record into, or copy to a file for storage. Transmitting and Receiving MIDI Messages explained that devices typically have Receiver objects, Transmitter objects, or both. To play music, a device generally receives MidiMessages through a Receiver, which in turn has usually received them from a Transmitter that belongs to a Sequencer. The device that owns this Receiver might be a Synthesizer, which will generate audio directly, or it might be a MIDI output port, which transmits MIDI data through a physical cable to some external piece of equipment. Similarly, to record music, a series of time-stamped MidiMessages are generally sent to a Receiver owned by a Sequencer, which places them in a Sequence object. Typically the object sending the messages is a Transmitter associated with a hardware input port, and the port relays MIDI data that it gets from an external instrument. However, the device responsible for sending the messages might instead be some other Sequencer, or any other device that has a Transmitter. Furthermore, as previously described, a program can send messages without using any Transmitter at all. A Sequencer itself has both Receivers and Transmitters. When it’s recording, it actually obtains MidiMessages via its Receivers. During playback, it uses its Transmitters to send MidiMessages that are stored in the Sequence that it has recorded (or loaded from a file). One way to think of the role of a Sequencer in the Java Sound API is as an aggregator and “de-aggregator” of MidiMessages. A series of separate MidiMessages, each of which is independent, is sent to the Sequencer along with its own time stamp that marks the timing of a musical event. These MidiMessages are encapsulated in MidiEvent objects and collected in Sequence objects through the action of the Sequencer.record method. A Sequence is a data structure containing aggregates of MidiEvents, and it usually represents a series of musical notes, often an entire song or composition. On playback, the Sequencer again extracts the MidiMessages from the MidiEvent objects in the Sequence and then transmits them to one or more devices that will either render them into sound, save them, modify them, or pass them on to some other device. Some sequencers might have neither transmitters nor receivers. For example, they might create MidiEvents from scratch as a result of keyboard or mouse events, instead of receiving MidiMessages through Receivers. Similarly, they might play music by communicating directly with an internal synthesizer (which could actually be the same object as the sequencer) instead of sending MidiMessages to a Receiver associated with a separate object. However, the rest of this discussion assumes the normal case of a sequencer that uses Receivers and Transmitters. When to Use a Sequencer It’s possible for an application program to send MIDI messages directly to a device, without using a sequencer, as was described inTransmitting and Receiving MIDI Messages. The program simply invokes the Receiver.send method each time it wants to send a message. This is a straightforward approach that’s useful when the program itself creates the messages in real time. For example, consider a program that lets the user play notes by clicking on an onscreen piano keyboard. When the program gets a mouse-down event, it immediately sends the appropriate Note On message to the synthesizer. As previously mentioned, the program can include a time stamp with each MIDI message it sends to the device’s receiver. However, such time stamps are used only for fine-tuning the timing, to correct for processing latency. The caller can’t generally set arbitrary time stamps; the time value passed to Receiver.send must be close to the present time, or the receiving device might not be able to schedule the message correctly. This means that if an application program wanted to create a queue of MIDI messages for an entire piece of music ahead of time (instead of creating each message in response to a real-time event), it would have to be very careful to schedule each invocation of Receiver.send for nearly the right time. Fortunately, most application programs don’t have to be concerned with such scheduling. Instead of invoking Receiver.send itself, a program can use a Sequencer object to manage the queue of MIDI messages for it. The sequencer takes care of scheduling and sending the messages&#226;&#128;&#148;in other words, playing the music with the correct timing. Generally, it’s advantageous to use a sequencer whenever you need to convert a non-real-time series of MIDI messages to a real-time series (as in playback), or vice versa (as in recording). Sequencers are most commonly used for playing data from MIDI files and for recording data from a MIDI input port. Understanding Sequence Data Before examining the Sequencer API, it helps to understand the kind of data that’s stored in a sequence. Sequences and Tracks In the Java Sound API, sequencers closely follow the Standard MIDI Files specification in the way that they organize recorded MIDI data. As mentioned above, a Sequence is an aggregation of MidiEvents, organized in time. But there is more structure to a Sequence than just a linear series of MidiEvents: a Sequence actually contains global timing information plus a collection of Tracks, and it is the Tracks themselves that hold the MidiEvent data. So the data played by a sequencer consists of a three-level hierarchy of objects: Sequencer, Track, and MidiEvent. In the conventional use of these objects, the Sequence represents a complete musical composition or section of a composition, with each Track corresponding to a voice or player in the ensemble. In this model, all the data on a particular Track would also therefore be encoded into a particular MIDI channel reserved for that voice or player. This way of organizing data is convenient for purposes of editing sequences, but note that this is just a conventional way to use Tracks. There is nothing in the definition of the Track class that keeps it from containing a mix of MidiEvents on different MIDI channels. For example, an entire multi-channel MIDI composition can be mixed and recorded onto one Track. Also, standard MIDI files of Type 0 (as opposed to Type 1 and Type 2) contain by definition only one track; so a Sequence that’s read from such a file will necessarily have a single Track object. MidiEvents and Ticks As discussed inOverview of the MIDI Package, the Java Sound API includes MidiMessage objects that correspond to the raw two- or three-byte sequences that make up most standard MIDI messages. A MidiEvent is simply a packaging of a MidiMessage along with an accompanying timing value that specifies when the event occurs. (We might then say that a sequence really consists of a four- or five-level hierarchy of data, rather than three-level, because the ostensible lowest level, MidiEvent, actually contains a lower-level MidiMessage, and likewise the MidiMessage object contains an array of bytes that comprises a standard MIDI message.) In the Java Sound API, there are two different ways in which MidiMessages can be associated with timing values. One is the way mentioned above under “When to Use a Sequencer.” This technique was described in detail underSending a Message to a Receiver without Using a Transmitter andUnderstanding Time Stamps. There, we saw that the send method of Receiver takes a MidiMessage argument and a time-stamp argument. That kind of time stamp can only be expressed in microseconds. The other way in which a MidiMessage can have its timing specified is by being encapsulated in a MidiEvent. In this case, the timing is expressed in slightly more abstract units called ticks. What is the duration of a tick? It can vary between sequences (but not within a sequence), and its value is stored in the header of a standard MIDI file. The size of a tick is given in one of two types of units: Pulses (ticks) per quarter note, abbreviated as PPQ Ticks per frame, also known as SMPTE time code (a standard adopted by the Society of Motion Picture and Television Engineers) If the unit is PPQ, the size of a tick is expressed as a fraction of a quarter note, which is a relative, not absolute, time value. A quarter note is a musical duration value that often corresponds to one beat of the music (a quarter of a measure in 4/4 time). The duration of a quarter note is dependent on the tempo, which can vary during the course of the music if the sequence contains tempo-change events. So if the sequence’s timing increments (ticks) occur, say 96 times per quarter note, each event’s timing value measures that event’s position in musical terms, not as an absolute time value. On the other hand, in the case of SMPTE, the units measure absolute time, and the notion of tempo is inapplicable. There are actually four different SMPTE conventions available, which refer to the number of motion-picture frames per second. The number of frames per second can be 24, 25, 29.97, or 30. With SMPTE time code, the size of a tick is expressed as a fraction of a frame. In the Java Sound API, you can invoke Sequence.getDivisionType to learn which type of unit&#226;&#128;&#148;namely, PPQ or one of the SMPTE units&#226;&#128;&#148;is used in a particular sequence. You can then calculate the size of a tick after invoking Sequence.getResolution. The latter method returns the number of ticks per quarter note if the division type is PPQ, or per SMPTE frame if the division type is one of the SMPTE conventions. You can get the size of a tick using this formula in the case of PPQ: 12345ticksPerSecond &#x3D; resolution * (currentTempoInBeatsPerMinute &#x2F; 60.0);tickSize &#x3D; 1.0 &#x2F; ticksPerSecond; and this formula in the case of SMPTE: 12345678910framesPerSecond &#x3D; (divisionType &#x3D;&#x3D; Sequence.SMPTE_24 ? 24 : (divisionType &#x3D;&#x3D; Sequence.SMPTE_25 ? 25 : (divisionType &#x3D;&#x3D; Sequence.SMPTE_30 ? 30 : (divisionType &#x3D;&#x3D; Sequence.SMPTE_30DROP ?&lt;br &#x2F;&gt; 29.97))));ticksPerSecond &#x3D; resolution * framesPerSecond;tickSize &#x3D; 1.0 &#x2F; ticksPerSecond; The Java Sound API’s definition of timing in a sequence mirrors that of the Standard MIDI Files specification. However, there’s one important difference. The tick values contained in MidiEvents measure cumulative time, rather than delta time. In a standard MIDI file, each event’s timing information measures the amount of time elapsed since the onset of the previous event in the sequence. This is called delta time. But in the Java Sound API, the ticks aren’t delta values; they’re the previous event’s time value plus the delta value. In other words, in the Java Sound API the timing value for each event is always greater than that of the previous event in the sequence (or equal, if the events are supposed to be simultaneous). Each event’s timing value measures the time elapsed since the beginning of the sequence. To summarize, the Java Sound API expresses timing information in either MIDI ticks or microseconds. MidiEvents store timing information in terms of MIDI ticks. The duration of a tick can be calculated from the Sequence&#39;s global timing information and, if the sequence uses tempo-based timing, the current musical tempo. The time stamp associated with a MidiMessage sent to a Receiver, on the other hand, is always expressed in microseconds. One goal of this design is to avoid conflicting notions of time. It’s the job of a Sequencer to interpret the time units in its MidiEvents, which might have PPQ units, and translate these into absolute time in microseconds, taking the current tempo into account. The sequencer must also express the microseconds relative to the time when the device receiving the message was opened. Note that a sequencer can have multiple transmitters, each delivering messages to a different receiver that might be associated with a completely different device. You can see, then, that the sequencer has to be able to perform multiple translations at the same time, making sure that each device receives time stamps appropriate for its notion of time. To make matters more complicated, different devices might update their notions of time based on different sources (such as the operating system’s clock, or a clock maintained by a sound card). This means that their timings can drift relative to the sequencer’s. To keep in synchronization with the sequencer, some devices permit themselves to be “slaves” to the sequencer’s notion of time. Setting masters and slaves is discussed later underMidiEvent.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Transmitting and Receiving MIDI Messages","date":"2020-12-05T17:47:50.839Z","path":"wiki/2021-03-03-Transmitting and Receiving MIDI Messages/","text":"Transmitting and Receiving MIDI Messages Understanding Devices, Transmitters, and ReceiversThe Java Sound API specifies a message-routing architecture for MIDI data that’s flexible and easy to use, once you understand how it works. The system is based on a module-connection design: distinct modules, each of which performs a specific task, can be interconnected (networked), enabling data to flow from one module to another. The base module in the Java Sound API’s messaging system is theMidiDevice interface. MidiDevices include sequencers (which record, play, load, and edit sequences of time-stamped MIDI messages), synthesizers (which generate sounds when triggered by MIDI messages), and MIDI input and output ports, through which data comes from and goes to external MIDI devices. The functionality typically required of MIDI ports is described by the base MidiDevice interface. TheSequencer andSynthesizer interfaces extend the MidiDevice interface to describe the additional functionality characteristic of MIDI sequencers and synthesizers, respectively. Concrete classes that function as sequencers or synthesizers should implement these interfaces. A MidiDevice typically owns one or more ancillary objects that implement the Receiver or Transmitter interfaces. These interfaces represent the “plugs” or “portals” that connect devices together, permitting data to flow into and out of them. By connecting a Transmitter of one MidiDevice to a Receiver of another, you can create a network of modules in which data flows from one to another. The MidiDevice interface includes methods for determining how many transmitter and receiver objects the device can support concurrently, and other methods for accessing those objects. A MIDI output port normally has at least one Receiver through which the outgoing messages may be received; similarly, a synthesizer normally responds to messages sent to its Receiver or Receivers. A MIDI input port normally has at least one Transmitter, which propagates the incoming messages. A full-featured sequencer supports both Receivers, which receive messages during recording, and Transmitters, which send messages during playback. The Transmitter interface includes methods for setting and querying the receivers to which the transmitter sends its MidiMessages. Setting the receiver establishes the connection between the two. The Receiver interface contains a method that sends a MidiMessage to the receiver. Typically, this method is invoked by a Transmitter. Both the Transmitter and Receiver interfaces include a close method that frees up a previously connected transmitter or receiver, making it available for a different connection. We’ll now examine how to use transmitters and receivers. Before getting to the typical case of connecting two devices (such as hooking a sequencer to a synthesizer), we’ll examine the simpler case where you send a MIDI message directly from your application program to a device. Studying this simple scenario should make it easier to understand how the Java Sound API arranges for sending MIDI messages between two devices. Sending a Message to a Receiver without Using a Transmitter Let’s say you want to create a MIDI message from scratch and then send it to some receiver. You can create a new, blank ShortMessage and then fill it with MIDI data using the following ShortMessage method: 1234void setMessage(int command, int channel, int data1, int data2) Once you have a message ready to send, you can send it to a Receiver object, using this Receiver method: 123void send(MidiMessage message, long timeStamp) The time-stamp argument will be explained momentarily. For now, we’ll just mention that its value can be set to -1 if you don’t care about specifying a precise time. In this case, the device receiving the message will try to respond to the message as soon as possible. An application program can obtain a receiver for a MidiDevice by invoking the device’s getReceiver method. If the device can’t provide a receiver to the program (typically because all the device’s receivers are already in use), a MidiUnavailableException is thrown. Otherwise, the receiver returned from this method is available for immediate use by the program. When the program has finished using the receiver, it should call the receiver’s close method. If the program attempts to invoke methods on a receiver after calling close, an IllegalStateException may be thrown. As a concrete simple example of sending a message without using a transmitter, let’s send a Note On message to the default receiver, which is typically associated with a device such as the MIDI output port or a synthesizer. We do this by creating a suitable ShortMessage and passing it as an argument to Receiver&#39;s send method: 123456789ShortMessage myMsg &#x3D; new ShortMessage();&#x2F;&#x2F; Start playing the note Middle C (60), &#x2F;&#x2F; moderately loud (velocity &#x3D; 93).myMsg.setMessage(ShortMessage.NOTE_ON, 0, 60, 93);long timeStamp &#x3D; -1;Receiver rcvr &#x3D; MidiSystem.getReceiver();rcvr.send(myMsg, timeStamp); This code uses a static integer field of ShortMessage, namely, NOTE_ON, for use as the MIDI message’s status byte. The other parts of the MIDI message are given explicit numeric values as arguments to the setMessage method. The zero indicates that the note is to be played using MIDI channel number 1; the 60 indicates the note Middle C; and the 93 is an arbitrary key-down velocity value, which typically indicates that the synthesizer that eventually plays the note should play it somewhat loudly. (The MIDI specification leaves the exact interpretation of velocity up to the synthesizer’s implementation of its current instrument.) This MIDI message is then sent to the receiver with a time stamp of -1. We now need to examine exactly what the time stamp parameter means, which is the subject of the next section. Understanding Time Stamps As you already know, the MIDI specification has different parts. One part describes MIDI “wire” protocol (messages sent between devices in real time), and another part describes Standard MIDI Files (messages stored as events in “sequences”). In the latter part of the specification, each event stored in a standard MIDI file is tagged with a timing value that indicates when that event should be played. By contrast, messages in MIDI wire protocol are always supposed to be processed immediately, as soon as they’re received by a device, so they have no accompanying timing values. The Java Sound API adds an additional twist. It comes as no surprise that timing values are present in the MidiEvent objects that are stored in sequences (as might be read from a MIDI file), just as in the Standard MIDI Files specification. But in the Java Sound API, even the messages sent between devices&#226;&#128;&#148;in other words, the messages that correspond to MIDI wire protocol&#226;&#128;&#148;can be given timing values, known as time stamps. It is these time stamps that concern us here. Time Stamps on Messages Sent to Devices The time stamp that can optionally accompany messages sent between devices in the Java Sound API is quite different from the timing values in a standard MIDI file. The timing values in a MIDI file are often based on musical concepts such as beats and tempo, and each event’s timing measures the time elapsed since the previous event. In contrast, the time stamp on a message sent to a device’s Receiver object always measures absolute time in microseconds. Specifically, it measures the number of microseconds elapsed since the device that owns the receiver was opened. This kind of time stamp is designed to help compensate for latencies introduced by the operating system or by the application program. It’s important to realize that these time stamps are used for minor adjustments to timing, not to implement complex queues that can schedule events at completely arbitrary times (as MidiEvent timing values do). The time stamp on a message sent to a device (through a Receiver) can provide precise timing information to the device. The device might use this information when it processes the message. For example, it might adjust the event’s timing by a few milliseconds to match the information in the time stamp. On the other hand, not all devices support time stamps, so the device might completely ignore the message’s time stamp. Even if a device supports time stamps, it might not schedule the event for exactly the time that you requested. You can’t expect to send a message whose time stamp is very far in the future and have the device handle it as you intended, and you certainly can’t expect a device to correctly schedule a message whose time stamp is in the past! It’s up to the device to decide how to handle time stamps that are too far off in the future or are in the past. The sender doesn’t know what the device considers to be too far off, or whether the device had any problem with the time stamp. This ignorance mimics the behavior of external MIDI hardware devices, which send messages without ever knowing whether they were received correctly. (MIDI wire protocol is unidirectional.) Some devices send time-stamped messages (via a Transmitter). For example, the messages sent by a MIDI input port might be stamped with the time the incoming message arrived at the port. On some systems, the event-handling mechanisms cause a certain amount of timing precision to be lost during subsequent processing of the message. The message’s time stamp allows the original timing information to be preserved. To learn whether a device supports time stamps, invoke the following method of MidiDevice: 123long getMicrosecondPosition() This method returns -1 if the device ignores time stamps. Otherwise, it returns the device’s current notion of time, which you as the sender can use as an offset when determining the time stamps for messages you subsequently send. For example, if you want to send a message with a time stamp for five milliseconds in the future, you can get the device’s current position in microseconds, add 5000 microseconds, and use that as the time stamp. Keep in mind that the MidiDevice&#39;s notion of time always places time zero at the time the device was opened. Now, with all that explanation of time stamps as a background, let’s return to the send method of Receiver: 123void send(MidiMessage message, long timeStamp) The timeStamp argument is expressed in microseconds, according to the receiving device’s notion of time. If the device doesn’t support time stamps, it simply ignores the timeStamp argument. You aren’t required to time-stamp the messages you send to a receiver. You can use -1 for the timeStamp argument to indicate that you don’t care about adjusting the exact timing; you’re just leaving it up to the receiving device to process the message as soon as it can. However, it’s not advisable to send -1 with some messages and explicit time stamps with other messages sent to the same receiver. Doing so is likely to cause irregularities in the resultant timing. Connecting Transmitters to Receivers We’ve seen how you can send a MIDI message directly to a receiver, without using a transmitter. Now let’s look at the more common case, where you aren’t creating MIDI messages from scratch, but are simply connecting devices together so that one of them can send MIDI messages to the other. Connecting to a Single Device The specific case we’ll take as our first example is connecting a sequencer to a synthesizer. After this connection is made, starting the sequencer running will cause the synthesizer to generate audio from the events in the sequencer’s current sequence. For now, we’ll ignore the process of loading a sequence from a MIDI file into the sequencer. Also, we won’t go into the mechanism of playing the sequence. Loading and playing sequences is discussed in detail inPlaying, Recording, and Editing MIDI Sequences. Loading instruments into the synthesizer is discussed inSynthesizing Sound. For now, all we’re interested in is how to make the connection between the sequencer and the synthesizer. This will serve as an illustration of the more general process of connecting one device’s transmitter to another device’s receiver. For simplicity, we’ll use the default sequencer and the default synthesizer. 123456789101112131415Sequencer seq;Transmitter seqTrans;Synthesizer synth;Receiver synthRcvr;try &#123; seq &#x3D; MidiSystem.getSequencer(); seqTrans &#x3D; seq.getTransmitter(); synth &#x3D; MidiSystem.getSynthesizer(); synthRcvr &#x3D; synth.getReceiver(); seqTrans.setReceiver(synthRcvr); &#125; catch (MidiUnavailableException e) &#123; &#x2F;&#x2F; handle or throw exception&#125; An implementation might actually have a single object that serves as both the default sequencer and the default synthesizer. In other words, the implementation might use a class that implements both the Sequencer interface and the Synthesizer interface. In that case, it probably wouldn’t be necessary to make the explicit connection that we did in the code above. For portability, though, it’s safer not to assume such a configuration. If desired, you can test for this condition, of course: 123if (seq instanceof Synthesizer) although the explicit connection above should work in any case. Connecting to More than One Device The previous code example illustrated a one-to-one connection between a transmitter and a receiver. But, what if you need to send the same MIDI message to multiple receivers? For example, suppose you want to capture MIDI data from an external device to drive the internal synthesizer while simultaneously recording the data to a sequence. This form of connection, sometimes referred to as “fan out” or as a “splitter,” is straightforward. The following statements show how to create a fan-out connection, through which the MIDI messages arriving at the MIDI input port are sent to both a Synthesizer object and a Sequencer object. We assume you’ve already obtained and opened the three devices: the input port, sequencer, and synthesizer. (To obtain the input port, you’ll need to iterate over all the items returned by MidiSystem.getMidiDeviceInfo.) 12345678910111213141516171819Synthesizer synth;Sequencer seq;MidiDevice inputPort;&#x2F;&#x2F; [obtain and open the three devices...]Transmitter inPortTrans1, inPortTrans2;Receiver synthRcvr;Receiver seqRcvr;try &#123; inPortTrans1 &#x3D; inputPort.getTransmitter(); synthRcvr &#x3D; synth.getReceiver(); inPortTrans1.setReceiver(synthRcvr); inPortTrans2 &#x3D; inputPort.getTransmitter(); seqRcvr &#x3D; seq.getReceiver(); inPortTrans2.setReceiver(seqRcvr);&#125; catch (MidiUnavailableException e) &#123; &#x2F;&#x2F; handle or throw exception&#125; This code introduces a dual invocation of the MidiDevice.getTransmitter method, assigning the results to inPortTrans1 and inPortTrans2. As mentioned earlier, a device can own multiple transmitters and receivers. Each time MidiDevice.getTransmitter() is invoked for a given device, another transmitter is returned, until no more are available, at which time an exception will be thrown. To learn how many transmitters and receivers a device supports, you can use the following MidiDevice method: 1234int getMaxTransmitters()int &#96;getMaxReceivers&#96;() These methods return the total number owned by the device, not the number currently available. A transmitter can transmit MIDI messages to only one receiver at a time. (Every time you call Transmitter&#39;s setReceiver method, the existing Receiver, if any, is replaced by the newly specified one. You can tell whether the transmitter currently has a receiver by invoking Transmitter.getReceiver.) However, if a device has multiple transmitters, it can send data to more than one device at a time, by connecting each transmitter to a different receiver, as we saw in the case of the input port above. Similarly, a device can use its multiple receivers to receive from more than one device at a time. The multiple-receiver code that’s required is straightforward, being directly analogous to the multiple-transmitter code above. It’s also possible for a single receiver to receive messages from more than one transmitter at a time. Closing Connections Once you’re done with a connection, you can free up its resources by invoking the close method for each transmitter and receiver that you’ve obtained. The Transmitter and Receiver interfaces each have a close method. Note that invoking Transmitter.setReceiver doesn’t close the transmitter’s current receiver. The receiver is left open, and it can still receive messages from any other transmitter that’s connected to it. If you’re also done with the devices, you can similarly make them available to other application programs by invoking MidiDevice.close(). Closing a device automatically closes all its transmitters and receivers.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Accessing MIDI System Resources","date":"2020-12-05T17:47:48.666Z","path":"wiki/2021-03-03-Accessing MIDI System Resources/","text":"Accessing MIDI System ResourcesThe Java Sound API offers a flexible model for MIDI system configuration, just as it does for configuration of the sampled-audio system. An implementation of the Java Sound API can itself provide different sorts of MIDI devices, and additional ones can be supplied by service providers and installed by users. You can write your program in such a way that it makes few assumptions about which specific MIDI devices are installed on the computer. Instead, the program can take advantage of the MIDI system’s defaults, or it can allow the user to select from whatever devices happen to be available. This section shows how your program can learn what MIDI resources have been installed, and how to get access to the desired ones. After you’ve accessed and opened the devices, you can connect them to each other, as discussed later inTransmitting and Receiving MIDI Messages. The MidiSystem Class The role of theMidiSystem class in the Java Sound API’s MIDI package is directly analogous to the role ofAudioSystem in the sampled-audio package. MidiSystem acts as a clearinghouse for accessing the installed MIDI resources. You can query the MidiSystem to learn what sorts of devices are installed, and then you can iterate over the available devices and obtain access to the desired ones. For example, an application program might start out by asking the MidiSystem what synthesizers are available, and then display a list of them, from which the user can select one. A simpler application program might just use the system’s default synthesizer. The MidiSystem class also provides methods for translating between MIDI files and Sequences. It can report the file format of a MIDI file and can write files of different types. An application program can obtain the following resources from the MidiSystem: Sequencers Synthesizers Transmitters (such as those associated with MIDI input ports) Receivers (such as those associated with MIDI output ports) Data from standard MIDI files Data from soundbank files This page focuses on the first four of these types of resource. The others are discussed later in this tutorial. Obtaining Default Devices A typical MIDI application program that uses the Java Sound API begins by obtaining the devices it needs, which can consist of one or more sequencers, synthesizers, input ports, or output ports. There is a default synthesizer device, a default sequencer device, a default transmitting device, and a default receiving device. The latter two devices normally represent the MIDI input and output ports, respectively, if there are any available on the system. (It’s easy to get confused about the directionality here. Think of the ports’ transmission or reception in relation to the software, not in relation to any external physical devices connected to the physical ports. A MIDI input port transmits data from an external device to a Java Sound API Receiver, and likewise a MIDI output port receives data from a software object and relays the data to an external device.) A simple application program might just use the default instead of exploring all the installed devices. The MidiSystem class includes the following methods for retrieving default resources: 123456static Sequencer getSequencer()static Synthesizer getSynthesizer()static Receiver getReceiver()static Transmitter getTransmitter() The first two of these methods obtain the system’s default sequencing and synthesis resources, which either represent physical devices or are implemented wholly in software. The getReceiver method obtains a Receiver object that takes MIDI messages sent to it and relays them to the default receiving device. Similarly, the getTransmitter method obtains a Transmitter object that can send MIDI messages to some receiver on behalf of the default transmitting device. Learning What Devices Are Installed Instead of using the default devices, a more thorough approach is to select the desired devices from the full set of devices that are installed on the system. An application program can select the desired devices programmatically, or it can display a list of available devices and let the user select which ones to use. The MidiSystem class provides a method for learning which devices are installed, and a corresponding method to obtain a device of a given type. Here is the method for learning about the installed devices: 123tatic MidiDevice.Info[] getMidiDeviceInfo() As you can see, it returns an array of information objects. Each of these returned MidiDevice.Info objects identifies one type of sequencer, synthesizer, port, or other device that is installed. (Usually a system has at most one instance of a given type. For example, a given model of synthesizer from a certain vendor will be installed only once.) The MidiDevice.Info includes the following strings to describe the device: Name Version number Vendor (the company that created the device) A description of the device You can display these strings in your user interface to let the user select from the list of devices. However, to use the strings programmatically to select a device (as opposed to displaying the strings to the user), you need to know in advance what they might be. The company that provides each device should include this information in its documentation. An application program that requires or prefers a particular device can use this information to locate that device. This approach has the drawback of limiting the program to device implementations that it knows about in advance. Another, more general, approach is to go ahead and iterate over the MidiDevice.Info objects, obtaining each corresponding device, and determining programmatically whether it’s suitable to use (or at least suitable to include in a list from which the user can choose). The next section describes how to do this. Obtaining a Desired DeviceOnce an appropriate device’s info object is found, the application program invokes the following MidiSystem method to obtain the corresponding device itself: 123static MidiDevice getMidiDevice(MidiDevice.Info info) You can use this method if you’ve already found the info object describing the device you need. However, if you can’t interpret the info objects returned by getMidiDeviceInfo to determine which device you need, and if you don’t want to display information about all the devices to the user, you might be able to do the following instead: Iterate over all the MidiDevice.Info objects returned by getMidiDeviceInfo, get the corresponding devices using the method above, and test each device to see whether it’s suitable. In other words, you can query each device for its class and its capabilities before including it in the list that you display to the user, or as a way to decide upon a device programmatically without involving the user. For example, if your program needs a synthesizer, you can obtain each of the installed devices, see which are instances of classes that implement the Synthesizer interface, and then display them in a list from which the user can choose one, as follows: 1234567891011121314151617&#x2F;&#x2F; Obtain information about all the installed synthesizers.Vector synthInfos;MidiDevice device;MidiDevice.Info[] infos &#x3D; MidiSystem.getMidiDeviceInfo();for (int i &#x3D; 0; i &lt; infos.length; i++) &#123; try &#123; device &#x3D; MidiSystem.getMidiDevice(infos[i]); &#125; catch (MidiUnavailableException e) &#123; &#x2F;&#x2F; Handle or throw exception... &#125; if (device instanceof Synthesizer) &#123; synthInfos.add(infos[i]); &#125;&#125;&#x2F;&#x2F; Now, display strings from synthInfos list in GUI. As another example, you might choose a device programmatically, without involving the user. Let’s suppose you want to obtain the synthesizer that can play the most notes simultaneously. You iterate over all the MidiDevice.Info objects, as above, but after determining that a device is a synthesizer, you query its capabilities by invoking the getMaxPolyphony method of Synthesizer. You reserve the synthesizer that has the greatest polyphony, as described in the next section. Even though you’re not asking the user to choose a synthesizer, you might still display strings from the chosen MidiDevice.Info object, just for the user’s information. Opening Devices The previous section showed how to get an installed device. However, a device might be installed but unavailable. For example, another application program might have exclusive use of it. To actually reserve a device for your program, you need to use the MidiDevice method open: 123456789if (!(device.isOpen())) &#123; try &#123; device.open(); &#125; catch (MidiUnavailableException e) &#123; &#x2F;&#x2F; Handle or throw exception... &#125;&#125; Once you’ve accessed a device and reserved it by opening it, you’ll probably want to connect it to one or more other devices to let MIDI data flow between them. This procedure is described in later inTransmitting and Receiving MIDI Messages. When done with a device, you release it for other programs’ use by invoking the close method of MidiDevice.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Overview of the MIDI Package","date":"2020-12-05T17:47:46.515Z","path":"wiki/2021-03-03-Overview of the MIDI Package/","text":"Overview of the MIDI Package Theintroduction gave a glimpse into the MIDI capabilities of the Java Sound API. The discussion that follows provides a more detailed introduction to the Java Sound API’s MIDI architecture, which is accessed through the javax.sound.midi package. Some basic features of MIDI itself are explained, as a refresher or introduction, to place the Java Sound API’s MIDI features in context. It then goes on to discuss the Java Sound API’s approach to MIDI, as a preparation for the programming tasks that are explained in subsequent sections. The following discussion of the MIDI API is divided into two main areas: data and devices. A MIDI Refresher: Wires and Files The Musical Instrument Digital Interface (MIDI) standard defines a communication protocol for electronic music devices, such as electronic keyboard instruments and personal computers. MIDI data can be transmitted over special cables during a live performance, and can also be stored in a standard type of file for later playback or editing. This section reviews some MIDI basics, without reference to the Java Sound API. The discussion is intended as a refresher for readers acquainted with MIDI, and as a brief introduction for those who are not, to provide background for the subsequent discussion of the Java Sound API’s MIDI package. If you have a thorough understanding of MIDI, you can safely skip this section. Before writing substantial MIDI applications, programmers who are unfamiliar with MIDI will probably need a fuller description of MIDI than can be included in this tutorial. See the Complete MIDI 1.0 Detailed Specification, which is available only in hard copy fromhttp://www.midi.org (although you might find paraphrased or summarized versions on the Web). MIDI is both a hardware specification and a software specification. To understand MIDI’s design, it helps to understand its history. MIDI was originally designed for passing musical events, such as key depressions, between electronic keyboard instruments such as synthesizers. Hardware devices known as sequencers stored sequences of notes that could control a synthesizer, allowing musical performances to be recorded and subsequently played back. Later, hardware interfaces were developed that connected MIDI instruments to a computer’s serial port, allowing sequencers to be implemented in software. More recently, computer sound cards have incorporated hardware for MIDI I/O and for synthesizing musical sound. Today, many users of MIDI deal only with sound cards, never connecting to external MIDI devices. CPUs have become fast enough that synthesizers, too, can be implemented in software. A sound card is needed only for audio I/O and, in some applications, for communicating with external MIDI devices. The brief hardware portion of the MIDI specification prescribes the pinouts for MIDI cables and the jacks into which these cables are plugged. This portion need not concern us. Because devices that originally required hardware, such as sequencers and synthesizers, are now implementable in software, perhaps the only reason for most programmers to know anything about MIDI hardware devices is simply to understand the metaphors in MIDI. However, external MIDI hardware devices are still essential for some important music applications, and so the Java Sound API supports input and output of MIDI data. The software portion of the MIDI specification is extensive. This portion concerns the structure of MIDI data and how devices such as synthesizers should respond to that data. It is important to understand that MIDI data can be streamed or sequenced. This duality reflects two different parts of the Complete MIDI 1.0 Detailed Specification: MIDI 1.0 Standard MIDI Files We’ll explain what’s meant by streaming and sequencing by examining the purpose of each of these two parts of the MIDI specification. Streaming Data in the MIDI Wire Protocol The first of these two parts of the MIDI specification describes what is known informally as “MIDI wire protocol.” MIDI wire protocol, which is the original MIDI protocol, is based on the assumption that the MIDI data is being sent over a MIDI cable (the “wire”). The cable transmits digital data from one MIDI device to another. Each of the MIDI devices might be a musical instrument or a similar device, or it might be a general-purpose computer equipped with a MIDI-capable sound card or a MIDI-to-serial-port interface. MIDI data, as defined by MIDI wire protocol, is organized into messages. The different kinds of message are distinguished by the first byte in the message, known as the status byte. (Status bytes are the only bytes that have the highest-order bit set to 1.) The bytes that follow the status byte in a message are known as data bytes. Certain MIDI messages, known as channel messages, have a status byte that contains four bits to specify the kind of channel message and another four bits to specify the channel number. There are therefore 16 MIDI channels; devices that receive MIDI messages can be set to respond to channel messages on all or only one of these virtual channels. Often each MIDI channel (which shouldn’t be confused with a channel of audio) is used to send the notes for a different instrument. As an example, two common channel messages are Note On and Note Off, which start a note sounding and then stop it, respectively. These two messages each take two data bytes: the first specifies the note’s pitch and the second its “velocity” (how fast the key is depressed or released, assuming a keyboard instrument is playing the note). MIDI wire protocol defines a streaming model for MIDI data. A central feature of this protocol is that the bytes of MIDI data are delivered in real time&#226;&#128;&#148;in other words, they are streamed. The data itself contains no timing information; each event is processed as it’s received, and it’s assumed that it arrives at the correct time. That model is fine if the notes are being generated by a live musician, but it’s insufficient if you want to store the notes for later playback, or if you want to compose them out of real time. This limitation is understandable when you realize that MIDI was originally designed for musical performance, as a way for a keyboard musician to control more than one synthesizer, back in the days before many musicians used computers. (The first version of the specification was released in 1984.) Sequenced Data in Standard MIDI Files The Standard MIDI Files part of the MIDI specification addresses the timing limitation in MIDI wire protocol. A standard MIDI file is a digital file that contains MIDI events. An event is simply a MIDI message, as defined in the MIDI wire protocol, but with an additional piece of information that specifies the event’s timing. (There are also some events that don’t correspond to MIDI wire protocol messages, as we’ll see in the next section.) The additional timing information is a series of bytes that indicates when to perform the operation described by the message. In other words, a standard MIDI file specifies not just which notes to play, but exactly when to play each of them. It’s a bit like a musical score. The information in a standard MIDI file is referred to as a sequence. A standard MIDI file contains one or more tracks. Each track typically contains the notes that a single instrument would play if the music were performed by live musicians. A sequencer is a software or hardware device that can read a sequence and deliver the MIDI messages contained in it at the right time. A sequencer is a bit like an orchestra conductor: it has the information for all the notes, including their timings, and it tells some other entity when to perform the notes. The Java Sound API’s Representation of MIDI Data Now that we’ve sketched the MIDI specification’s approach to streamed and sequenced musical data, let’s examine how the Java Sound API represents that data. MIDI MessagesMidiMessage is an abstract class that represents a “raw” MIDI message. A “raw” MIDI message is usually a message defined by the MIDI wire protocol. It can also be one of the events defined by the Standard MIDI Files specification, but without the event’s timing information. There are three categories of raw MIDI message, represented in the Java Sound API by these three respective MidiMessage subclasses: [`ShortMessages`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/ShortMessage.html) are the most common messages and have at most two data bytes following the status byte. The channel messages, such as Note On and Note Off, are all short messages, as are some other messages. [`SysexMessages`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/SysexMessage.html) contain **system-exclusive** MIDI messages. They may have many bytes, and generally contain manufacturer-specific instructions. [`MetaMessages`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/MetaMessage.html) occur in MIDI files, but not in MIDI wire protocol. Meta messages contain data, such as lyrics or tempo settings, that might be useful to sequencers but that are usually meaningless for synthesizers. MIDI Events As we’ve seen, standard MIDI files contain events that are wrappers for “raw” MIDI messages along with timing information. An instance of the Java Sound API’sMidiEvent class represents an event such as might be stored in a standard MIDI file. The API for MidiEvent includes methods to set and get the event’s timing value. There’s also a method to retrieve its embedded raw MIDI message, which is an instance of a subclass of MidiMessage, discussed next. (The embedded raw MIDI message can be set only when constructing the MidiEvent.) Sequences and Tracks As mentioned earlier, a standard MIDI file stores events that are arranged into tracks. Usually the file represents one musical composition, and usually each track represents a part such as might have been played by a single instrumentalist. Each note that the instrumentalist plays is represented by at least two events: a Note On that starts the note, and a Note Off that ends it. The track may also contain events that don’t correspond to notes, such as meta-events (which were mentioned above). The Java Sound API organizes MIDI data in a three-part hierarchy: [`Sequence`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/Sequence.html) [`Track`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/Track.html) [`MidiEvent`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/MidiEvent.html) A Track is a collection of MidiEvents, and a Sequence is a collection of Tracks. This hierarchy reflects the files, tracks, and events of the Standard MIDI Files specification. (Note: this is a hierarchy in terms of containment and ownership; it’s not a class hierarchy in terms of inheritance. Each of these three classes inherits directly from java.lang.Object.) Sequences can be read from MIDI files, or created from scratch and edited by adding Tracks to the Sequence (or removing them). Similarly, MidiEvents can be added to or removed from the tracks in the sequence. The Java Sound API’s Representation of MIDI Devices The previous section explained how MIDI messages are represented in the Java Sound API. However, MIDI messages don’t exist in a vacuum. They’re typically sent from one device to another. A program that uses the Java Sound API can generate MIDI messages from scratch, but more often the messages are instead created by a software device, such as a sequencer, or received from outside the computer through a MIDI input port. Such a device usually sends these messages to another device, such as a synthesizer or a MIDI output port. The MidiDevice Interface In the world of external MIDI hardware devices, many devices can transmit MIDI messages to other devices and also receive messages from other devices. Similarly, in the Java Sound API, software objects that implement theMidiDevice interface can transmit and receive messages. Such an object can be implemented purely in software, or it can serve as an interface to hardware such as a sound card’s MIDI capabilities. The base MidiDevice interface provides all the functionality generally required by a MIDI input or output port. Synthesizers and sequencers, however, further implement one of the subinterfaces of MidiDevice:Synthesizer orSequencer , respectively. The MidiDevice interface includes an API for opening and closing a device. It also includes an inner class called MidiDevice.Info that provides textual descriptions of the device, including its name, vendor, and version. If you’ve read the sampled-audio portion of this tutorial, this API will probably sound familiar, because its design is similar to that of the javax.sampled.Mixer interface, which represents an audio device and which has an analogous inner class, Mixer.Info. Transmitters and Receivers Most MIDI devices are capable of sending MidiMessages, receiving them, or both. The way a device sends data is via one or more transmitter objects that it “owns.” Similarly, the way a device receives data is via one or more of its receiver objects. The transmitter objects implement theTransmitter interface, and the receivers implement theReceiver interface. Each transmitter can be connected to only one receiver at a time, and vice versa. A device that sends its MIDI messages to multiple other devices simultaneously does so by having multiple transmitters, each connected to a receiver of a different device. Similarly, a device that can receive MIDI messages from more than one source at a time must do so via multiple receivers. Sequencers A sequencer is a device for capturing and playing back sequences of MIDI events. It has transmitters, because it typically sends the MIDI messages stored in the sequence to another device, such as a synthesizer or MIDI output port. It also has receivers, because it can capture MIDI messages and store them in a sequence. To its superinterface, MidiDevice, Sequencer adds methods for basic MIDI sequencing operations. A sequencer can load a sequence from a MIDI file, query and set the sequence’s tempo, and synchronize other devices to it. An application program can register an object to be notified when the sequencer processes certain kinds of events. Synthesizers A Synthesizer is a device for generating sound. It’s the only object in the javax.sound.midi package that produces audio data. A synthesizer device controls a set of MIDI channel objects &#8212; typically 16 of them, since the MIDI specification calls for 16 MIDI channels. These MIDI channel objects are instances of a class that implements theMidiChannel interface, whose methods represent the MIDI specification’s “channel voice messages” and “channel mode messages.” An application program can generate sound by directly invoking methods of a synthesizer’s MIDI channel objects. More commonly, though, a synthesizer generates sound in response to messages sent to one or more of its receivers. These messages might be sent by a sequencer or MIDI input port, for example. The synthesizer parses each message that its receivers get, and usually dispatches a corresponding command (such as noteOn or controlChange) to one of its MidiChannel objects, according to the MIDI channel number specified in the event. The MidiChannel uses the note information in these messages to synthesize music. For example, a noteOn message specifies the note’s pitch and “velocity” (volume). However, the note information is insufficient; the synthesizer also requires precise instructions on how to create the audio signal for each note. These instructions are represented by anInstrument. Each Instrument typically emulates a different real-world musical instrument or sound effect. The Instruments might come as presets with the synthesizer, or they might be loaded from soundbank files. In the synthesizer, the Instruments are arranged by bank number (these can be thought of as rows) and program number (columns). This section has provided a background for understanding MIDI data, and it has introduced some of the important interfaces and classes related to MIDI in the Java Sound API. Subsequent sections show how you can access and use these objects in your application programs.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Using Files and Format Converters","date":"2020-12-05T17:47:44.580Z","path":"wiki/2021-03-03-Using Files and Format Converters/","text":"Using Files and Format Converters Most application programs that deal with sound need to read sound files or audio streams. This is common functionality, regardless of what the program may subsequently do with the data it reads (such as play, mix, or process it). Similarly, many programs need to write sound files (or streams). In some cases, the data that has been read (or that will be written) needs to be converted to a different format. As was briefly mentioned inAccessing Audio System Resources, the Java Sound API provides application developers with various facilities for file input/output and format translations. Application programs can read, write, and translate between a variety of sound file formats and audio data formats. Overview of the Sampled Package introduced the main classes related to sound files and audio data formats. As a review: A stream of audio data, as might be read from or written to a file, is represented by an AudioInputStream object. (AudioInputStream inherits from java.io.InputStream.)The format of this audio data is represented by an `AudioFormat` object. This format specifies how the audio samples themselves are arranged, but not the structure of a file that they might be stored in. In other words, an `AudioFormat` describes \"raw\" audio data, such as the system might hand your program after capturing it from a microphone input or after parsing it from a sound file. An `AudioFormat` includes such information as the encoding, the byte order, the number of channels, the sampling rate, and the number of bits per sample. There are several well-known, standard formats for sound files, such as WAV, AIFF, or AU. The different types of sound file have different structures for storing audio data as well as for storing descriptive information about the audio data. A sound file format is represented in the Java Sound API by an AudioFileFormat object. The AudioFileFormat includes an AudioFormat object to describe the format of the audio data stored in the file, and also includes information about the file type and the length of the data in the file. The AudioSystem class provides methods for (1) storing a stream of audio data from an AudioInputStream into an audio file of a particular type (in other words, writing a file), (2) extracting a stream of audio bytes (an AudioInputStream) from an audio file (in other words, reading a file), and (3) converting audio data from one data format to another. This page, which is divided into three sections, explains these three kinds of activity. an implementation of the Java Sound API does not necessarily provide comprehensive facilities for reading, writing, and converting audio in different data and file formats. It might support only the most common data and file formats. However, service providers can develop and distribute conversion services that extend this set, as you’ll later see in Providing Sampled-Audio Services. The AudioSystem class supplies methods that allow application programs to learn what conversions are available, as described later under Converting File and Data Formats. Reading Sound Files The AudioSystem class provides two types of file-reading services: Information about the format of the audio data stored in the sound file A stream of formatted audio data that can be read from the sound file The first of these is given by three variants of the getAudioFileFormat method: 12345static AudioFileFormat getAudioFileFormat (java.io.File file)static AudioFileFormat getAudioFileFormat(java.io.InputStream stream)static AudioFileFormat getAudioFileFormat (java.net.URL url) As mentioned above, the returned AudioFileFormat object tells you the file type, the length of the data in the file, encoding, the byte order, the number of channels, the sampling rate, and the number of bits per sample. The second type of file-reading functionality is given by these AudioSystem methods 12345static AudioInputStream getAudioInputStream (java.io.File file)static AudioInputStream getAudioInputStream (java.net.URL url)static AudioInputStream getAudioInputStream (java.io.InputStream stream) These methods give you an object (an AudioInputStream) that lets you read the file’s audio data, using one of the read methods of AudioInputStream. We’ll see an example momentarily. Suppose you’re writing a sound-editing application that allows the user to load sound data from a file, display a corresponding waveform or spectrogram, edit the sound, play back the edited data, and save the result in a new file. Or perhaps your program will read the data stored in a file, apply some kind of signal processing (such as an algorithm that slows the sound down without changing its pitch), and then play the processed audio. In either case, you need to get access to the data contained in the audio file. Assuming that your program provides some means for the user to select or specify an input sound file, reading that file’s audio data involves three steps: Get an AudioInputStream object from the file. Create a byte array in which you’ll store successive chunks of data from the file. Repeatedly read bytes from the audio input stream into the array. On each iteration, do something useful with the bytes in the array (for example, you might play them, filter them, analyze them, display them, or write them to another file). The following code snippet outlines these steps: 12345678910111213141516171819202122232425262728293031323334353637int totalFramesRead &#x3D; 0;File fileIn &#x3D; new File(somePathName);&#x2F;&#x2F; somePathName is a pre-existing string whose value was&#x2F;&#x2F; based on a user selection.try &#123; AudioInputStream audioInputStream &#x3D; AudioSystem.getAudioInputStream(fileIn); int bytesPerFrame &#x3D; audioInputStream.getFormat().getFrameSize(); if (bytesPerFrame &#x3D;&#x3D; AudioSystem.NOT_SPECIFIED) &#123; &#x2F;&#x2F; some audio formats may have unspecified frame size &#x2F;&#x2F; in that case we may read any amount of bytes bytesPerFrame &#x3D; 1; &#125; &#x2F;&#x2F; Set an arbitrary buffer size of 1024 frames. int numBytes &#x3D; 1024 * bytesPerFrame; byte[] audioBytes &#x3D; new byte[numBytes]; try &#123; int numBytesRead &#x3D; 0; int numFramesRead &#x3D; 0; &#x2F;&#x2F; Try to read numBytes bytes from the file. while ((numBytesRead &#x3D; audioInputStream.read(audioBytes)) !&#x3D; -1) &#123; &#x2F;&#x2F; Calculate the number of frames actually read. numFramesRead &#x3D; numBytesRead &#x2F; bytesPerFrame; totalFramesRead +&#x3D; numFramesRead; &#x2F;&#x2F; Here, do something useful with the audio data that&#39;s &#x2F;&#x2F; now in the audioBytes array... &#125; &#125; catch (Exception ex) &#123; &#x2F;&#x2F; Handle the error... &#125;&#125; catch (Exception e) &#123; &#x2F;&#x2F; Handle the error...&#125; Let’s take a look at what’s happening in the above code sample. First, the outer try clause instantiates an AudioInputStream object through the call to the AudioSystem.getAudioInputStream(File) method. This method transparently performs all of the testing required to determine whether the specified file is actually a sound file of a type that is supported by the Java Sound API. If the file being inspected (fileIn in this example) is not a sound file, or is a sound file of some unsupported type, an UnsupportedAudioFileException exception is thrown. This behavior is convenient, in that the application programmer need not be bothered with testing file attributes, nor with adhering to any file-naming conventions. Instead, the getAudioInputStream method takes care of all the low-level parsing and verification that is required to validate the input file. The outer try clause then creates a byte array, audioBytes, of an arbitrary fixed length. We make sure that its length in bytes equals an integral number of frames, so that we won’t end up reading only part of a frame or, even worse, only part of a sample. This byte array will serve as a buffer to temporarily hold a chunk of audio data as it’s read from the stream. If we knew we would be reading nothing but very short sound files, we could make this array the same length as the data in the file, by deriving the length in bytes from the length in frames, as returned by AudioInputStream&#39;s getFrameLength method. (Actually, we’d probably just use a Clip object instead.) But to avoid running out of memory in the general case, we instead read the file in chunks, one buffer at a time. The inner try clause contains a while loop, which is where we read the audio data from the AudioInputStream into the byte array. You should add code in this loop to handle the audio data in this array in whatever way is appropriate for your program’s needs. If you’re applying some kind of signal processing to the data, you’ll probably need to query the AudioInputStream&#39;s AudioFormat further, to learn the number of bits per sample and so on. Note that the method AudioInputStream.read(byte[]) returns the number of bytes read&#226;&#128;&#148;not the number of samples or frames. This method returns -1 when there’s no more data to read. Upon detecting this condition, we break from the while loop. Writing Sound Files The previous section described the basics of reading a sound file, using specific methods of the AudioSystem and AudioInputStream classes. This section describes how to write audio data out to a new file. The following AudioSystem method creates a disk file of a specified file type. The file will contain the audio data that’s in the specified AudioInputStream: 1234static int write(AudioInputStream in, AudioFileFormat.Type fileType, File out) Note that the second argument must be one of the file types supported by the system (for example, AU, AIFF, or WAV), otherwise the write method will throw an IllegalArgumentException. To avoid this, you can test whether or not a particular AudioInputStream may be written to a particular type of file, by invoking this AudioSystem method: 1234static boolean isFileTypeSupported (AudioFileFormat.Type fileType, AudioInputStream stream) which will return true only if the particular combination is supported. More generally, you can learn what types of file the system can write by invoking one of these AudioSystem methods: 1234static AudioFileFormat.Type[] getAudioFileTypes() static AudioFileFormat.Type[] getAudioFileTypes(AudioInputStream stream) The first of these returns all the types of file that the system can write, and the second returns only those that the system can write from the given audio input stream. The following excerpt demonstrates one technique for creating an output file from an AudioInputStream using the write method mentioned above. 12345678File fileOut &#x3D; new File(someNewPathName);AudioFileFormat.Type fileType &#x3D; fileFormat.getType();if (AudioSystem.isFileTypeSupported(fileType, audioInputStream)) &#123; AudioSystem.write(audioInputStream, fileType, fileOut);&#125; The first statement above, creates a new File object, fileOut, with a user- or program-specified pathname. The second statement gets a file type from a pre-existing AudioFileFormat object called fileFormat, which might have been obtained from another sound file, such as the one that was read in Reading Sound Files above. (You could instead supply whatever supported file type you want, instead of getting the file type from elsewhere. For example, you might delete the second statement and replace the other two occurrences of fileType in the code above with AudioFileFormat.Type.WAVE.) The third statement tests whether a file of the designated type can be written from a desired AudioInputStream. Like the file format, this stream might have been derived from the sound file previously read. (If so, presumably you’ve processed or altered its data in some way, because otherwise there are easier ways to simply copy a file.) Or perhaps the stream contains bytes that have been freshly captured from the microphone input. Finally, the stream, file type, and output file are passed to the AudioSystem.write method, to accomplish the goal of writing the file. Converting File and Data Formats Recall fromWhat is Formatted Audio Data?, that the Java Sound API distinguishes between audio file formats and audio data formats. The two are more or less independent. Roughly speaking, the data format refers to the way in which the computer represents each raw data point (sample), while the file format refers to the organization of a sound file as stored on a disk. Each sound file format has a particular structure that defines, for example, the information stored in the file’s header. In some cases, the file format also includes structures that contain some form of meta-data, in addition to the actual “raw” audio samples. The remainder of this page examines methods of the Java Sound API that enable a variety of file-format and data-format conversions. Converting from One File Format to Another This section covers the fundamentals of converting audio file types in the Java Sound API. Once again we pose a hypothetical program whose purpose, this time, is to read audio data from an arbitrary input file and write it into a file whose type is AIFF. Of course, the input file must be of a type that the system is capable of reading, and the output file must be of a type that the system is capable of writing. (In this example, we assume that the system is capable of writing AIFF files.) The example program doesn’t do any data format conversion. If the input file’s data format can’t be represented as an AIFF file, the program simply notifies the user of that problem. On the other hand, if the input sound file is an already an AIFF file, the program notifies the user that there is no need to convert it. The following function implements the logic just described: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void ConvertFileToAIFF(String inputPath, String outputPath) &#123; AudioFileFormat inFileFormat; File inFile; File outFile; try &#123; inFile &#x3D; new File(inputPath); outFile &#x3D; new File(outputPath); &#125; catch (NullPointerException ex) &#123; System.out.println(&quot;Error: one of the ConvertFileToAIFF&quot; +&quot; parameters is null!&quot;); return; &#125; try &#123; &#x2F;&#x2F; query file type inFileFormat &#x3D; AudioSystem.getAudioFileFormat(inFile); if (inFileFormat.getType() !&#x3D; AudioFileFormat.Type.AIFF) &#123; &#x2F;&#x2F; inFile is not AIFF, so let&#39;s try to convert it. AudioInputStream inFileAIS &#x3D; AudioSystem.getAudioInputStream(inFile); inFileAIS.reset(); &#x2F;&#x2F; rewind if (AudioSystem.isFileTypeSupported( AudioFileFormat.Type.AIFF, inFileAIS)) &#123; &#x2F;&#x2F; inFileAIS can be converted to AIFF. &#x2F;&#x2F; so write the AudioInputStream to the &#x2F;&#x2F; output file. AudioSystem.write(inFileAIS, AudioFileFormat.Type.AIFF, outFile); System.out.println(&quot;Successfully made AIFF file, &quot; + outFile.getPath() + &quot;, from &quot; + inFileFormat.getType() + &quot; file, &quot; + inFile.getPath() + &quot;.&quot;); inFileAIS.close(); return; &#x2F;&#x2F; All done now &#125; else System.out.println(&quot;Warning: AIFF conversion of &quot; + inFile.getPath() + &quot; is not currently supported by AudioSystem.&quot;); &#125; else System.out.println(&quot;Input file &quot; + inFile.getPath() + &quot; is AIFF.&quot; + &quot; Conversion is unnecessary.&quot;); &#125; catch (UnsupportedAudioFileException e) &#123; System.out.println(&quot;Error: &quot; + inFile.getPath() + &quot; is not a supported audio file type!&quot;); return; &#125; catch (IOException e) &#123; System.out.println(&quot;Error: failure attempting to read &quot; + inFile.getPath() + &quot;!&quot;); return; &#125;&#125; As mentioned, the purpose of this example function, ConvertFileToAIFF, is to query an input file to determine whether it’s an AIFF sound file, and if it isn’t, to try to convert it to one, producing a new copy whose pathname is specified by the second argument. (As an exercise, you might try making this function more general, so that instead of always converting to AIFF, the function converts to the file type specified by a new function argument.) Note that the audio data format of the copy&#226;&#128;&#148;that is, the new file-mimics the audio data format of original input file. Most of this function is self-explanatory and is not specific to the Java Sound API. There are, however, a few Java Sound API methods used by the routine that are crucial for sound file-type conversions. These method invocations are all found in the second try clause, above, and include the following: AudioSystem.getAudioFileFormat: used here to determine whether the input file is already an AIFF type. If so, the function quickly returns; otherwise the conversion attempt proceeds. AudioSystem.isFileTypeSupported: Indicates whether the system can write a file of the specified type that contains audio data from the specified AudioInputStream. In our example, this method returns true if the specified audio input file can be converted to AIFF audio file format. If AudioFileFormat.Type.AIFF isn’t supported, ConvertFileToAIFF issues a warning that the input file can’t be converted, then returns. AudioSystem.write: used here to write the audio data from the AudioInputStream inFileAIS to the output file outFile. The second of these methods, isFileTypeSupported, helps to determine, in advance of the write, whether a particular input sound file can be converted to a particular output sound file type. In the next section we will see how, with a few modifications to this ConvertFileToAIFF sample routine, we can convert the audio data format, as well as the sound file type. Converting Audio between Different Data Formats The previous section showed how to use the Java Sound API to convert a file from one file format (that is, one type of sound file) to another. This section explores some of the methods that enable audio data format conversions. In the previous section, we read data from a file of an arbitrary type, and saved it in an AIFF file. Note that although we changed the type of file used to store the data, we didn’t change the format of the audio data itself. (Most common audio file types, including AIFF, can contain audio data of various formats.) So if the original file contained CD-quality audio data (16-bit sample size, 44.1-kHz sample rate, and two channels), so would our output AIFF file. Now suppose that we want to specify the data format of the output file, as well as the file type. For example, perhaps we are saving many long files for use on the Internet, and are concerned about the amount of disk space and download time required by our files. We might choose to create smaller AIFF files that contain lower-resolution data-for example, data that has an 8-bit sample size, an 8-kHz sample rate, and a single channel. Without going into as much coding detail as before, let’s explore some of the methods used for data format conversion, and consider the modifications that we would need to make to the ConvertFileToAIFF function to accomplish the new goal. The principal method for audio data conversion is, once again, found in the AudioSystem class. This method is a variant of getAudioInputStream: 1234AudioInputStream getAudioInputStream(AudioFormat format, AudioInputStream stream) This function returns an AudioInputStream that is the result of converting the AudioInputStream, stream, using the indicated AudioFormat, format. If the conversion isn’t supported by AudioSystem, this function throws an IllegalArgumentException. To avoid that, we can first check whether the system can perform the required conversion by invoking this AudioSystem method: 1234boolean isConversionSupported(AudioFormat targetFormat, AudioFormat sourceFormat) In this case, we’d pass stream.getFormat() as the second argument. To create a specific AudioFormat object, we use one of the two AudioFormat constructors shown below, either: 1234AudioFormat(float sampleRate, int sampleSizeInBits, int channels, boolean signed, boolean bigEndian) which constructs an AudioFormat with a linear PCM encoding and the given parameters, or: 12345AudioFormat(AudioFormat.Encoding encoding, float sampleRate, int sampleSizeInBits, int channels, int frameSize, float frameRate, boolean bigEndian) which also constructs an AudioFormat, but lets you specify the encoding, frame size, and frame rate, in addition to the other parameters. Now, armed with the methods above, let’s see how we might extend our ConvertFileToAIFF function to perform the desired “low-res” audio data format conversion. First, we would construct an AudioFormat object describing the desired output audio data format. The following statement would suffice and could be inserted near the top of the function: 1234AudioFormat outDataFormat &#x3D; new AudioFormat((float) 8000.0,(int) 8, (int) 1, true, false); Since the AudioFormat constructor above is describing a format with 8-bit samples, the last parameter to the constructor, which specifies whether the samples are big or little endian, is irrelevant. (Big versus little endian is only an issue if the sample size is greater than a single byte.) The following example shows how we would use this new AudioFormat to convert the AudioInputStream, inFileAIS, that we created from the input file: 12345678AudioInputStream lowResAIS; if (AudioSystem.isConversionSupported(outDataFormat, inFileAIS.getFormat())) &#123; lowResAIS &#x3D; AudioSystem.getAudioInputStream (outDataFormat, inFileAIS); &#125; It wouldn’t matter too much where we inserted this code, as long as it was after the construction of inFileAIS. Without the isConversionSupported test, the call would fail and throw an IllegalArgumentException if the particular conversion being requested was unsupported. (In this case, control would transfer to the appropriate catch clause in our function.) So by this point in the process, we would have produced a new AudioInputStream, resulting from the conversion of the original input file (in its AudioInputStream form) to the desired low-resolution audio data format as defined by outDataFormat. The final step to produce the desired low-resolution, AIFF sound file would be to replace the AudioInputStream parameter in the call to AudioSystem.write (that is, the first parameter) with our converted stream, lowResAIS, as follows: 1234AudioSystem.write(lowResAIS, AudioFileFormat.Type.AIFF, outFile); These few modifications to our earlier function produce something that converts both the audio data and the file format of any specified input file, assuming of course that the system supports the conversion. Learning What Conversions Are Available Several AudioSystem methods test their parameters to determine whether the system supports a particular data format conversion or file-writing operation. (Typically, each method is paired with another that performs the data conversion or writes the file.) One of these query methods, AudioSystem.isFileTypeSupported, was used in our example function, ConvertFileToAIFF, to determine whether the system was capable of writing the audio data to an AIFF file. A related AudioSystem method, getAudioFileTypes(AudioInputStream), returns the complete list of supported file types for the given stream, as an array of AudioFileFormat.Type instances. The method: BEGINCODE boolean isConversionSupported(AudioFormat.Encoding encoding,AudioFormat format)","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Processing Audio with Controls","date":"2020-12-05T17:47:42.563Z","path":"wiki/2021-03-03-Processing Audio with Controls/","text":"Processing Audio with ControlsPrevious sections have discussed how to play or capture audio samples. The implicit goal has been to deliver samples as faithfully as possible, without modification (other than possibly mixing the samples with those from other audio lines). Sometimes, however, you want to be able to modify the signal. The user might want it to sound louder, quieter, fuller, more reverberant, higher or lower in pitch, and so on. This page discusses the Java Sound API features that provide these kinds of signal processing. There are two ways to apply signal processing: You can use any processing supported by the mixer or its component lines, by querying for [`Control`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Control.html) objects and then setting the controls as the user desires. Typical controls supported by mixers and lines include gain, pan, and reverberation controls. - If the kind of processing you need isn't provided by the mixer or its lines, your program can operate directly on the audio bytes, manipulating them as desired. This page discusses the first technique in greater detail, because there is no special API for the second technique. Introduction to Controls A mixer can have various sorts of signal-processing controls on some or all of its lines. For example, a mixer used for audio capture might have an input port with a gain control, and target data lines with gain and pan controls. A mixer used for audio playback might have sample-rate controls on its source data lines. In each case, the controls are all accessed through methods of the Line interface. Because the Mixer interface extends Line, the mixer itself can have its own set of controls. These might serve as master controls affecting all the mixer’s source or target lines. For example, the mixer might have a master gain control whose value in decibels is added to the values of individual gain controls on its target lines. Others of the mixer’s own controls might affect a special line, neither a source nor a target, that the mixer uses internally for its processing. For example, a global reverb control might choose the sort of reverberation to apply to a mixture of the input signals, and this “wet” (reverberated) signal would get mixed back into the “dry” signal before delivery to the mixer’s target lines. If the mixer or any of its lines have controls, you might wish to expose the controls via graphical objects in your program’s user interface, so that the user can adjust the audio characteristics as desired. The controls are not themselves graphical; they just allow you to retrieve and change their settings. It’s up to you to decide what sort of graphical representations (sliders, buttons, etc.), if any, to use in your program. All controls are implemented as concrete subclasses of the abstract class Control. Many typical audio-processing controls can be described by abstract subclasses of Control based on a data type (such as boolean, enumerated, or float). Boolean controls, for example, represent binary-state controls, such as on/off controls for mute or reverb. Float controls, on the other hand, are well suited to represent continuously variable controls, such as pan, balance, or volume. The Java Sound API specifies the following abstract subclasses of Control: [`BooleanControl`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/BooleanControl.html)&#8212; represents a binary-state (true or false) control. For example, mute, solo, and on/off switches would be good candidates for `BooleanControls`. [`FloatControl`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/FloatControl.html) &#8212; data model providing control over a range of floating-point values. For example, volume and pan are `FloatControls` that could be manipulated via a dial or slider. [`EnumControl`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/EnumControl.html)&#8212; offers a choice from a set of objects. For example, you might associate a set of buttons in the user interface with an `EnumControl` to select one of several preset reverberation settings. [`CompoundControl`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/CompoundControl.html)&#226;&#128;&#148;provides access to a collection of related items, each of which is itself an instance of a `Control` subclass. `CompoundControls` represent multi-control modules such as graphic equalizers. (A graphic equalizer would typically be depicted by a set of sliders, each affecting a `FloatControl`.) Each subclass of Control above has methods appropriate for its underlying data type. Most of the classes include methods that set and get the control’s current value(s), get the control’s label(s), and so on. Of course, each class has methods that are particular to it and the data model represented by the class. For example, EnumControl has a method that lets you get the set of its possible values, and FloatControl permits you to get its minimum and maximum values, as well as the precision (increment or step size) of the control. Each subclass of Control has a corresponding Control.Type subclass, which includes static instances that identify specific controls. The following table shows each Control subclass, its corresponding Control.Type subclass, and the static instances that indicate specific kinds of controls: `Control` `Control.Type` `Control.Type` **instances** `CompoundControl` `CompoundControl.Type` (none) An implementation of the Java Sound API can provide any or all of these control types on its mixers and lines. It can also supply additional control types not defined in the Java Sound API. Such control types could be implemented via concrete subclasses of any of these four abstract subclasses, or via additional Control subclasses that don’t inherit from any of these four abstract subclasses. An application program can query each line to find what controls it supports. Getting a Line that Has the Desired Controls In many cases, an application program will simply display whatever controls happen to be supported by the line in question. If the line doesn’t have any controls, so be it. But what if it’s important to find a line that has certain controls? In that case, you can use a Line.Info to obtain a line that has the right characteristics, as previously described underGetting a Line of a Desired Type. For example, suppose you prefer an input port that lets the user set the volume of the sound input. The following code excerpt shows how one might query the default mixer to determine whether it has the desired port and control: 12345678910111213141516171819Port lineIn;FloatControl volCtrl;try &#123; mixer &#x3D; AudioSystem.getMixer(null); lineIn &#x3D; (Port)mixer.getLine(Port.Info.LINE_IN); lineIn.open(); volCtrl &#x3D; (FloatControl) lineIn.getControl(&lt;br &#x2F;&gt; FloatControl.Type.VOLUME); &#x2F;&#x2F; Assuming getControl call succeeds, &#x2F;&#x2F; we now have our LINE_IN VOLUME control.&#125; catch (Exception e) &#123; System.out.println(&quot;Failed trying to find LINE_IN&quot; + &quot; VOLUME control: exception &#x3D; &quot; + e);&#125;if (volCtrl !&#x3D; null) &#x2F;&#x2F; ... Getting the Controls from the Line An application program that needs to expose controls in its user interface might simply query the available lines and controls, and then display an appropriate user-interface element for every control on every line of interest. In such a case, the program’s only mission is to provide the user with “handles” on the control; not to know what those controls do to the audio signal. As long as the program knows how to map a line’s controls into user-interface elements, the Java Sound API architecture of Mixer, Line, and Control will generally take care of the rest. For example, suppose your program plays back sound. You’re using a SourceDataLine, which you’ve obtained as previously described underGetting a Line of a Desired Type. You can access the line’s controls by invoking the following Line method: 123Control[] getControls() Then, for each of the controls in this returned array, you then use the following Control method to get the control’s type: 123Control.Type getType() Knowing the specific Control.Type instance, your program can display a corresponding user-interface element. Of course, choosing “a corresponding user-interface element” for a specific Control.Type depends on the approach taken by your program. On the one hand, you might use the same kind of element to represent all Control.Type instances of the same class. This would require you to query the class of the Control.Type instance using, for example, the Object.getClass method. Let’s say the result matched BooleanControl.Type. In this case, your program might display a generic checkbox or toggle button, but if its class matched FloatControl.Type, then you might display a graphic slider. On the other hand, your program might distinguish between different types of controls&#226;&#128;&#148;even those of the same class&#226;&#128;&#148;and use a different user-interface element for each one. This would require you to test the instance returned by Control&#39;s getType method. Then if, for example, the type matched BooleanControl.Type.APPLY_REVERB, your program might display a checkbox; while if the type matched BooleanControl.Type.MUTE, you might instead display a toggle button. Using a Control to Change the Audio Signal Now that you know how to access a control and determine its type, this section will describe how to use Controls to change aspects of the audio signal. This section doesn’t cover every available control; rather, it provides a few examples in this area to show you how to get started. These example include: Controlling a line’s mute state Changing a line’s volume Selecting among various reverberation presets Suppose that your program has accessed all of its mixers, their lines and the controls on those lines, and that it has a data structure to manage the logical associations between the controls and their corresponding user-interface elements. Then, translating the user’s manipulations of those controls into the corresponding Control methods becomes a fairly straightforward matter. The following subsections describe some of the methods that must be invoked to affect the changes to specific controls. Controlling a Line’s Mute State Controlling the mute state of any line is simply a matter of calling the following BooleanControl method: 123void setValue(boolean value) (Presumably, the program knows, by referring to its control-management data structures, that the mute is an instance of a BooleanControl.) To mute the signal that’s passing through the line, the program invokes the method above, specifying true as the value. To turn muting off, permitting the signal to flow through the line, the program invokes the method with the parameter set to false. Changing a Line’s Volume Let’s assume your program associates a particular graphic slider with a particular line’s volume control. The value of a volume control (i.e., FloatControl.Type.VOLUME) is set using the following FloatControl method: 123void setValue(float newValue) Detecting that the user moved the slider, the program gets the slider’s current value and passes it, as the parameter newValue, to the method above. This changes the volume of the signal flowing though the line that “owns” the control. Selecting among Various Reverberation Presets Let’s suppose that our program has a mixer with a line that has a control of type EnumControl.Type.REVERB. Calling the EnumControl method: 123java.lang.Objects[] getValues() on that control produces an array of ReverbType objects. If desired, the particular parameter settings of each of these objects can be accessed using the following ReverbType methods: 1234567int getDecayTime() int getEarlyReflectionDelay() float getEarlyReflectionIntensity() int getLateReflectionDelay() float getLateReflectionIntensity() For example, if a program only wants a single reverb setting that sounds like a cavern, it can iterate over the ReverbType objects until it finds one for which getDecayTime returns a value greater than 2000. For a thorough explanation of these methods, including a table of representative return values, see the API reference documentation for javax.sound.sampled.ReverbType. Typically, though, a program will create a user-interface element, for example, a radio button, for each of the ReverbType objects within the array returned by the getValues method. When the user clicks on one of these radio buttons, the program invokes the EnumControl method 123void setValue(java.lang.Object value) where value is set to the ReverbType that corresponds to the newly engaged button. The audio signal sent through the line that “owns” this EnumControl will then be reverberated according to the parameter settings that constitute the control’s current ReverbType (i.e., the particular ReverbType specified in the value argument of the setValue method). So, from our application program’s perspective, enabling a user to move from one reverberation preset (i.e., ReverbType) to another is simply a matter of connecting each element of the array returned by getValues to a distinct radio button. Manipulating the Audio Data Directly The Control API allows an implementation of the Java Sound API, or a third-party provider of a mixer, to supply arbitrary sorts of signal processing through controls. But what if no mixer offers the kind of signal processing you need? It will take more work, but you might be able to implement the signal processing in your program. Because the Java Sound API gives you access to the audio data as an array of bytes, you can alter these bytes in any way you choose. If you’re processing incoming sound, you can read the bytes from a TargetDataLine and then manipulate them. An algorithmically trivial example that can yield sonically intriguing results is to play a sound backwards by arranging its frames in reverse order. This trivial example may not be of much use for your program, but there are numerous sophisticated digital signal processing (DSP) techniques that might be more appropriate. Some examples are equalization, dynamic-range compression, peak limiting, and time stretching or compression, as well as special effects such as delay, chorus, flanging, distortion, and so on. To play back processed sound, you can place your manipulated array of bytes into a SourceDataLine or Clip. Of course, the array of bytes need not be derived from an existing sound. You can synthesize sounds from scratch, although this requires some knowledge of acoustics or else access to sound-synthesis functions. For either processing or synthesis, you may want to consult an audio DSP textbook for the algorithms in which you’re interested, or else import a third-party library of signal-processing functions into your program. For playback of synthesized sound, consider whether the Synthesizer API in the javax.sound.midi package meets your needs instead. You’ll learn about more about javax.sound.midi later underSynthesizing Sound.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Capturing Audio","date":"2020-12-05T17:47:40.267Z","path":"wiki/2021-03-03-Capturing Audio/","text":"Capturing Audio Capturing refers to the process of obtaining a signal from outside the computer. A common application of audio capture is recording, such as recording the microphone input to a sound file. However, capturing isn’t synonymous with recording, because recording implies that the application always saves the sound data that’s coming in. An application that captures audio doesn’t necessarily store the audio. Instead it might do something with the data as it’s coming in &#8212; such as transcribe speech into text &#8212; but then discard each buffer of audio as soon as it’s finished with that buffer. As discussed inOverview of the Sampled Package, a typical audio-input system in an implementation of the Java Sound API consists of: An input port, such as a microphone port or a line-in port, which feeds its incoming audio data into: A mixer, which places the input data in: One or more target data lines, from which an application can retrieve the data. Commonly, only one input port can be open at a time, but an audio-input mixer that mixes audio from multiple ports is also possible. Another scenario consists of a mixer that has no ports but instead gets its audio input over a network. The TargetDataLine interface was introduced briefly underThe Line Interface Hierarchy. TargetDataLine is directly analogous to the SourceDataLine interface, which was discussed extensively inPlaying Back Audio. Recall that the SourceDataLine interface consists of: A write method to send audio to the mixer An available method to determine how much data can be written to the buffer without blocking Similarly, TargetDataLine consists of: A read method to get audio from the mixer An available method to determine how much data can be read from the buffer without blocking Setting Up a TargetDataLine The process of obtaining a target data line was described inAccessing Audio System Resources but we repeat it here for convenience: 12345678910111213141516TargetDataLine line;DataLine.Info info &#x3D; new DataLine.Info(TargetDataLine.class, format); &#x2F;&#x2F; format is an AudioFormat objectif (!AudioSystem.isLineSupported(info)) &#123; &#x2F;&#x2F; Handle the error ... &#125;&#x2F;&#x2F; Obtain and open the line.try &#123; line &#x3D; (TargetDataLine) AudioSystem.getLine(info); line.open(format);&#125; catch (LineUnavailableException ex) &#123; &#x2F;&#x2F; Handle the error ... &#125; You could instead invoke Mixer&#39;s getLine method, rather than AudioSystem&#39;s. As shown in this example, once you’ve obtained a target data line, you reserve it for your application’s use by invoking the SourceDataLine method open, exactly as was described in the case of a source data line inPlaying Back Audio. The single-parameter version of the open method causes the line’s buffer to have the default size. You can instead set the buffer size according to your application’s needs by invoking the two-parameter version: 123void open(AudioFormat format, int bufferSize) Reading the Data from the TargetDataLine Once the line is open, it is ready to start capturing data, but it isn’t active yet. To actually commence the audio capture, use the DataLine method start. This begins delivering input audio data to the line’s buffer for your application to read. Your application should invoke start only when it’s ready to begin reading from the line; otherwise a lot of processing is wasted on filling the capture buffer, only to have it overflow (that is, discard data). To start retrieving data from the buffer, invoke TargetDataLine&#39;s read method: 123int read(byte[] b, int offset, int length) This method attempts to read length bytes of data into the array b, starting at the byte position offset in the array. The method returns the number of bytes actually read. As with SourceDataLine&#39;s write method, you can request more data than actually fits in the buffer, because the method blocks until the requested amount of data has been delivered, even if you request many buffers’ worth of data. To avoid having your application hang during recording, you can invoke the read method within a loop, until you’ve retrieved all the audio input, as in this example: 123456789101112131415161718&#x2F;&#x2F; Assume that the TargetDataLine, line, has already&#x2F;&#x2F; been obtained and opened.ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();int numBytesRead;byte[] data &#x3D; new byte[line.getBufferSize() &#x2F; 5];&#x2F;&#x2F; Begin audio capture.line.start();&#x2F;&#x2F; Here, stopped is a global boolean set by another thread.while (!stopped) &#123; &#x2F;&#x2F; Read the next chunk of data from the TargetDataLine. numBytesRead &#x3D; line.read(data, 0, data.length); &#x2F;&#x2F; Save this chunk of data. out.write(data, 0, numBytesRead);&#125; Notice that in this example, the size of the byte array into which the data is read is set to be one-fifth the size of the line’s buffer. If you instead make it as big as the line’s buffer and try to read the entire buffer, you need to be very exact in your timing, because data will be dumped if the mixer needs to deliver data to the line while you are reading from it. By using some fraction of the line’s buffer size, as shown here, your application will be more successful in sharing access to the line’s buffer with the mixer. The read method of TargetDataLine takes three arguments: a byte array, an offset into the array, and the number of bytes of input data that you would like to read. In this example, the third argument is simply the length of your byte array. The read method returns the number of bytes that were actually read into your array. Typically, you read data from the line in a loop, as in this example. Within the while loop, each chunk of retrieved data is processed in whatever way is appropriate for the application&#226;&#128;&#148;here, it’s written to a ByteArrayOutputStream. Not shown here is the use of a separate thread to set the boolean stopped, which terminates the loop. This boolean’s value might be set to true when the user clicks a Stop button, and also when a listener receives a CLOSE or STOP event from the line. The listener is necessary for CLOSE events and recommended for STOP events. Otherwise, if the line gets stopped somehow without stopped being set to true, the while loop will capture zero bytes on each iteration, running fast and wasting CPU cycles. A more thorough code example would show the loop being re-entered if capture becomes active again. As with a source data line, it’s possible to drain or flush a target data line. For example, if you’re recording the input to a file, you’ll probably want to invoke the drain method when the user clicks a Stop button. The drain method will cause the mixer’s remaining data to get delivered to the target data line’s buffer. If you don’t drain the data, the captured sound might seem to be truncated prematurely at the end. There might be some cases where you instead want to flush the data. In any case, if you neither flush nor drain the data, it will be left in the mixer. This means that when capture recommences, there will be some leftover sound at the beginning of the new recording, which might be undesirable. It can be useful, then, to flush the target data line before restarting the capture. Monitoring the Line’s Status Because the TargetDataLine interface extends DataLine, target data lines generate events in the same way source data lines do. You can register an object to receive events whenever the target data line opens, closes, starts, or stops. For more information, see the previous discussion ofMonitoring a Line’s Status. Processing the Incoming Audio Like some source data lines, some mixers’ target data lines have signal-processing controls, such as gain, pan, reverb, or sample-rate controls. The input ports might have similar controls, especially gain controls. In the next section, you’ll learn how to determine whether a line has such controls, and how to use them if it does.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Playing Back Audio","date":"2020-12-05T17:47:38.469Z","path":"wiki/2021-03-03-Playing Back Audio/","text":"Playing Back AudioPlayback is sometimes referred to as presentation or rendering. These are general terms that are applicable to other kinds of media besides sound. The essential feature is that a sequence of data is delivered somewhere for eventual perception by a user. If the data is time-based, as sound is, it must be delivered at the correct rate. With sound even more than video, it’s important that the rate of data flow be maintained, because interruptions to sound playback often produce loud clicks or irritating distortion. The Java Sound API is designed to help application programs play sounds smoothly and continuously, even very long sounds. Earlier you saw how to obtain a line from the audio system or from a mixer. Here you will learn how to play sound through a line. As you know, there are two kinds of line that you can use for playing sound: aClip and aSourceDataLine. The primary difference between the two is that with a Clip you specify all the sound data at one time, before playback, whereas with a SourceDataLine you keep writing new buffers of data continuously during playback. Although there are many situations in which you could use either a Clip or a SourceDataLine, the following criteria help identify which kind of line is better suited for a particular situation: Use a `Clip` when you have non-real-time sound data that can be preloaded into memory. For example, you might read a short sound file into a clip. If you want the sound to play back more than once, a `Clip` is more convenient than a `SourceDataLine`, especially if you want the playback to loop (cycle repeatedly through all or part of the sound). If you need to start the playback at an arbitrary position in the sound, the `Clip` interface provides a method to do that easily. Finally, playback from a `Clip` generally has less latency than buffered playback from a `SourceDataLine`. In other words, because the sound is preloaded into a clip, playback can start immediately instead of having to wait for the buffer to be filled. Use a `SourceDataLine` for streaming data, such as a long sound file that won't all fit in memory at once, or a sound whose data can't be known in advance of playback. As an example of the latter case, suppose you're monitoring sound input&#226;&#128;&#148;that is, playing sound back as it's being captured. If you don't have a mixer that can send input audio right back out an output port, your application program will have to take the captured data and send it to an audio-output mixer. In this case, a `SourceDataLine` is more appropriate than a `Clip`. Another example of sound that can't be known in advance occurs when you synthesize or manipulate the sound data interactively in response to the user's input. For example, imagine a game that gives aural feedback by \"morphing\" from one sound to another as the user moves the mouse. The dynamic nature of the sound transformation requires the application program to update the sound data continuously during playback, instead of supplying it all before playback starts. Using a Clip You obtain a Clip as described earlier underGetting a Line of a Desired Type; Construct a DataLine.Info object with Clip.class for the first argument, and pass this DataLine.Info as an argument to the getLine method of AudioSystem or Mixer. Obtaining a line just means you’ve gotten a way to refer to it; getLine doesn’t actually reserve the line for you. Because a mixer might have a limited number of lines of the desired type available, it can happen that after you invoke getLine to obtain the clip, another application program jumps in and grabs the clip before you’re ready to start playback. To actually use the clip, you need to reserve it for your program’s exclusive use by invoking one of the following Clip methods: 1234void open(AudioInputStream stream)void open(AudioFormat format, byte[] data, int offset, int bufferSize) Despite the bufferSize argument in the second open method above, Clip (unlike SourceDataLine) includes no methods for writing new data to the buffer. The bufferSize argument here just specifies how much of the byte array to load into the clip. It’s not a buffer into which you can subsequently load more data, as you can with a SourceDataLine&#39;s buffer. After opening the clip, you can specify at what point in the data it should start playback, using Clip&#39;s setFramePosition or setMicroSecondPosition methods. Otherwise, it will start at the beginning. You can also configure the playback to cycle repeatedly, using the setLoopPoints method. When you’re ready to start playback, simply invoke the start method. To stop or pause the clip, invoke the stop method, and to resume playback, invoke start again. The clip remembers the media position where it stopped playback, so there’s no need for explicit pause and resume methods. If you don’t want it to resume where it left off, you can “rewind” the clip to the beginning (or to any other position, for that matter) using the frame- or microsecond-positioning methods mentioned above. A Clip&#39;s volume level and activity status (active versus inactive) can be monitored by invoking the DataLine methods getLevel and isActive, respectively. An active Clip is one that is currently playing sound. Using a SourceDataLine Obtaining a SourceDataLine is similar to obtaining a Clip. Opening the SourceDataLine is also similar to opening a Clip, in that the purpose is once again to reserve the line. However, you use a different method, inherited from DataLine: 123void open(AudioFormat format) Notice that when you open a SourceDataLine, you don’t associate any sound data with the line yet, unlike opening a Clip. Instead, you just specify the format of the audio data you want to play. The system chooses a default buffer length. You can also stipulate a certain buffer length in bytes, using this variant: 123void open(AudioFormat format, int bufferSize) For consistency with similar methods, the bufferSize argument is expressed in bytes, but it must correspond to an integral number of frames. Instead of using the open method described above, it’s also possible to open a SourceDataLine using Line&#39;s open() method, without arguments. In this case, the line is opened with its default audio format and buffer size. However, you can’t change these later. If you want to know the line’s default audio format and buffer size, you can invoke DataLine&#39;s getFormat and getBufferSize methods, even before the line has ever been opened. Once the SourceDataLine is open, you can start playing sound. You do this by invoking DataLine&#39;s start method, and then writing data repeatedly to the line’s playback buffer. The start method permits the line to begin playing sound as soon as there’s any data in its buffer. You place data in the buffer by the following method: 123int write(byte[] b, int offset, int length) The offset into the array is expressed in bytes, as is the array’s length. Monitoring a Line’s Status. The line is now considered active, so the isActive method of DataLine will return true. Notice that all this happens only once the buffer contains data to play, not necessarily right when the start method is invoked. If you invoked start on a new SourceDataLine but never wrote data to the buffer, the line would never be active and a START event would never be sent. (However, in this case, the isRunning method of DataLine would return true.) So how do you know how much data to write to the buffer, and when to send the second batch of data? Fortunately, you don’t need to time the second invocation of write to synchronize with the end of the first buffer! Instead, you can take advantage of the write method’s blocking behavior: The method returns as soon as the data has been written to the buffer. It doesn’t wait until all the data in the buffer has finished playing. (If it did, you might not have time to write the next buffer without creating a discontinuity in the audio.) It’s all right to try to write more data than the buffer will hold. In this case, the method blocks (doesn’t return) until all the data you requested has actually been placed in the buffer. In other words, one buffer’s worth of your data at a time will be written to the buffer and played, until the remaining data all fits in the buffer, at which point the method returns. Whether or not the method blocks, it returns as soon as the last buffer’s worth of data from this invocation can be written. Again, this means that your code will in all likelihood regain control before playback of the last buffer’s worth of data has finished. While in many contexts it is fine to write more data than the buffer will hold, if you want to be certain that the next write issued does not block, you can limit the number of bytes you write to the number that DataLine&#39;s available method returns. Here’s an example of iterating through chunks of data that are read from a stream, writing one chunk at a time to the SourceDataLine for playback: 123456789101112&#x2F;&#x2F; read chunks from a stream and write them to a source data line line.start();while (total &lt; totalToRead &amp;&amp; !stopped)&#125; numBytesRead &#x3D; stream.read(myData, 0, numBytesToRead); if (numBytesRead &#x3D;&#x3D; -1) break; total +&#x3D; numBytesRead; line.write(myData, 0, numBytesRead);&#125; If you don’t want the write method to block, you can first invoke the available method (inside the loop) to find out how many bytes can be written without blocking, and then limit the numBytesToRead variable to this number, before reading from the stream. In the example given, though, blocking won’t matter much, since the write method is invoked inside a loop that won’t complete until the last buffer is written in the final loop iteration. Whether or not you use the blocking technique, you’ll probably want to invoke this playback loop in a separate thread from the rest of the application program, so that your program doesn’t appear to freeze when playing a long sound. On each iteration of the loop, you can test whether the user has requested playback to stop. Such a request needs to set the stopped boolean, used in the code above, to true. Since write returns before all the data has finished playing, how do you learn when the playback has actually completed? One way is to invoke the drain method of DataLine after writing the last buffer’s worth of data. This method blocks until all the data has been played. When control returns to your program, you can free up the line, if desired, without fear of prematurely cutting off the playback of any audio samples: 12345678line.write(b, offset, numBytesToWrite); &#x2F;&#x2F;this is the final invocation of writeline.drain();line.stop();line.close();line &#x3D; null; You can intentionally stop playback prematurely, of course. For example, the application program might provide the user with a Stop button. Invoke DataLine&#39;s stop method to stop playback immediately, even in the middle of a buffer. This leaves any unplayed data in the buffer, so that if you subsequently invoke start, the playback resumes where it left off. If that’s not what you want to happen, you can discard the data left in the buffer by invoking flush. A SourceDataLine generates a STOP event whenever the flow of data has been stopped, whether this stoppage was initiated by the drain method, the stop method, or the flush method, or because the end of a playback buffer was reached before the application program invoked write again to provide new data. A STOP event doesn’t necessarily mean that the stop method was invoked, and it doesn’t necessarily mean that a subsequent invocation of isRunning will return false. It does, however, mean that isActive will return false. (When the start method has been invoked, the isRunning method will return true, even if a STOP event is generated, and it will begin to return false only once the stop method is invoked.) It’s important to realize that START and STOP events correspond to isActive, not to isRunning. Monitoring a Line’s Status Once you have started a sound playing, how do you find when it’s finished? We saw one solution above, invoking the drain method after writing the last buffer of data, but that approach is applicable only to a SourceDataLine. Another approach, which works for both SourceDataLines and Clips, is to register to receive notifications from the line whenever the line changes its state. These notifications are generated in the form of LineEvent objects, of which there are four types: OPEN, CLOSE, START, and STOP. Any object in your program that implements the LineListener interface can register to receive such notifications. To implement the LineListener interface, the object simply needs an update method that takes a LineEvent argument. To register this object as one of the line’s listeners, you invoke the following Line method: 123public void addLineListener(LineListener listener) Whenever the line opens, closes, starts, or stops, it sends an update message to all its listeners. Your object can query the LineEvent that it receives. First you might invoke LineEvent.getLine to make sure the line that stopped is the one you care about. In the case we’re discussing here, you want to know if the sound is finished, so you see whether the LineEvent is of type STOP. If it is, you might check the sound’s current position, which is also stored in the LineEvent object, and compare it to the sound’s length (if known) to see whether it reached the end and wasn’t stopped by some other means (such as the user’s clicking a Stop button, although you’d probably be able to determine that cause elsewhere in your code). Along the same lines, if you need to know when the line is opened, closed, or started, you use the same mechanism. LineEvents are generated by different kinds of lines, not just Clips and SourceDataLines. However, in the case of a Port you can’t count on getting an event to learn about a line’s open or closed state. For example, a Port might be initially open when it’s created, so you don’t invoke the open method and the Port doesn’t ever generate an OPEN event. (See the previous discussion ofSelecting Input and Output Ports.) Synchronizing Playback on Multiple Lines If you’re playing back multiple tracks of audio simultaneously, you probably want to have them all start and stop at exactly the same time. Some mixers facilitate this behavior with their synchronize method, which lets you apply operations such as open, close, start, and stop to a group of data lines using a single command, instead of having to control each line individually. Furthermore, the degree of accuracy with which operations are applied to the lines is controllable. To find out whether a particular mixer offers this feature for a specified group of data lines, invoke the Mixer interface’s isSynchronizationSupported method: 123boolean isSynchronizationSupported(Line[] lines, boolean maintainSync) The first parameter specifies a group of specific data lines, and the second parameter indicates the accuracy with which synchronization must be maintained. If the second parameter is true, the query is asking whether the mixer is capable of maintaining sample-accurate precision in controlling the specified lines at all times; otherwise, precise synchronization is required only during start and stop operations, not throughout playback. Processing the Outgoing Audio Some source data lines have signal-processing controls, such as gain, pan, reverb, and sample-rate controls. Similar controls, especially gain controls, might be present on the output ports as well. For more information on how to determine whether a line has such controls, and how to use them if it does, seeProcessing Audio with Controls.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Accessing Audio System Resources","date":"2020-12-05T17:47:36.485Z","path":"wiki/2021-03-03-Accessing Audio System Resources/","text":"Accessing Audio System ResourcesThe Java Sound API takes a flexible approach to system configuration. Different sorts of audio devices (mixers) can be installed on a computer. The API makes few assumptions about what devices have been installed and what their capabilities are. Instead, it provides ways for the system to report about the available audio components, and ways for your program to access them. The following sections show how your program can learn what sampled-audio resources have been installed on the computer, and how it can gain access to the available resources. Among other things, the resources include mixers and the various types of lines owned by the mixers. The AudioSystem Class TheAudioSystem class acts as a clearinghouse for audio components, including built-in services and separately installed services from third-party providers. AudioSystem serves as an application program’s entry point for accessing these installed sampled-audio resources. You can query the AudioSystem to learn what sorts of resources have been installed, and then you can obtain access to them. For example, an application program might start out by asking the AudioSystem class whether there is a mixer that has a certain configuration, such as one of the input or output configurations illustrated earlier in the discussion of lines. From the mixer, the program would then obtain data lines, and so on. Here are some of the resources an application program can obtain from the AudioSystem: Mixers &#8212; A system typically has multiple mixers installed. There is usually at least one for audio input and one for audio output. There might also be mixers that don’t have I/O ports but instead accept audio from an application program and deliver the mixed audio back to the program. The AudioSystem class provides a list of all of the installed mixers. Lines &#8212; Even though every line is associated with a mixer, an application program can get a line directly from the AudioSystem, without dealing explicitly with mixers. Format conversions &#8212; An application program can use format conversions to translate audio data from one format to another. Files and streams &#8212; The AudioSystem class provides methods for translating between audio files and audio streams. It can also report the file format of a sound file and can write files in different formats. Information Objects Several classes in the Java Sound API provide useful information about associated interfaces. For example,Mixer.Info provides details about an installed mixer, such as the mixer’s vendor, name, description, and version.Line.Info obtains the class of a specific line. Subclasses of Line.Info includePort.Info andDataLine.Info , which obtain details relevant to a specific port and data line, respectively. Each of these classes is described further in the appropriate section below. It’s important not to confuse the Info object with the mixer or line object that it describes. Getting a MixerUsually, one of the first things a program that uses the Java Sound API needs to do is to obtain a mixer, or at least one line of a mixer, so that you can get sound into or out of the computer. Your program might need a specific kind of mixer, or you might want to display a list of all the available mixers so that the user can select one. In either case, you need to learn what kinds of mixers are installed. AudioSystem provides the following method: 123static Mixer.Info[] getMixerInfo() EachMixer.Info object returned by this method identifies one type of mixer that is installed. (Usually a system has at most one mixer of a given type. If there happens to be more than one of a given type, the returned array still only has one Mixer.Info for that type.) An application program can iterate over the Mixer.Info objects to find an appropriate one, according to its needs. The Mixer.Info includes the following strings to identify the kind of mixer: Name Version Vendor Description These are arbitrary strings, so an application program that needs a specific mixer must know what to expect and what to compare the strings to. The company that provides the mixer should include this information in its documentation. Alternatively, and perhaps more typically, the application program will display all the Mixer.Info objects’ strings to the user and let the user choose the corresponding mixer. Once an appropriate mixer is found, the application program invokes the following AudioSystem method to obtain the desired mixer: 123static Mixer getMixer(Mixer.Info info) What if your program needs a mixer that has certain capabilities, but it doesn’t need a specific mixer made by a specific vendor? And what if you can’t depend on the user’s knowing which mixer should be chosen? In that case, the information in the Mixer.Info objects won’t be of much use. Instead, you can iterate over all the Mixer.Info objects returned by getMixerInfo, get a mixer for each by invoking getMixer, and query each mixer for its capabilities. For example, you might need a mixer that can write its mixed audio data to a certain number of target data lines simultaneously. In that case, you would query each mixer using this Mixer method: 123int getMaxLines(Line.Info info) Here, theLine.Info would specify a TargetDataLine. The Line.Info class is discussed in the next section. Getting a Line of a Desired TypeThere are two ways to get a line: Directly from the [`AudioSystem`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioSystem.html) object - From a mixer that you have already obtained from the `AudioSystem` object Getting a Line Directly from the AudioSystem Let’s assume you haven’t obtained a mixer, and your program is a simple one that really only needs a certain kind of line; the details of the mixer don’t matter to you. You can use the AudioSystem method: 123static Line getLine(Line.Info info) which is analogous to the getMixer method discussed previously. UnlikeMixer.Info , theLine.Info used as an argument doesn’t store textual information to specify the desired line. Instead, it stores information about the class of line desired. Line.Info is an abstract class, so you use one of its subclasses (Port.Info orDataLine.Info ) to obtain a line. The following code excerpt uses the DataLine.Info subclass to obtain and open a target data line: 12345678910111213141516TargetDataLine line;DataLine.Info info &#x3D; new DataLine.Info(TargetDataLine.class, format); &#x2F;&#x2F; format is an AudioFormat objectif (!AudioSystem.isLineSupported(info)) &#123; &#x2F;&#x2F; Handle the error. &#125; &#x2F;&#x2F; Obtain and open the line.try &#123; line &#x3D; (TargetDataLine) AudioSystem.getLine(info); line.open(format);&#125; catch (LineUnavailableException ex) &#123; &#x2F;&#x2F; Handle the error. &#x2F;&#x2F;... &#125; This code obtains aTargetDataLine object without specifying any attributes other than its class and its audio format. You can use analogous code to obtain other kinds of lines. For a SourceDataLine or a Clip, just substitute that class for TargetDataLine as the class of the line variable, and also in the first argument to the DataLine.Info constructor. For a Port, you can use static instances of Port.Info, in code like the following: 12345678if (AudioSystem.isLineSupported(Port.Info.MICROPHONE)) &#123; try &#123; line &#x3D; (Port) AudioSystem.getLine( Port.Info.MICROPHONE); &#125;&#125; Note the use of the method isLineSupported to see whether the mixer even has a line of the desired type. Recall that a source line is an input to a mixer, namely, a Port object if the mixer represents an audio-input device, and a SourceDataLine or Clip object if the mixer represents an audio-output device. Similarly, a target line is an output of the mixer: a Port object for an audio-output mixer, and a TargetDataLine object for an audio-input mixer. What if a mixer doesn’t connect to any external hardware device at all? For example, consider an internal or software-only mixer that gets audio from an application program and delivers its mixed audio back to the program. This kind of mixer has SourceDataLine or Clip objects for its input lines and TargetDataLine objects for its output lines. You can also use the following AudioSystem methods to learn more about source and target lines of a specified type that are supported by any installed mixer: 1234static Line.Info[] getSourceLineInfo(Line.Info info)static Line.Info[] getTargetLineInfo(Line.Info info) Note that the array returned by each of these methods indicates unique types of lines, not necessarily all the lines. For example, if two of a mixer’s lines, or two lines of different mixers, have identical Line.Info objects, the two lines will represented by only one Line.Info in the returned array. Getting a Line from a Mixer The Mixer interface includes variations on the AudioSystem access methods for source and target lines, described above. These Mixer methods include ones that take Line.Info arguments, just as AudioSystem&#39;s methods do. However, Mixer also includes these variants, which take no arguments: 1234Line.Info[] getSourceLineInfo()Line.Info[] getTargetLineInfo() These methods return arrays of all the Line.Info objects for the particular mixer. Once you’ve obtained the arrays, you can iterate over them, calling Mixer&#39;s getLine method to obtain each line, followed by Line&#39;s open method to reserve use of each line for your program. Selecting Input and Output Ports The previous section, regarding how to obtain a line of a desired type, applies to ports as well as other types of lines. You can obtain all of the source (i.e., input) and target (i.e, output) ports by passing a Port.Info object to the AudioSystem (or Mixer) methods getSourceLineInfo and getTargetLineInfo that take a Line.Info argument. You then iterate over the returned array of objects and invoke Mixer’s getLine method to get each port. You can then open each Port by invoking Line&#39;s open method. Opening a port means you turn it on&#226;&#128;&#148;that is, you allow sound to come in or out the port. Similarly, you can close ports that you don’t want sound to travel through, because some ports might already be open before you even obtain them. Some platforms leave all ports on by default; or a user or system administrator might have selected certain ports to be on or off, using another application program or operating-system software. Warning: If you want to select a certain port and make sure that the sound is actually going in or out the port, you can open the port as described. However, this can be considered user-hostile behavior! For example, a user might have the speaker port turned off so as not to disturb her co-workers. She would be rather upset if your program suddenly overrode her wishes and started blaring music. As another example, a user might want to be assured that his computer’s microphone is never turned on without his knowledge, to avoid eavesdropping. In general, it is recommended not to open or close ports unless your program is responding to the user’s intentions, as expressed through the user interface. Instead, respect the settings that the user or the operating system has already selected. It isn’t necessary to open or close a port before the mixer it’s attached to will function correctly. For example, you can start playing back sound into an audio-output mixer, even though all its output ports are closed. The data still flows into the mixer; the playback isn’t blocked. The user just won’t hear anything. As soon as the user opens an output port, the sound will be audible through that port, starting at whatever point in the media the playback has already reached. Also, you don’t need to access the ports to learn whether the mixer has certain ports. To learn whether a mixer is actually an audio-output mixer, for example, you can invoke getTargetLineInfo to see whether it has output ports. There’s no reason to access the ports themselves unless you want to change their settings (such as their open-or-closed state, or the settings of any controls they might have). Permission to Use Audio Resources The Java Sound API includes anAudioPermission class that indicates what kinds of access an applet (or an application running with a security manager) can have to the sampled-audio system. Permission to record sound is controlled separately. This permission should be granted with care, to help prevent security risks such as unauthorized eavesdropping. By default, applets and applications are granted permissions as follows: An applet running with the applet security manager can play, but not record, audio. An application running with no security manager can both play and record audio. An application running with the default security manager can play, but not record, audio. In general, applets are run under the scrutiny of a security manager and aren’t permitted to record sound. Applications, on the other hand, don’t automatically install a security manager, and are able to record sound. (However, if the default security manager is invoked explicitly for an application, the application isn’t permitted to record sound.) Both applets and applications can record sound even when running with a security manager if they have been granted explicit permission to do so. If your program doesn’t have permission to record (or play) sound, an exception will be thrown when it attempts to open a line. There is nothing you can do about this in your program, other than to catch the exception and report the problem to the user, because permissions can’t be changed through the API. (If they could, they would be pointless, because nothing would be secure!) Generally, permissions are set in one or more policy configuration files, which a user or system administrator can edit using a text editor or the Policy Tool program.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Overview of the Sampled Package","date":"2020-12-05T17:47:34.425Z","path":"wiki/2021-03-03-Overview of the Sampled Package/","text":"Overview of the Sampled Package Thejavax.sound.sampled package is fundamentally concerned with audio transport &#8212; in other words, the Java Sound API focuses on playback and capture. The central task that the Java Sound API addresses is how to move bytes of formatted audio data into and out of the system. This task involves opening audio input and output devices and managing buffers that get filled with real-time sound data. It can also involve mixing multiple streams of audio into one stream (whether for input or output). The transport of sound into or out of the system has to be correctly handled when the user requests that the flow of sound be started, paused, resumed, or stopped. To support this focus on basic audio input and output, the Java Sound API provides methods for converting between various audio data formats, and for reading and writing common types of sound files. However, it does not attempt to be a comprehensive sound-file toolkit. A particular implementation of the Java Sound API need not support an extensive set of file types or data format conversions. Third-party service providers can supply modules that “plug in” to an existing implementation to support additional file types and conversions. The Java Sound API can handle audio transport in both a streaming, buffered fashion and an in-memory, unbuffered fashion. “Streaming” is used here in a general sense to refer to real-time handling of audio bytes; it does not refer to the specific, well-known case of sending audio over the Internet in a certain format. In other words, a stream of audio is simply a continuous set of audio bytes that arrive more or less at the same rate that they are to be handled (played, recorded, etc.). Operations on the bytes commence before all the data has arrived. In the streaming model, particularly in the case of audio input rather than audio output, you do not necessarily know in advance how long the sound is and when it will finish arriving. You simply handle one buffer of audio data at a time, until the operation is halted. In the case of audio output (playback), you also need to buffer data if the sound you want to play is too large to fit in memory all at once. In other words, you deliver your audio bytes to the sound engine in chunks, and it takes care of playing each sample at the right time. Mechanisms are provided that make it easy to know how much data to deliver in each chunk. The Java Sound API also permits unbuffered transport in the case of playback only, assuming you already have all the audio data at hand and it is not too large to fit in memory. In this situation, there is no need for the application program to buffer the audio, although the buffered, real-time approach is still available if desired. Instead, the entire sound can be preloaded at once into memory for subsequent playback. Because all the sound data is loaded in advance, playback can start immediately &#8212; for example, as soon as the user clicks a Start button. This can be an advantage compared to the buffered model, where the playback has to wait for the first buffer to fill. In addition, the in-memory, unbuffered model allows sounds to be easily looped (cycled) or set to arbitrary positions in the data. To play or capture sound using the Java Sound API, you need at least three things: formatted audio data, a mixer, and a line. The following provides an overview of these concepts. What is Formatted Audio Data?Formatted audio data refers to sound in any of a number of standard formats. The Java Sound API distinguishes between data formats and file formats. Data Formats A data format tells you how to interpret a series of bytes of “raw” sampled audio data, such as samples that have already been read from a sound file, or samples that have been captured from the microphone input. You might need to know, for example, how many bits constitute one sample (the representation of the shortest instant of sound), and similarly you might need to know the sound’s sample rate (how fast the samples are supposed to follow one another). When setting up for playback or capture, you specify the data format of the sound you are capturing or playing. In the Java Sound API, a data format is represented by anAudioFormat object, which includes the following attributes: Encoding technique, usually pulse code modulation (PCM) Number of channels (1 for mono, 2 for stereo, etc.) Sample rate (number of samples per second, per channel) Number of bits per sample (per channel) Frame rate Frame size in bytes Byte order (big-endian or little-endian) PCM is one kind of encoding of the sound waveform. The Java Sound API includes two PCM encodings that use linear quantization of amplitude, and signed or unsigned integer values. Linear quantization means that the number stored in each sample is directly proportional (except for any distortion) to the original sound pressure at that instant&#226;&#128;&#148;and similarly proportional to the displacement of a loudspeaker or eardrum that is vibrating with the sound at that instant. Compact discs, for example, use linear PCM-encoded sound. Mu-law encoding and a-law encoding are common nonlinear encodings that provide a more compressed version of the audio data; these encodings are typically used for telephony or recordings of speech. A nonlinear encoding maps the original sound’s amplitude to the stored value using a nonlinear function, which can be designed to give more amplitude resolution to quiet sounds than to loud sounds. A frame contains the data for all channels at a particular time. For PCM-encoded data, the frame is simply the set of simultaneous samples in all channels, for a given instant in time, without any additional information. In this case, the frame rate is equal to the sample rate, and the frame size in bytes is the number of channels multiplied by the sample size in bits, divided by the number of bits in a byte. For other kinds of encodings, a frame might contain additional information besides the samples, and the frame rate might be completely different from the sample rate. For example, consider the MP3 (MPEG-1 Audio Layer 3) encoding, which is not explicitly mentioned in the current version of the Java Sound API, but which could be supported by an implementation of the Java Sound API or by a third-party service provider. In MP3, each frame contains a bundle of compressed data for a series of samples, not just one sample per channel. Because each frame encapsulates a whole series of samples, the frame rate is slower than the sample rate. The frame also contains a header. Despite the header, the frame size in bytes is less than the size in bytes of the equivalent number of PCM frames. (After all, the purpose of MP3 is to be more compact than PCM data.) For such an encoding, the sample rate and sample size refer to the PCM data that the encoded sound will eventually be converted into before being delivered to a digital-to-analog converter (DAC). File Formats A file format specifies the structure of a sound file, including not only the format of the raw audio data in the file, but also other information that can be stored in the file. Sound files come in various standard varieties, such as WAVE (also known as WAV, and often associated with PCs), AIFF (often associated with Macintoshes), and AU (often associated with UNIX systems). The different types of sound file have different structures. For example, they might have a different arrangement of data in the file’s “header.” A header contains descriptive information that typically precedes the file’s actual audio samples, although some file formats allow successive “chunks” of descriptive and audio data. The header includes a specification of the data format that was used for storing the audio in the sound file. Any of these types of sound file can contain various data formats (although usually there is only one data format within a given file), and the same data format can be used in files that have different file formats. In the Java Sound API, a file format is represented by anAudioFileFormat object, which contains: The file type (WAVE, AIFF, etc.) The file’s length in bytes The length, in frames, of the audio data contained in the file An AudioFormat object that specifies the data format of the audio data contained in the file TheAudioSystem class provides methods for reading and writing sounds in different file formats, and for converting between different data formats. Some of the methods let you access a file’s contents through a kind of stream called anAudioInputStream . An AudioInputStream is a subclass of theInputStream class, which encapsulates a series of bytes that can be read sequentially. To its superclass, the AudioInputStream class adds knowledge of the bytes’ audio data format (represented by an AudioFormat object). By reading a sound file as an AudioInputStream, you get immediate access to the samples, without having to worry about the sound file’s structure (its header, chunks, etc.). A single method invocation gives you all the information you need about the data format and the file type. What is a Mixer? Many application programming interfaces (APIs) for sound make use of the notion of an audio device. A device is often a software interface to a physical input/output device. For example, a sound-input device might represent the input capabilities of a sound card, including a microphone input, a line-level analog input, and perhaps a digital audio input. In the Java Sound API, devices are represented byMixer objects. The purpose of a mixer is to handle one or more streams of audio input and one or more streams of audio output. In the typical case, it actually mixes together multiple incoming streams into one outgoing stream. A Mixer object can represent the sound-mixing capabilities of a physical device such as a sound card, which might need to mix the sound coming in to the computer from various inputs, or the sound coming from application programs and going to outputs. Alternatively, a Mixer object can represent sound-mixing capabilities that are implemented entirely in software, without any inherent interface to physical devices. In the Java Sound API, a component such as the microphone input on a sound card is not itself considered a device &#8212; that is, a mixer &#8212; but rather a port into or out of the mixer. A port typically provides a single stream of audio into or out of the mixer (although the stream can be multichannel, such as stereo). The mixer might have several such ports. For example, a mixer representing a sound card’s output capabilities might mix several streams of audio together, and then send the mixed signal to any or all of various output ports connected to the mixer. These output ports could be (for example) a headphone jack, a built-in speaker, or a line-level output. To understand the notion of a mixer in the Java Sound API, it helps to visualize a physical mixing console, such as those used in live concerts and recording studios. A Physical Mixing Console A physical mixer has “strips” (also called “slices”), each representing a path through which a single audio signal goes into the mixer for processing. The strip has knobs and other controls by which you can control the volume and pan (placement in the stereo image) for the signal in that strip. Also, the mixer might have a separate bus for effects such as reverb, and this bus can be connected to an internal or external reverberation unit. Each strip has a potentiometer that controls how much of that strip’s signal goes into the reverberated mix. The reverberated (“wet”) mix is then mixed with the “dry” signals from the strips. A physical mixer sends this final mixture to an output bus, which typically goes to a tape recorder (or disk-based recording system) and/or speakers. Imagine a live concert that is being recorded in stereo. Cables (or wireless connections) coming from the many microphones and electric instruments on stage are plugged into the inputs of the mixing console. Each input goes to a separate strip of the mixer, as illustrated. The sound engineer decides on the settings of the gain, pan, and reverb controls. The output of all the strips and the reverb unit are mixed together into two channels. These two channels go to two outputs on the mixer, into which cables are plugged that connect to the stereo tape recorder’s inputs. The two channels are perhaps also sent via an amplifier to speakers in the hall, depending on the type of music and the size of the hall. Now imagine a recording studio, in which each instrument or singer is recorded to a separate track of a multitrack tape recorder. After the instruments and singers have all been recorded, the recording engineer performs a “mixdown” to combine all the taped tracks into a two-channel (stereo) recording that can be distributed on compact discs. In this case, the input to each of the mixer’s strips is not a microphone, but one track of the multitrack recording. Once again, the engineer can use controls on the strips to decide each track’s volume, pan, and reverb amount. The mixer’s outputs go once again to a stereo recorder and to stereo speakers, as in the example of the live concert. These two examples illustrate two different uses of a mixer: to capture multiple input channels, combine them into fewer tracks, and save the mixture, or to play back multiple tracks while mixing them down to fewer tracks. In the Java Sound API, a mixer can similarly be used for input (capturing audio) or output (playing back audio). In the case of input, the source from which the mixer gets audio for mixing is one or more input ports. The mixer sends the captured and mixed audio streams to its target, which is an object with a buffer from which an application program can retrieve this mixed audio data. In the case of audio output, the situation is reversed. The mixer’s source for audio is one or more objects containing buffers into which one or more application programs write their sound data; and the mixer’s target is one or more output ports. What is a Line? The metaphor of a physical mixing console is also useful for understanding the Java Sound API’s concept of a line. A line is an element of the digital audio “pipeline” that is, a path for moving audio into or out of the system. Usually the line is a path into or out of a mixer (although technically the mixer itself is also a kind of line). Audio input and output ports are lines. These are analogous to the microphones and speakers connected to a physical mixing console. Another kind of line is a data path through which an application program can get input audio from, or send output audio to, a mixer. These data paths are analogous to the tracks of the multitrack recorder connected to the physical mixing console. One difference between lines in the Java Sound API and those of a physical mixer is that the audio data flowing through a line in the Java Sound API can be mono or multichannel (for example, stereo). By contrast, each of a physical mixer’s inputs and outputs is typically a single channel of sound. To get two or more channels of output from the physical mixer, two or more physical outputs are normally used (at least in the case of analog sound; a digital output jack is often multichannel). In the Java Sound API, the number of channels in a line is specified by theAudioFormat of the data that is currently flowing through the line. Let’s now examine some specific kinds of lines and mixers. The following diagram shows different types of lines in a simple audio-output system that could be part of an implementation of the Java Sound API: A Possible Configuration of Lines for Audio Output In this example, an application program has gotten access to some available inputs of an audio-input mixer: one or more clips and source data lines. A clip is a mixer input (a kind of line) into which you can load audio data prior to playback; a source data line is a mixer input that accepts a real-time stream of audio data. The application program preloads audio data from a sound file into the clips. It then pushes other audio data into the source data lines, a buffer at a time. The mixer reads data from all these lines, each of which may have its own reverberation, gain, and pan controls, and mixes the dry audio signals with the wet (reverberated) mix. The mixer delivers its final output to one or more output ports, such as a speaker, a headphone jack, and a line-out jack. Although the various lines are depicted as separate rectangles in the diagram, they are all “owned” by the mixer, and can be considered integral parts of the mixer. The reverb, gain, and pan rectangles represent processing controls (rather than lines) that can be applied by the mixer to data flowing through the lines. Note that this is just one example of a possible mixer that is supported by the API. Not all audio configurations will have all the features illustrated. An individual source data line might not support panning, a mixer might not implement reverb, and so on. A simple audio-input system might be similar: A Possible Configuration of Lines for Audio Input Here, data flows into the mixer from one or more input ports, commonly the microphone or the line-in jack. Gain and pan are applied, and the mixer delivers the captured data to an application program via the mixer’s target data line. A target data line is a mixer output, containing the mixture of the streamed input sounds. The simplest mixer has just one target data line, but some mixers can deliver captured data to multiple target data lines simultaneously. The Line Interface Hierarchy Now that we’ve seen some functional pictures of what lines and mixers are, let’s discuss them from a slightly more programmatic perspective. Several types of line are defined by subinterfaces of the basicLine interface. The interface hierarchy is shown below. The Line Interface Hierarchy The base interface,Line, describes the minimal functionality common to all lines: Controls &#8211; Data lines and ports often have a set of controls that affect the audio signal passing through the line. The Java Sound API specifies control classes that can be used to manipulate aspects of sound such as: gain (which affects the signal’s volume in decibels), pan (which affects the sound’s right-left positioning, reverb (which adds reverberation to the sound to emulate different kinds of room acoustics), and sample rate (which affects the rate of playback as well as the sound’s pitch). Open or closed status &#8211; Successful opening of a line guarantees that resources have been allocated to the line. A mixer has a finite number of lines, so at some point multiple application programs (or the same one) might vie for usage of the mixer’s lines. Closing a line indicates that any resources used by the line may now be released.Events &#8211; A line generates events when it opens or closes. Subinterfaces of `Line` can introduce other types of events. When a line generates an event, the event is sent to all objects that have registered to \"listen\" for events on that line. An application program can create these objects, register them to listen for line events, and react to the events as desired. We’ll now examine the subinterfaces of the Line interface. Ports are simple lines for input or output of audio to or from audio devices. As mentioned earlier, some common types of ports are the microphone, line input, CD-ROM drive, speaker, headphone, and line output. TheMixer interface represents a mixer, of course, which as we have seen represents either a hardware or a software device. The Mixer interface provides methods for obtaining a mixer’s lines. These include source lines, which feed audio to the mixer, and target lines, to which the mixer delivers its mixed audio. For an audio-input mixer, the source lines are input ports such as the microphone input, and the target lines areTargetDataLines (described below), which deliver audio to the application program. For an audio-output mixer, on the other hand, the source lines areClips orSourceDataLines (described below), to which the application program feeds audio data, and the target lines are output ports such as the speaker. A Mixer is defined as having one or more source lines and one or more target lines. Note that this definition means that a mixer need not actually mix data; it might have only a single source line. The Mixer API is intended to encompass a variety of devices, but the typical case supports mixing. The Mixer interface supports synchronization; that is, you can specify that two or more of a mixer’s lines be treated as a synchronized group. Then you can start, stop, or close all those data lines by sending a single message to any line in the group, instead of having to control each line individually. With a mixer that supports this feature, you can obtain sample-accurate synchronization between lines. The generic Line interface does not provide a means to start and stop playback or recording. For that you need a data line. TheDataLine interface supplies the following additional media-related features beyond those of a Line: Audio format &#8211; Each data line has an audio format associated with its data stream. Media position &#8211; A data line can report its current position in the media, expressed in sample frames. This represents the number of sample frames captured by or rendered from the data line since it was opened. Buffer size &#8211; This is the size of the data line’s internal buffer in bytes. For a source data line, the internal buffer is one to which data can be written, and for a target data line it’s one from which data can be read. Level (the current amplitude of the audio signal) Start and stop playback or capture Pause and resume playback or capture Flush (discard unprocessed data from the queue) Drain (block until all unprocessed data has been drained from the queue, and the data line’s buffer has become empty) Active status &#8211; A data line is considered active if it is engaged in active presentation or capture of audio data to or from a mixer. Events &#8211; START and STOP events are produced when active presentation or capture of data from or to the data line starts or stops. A TargetDataLine receives audio data from a mixer. Commonly, the mixer has captured audio data from a port such as a microphone; it might process or mix this captured audio before placing the data in the target data line’s buffer. The TargetDataLine interface provides methods for reading the data from the target data line’s buffer and for determining how much data is currently available for reading. A SourceDataLine receives audio data for playback. It provides methods for writing data to the source data line’s buffer for playback, and for determining how much data the line is prepared to receive without blocking. A Clip is a data line into which audio data can be loaded prior to playback. Because the data is pre-loaded rather than streamed, the clip’s duration is known before playback, and you can choose any starting position in the media. Clips can be looped, meaning that upon playback, all the data between two specified loop points will repeat a specified number of times, or indefinitely. This section has introduced most of the important interfaces and classes of the sampled-audio API. Subsequent sections show how you can access and use these objects in your application program. &#160;","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Sound","date":"2020-12-05T17:47:26.048Z","path":"wiki/2021-03-03-Sound/","text":"Trail: SoundThe Java Sound API is a low-level API for effecting and controlling the input and output of sound media, including both audio and Musical Instrument Digital Interface (MIDI) data. The Java Sound API provides explicit control over the capabilities normally required for sound input and output, in a framework that promotes extensibility and flexibility. The Java Sound API fulfills the needs of a wide range of application developers. Potential application areas include: Communication frameworks, such as conferencing and telephony End-user content delivery systems, such as media players and music using streamed content Interactive application programs, such as games and Web sites that use dynamic content Content creation and editing Tools, toolkits, and utilities &lt;!– How Does the Java Sound API Relate to Other Interfaces? --> The Java Sound API provides the lowest level of sound support on the Java platform. It provides application programs with a great amount of control over sound operations, and it is extensible. For example, the Java Sound API supplies mechanisms for installing, accessing, and manipulating system resources such as audio mixers, MIDI synthesizers, other audio or MIDI devices, file readers and writers, and sound format converters. The Java Sound API does not include sophisticated sound editors or graphical tools, but it provides capabilities upon which such programs can be built. It emphasizes low-level control beyond that commonly expected by the end user. The Java Sound API includes support for both digital audio and MIDI data. These two major modules of functionality are provided in separate packages: [`javax.sound.sampled`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/package-summary.html) &#8211; This package specifies interfaces for capture, mixing, and playback of digital (sampled) audio. [`javax.sound.midi`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/package-summary.html) &#8211; This package provides interfaces for MIDI synthesis, sequencing, and event transport. Two other packages permit service providers (as opposed to application developers) to create custom software components that extend the capabilities of an implementation of the Java Sound API: [`javax.sound.sampled.spi`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/spi/package-summary.html) [`javax.sound.midi.spi`](https://docs.oracle.com/javase/8/docs/api/javax/sound/midi/spi/package-summary.html) This page introduces the sampled-audio system, the MIDI system, and the SPI packages. Each package is then discussed in greater detail later in the tutorial. There are other Java platform APIs that also have sound-related elements. TheJava Media Framework API (JMF) is a higher-level API that is currently available as a Standard Extension to the Java platform. JMF specifies a unified architecture, messaging protocol, and programming interface for capturing and playing back time-based media. JMF provides a simpler solution for basic media-player application programs, and it enables synchronization between different media types, such as audio and video. On the other hand, programs that focus on sound can benefit from the Java Sound API, especially if they require more advanced features, such as the ability to carefully control buffered audio playback or directly manipulate a MIDI synthesizer. Other Java APIs with sound aspects include Java 3D and APIs for telephony and speech. An implementation of any of these APIs might use an implementation of the Java Sound API internally, but is not required to do so. What is Sampled Audio? Thejavax.sound.sampled package handles digital audio data, which the Java Sound API refers to as sampled audio. Samples are successive snapshots of a signal. In the case of audio, the signal is a sound wave. A microphone converts the acoustic signal into a corresponding analog electrical signal, and an analog-to-digital converter transforms that analog signal into a sampled digital form. The following figure shows a brief moment in a sound recording. A Sampled Sound Wave This graph plots sound pressure (amplitude) on the vertical axis, and time on the horizontal axis. The amplitude of the analog sound wave is measured periodically at a certain rate, resulting in the discrete samples (the red data points in the figure) that comprise the digital audio signal. The center horizontal line indicates zero amplitude; points above the line are positive-valued samples, and points below are negative. The accuracy of the digital approximation of the analog signal depends on its resolution in time (the sampling rate) and its quantization, or resolution in amplitude (the number of bits used to represent each sample). As a point of reference, the audio recorded for storage on compact discs is sampled 44,100 times per second and represented with 16 bits per sample. The term “sampled audio” is used here slightly loosely. A sound wave could be sampled at discrete intervals while being left in an analog form. For purposes of the Java Sound API, however, “sampled audio” is equivalent to “digital audio.” Typically, sampled audio on a computer comes from a sound recording, but the sound could instead be synthetically generated (for example, to create the sounds of a touch-tone telephone). The term “sampled audio” refers to the type of data, not its origin. The Java Sound API does not assume a specific audio hardware configuration; it is designed to allow different sorts of audio components to be installed on a system and accessed by the API. The Java Sound API supports common functionality such as input and output from a sound card (for example, for recording and playback of sound files) as well as mixing of multiple streams of audio. Here is one example of a typical audio architecture: A Typical Audio Architecture In this example, a device such as a sound card has various input and output ports, and mixing is provided in the software. The mixer might receive data that has been read from a file, streamed from a network, generated on the fly by an application program, or produced by a MIDI synthesizer. The mixer combines all its audio inputs into a single stream, which can be sent to an output device for rendering. What is MIDI? Thejavax.sound.midi package contains APIs for transporting and sequencing MIDI events, and for synthesizing sound from those events. Whereas sampled audio is a direct representation of a sound itself, MIDI data can be thought of as a recipe for creating a sound, especially a musical sound. MIDI data, unlike audio data, does not describe sound directly. Instead, it describes events that affect the sounds (or actions) performed by a MIDI-enabled device or instrument, such as a synthesizer. MIDI data is analogous to a graphical user interface’s keyboard and mouse events. In the case of MIDI, the events can be thought of as actions upon a musical keyboard, along with actions on various pedals, sliders, switches, and knobs on that musical instrument. These events need not actually originate with a hardware musical instrument; they can be simulated in software, and they can be stored in MIDI files. A program that can create, edit, and perform these files is called a sequencer. Many computer sound cards include MIDI-controllable music synthesizer chips to which sequencers can send their MIDI events. Synthesizers can also be implemented entirely in software. The synthesizers interpret the MIDI events that they receive and produce audio output. Usually the sound synthesized from MIDI data is musical sound (as opposed to speech, for example). MIDI synthesizers are also capable of generating various kinds of sound effects. Some sound cards include MIDI input and output ports to which external MIDI hardware devices (such as keyboard synthesizers or other instruments) can be connected. From a MIDI input port, an application program can receive events generated by an external MIDI-equipped musical instrument. The program might play the musical performance using the computer’s internal synthesizer, save it to disk as a MIDI file, or render it into musical notation. A program might use a MIDI output port to play an external instrument, or to control other external devices such as recording equipment. The following diagram illustrates the functional relationships between the major components in a possible MIDI configuration based on the Java Sound API. (As with audio, the Java Sound API permits a variety of MIDI software devices to be installed and interconnected. The system shown here is just one potential scenario.) The flow of data between components is indicated by arrows. The data can be in a standard file format, or (as indicated by the key in the lower right corner of the diagram), it can be audio, raw MIDI bytes, or time-tagged MIDI messages. A Possible MIDI Configuration In this example, the application program prepares a musical performance by loading a musical score that’s stored as a standard MIDI file on a disk (left side of the diagram). Standard MIDI files contain tracks, each of which is a list of time-tagged MIDI events. Most of the events represent musical notes (pitches and rhythms). This MIDI file is read and then “performed” by a software sequencer. A sequencer performs its music by sending MIDI messages to some other device, such as an internal or external synthesizer. The synthesizer itself may read a soundbank file containing instructions for emulating the sounds of certain musical instruments. If not, the synthesizer will play the notes stored in the MIDI file using whatever instrument sounds are already loaded into it. As illustrated, the MIDI events must be translated into raw (non-time-tagged) MIDI before being sent through a MIDI output port to an external MIDI instrument. Similarly, raw MIDI data coming into the computer from an external MIDI source (a keyboard instrument, in the diagram) is translated into time-tagged MIDI messages that can control a synthesizer, or that a sequencer can store for later use. Service Provider Interfaces Thejavax.sound.sampled.spi andjavax.sound.midi.spi packages contain APIs that let software developers create new audio or MIDI resources that can be provided separately to the user and “plugged in” to an existing implementation of the Java Sound API. Here are some examples of services (resources) that can be added in this way: An audio mixer A MIDI synthesizer A file parser that can read or write a new type of audio or MIDI file A converter that translates between different sound data formats In some cases, services are software interfaces to the capabilities of hardware devices, such as sound cards, and the service provider might be the same as the vendor of the hardware. In other cases, the services exist purely in software. For example, a synthesizer or a mixer could be an interface to a chip on a sound card, or it could be implemented without any hardware support at all. An implementation of the Java Sound API contains a basic set of services, but the service provider interface (SPI) packages allow third parties to create new services. These third-party services are integrated into the system in the same way as the built-in services. TheAudioSystem class and theMidiSystem class act as coordinators that let application programs access the services explicitly or implicitly. Often the existence of a service is completely transparent to an application program that uses it. The service-provider mechanism benefits users of application programs based on the Java Sound API, because new sound features can be added to a program without requiring a new release of the JDK or runtime environment, and, in many cases, without even requiring a new release of the application program itself.","tags":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"}],"categories":[{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"}]},{"title":"Bean Customization","date":"2020-12-05T17:47:24.562Z","path":"wiki/2021-03-03-Bean Customization/","text":"Bean CustomizationCustomization provides a means for modifying the appearance and behavior of a bean within an application builder so it meets your specific needs. There are several levels of customization available for a bean developer to allow other developers to get maximum benefit from a bean’s potential functionality. The following links are useful for learning about property editors and customizers: [`PropertyEditor`](https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditor.html) interface [`PropertyEditorSupport`](https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditorSupport.html) class [`PropertyEditorManager`](https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditorManager.html) class [`Customizer`](https://docs.oracle.com/javase/8/docs/api/java/beans/Customizer.html) interface [`BeanInfo`](https://docs.oracle.com/javase/8/docs/api/java/beans/BeanInfo.html) interface A bean’s appearance and behavior can be customized at design time within beans-compliant builder tools. There are two ways to customize a bean: By using a property editor. Each bean property has its own property editor. The NetBeans GUI Builder usually displays a bean’s property editors in the Properties window. The property editor that is associated with a particular property type edits that property type. By using customizers. Customizers give you complete GUI control over bean customization. Customizers are used where property editors are not practical or applicable. Unlike a property editor, which is associated with a property, a customizer is associated with a bean. Property EditorsA property editor is a tool for customizing a particular property type. Property editors are activated in the Properties window. This window determines a property’s type, searches for a relevant property editor, and displays the property’s current value in a relevant way. Property editors must implement the PropertyEditor interface, which provides methods to specify how a property should be displayed in a property sheet. The following figure represents the Properties window containing myBean1 properties: You begin the process of editing these properties by clicking the property entry. Clicking most of these entries will bring up separate panels. For example, to set up the foreground or background use selection boxes with choices of colors, or press the “…” button to work with a standard ColorEditor window. Clicking on the toolTipText property opens a StringEditor window. The support class PropertyEditorSupport provides a default implementation of the PropertyEditor interface. By subclassing your property editor from PropertyEditorSupport, you can simply override the methods you need. To display the current property value “sample” within the Properties window, you need to override isPaintable to return true. You then must override paintValue to paint the current property value in a rectangle in the property sheet. Here’s how ColorEditor implements paintValue: 12345678910public void paintValue(java.awt.Graphics gfx, java.awt.Rectangle box) &#123; Color oldColor &#x3D; gfx.getColor(); gfx.setColor(Color.black); gfx.drawRect(box.x, box.y, box.width-3, box.height-3); gfx.setColor(color); gfx.fillRect(box.x+1, box.y+1, box.width-4, box.height-4); gfx.setColor(oldColor);&#125; To support the custom property editor, override two more methods. Override supportsCustomEditor to return true, and then override getCustomEditor to return a custom editor instance. ColorEditor.getCustomEditor returns this. In addition, the PropertyEditorSupport class maintains a PropertyChangeListener list, and fires property change event notifications to those listeners when a bound property is changed. How Property Editors are Associated with PropertiesProperty editors are discovered and associated with a given property in the following ways: Explicit association by way of a `BeanInfo` object. The editor of the title's property is set with the following line of code: pd.setPropertyEditorClass(TitleEditor.class); - Explicit registration by way of the `java.beans.PropertyEditorManager.registerEditor` method. This method takes two arguments: the bean class type, and the editor class to be associated with that type. Name search. If a class has no explicitly associated property editor, then the `PropertyEditorManager` searchs for that class's property editor in the following ways: - Appending \"Editor\" to the fully qualified class name. For example, for the `my.package.ComplexNumber` class, the property editor manager would search for the `my.package.ComplexNumberEditor` class. - Appending \"Editor\" to the class name and searching a class path. CustomizersYou have learned that builder tools provide support for you to create your own property editors. What other needs should visual builders meet for complex, industrial-strength beans? Often it is undesirable to have all the properties of a bean revealed on a single (sometimes huge) property sheet. What if one single root choice about the type of the bean rendered half the properties irrelevant? The JavaBeans specification provides for user-defined customizers, through which you can define a higher level of customization for bean properties than is available with property editors. When you use a bean Customizer, you have complete control over how to configure or edit a bean. A Customizer is an application that specifically targets a bean’s customization. Sometimes properties are insufficient for representing a bean’s configurable attributes. Customizers are used where sophisticated instructions would be needed to change a bean, and where property editors are too primitive to achieve bean customization. All customizers must: Extend java.awt.Component or one of its subclasses. Implement the java.beans.Customizer interface This means implementing methods to register PropertyChangeListener objects, and firing property change events at those listeners when a change to the target bean has occurred. Implement a default constructor. Associate the customizer with its target class via BeanInfo.getBeanDescriptor.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Long Term Persistence","date":"2020-12-05T17:47:22.307Z","path":"wiki/2021-03-03-Long Term Persistence/","text":"Long Term PersistenceLong-term persistence is a model that enables beans to be saved in XML format. Information on the XML format and on how to implement long-term persistence for non-beans can be found inXML Schema andUsing XMLEncoder. Encoder and DecoderTheXMLEncoder class is assigned to write output files for textual representation of Serializable objects. The following code fragment is an example of writing a Java bean and its properties in XML format: 12345678XMLEncoder encoder &#x3D; new XMLEncoder( new BufferedOutputStream( new FileOutputStream(&quot;Beanarchive.xml&quot;)));encoder.writeObject(object);encoder.close(); TheXMLDecoder class reads an XML document that was created with XMLEncoder: 12345678XMLDecoder decoder &#x3D; new XMLDecoder( new BufferedInputStream( new FileInputStream(&quot;Beanarchive.xml&quot;)));Object object &#x3D; decoder.readObject();decoder.close(); What’s in XML?An XML bean archive has its own specific syntax, which includes the following tags to represent each bean element: an XML preamble to describe a version of XML and type of encoding a **&amp;lt;java&amp;gt;** tag to embody all object elements of the beanan `**&lt;object&gt;**` tag to represent a set of method calls needed to reconstruct an object from its serialized form &lt;object class=\"javax.swing.JButton\" method=\"new\"&gt; &lt;string&gt;Ok&lt;/string&gt; &lt;/object&gt; or statements &lt;object class=\"javax.swing.JButton\"&gt; &lt;void method=\"setText\"&gt; &lt;string&gt;Cancel&lt;/string&gt; &lt;/void&gt; &lt;/object&gt; tags to define appropriate primitive types: **&amp;lt;boolean&amp;gt;** **&amp;lt;byte&amp;gt;** **&amp;lt;char&amp;gt;** **&amp;lt;short&amp;gt;** **&amp;lt;int&amp;gt;** **&amp;lt;long&amp;gt;** **&amp;lt;float&amp;gt;** **&amp;lt;double&amp;gt;** 123&lt;int&gt;5555&lt;&#x2F;int&gt; 123&lt;class&gt;java.swing.JFrame&lt;&#x2F;class&gt; 1234&lt;array class&#x3D;&quot;java.lang.String&quot; length&#x3D;&quot;5&quot;&gt;&lt;&#x2F;array&gt; The following code represents an XML archive that will be generated for the SimpleBean component: 123456789101112131415161718&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;java&gt; &lt;object class&#x3D;&quot;javax.swing.JFrame&quot;&gt; &lt;void method&#x3D;&quot;add&quot;&gt; &lt;object class&#x3D;&quot;java.awt.BorderLayout&quot; field&#x3D;&quot;CENTER&quot;&#x2F;&gt; &lt;object class&#x3D;&quot;SimpleBean&quot;&#x2F;&gt; &lt;&#x2F;void&gt; &lt;void property&#x3D;&quot;defaultCloseOperation&quot;&gt; &lt;object class&#x3D;&quot;javax.swing.WindowConstants&quot; field&#x3D;&quot;DISPOSE_ON_CLOSE&quot;&#x2F;&gt; &lt;&#x2F;void&gt; &lt;void method&#x3D;&quot;pack&quot;&#x2F;&gt; &lt;void property&#x3D;&quot;visible&quot;&gt; &lt;boolean&gt;true&lt;&#x2F;boolean&gt; &lt;&#x2F;void&gt; &lt;&#x2F;object&gt;&lt;&#x2F;java&gt;","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Bean Persistence","date":"2020-12-05T17:47:20.096Z","path":"wiki/2021-03-03-Bean Persistence/","text":"Bean PersistenceA bean has the property of persistence when its properties, fields, and state information are saved to and retrieved from storage. Component models provide a mechanism for persistence that enables the state of components to be stored in a non-volatile place for later retrieval. The mechanism that makes persistence possible is called serialization. Object serialization means converting an object into a data stream and writing it to storage. Any applet, application, or tool that uses that bean can then “reconstitute” it by deserialization. The object is then restored to its original state. For example, a Java application can serialize a Frame window on a Microsoft Windows machine, the serialized file can be sent with e-mail to a Solaris machine, and then a Java application can restore the Frame window to the exact state which existed on the Microsoft Windows machine. Any applet, application, or tool that uses that bean can then “reconstitute” it by deserialization. All beans must persist. To persist, your beans must support serialization by implementing either thejava.io.Serializable (in the API reference documentation) interface, or thejava.io.Externalizable (in the API reference documentation) interface. These interfaces offer you the choices of automatic serialization and customized serialization. If any class in a class’s inheritance hierarchy implements Serializable or Externalizable, then that class is serializable. Classes That Are SerializableAny class is serializable as long as that class or a parent class implements the java.io.Serializable interface. Examples of serializable classes include Component, String, Date, Vector, and Hashtable. Thus, any subclass of the Component class, including Applet, can be serialized. Notable classes not supporting serialization include Image, Thread, Socket, and InputStream. Attempting to serialize objects of these types will result in an NotSerializableException. The Java Object Serialization API automatically serializes most fields of a Serializable object to the storage stream. This includes primitive types, arrays,and strings. The API does not serialize or deserialize fields that are marked transient or static. Controlling SerializationYou can control the level of serialization that your beans undergo. Three ways to control serilization are: Automatic serialization, implemented by the Serializable interface. The Java serialization software serializes the entire object, except transient and static fields. Customized serialization. Selectively exclude fields you do not want serialized by marking with the transient (or static) modifier. Customized file format, implemented by the Externalizable interface and its two methods. Beans are written in a specific file format. Default Serialization: The Serializable InterfaceThe Serializable interface provides automatic serialization by using the Java Object Serialization tools. Serializable declares no methods; it acts as a marker, telling the Object Serialization tools that your bean class is serializable. Marking your class Serializable means you are telling the Java Virtual Machine (JVM) that you have made sure your class will work with default serialization. Here are some important points about working with the Serializable interface: Classes that implement Serializable must have an access to a no-argument constructor of supertype. This constructor will be called when an object is “reconstituted” from a .ser file. You don’t need to implement Serializable in your class if it is already implemented in a superclass. All fields except static and transient fields are serialized. Use the transient modifier to specify fields you do not want serialized, and to specify classes that are not serializable. Selective Serialization Using the transient KeywordTo exclude fields from serialization in a Serializable object mark the fields with the transient modifier. 123transient int status; Default serialization will not serialize transient and static fields. Selective Serialization: writeObject and readObjectIf your serializable class contains either of the following two methods (the signatures must be exact), then the default serialization will not take place. 123456private void writeObject(java.io.ObjectOutputStream out) throws IOException;private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException; You can control how more complex objects are serialized, by writing your own implementations of the writeObject and readObject methods. Implement writeObject when you need to exercise greater control over what gets serialized when you need to serialize objects that default serialization cannot handle, or when you need to add data to the serialization stream that is not an object data member. Implement readObject to reconstruct the data stream you wrote with writeObject. The Externalizable InterfaceUse the Externalizable interface when you need complete control over your bean’s serialization (for example, when writing and reading a specific file format). To use the Externalizable interface you need to implement two methods: readExternal and writeExternal. Classes that implement Externalizable must have a no-argument constructor.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Advanced JavaBeans Topics","date":"2020-12-05T17:47:17.900Z","path":"wiki/2021-03-03-Advanced JavaBeans Topics/","text":"Lesson: Advanced JavaBeans TopicsGetting started with JavaBeans development is easy, but beans have surprising depth. This lesson covers some more advanced topics, including how beans can be stored (persisted) and how you can supply custom editors for custom data types. Bean Persistence describes the mechanisms for saving and reconstituting a bean. Long Term Persistence covers representing a bean as XML. Bean Customization provides an overview of creating editor components for custom data types.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Using a BeanInfo","date":"2020-12-05T17:47:16.406Z","path":"wiki/2021-03-03-Using a BeanInfo/","text":"Using a BeanInfoBeans, especially graphic components, can have a dizzying number of properties. If your class inherits from Component, or JComponent, or other Swing classes, it will have over one hundred properties already. Although a builder tool like NetBeans makes it easy to edit bean properties, it can be hard to find the right properties to edit, especially for inexperienced programmers. Overview of BeanInfoA BeanInfo is a class that changes how your bean appears in a builder tool. A builder tool can query the BeanInfo to find out which properties it should display first and which should be hidden. The BeanInfo class for your bean should have the same name as the bean class, with BeanInfo appended. For example, the FaceBean class has a corresponding FaceBeanBeanInfo class that describes it. Although it is possible to implement a BeanInfo class “by hand,” you will find it is much easier to use a tool like NetBeans to edit the BeanInfo. Creating a BeanInfo in NetBeansIn the Projects pane, Control-click on the name of your bean class and choose BeanInfo Editor… from the popup menu. NetBeans notices you don’t have a BeanInfo and asks if you want to create one. Click Yes. NetBeans creates a new class and drops you into the source code editor. Click on Designer to switch to a visual editor. Select properties from the list in the left side of the visual editor, then edit its attributes in the right side. If you don’t want a particular property to appear to a developer using a builder tool, click Hidden. To signal that a property should be shown before others, click Preferred. You can also indicate if a property is bound or constrained. You can provide similar information for the bean’s event sources and methods. When a builder tool loads your bean class to add it to a palette, it will automatically find the corresponding BeanInfo and use it to decide how to present your bean to the developer.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Events","date":"2020-12-05T17:47:14.175Z","path":"wiki/2021-03-03-Events/","text":"EventsA bean class can fire off any type of event, including custom events. As with properties, events are identified by a specific pattern of method names. 1234public void add*&lt;Event&gt;*Listener(*&lt;Event&gt;*Listener a)public void remove*&lt;Event&gt;*Listener(*&lt;Event&gt;*Listener a) The listener type must be a descendant of java.util.EventListener. For example, a Swing JButton is a bean that fires action events when the user clicks on it. JButton includes the following methods (actually inherited from AbstractButton), which are the bean pattern for an event: 1234public void addActionListener(ActionListener l);public void removeActionListener(ActionListener l); Bean events are recognized by builder tools and can be used in wiring components together. For example, you can wire a button’s action event to make something happen, like invoking another bean’s method.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Methods","date":"2020-12-05T17:47:11.969Z","path":"wiki/2021-03-03-Methods/","text":"MethodsA bean’s methods are the things it can do. Any public method that is not part of a property definition is a bean method. When you use a bean in the context of a builder tool like NetBeans, you can use a bean’s methods as part of your application. For example, you could wire a button press to call one of your bean’s methods.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Properties","date":"2020-12-05T17:47:09.766Z","path":"wiki/2021-03-03-Properties/","text":"PropertiesTo define a property in a bean class, supply public getter and setter methods. For example, the following methods define an int property called mouthWidth: 12345678910111213public class FaceBean &#123; private int mMouthWidth &#x3D; 90; public int getMouthWidth() &#123; return mMouthWidth; &#125; public void setMouthWidth(int mw) &#123; mMouthWidth &#x3D; mw; &#125;&#125; A builder tool like NetBeans recognizes the method names and shows the mouthWidth property in its list of properties. It also recognizes the type, int, and provides an appropriate editor so the property can be manipulated at design time. This example shows a property than can be read and written. Other combinations are also possible. A read-only property, for example, has a getter method but no setter. A write-only property has a setter method only. A special case for boolean properties allows the accessor method to be defined using is instead of get. For example, the accessor for a boolean property running could be as follows: 12345public boolean isRunning() &#123; &#x2F;&#x2F; ...&#125; Various specializations of basic properties are available and described in the following sections. Indexed PropertiesAn indexed property is an array instead of a single value. In this case, the bean class provides a method for getting and setting the entire array. Here is an example for an int[] property called testGrades: 123456789public int[] getTestGrades() &#123; return mTestGrades;&#125;public void setTestGrades(int[] tg) &#123; mTestGrades &#x3D; tg;&#125; For indexed properties, the bean class also provides methods for getting and setting a specific element of the array. 123456789public int getTestGrades(int index) &#123; return mTestGrades[index];&#125;public void setTestGrades(int index, int grade) &#123; mTestGrades[index] &#x3D; grade;&#125; Bound PropertiesA bound property notifies listeners when its value changes. This has two implications: The bean class includes addPropertyChangeListener() and removePropertyChangeListener() methods for managing the bean’s listeners. When a bound property is changed, the bean sends a PropertyChangeEvent to its registered listeners. PropertyChangeEvent and PropertyChangeListener live in the java.beans package. The java.beans package also includes a class, PropertyChangeSupport, that takes care of most of the work of bound properties. This handy class keeps track of property listeners and includes a convenience method that fires property change events to all registered listeners. The following example shows how you could make the mouthWidth property a bound property using PropertyChangeSupport. The necessary additions for the bound property are shown in bold. 123456789101112131415161718192021222324252627282930**import java.beans.*;**public class FaceBean &#123; private int mMouthWidth &#x3D; 90; &lt;b&gt;private PropertyChangeSupport mPcs &#x3D; new PropertyChangeSupport(this);&lt;&#x2F;b&gt; public int getMouthWidth() &#123; return mMouthWidth; &#125; public void setMouthWidth(int mw) &#123; **int oldMouthWidth &#x3D; mMouthWidth;** mMouthWidth &#x3D; mw; &lt;b&gt;mPcs.firePropertyChange(&quot;mouthWidth&quot;, oldMouthWidth, mw);&lt;&#x2F;b&gt; &#125; &lt;b&gt;public void addPropertyChangeListener(PropertyChangeListener listener) &#123; mPcs.addPropertyChangeListener(listener); &#125; public void removePropertyChangeListener(PropertyChangeListener listener) &#123; mPcs.removePropertyChangeListener(listener); &#125;&lt;&#x2F;b&gt;&#125; Bound properties can be tied directly to other bean properties using a builder tool like NetBeans. You could, for example, take the value property of a slider component and bind it to the mouthWidth property shown in the example. NetBeans allows you to do this without writing any code. Constrained PropertiesA constrained property is a special kind of bound property. For a constrained property, the bean keeps track of a set of veto listeners. When a constrained property is about to change, the listeners are consulted about the change. Any one of the listeners has a chance to veto the change, in which case the property remains unchanged. The veto listeners are separate from the property change listeners. Fortunately, the java.beans package includes a VetoableChangeSupport class that greatly simplifies constrained properties. Changes to the mouthWidth example are shown in bold: 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.beans.*;public class FaceBean &#123; private int mMouthWidth &#x3D; 90; private PropertyChangeSupport mPcs &#x3D; new PropertyChangeSupport(this); &lt;b&gt;private VetoableChangeSupport mVcs &#x3D; new VetoableChangeSupport(this);&lt;&#x2F;b&gt; public int getMouthWidth() &#123; return mMouthWidth; &#125; public void setMouthWidth(int mw) **throws PropertyVetoException** &#123; int oldMouthWidth &#x3D; mMouthWidth; &lt;b&gt;mVcs.fireVetoableChange(&quot;mouthWidth&quot;, oldMouthWidth, mw);&lt;&#x2F;b&gt; mMouthWidth &#x3D; mw; mPcs.firePropertyChange(&quot;mouthWidth&quot;, oldMouthWidth, mw); &#125; public void addPropertyChangeListener(PropertyChangeListener listener) &#123; mPcs.addPropertyChangeListener(listener); &#125; public void removePropertyChangeListener(PropertyChangeListener listener) &#123; mPcs.removePropertyChangeListener(listener); &#125; &lt;b&gt;public void addVetoableChangeListener(VetoableChangeListener listener) &#123; mVcs.addVetoableChangeListener(listener); &#125; public void removeVetoableChangeListener(VetoableChangeListener listener) &#123; mVcs.removeVetoableChangeListener(listener); &#125;&lt;&#x2F;b&gt;&#125; Development Support in NetBeansThe coding patterns for creating bean properties are straightforward, but sometimes it’s hard to tell if you are getting everything correct. NetBeans has support for property patterns so you can immediately see results as you are writing code. To take advantage of this feature, look at the Navigator pane, which is typically in the lower left corner of the NetBeans window. Normally, this pane is in Members View mode, which shows all the methods and fields defined in the current class. Click on the combo box to switch to Bean Patterns view. You will see a list of the properties that NetBeans can infer from your method definitions. NetBeans updates this list as you type, making it a handy way to check your work. In the following example, NetBeans has found the read-write mouthWidth property and the read-write indexed testGrades property. In addition, NetBeans has recognized that FaceBean allows registration of both PropertyChangeListeners and VetoableChangeListeners.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Writing JavaBeans Components","date":"2020-12-05T17:47:08.676Z","path":"wiki/2021-03-03-Writing JavaBeans Components/","text":"Lesson: Writing JavaBeans ComponentsWriting JavaBeans components is surprisingly easy. You don’t need a special tool and you don’t have to implement any interfaces. Writing beans is simply a matter of following certain coding conventions. All you have to do is make your class look like a bean &#8212; tools that use beans will be able to recognize and use your bean. However, NetBeans provides some features that make it easier to write beans. In addition, the Java SE API includes some support classes to help implement common tasks. The code examples in this lesson are based on a simple graphic component called FaceBean. A bean is a Java class with method names that follow the JavaBeans guidelines. A bean builder tool uses introspection to examine the bean class. Based on this inspection, the bean builder tool can figure out the bean’s properties, methods, and events. The following sections describe the JavaBeans guidelines for properties, methods, and events. Finally, a section onBeanInfo shows how you can customize the developer’s experience with your bean.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Using a Third-Party Bean","date":"2020-12-05T17:47:07.174Z","path":"wiki/2021-03-03-Using a Third-Party Bean/","text":"Using a Third-Party BeanAlmost any code can be packaged as a bean. The beans you have seen so far are all visual beans, but beans can provide functionality without having a visible component. The power of JavaBeans is that you can use software components without having to write them or understand their implementation. This page describes how you can add a JavaBean to your application and take advantage of its functionality. Adding a Bean to the NetBeans PaletteDownloadan example JavaBean component, &lt;code&gt;BumperSticker. Beans are distributed as JAR files. Save the file somewhere on your computer. BumperSticker is graphic component and exposes one method, go(), that kicks off an animation. To add BumperSticker to the NetBeans palette, choose Tools &gt; Palette &gt; Swing/AWT Components from the NetBeans menu. Click on the Add from JAR… button. NetBeans asks you to locate the JAR file that contains the beans you wish to add to the palette. Locate the file you just downloaded and click Next. NetBeans shows a list of the classes in the JAR file. Choose the ones you wish you add to the palette. In this case, select BumperSticker and click Next. Finally, NetBeans needs to know which section of the palette will receive the new beans. Choose Beans and click Finish. Click Close to make the Palette Manager window go away. Now take a look in the palette. BumperSticker is there in the Beans section. Using Your New JavaBeanGo ahead and drag BumperSticker out of the palette and into your form. You can work with the BumperSticker instance just as you would work with any other bean. To see this in action, drag another button out into the form. This button will kick off the BumperSticker‘s animation. Wire the button to the BumperSticker bean, just as you already wired the first button to the text field. Begin by clicking on the Connection Mode button. Click on the second button. NetBeans gives it a red outline. Click on the BumperSticker component. The Connection Wizard pops up. Click on the + next to action and select actionPerformed. Click Next &gt;. Select Method Call, then select go() from the list. Click Finish. If you’re unsure of any of the steps, review Wiring the Application. The process here is very similar. Run the application again. When you click on the second button, the BumperSticker component animates the color of the heart. Again, notice how you have produced a functioning application without writing any code.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Wiring the Application","date":"2020-12-05T17:47:04.870Z","path":"wiki/2021-03-03-Wiring the Application/","text":"Wiring the ApplicationTo wire the button and the label together, click on the Connection Mode button in the visual designer toolbar. Click on the button in the SnapFrame form. NetBeans outlines the button in red to show that it is the component that will be generating an event. Click on the label. NetBeans’ Connection Wizard pops up. First you will choose the event you wish to respond to. For the button, this is the action event. Click on the + next to action and select actionPerformed. Click Next &gt;. Now you get to choose what happens when the button fires its action event. The Connection Wizard lists all the properites in the label bean. Select text in the list and click Next. In the final screen of the Connection Wizard, fill in the value you wish to set for the text property. Click on Value, then type You pressed the button! or something just as eloquent. Click Finish. NetBeans wires the components together and shows you its handiwork in the source code editor. Click on the Design button in the source code toolbar to return to the UI designer. Click Run Main Project or press F6 to build and run your project. NetBeans builds and runs the project. It asks you to identify the main class, which is SnapFrame. When the application window pops up, click on the button. You’ll see your immortal prose in the label. Notice that you did not write any code. This is the real power of JavaBeans &#8212; with a good builder tool like NetBeans, you can quickly wire together components to create a running application.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"A Button is a Bean","date":"2020-12-05T17:47:02.614Z","path":"wiki/2021-03-03-A Button is a Bean/","text":"A Button is a BeanTake a closer look at the Palette. All of the components listed are beans. The components are grouped by function. Scroll to find the Swing Controls group, then click on Button and drag it over into the visual designer. The button is a bean! Under the palette on the right side of NetBeans is an inspector pane that you can use to examine and manipulate the button. Try closing the output window at the bottom to give the inspector pane more space. PropertiesThe properties of a bean are the things you can change that affect its appearance or internal state. For the button in this example, the properties include the foreground color, the font, and the text that appears on the button. The properties are shown in two groups. Properties lists the most frequently used properties, while Other Properties shows less commonly used properties. Go ahead and edit the button’s properties. For some properties, you can type values directly into the table. For others, click on the … button to edit the value. For example, click on … to the right of the foreground property. A color chooser dialog pops up and you can choose a new color for the foreground text on the button. Try some other properties to see what happens. Notice you are not writing any code. EventsBeans can also fire events. Click on the Events button in the bean properties pane. You’ll see a list of every event that the button is capable of firing. You can use NetBeans to hook up beans using their events and properties. To see how this works, drag a Label out of the palette into the visual designer for SnapFrame. Edit the label’s properties until it looks just perfect.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Creating a Project","date":"2020-12-05T17:47:00.389Z","path":"wiki/2021-03-03-Creating a Project/","text":"Creating a ProjectThe easiest way to learn about JavaBeans is to start using them. To begin, download and install the latest version of NetBeans. This tutorial describes how to use NetBeans version 7.0. NetBeans is a bean builder tool, which means it recognizes JavaBeans components (beans) and enables you to snap components together into an application with ease. A Button is a BeanStart NetBeans. Choose File &gt; New Project… from the menu. Select Java from the Categories list and select Java Application from the Projects list. Click Next &gt;. Enter SnapApp as the application name. Uncheck Create Main Class and click Finish. NetBeans creates the new project and you can see it in NetBeans’ Projects pane: Control-click on the SnapApp project and choose New &gt; JFrame Form… from the popup menu. Fill in SnapFrame for the class name and snapapp as the package. Click Finish. NetBeans creates the new class and shows its visual designer: In the Projects pane on the left, you can see the newly created SnapFrame class. In the center of the screen is the NetBeans visual designer. On the right side is the Palette, which contains all the components you can add to the frame in the visual designer.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Quick Start","date":"2020-12-05T17:46:58.176Z","path":"wiki/2021-03-03-Quick Start/","text":"Lesson: Quick StartThis lesson describes how to use NetBeans to build a simple application. With a good tool like NetBeans, you can assemble JavaBeans components into an application without having to write any code. The first three pages of this lesson show how to create a simple application using graphic beans that are part of the Java platform. The last page demonstrates how easy it is to incorporate a third-party bean into your application. Creating a Project describes the steps for setting up a new project in NetBeans. A Button is a Bean shows how to add a bean to the application’s user interface and describes properties and events. Wiring the Application covers using NetBeans to respond to bean events in your application. Using a Third-Party Bean show how easy it is to add a new bean to the palette and use it in your application.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"JavaBeans(TM)","date":"2020-12-05T17:46:56.412Z","path":"wiki/2021-03-03-JavaBeans(TM)/","text":"Trail: JavaBeans(TM)JavaBeans&#8482; makes it easy to reuse software components. Developers can use software components written by others without having to understand their inner workings. To understand why software components are useful, think of a worker assembling a car. Instead of building a radio from scratch, for example, she simply obtains a radio and hooks it up with the rest of the car. This trail describes JavaBeans using the following lessons: Quick Start provides a speedy introduction to JavaBeans by showing how to build applications with NetBeans. Writing JavaBeans Components describes the coding patterns used for bean properties, methods, and events. It also outlines the use of a BeanInfo to customize the development experience in a builder tool. Advanced JavaBeans Topics covers bean persistence, long term persistence, and customization.","tags":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"}],"categories":[{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"}]},{"title":"Running the Example Programs","date":"2020-12-05T17:43:31.562Z","path":"wiki/2021-03-03-Running the Example Programs/","text":"Trail: Security Features in Java SEIn this trail you’ll learn how the built-in Java&#8482; security features protect you from malevolent programs. You’ll see how to use tools to control access to resources, to generate and to check digital signatures, and to create and to manage keys needed for signature generation and checking. You’ll also see how to incorporate cryptography services, such as digital signature generation and checking, into your programs. The security features provided by the Java Development Kit (JDK&#8482;) are intended for a variety of audiences: **Users running programs**: Built-in security functionality protects you from malevolent programs (including viruses), maintains the privacy of your files and information about you, and authenticates the identity of each code provider. You can subject applications and applets to security controls when you need to. **Developers**: You can use API methods to incorporate security functionality into your programs, including cryptography services and security checks. The API framework enables you to define and integrate your own permissions (controlling access to specific resources), cryptography service implementations, security manager implementations, and policy implementations. In addition, classes are provided for management of your public/private key pairs and public key certificates from people you trust. **Systems administrators, developers, and users**: JDK tools manage your keystore (database of keys and certificates); generate digital signatures for JAR files, and verify the authenticity of such signatures and the integrity of the signed contents; and create and modify the policy files that define your installation's security policy. Trail Lessons&#160;Creating a Policy File shows how resource accesses can be controlled by a policy file. For latest information on policy configuration files, see Policy Guide page. &#160;Quick Tour of Controlling Applications builds on the previous lesson, showing how resource accesses, such as reading or writing a file, are not permitted for applications that are run under a security manager unless explicitly allowed by a permission in a policy file. &#160;API and Tools Use for Secure Code and File Exchanges defines digital signatures, certificates, and keystores and discusses why they are needed. It also reviews information applicable to the next three lessons regarding the steps commonly needed for using the tools or the API to generate signatures, export/import certificates, and so on. &#160;Signing Code and Granting It Permissions illustrates the use of all the security-related tools. It shows the steps that a developer would take to sign and to distribute code for others to run. The lesson also shows how someone who will run the code (or a system administrator) could add an entry in a policy file to grant the code permission for the resource accesses it needs. &#160;Exchanging Files shows use of the tools by one person to sign an important document, such as a contract, and to export the public key certificate for the public key corresponding to the private key used to sign the contract. Then the lesson shows how another person, who receives the contract, the signature, and the public key certificate, can import the certificate and verify the signature. &#160;Generating and Verifying Signatures walks you step by step through an example of writing a Java program using the JDK Security API to generate keys, to generate a digital signature for data using the private key, and to export the public key and the signature to files. Then the example shows writing a second program, which may be expected to run on a different person’s computer, that imports the public key and verifies the authenticity of the signature. Finally, the example discusses potential weaknesses of the approach used by the basic programs and demonstrates possible alternative approaches and methods of supplying and importing keys, including in certificates. &#160;Implementing Your Own Permission demonstrates how to write a class that defines its own special permission. For More InformationJDK security release documentation can be found at theSecurity guides page. This index page lists Specifications which present detailed information about latest security features, including architecture specifications, usage guides, API documentation, and tool documentation.","tags":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/tags/RMI/"}],"categories":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/categories/RMI/"}]},{"title":"Compiling the Example Programs","date":"2020-12-05T17:43:30.270Z","path":"wiki/2021-03-03-Compiling the Example Programs/","text":"Running the Example ProgramsA Note About SecurityThe server and client programs run with a security manager installed. When you run either program, you need to specify a security policy file so that the code is granted the security permissions it needs to run. Here is an example policy file to use with the server program: 12345grant codeBase &quot;file:&#x2F;home&#x2F;ann&#x2F;src&#x2F;&quot; &#123; permission java.security.AllPermission;&#125;; Here is an example policy file to use with the client program: 12345grant codeBase &quot;file:&#x2F;home&#x2F;jones&#x2F;src&#x2F;&quot; &#123; permission java.security.AllPermission;&#125;; For both example policy files, all permissions are granted to the classes in the program’s local class path, because the local application code is trusted, but no permissions are granted to code downloaded from other locations. Therefore, the compute engine server restricts the tasks that it executes (whose code is not known to be trusted and might be hostile) from performing any operations that require security permissions. The example client’s Pi task does not require any permissions to execute. In this example, the policy file for the server program is named server.policy, and the policy file for the client program is named client.policy. Starting the ServerBefore starting the compute engine, you need to start the RMI registry. The RMI registry is a simple server-side bootstrap naming facility that enables remote clients to obtain a reference to an initial remote object. It can be started with the rmiregistry command. Before you execute rmiregistry, you must make sure that the shell or window in which you will run rmiregistry either has no CLASSPATH environment variable set or has a CLASSPATH environment variable that does not include the path to any classes that you want downloaded to clients of your remote objects. To start the registry on the server, execute the rmiregistry command. This command produces no output and is typically run in the background. For this example, the registry is started on the host mycomputer. Microsoft Windows (use javaw if start is not available): 123start rmiregistry Solaris OS or Linux: 123rmiregistry &amp; By default, the registry runs on port 1099. To start the registry on a different port, specify the port number on the command line. Do not forget to unset your CLASSPATH environment variable. Microsoft Windows: 123start rmiregistry 2001 Solaris OS or Linux: 123rmiregistry 2001 &amp; Once the registry is started, you can start the server. You need to make sure that both the compute.jar file and the remote object implementation class are in your class path. When you start the compute engine, you need to specify, using the java.rmi.server.codebase property, where the server’s classes are network accessible. In this example, the server-side classes to be made available for downloading are the Compute and Task interfaces, which are available in the compute.jar file in the public_html\\classes directory of user ann. The compute engine server is started on the host mycomputer, the same host on which the registry was started. Microsoft Windows: 1234567java -cp c:\\home\\ann\\src;c:\\home\\ann\\public_html\\classes\\compute.jar -Djava.rmi.server.codebase&#x3D;file:&#x2F;c:&#x2F;home&#x2F;ann&#x2F;public_html&#x2F;classes&#x2F;compute.jar -Djava.rmi.server.hostname&#x3D;mycomputer.example.com -Djava.security.policy&#x3D;server.policy engine.ComputeEngine Solaris OS or Linux: 1234567java -cp &#x2F;home&#x2F;ann&#x2F;src:&#x2F;home&#x2F;ann&#x2F;public_html&#x2F;classes&#x2F;compute.jar -Djava.rmi.server.codebase&#x3D;http:&#x2F;&#x2F;mycomputer&#x2F;~ann&#x2F;classes&#x2F;compute.jar -Djava.rmi.server.hostname&#x3D;mycomputer.example.com -Djava.security.policy&#x3D;server.policy engine.ComputeEngine The above java command defines the following system properties: The java.rmi.server.codebase property specifies the location, a codebase URL, from which the definitions for classes originating from this server can be downloaded. If the codebase specifies a directory hierarchy (as opposed to a JAR file), you must include a trailing slash at the end of the codebase URL. The java.rmi.server.hostname property specifies the host name or address to put in the stubs for remote objects exported in this Java virtual machine. This value is the host name or address used by clients when they attempt to communicate remote method invocations. By default, the RMI implementation uses the server’s IP address as indicated by the java.net.InetAddress.getLocalHost API. However, sometimes, this address is not appropriate for all clients and a fully qualified host name would be more effective. To ensure that RMI uses a host name (or IP address) for the server that is routable from all potential clients, set the java.rmi.server.hostname property. The java.security.policy property is used to specify the policy file that contains the permissions you intend to grant. Starting the ClientOnce the registry and the compute engine are running, you can start the client, specifying the following: The location where the client serves its classes (the Pi class) by using the java.rmi.server.codebase property The java.security.policy property, which is used to specify the security policy file that contains the permissions you intend to grant to various pieces of codeAs command-line arguments, the host name of the server (so that the client knows where to locate the `Compute` remote object) and the number of decimal places to use in the calculation Start the client on another host (a host named mysecondcomputer, for example) as follows: Microsoft Windows: 123456java -cp c:\\home\\jones\\src;c:\\home\\jones\\public_html\\classes\\compute.jar -Djava.rmi.server.codebase&#x3D;file:&#x2F;c:&#x2F;home&#x2F;jones&#x2F;public_html&#x2F;classes&#x2F; -Djava.security.policy&#x3D;client.policy client.ComputePi mycomputer.example.com 45 Solaris OS or Linux: 123456java -cp &#x2F;home&#x2F;jones&#x2F;src:&#x2F;home&#x2F;jones&#x2F;public_html&#x2F;classes&#x2F;compute.jar -Djava.rmi.server.codebase&#x3D;http:&#x2F;&#x2F;mysecondcomputer&#x2F;~jones&#x2F;classes&#x2F; -Djava.security.policy&#x3D;client.policy client.ComputePi mycomputer.example.com 45 Note that the class path is set on the command line so that the interpreter can find the client classes and the JAR file containing the interfaces. Also note that the value of the java.rmi.server.codebase property, which specifies a directory hierarchy, ends with a trailing slash. After you start the client, the following output is displayed: 1233.141592653589793238462643383279502884197169399 The following figure illustrates where the rmiregistry, the ComputeEngine server, and the ComputePi client obtain classes during program execution. When the ComputeEngine server binds its remote object reference in the registry, the registry downloads the Compute and Task interfaces on which the stub class depends. These classes are downloaded from either the ComputeEngine server’s web server or file system, depending on the type of codebase URL used when starting the server. Because the ComputePi client has both the Compute and the Task interfaces available in its class path, it loads their definitions from its class path, not from the server’s codebase. Finally, the Pi class is loaded into the ComputeEngine server’s Java virtual machine when the Pi object is passed in the executeTask remote call to the ComputeEngine object. The Pi class is loaded by the server from either the client’s web server or file system, depending on the type of codebase URL used when starting the client.","tags":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/tags/RMI/"}],"categories":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/categories/RMI/"}]},{"title":"Compiling and Running the Example","date":"2020-12-05T17:43:28.116Z","path":"wiki/2021-03-03-Compiling and Running the Example/","text":"Compiling the Example ProgramsIn a real-world scenario in which a service such as the compute engine is deployed, a developer would likely create a Java Archive (JAR) file that contains the Compute and Task interfaces for server classes to implement and client programs to use. Next, a developer, perhaps the same developer of the interface JAR file, would write an implementation of the Compute interface and deploy that service on a machine available to clients. Developers of client programs can use the Compute and the Task interfaces, contained in the JAR file, and independently develop a task and client program that uses a Compute service. In this section, you learn how to set up the JAR file, server classes, and client classes. You will see that the client’s Pi class will be downloaded to the server at runtime. Also, the Compute and Task interfaces will be downloaded from the server to the registry at runtime. This example separates the interfaces, remote object implementation, and client code into three packages: `compute` &#8211; [`Compute`](examples/compute/Compute.java) and [`Task`](examples/compute/Task.java) interfaces `engine` &#8211; [`ComputeEngine`](examples/engine/ComputeEngine.java) implementation class `client` &#8211; [`ComputePi`](examples/client/ComputePi.java) client code and [`Pi`](examples/client/Pi.java) task implementation First, you need to build the interface JAR file to provide to server and client developers. Building a JAR File of Interface ClassesFirst, you need to compile the interface source files in the compute package and then build a JAR file that contains their class files. Assume that user waldo has written these interfaces and placed the source files in the directory c:\\home\\waldo\\src\\compute on Windows or the directory /home/waldo/src/compute on Solaris OS or Linux. Given these paths, you can use the following commands to compile the interfaces and create the JAR file: Microsoft Windows: 12345cd c:\\home\\waldo\\srcjavac compute\\Compute.java compute\\Task.javajar cvf compute.jar compute\\*.class Solaris OS or Linux: 12345cd &#x2F;home&#x2F;waldo&#x2F;srcjavac compute&#x2F;Compute.java compute&#x2F;Task.javajar cvf compute.jar compute&#x2F;*.class","tags":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/tags/RMI/"}],"categories":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/categories/RMI/"}]},{"title":"Creating a Client Program","date":"2020-12-05T17:43:25.740Z","path":"wiki/2021-03-03-Creating a Client Program/","text":"Compiling and Running the ExampleNow that the code for the compute engine example has been written, it needs to be compiled and run. Compiling the Example Programs In this section, you learn how to compile the server and the client programs that make up the compute engine example. Running the Example Programs Finally, you run the server and client programs and consequently compute the value of.","tags":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/tags/RMI/"}],"categories":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/categories/RMI/"}]},{"title":"Implementing a Remote Interface","date":"2020-12-05T17:43:23.332Z","path":"wiki/2021-03-03-Implementing a Remote Interface/","text":"Creating a Client ProgramThe compute engine is a relatively simple program: it runs tasks that are handed to it. The clients for the compute engine are more complex. A client needs to call the compute engine, but it also has to define the task to be performed by the compute engine. Two separate classes make up the client in our example. The first class, ComputePi, looks up and invokes a Compute object. The second class, Pi, implements the Task interface and defines the work to be done by the compute engine. The job of the Pi class is to compute the value of to some number of decimal places. The non-remote&lt;code&gt;Task interface is defined as follows: 1234567package compute;public interface Task&lt;T&gt; &#123; T execute();&#125; The code that invokes a Compute object’s methods must obtain a reference to that object, create a Task object, and then request that the task be executed. The definition of the task class Pi is shown later. A Pi object is constructed with a single argument, the desired precision of the result. The result of the task execution is a java.math.BigDecimal representing calculated to the specified precision. Here is the source code for&lt;code&gt;client.ComputePi, the main client class: 123456789101112131415161718192021222324252627package client;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.math.BigDecimal;import compute.Compute;public class ComputePi &#123; public static void main(String args[]) &#123; if (System.getSecurityManager() &#x3D;&#x3D; null) &#123; System.setSecurityManager(new SecurityManager()); &#125; try &#123; String name &#x3D; &quot;Compute&quot;; Registry registry &#x3D; LocateRegistry.getRegistry(args[0]); Compute comp &#x3D; (Compute) registry.lookup(name); Pi task &#x3D; new Pi(Integer.parseInt(args[1])); BigDecimal pi &#x3D; comp.executeTask(task); System.out.println(pi); &#125; catch (Exception e) &#123; System.err.println(&quot;ComputePi exception:&quot;); e.printStackTrace(); &#125; &#125; &#125; Like the ComputeEngine server, the client begins by installing a security manager. This step is necessary because the process of receiving the server remote object’s stub could require downloading class definitions from the server. For RMI to download classes, a security manager must be in force. After installing a security manager, the client constructs a name to use to look up a Compute remote object, using the same name used by ComputeEngine to bind its remote object. Also, the client uses the LocateRegistry.getRegistry API to synthesize a remote reference to the registry on the server’s host. The value of the first command-line argument, args[0], is the name of the remote host on which the Compute object runs. The client then invokes the lookup method on the registry to look up the remote object by name in the server host’s registry. The particular overload of LocateRegistry.getRegistry used, which has a single String parameter, returns a reference to a registry at the named host and the default registry port, 1099. You must use an overload that has an int parameter if the registry is created on a port other than 1099. Next, the client creates a new Pi object, passing to the Pi constructor the value of the second command-line argument, args[1], parsed as an integer. This argument indicates the number of decimal places to use in the calculation. Finally, the client invokes the executeTask method of the Compute remote object. The object passed into the executeTask invocation returns an object of type BigDecimal, which the program stores in the variable result. Finally, the program prints the result. The following figure depicts the flow of messages among the ComputePi client, the rmiregistry, and the ComputeEngine. The Pi class implements the Task interface and computes the value of to a specified number of decimal places. For this example, the actual algorithm is unimportant. What is important is that the algorithm is computationally expensive, meaning that you would want to have it executed on a capable server. Here is the source code for&lt;code&gt;client.Pi, the class that implements the Task interface: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package client;import compute.Task;import java.io.Serializable;import java.math.BigDecimal;public class Pi implements Task&lt;BigDecimal&gt;, Serializable &#123; private static final long serialVersionUID &#x3D; 227L; &#x2F;** constants used in pi computation *&#x2F; private static final BigDecimal FOUR &#x3D; BigDecimal.valueOf(4); &#x2F;** rounding mode to use during pi computation *&#x2F; private static final int roundingMode &#x3D; BigDecimal.ROUND_HALF_EVEN; &#x2F;** digits of precision after the decimal point *&#x2F; private final int digits; &#x2F;** * Construct a task to calculate pi to the specified * precision. *&#x2F; public Pi(int digits) &#123; this.digits &#x3D; digits; &#125; &#x2F;** * Calculate pi. *&#x2F; public BigDecimal execute() &#123; return computePi(digits); &#125; &#x2F;** * Compute the value of pi to the specified number of * digits after the decimal point. The value is * computed using Machin&#39;s formula: * * pi&#x2F;4 &#x3D; 4*arctan(1&#x2F;5) - arctan(1&#x2F;239) * * and a power series expansion of arctan(x) to * sufficient precision. *&#x2F; public static BigDecimal computePi(int digits) &#123; int scale &#x3D; digits + 5; BigDecimal arctan1_5 &#x3D; arctan(5, scale); BigDecimal arctan1_239 &#x3D; arctan(239, scale); BigDecimal pi &#x3D; arctan1_5.multiply(FOUR).subtract( arctan1_239).multiply(FOUR); return pi.setScale(digits, BigDecimal.ROUND_HALF_UP); &#125; &#x2F;** * Compute the value, in radians, of the arctangent of * the inverse of the supplied integer to the specified * number of digits after the decimal point. The value * is computed using the power series expansion for the * arc tangent: * * arctan(x) &#x3D; x - (x^3)&#x2F;3 + (x^5)&#x2F;5 - (x^7)&#x2F;7 + * (x^9)&#x2F;9 ... *&#x2F; public static BigDecimal arctan(int inverseX, int scale) &#123; BigDecimal result, numer, term; BigDecimal invX &#x3D; BigDecimal.valueOf(inverseX); BigDecimal invX2 &#x3D; BigDecimal.valueOf(inverseX * inverseX); numer &#x3D; BigDecimal.ONE.divide(invX, scale, roundingMode); result &#x3D; numer; int i &#x3D; 1; do &#123; numer &#x3D; numer.divide(invX2, scale, roundingMode); int denom &#x3D; 2 * i + 1; term &#x3D; numer.divide(BigDecimal.valueOf(denom), scale, roundingMode); if ((i % 2) !&#x3D; 0) &#123; result &#x3D; result.subtract(term); &#125; else &#123; result &#x3D; result.add(term); &#125; i++; &#125; while (term.compareTo(BigDecimal.ZERO) !&#x3D; 0); return result; &#125;&#125; Note that all serializable classes, whether they implement the Serializable interface directly or indirectly, must declare a private static final field named serialVersionUID to guarantee serialization compatibility between versions. If no previous version of the class has been released, then the value of this field can be any long value, similar to the 227L used by Pi, as long as the value is used consistently in future versions. If a previous version of the class has been released without an explicit serialVersionUID declaration, but serialization compatibility with that version is important, then the default implicitly computed value for the previous version must be used for the value of the new version’s explicit declaration. The serialver tool can be run against the previous version to determine the default computed value for it. The most interesting feature of this example is that the Compute implementation object never needs the Pi class’s definition until a Pi object is passed in as an argument to the executeTask method. At that point, the code for the class is loaded by RMI into the Compute object’s Java virtual machine, the execute method is invoked, and the task’s code is executed. The result, which in the case of the Pi task is a BigDecimal object, is handed back to the calling client, where it is used to print the result of the computation. The fact that the supplied Task object computes the value of Pi is irrelevant to the ComputeEngine object. You could also implement a task that, for example, generates a random prime number by using a probabilistic algorithm. That task would also be computationally intensive and therefore a good candidate for passing to the ComputeEngine, but it would require very different code. This code could also be downloaded when the Task object is passed to a Compute object. In just the way that the algorithm for computing is brought in when needed, the code that generates the random prime number would be brought in when needed. The Compute object knows only that each object it receives implements the execute method. The Compute object does not know, and does not need to know, what the implementation does.","tags":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/tags/RMI/"}],"categories":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/categories/RMI/"}]},{"title":"Designing a Remote Interface","date":"2020-12-05T17:43:21.088Z","path":"wiki/2021-03-03-Designing a Remote Interface/","text":"Implementing a Remote InterfaceThis section discusses the task of implementing a class for the compute engine. In general, a class that implements a remote interface should at least do the following: Declare the remote interfaces being implemented Define the constructor for each remote object Provide an implementation for each remote method in the remote interfaces An RMI server program needs to create the initial remote objects and export them to the RMI runtime, which makes them available to receive incoming remote invocations. This setup procedure can be either encapsulated in a method of the remote object implementation class itself or included in another class entirely. The setup procedure should do the following: Create and install a security manager Create and export one or more remote objects Register at least one remote object with the RMI registry (or with another naming service, such as a service accessible through the Java Naming and Directory Interface) for bootstrapping purposes The complete implementation of the compute engine follows. The&lt;code&gt;engine.ComputeEngine class implements the remote interface Compute and also includes the main method for setting up the compute engine. Here is the source code for the ComputeEngine class: 123456789101112131415161718192021222324252627282930313233343536373839package engine;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.server.UnicastRemoteObject;import compute.Compute;import compute.Task;public class ComputeEngine implements Compute &#123; public ComputeEngine() &#123; super(); &#125; public &lt;T&gt; T executeTask(Task&lt;T&gt; t) &#123; return t.execute(); &#125; public static void main(String[] args) &#123; if (System.getSecurityManager() &#x3D;&#x3D; null) &#123; System.setSecurityManager(new SecurityManager()); &#125; try &#123; String name &#x3D; &quot;Compute&quot;; Compute engine &#x3D; new ComputeEngine(); Compute stub &#x3D; (Compute) UnicastRemoteObject.exportObject(engine, 0); Registry registry &#x3D; LocateRegistry.getRegistry(); registry.rebind(name, stub); System.out.println(&quot;ComputeEngine bound&quot;); &#125; catch (Exception e) &#123; System.err.println(&quot;ComputeEngine exception:&quot;); e.printStackTrace(); &#125; &#125;&#125; The following sections discuss each component of the compute engine implementation. Declaring the Remote Interfaces Being ImplementedThe implementation class for the compute engine is declared as follows: 123public class ComputeEngine implements Compute This declaration states that the class implements the Compute remote interface and therefore can be used for a remote object. The ComputeEngine class defines a remote object implementation class that implements a single remote interface and no other interfaces. The ComputeEngine class also contains two executable program elements that can only be invoked locally. The first of these elements is a constructor for ComputeEngine instances. The second of these elements is a main method that is used to create a ComputeEngine instance and make it available to clients. Defining the Constructor for the Remote ObjectThe ComputeEngine class has a single constructor that takes no arguments. The code for the constructor is as follows: 12345public ComputeEngine() &#123; super();&#125; This constructor just invokes the superclass constructor, which is the no-argument constructor of the Object class. Although the superclass constructor gets invoked even if omitted from the ComputeEngine constructor, it is included for clarity. Providing Implementations for Each Remote MethodThe class for a remote object provides implementations for each remote method specified in the remote interfaces. The Compute interface contains a single remote method, executeTask, which is implemented as follows: 12345public &lt;T&gt; T executeTask(Task&lt;T&gt; t) &#123; return t.execute();&#125; This method implements the protocol between the ComputeEngine remote object and its clients. Each client provides the ComputeEngine with a Task object that has a particular implementation of the Task interface’s execute method. The ComputeEngine executes each client’s task and returns the result of the task’s execute method directly to the client. Passing Objects in RMIArguments to or return values from remote methods can be of almost any type, including local objects, remote objects, and primitive data types. More precisely, any entity of any type can be passed to or from a remote method as long as the entity is an instance of a type that is a primitive data type, a remote object, or a serializable object, which means that it implements the interface java.io.Serializable. Some object types do not meet any of these criteria and thus cannot be passed to or returned from a remote method. Most of these objects, such as threads or file descriptors, encapsulate information that makes sense only within a single address space. Many of the core classes, including the classes in the packages java.lang and java.util, implement the Serializable interface. The rules governing how arguments and return values are passed are as follows: Remote objects are essentially passed by reference. A remote object reference is a stub, which is a client-side proxy that implements the complete set of remote interfaces that the remote object implements. Local objects are passed by copy, using object serialization. By default, all fields are copied except fields that are marked static or transient. Default serialization behavior can be overridden on a class-by-class basis. Passing a remote object by reference means that any changes made to the state of the object by remote method invocations are reflected in the original remote object. When a remote object is passed, only those interfaces that are remote interfaces are available to the receiver. Any methods defined in the implementation class or defined in non-remote interfaces implemented by the class are not available to that receiver. For example, if you were to pass a reference to an instance of the ComputeEngine class, the receiver would have access only to the compute engine’s executeTask method. That receiver would not see the ComputeEngine constructor, its main method, or its implementation of any methods of java.lang.Object. In the parameters and return values of remote method invocations, objects that are not remote objects are passed by value. Thus, a copy of the object is created in the receiving Java virtual machine. Any changes to the object’s state by the receiver are reflected only in the receiver’s copy, not in the sender’s original instance. Any changes to the object’s state by the sender are reflected only in the sender’s original instance, not in the receiver’s copy. Implementing the Server’s main MethodThe most complex method of the ComputeEngine implementation is the main method. The main method is used to start the ComputeEngine and therefore needs to do the necessary initialization and housekeeping to prepare the server to accept calls from clients. This method is not a remote method, which means that it cannot be invoked from a different Java virtual machine. Because the main method is declared static, the method is not associated with an object at all but rather with the class ComputeEngine. Creating and Installing a Security ManagerThe main method’s first task is to create and install a security manager, which protects access to system resources from untrusted downloaded code running within the Java virtual machine. A security manager determines whether downloaded code has access to the local file system or can perform any other privileged operations. If an RMI program does not install a security manager, RMI will not download classes (other than from the local class path) for objects received as arguments or return values of remote method invocations. This restriction ensures that the operations performed by downloaded code are subject to a security policy. Here’s the code that creates and installs a security manager: 12345if (System.getSecurityManager() &#x3D;&#x3D; null) &#123; System.setSecurityManager(new SecurityManager());&#125; Making the Remote Object Available to ClientsNext, the main method creates an instance of ComputeEngine and exports it to the RMI runtime with the following statements: 12345Compute engine &#x3D; new ComputeEngine();Compute stub &#x3D; (Compute) UnicastRemoteObject.exportObject(engine, 0); The static UnicastRemoteObject.exportObject method exports the supplied remote object so that it can receive invocations of its remote methods from remote clients. The second argument, an int, specifies which TCP port to use to listen for incoming remote invocation requests for the object. It is common to use the value zero, which specifies the use of an anonymous port. The actual port will then be chosen at runtime by RMI or the underlying operating system. However, a non-zero value can also be used to specify a specific port to use for listening. Once the exportObject invocation has returned successfully, the ComputeEngine remote object is ready to process incoming remote invocations. The exportObject method returns a stub for the exported remote object. Note that the type of the variable stub must be Compute, not ComputeEngine, because the stub for a remote object only implements the remote interfaces that the exported remote object implements. The exportObject method declares that it can throw a RemoteException, which is a checked exception type. The main method handles this exception with its try/catch block. If the exception were not handled in this way, RemoteException would have to be declared in the throws clause of the main method. An attempt to export a remote object can throw a RemoteException if the necessary communication resources are not available, such as if the requested port is bound for some other purpose. Before a client can invoke a method on a remote object, it must first obtain a reference to the remote object. Obtaining a reference can be done in the same way that any other object reference is obtained in a program, such as by getting the reference as part of the return value of a method or as part of a data structure that contains such a reference. The system provides a particular type of remote object, the RMI registry, for finding references to other remote objects. The RMI registry is a simple remote object naming service that enables clients to obtain a reference to a remote object by name. The registry is typically only used to locate the first remote object that an RMI client needs to use. That first remote object might then provide support for finding other objects. The java.rmi.registry.Registry remote interface is the API for binding (or registering) and looking up remote objects in the registry. The java.rmi.registry.LocateRegistry class provides static methods for synthesizing a remote reference to a registry at a particular network address (host and port). These methods create the remote reference object containing the specified network address without performing any remote communication. LocateRegistry also provides static methods for creating a new registry in the current Java virtual machine, although this example does not use those methods. Once a remote object is registered with an RMI registry on the local host, clients on any host can look up the remote object by name, obtain its reference, and then invoke remote methods on the object. The registry can be shared by all servers running on a host, or an individual server process can create and use its own registry. The ComputeEngine class creates a name for the object with the following statement: 123String name &#x3D; &quot;Compute&quot;; The code then adds the name to the RMI registry running on the server. This step is done later with the following statements: 1234Registry registry &#x3D; LocateRegistry.getRegistry();registry.rebind(name, stub); This rebind invocation makes a remote call to the RMI registry on the local host. Like any remote call, this call can result in a RemoteException being thrown, which is handled by the catch block at the end of the main method. Note the following about the Registry.rebind invocation: The no-argument overload of LocateRegistry.getRegistry synthesizes a reference to a registry on the local host and on the default registry port, 1099. You must use an overload that has an int parameter if the registry is created on a port other than 1099. When a remote invocation on the registry is made, a stub for the remote object is passed instead of a copy of the remote object itself. Remote implementation objects, such as instances of ComputeEngine, never leave the Java virtual machine in which they were created. Thus, when a client performs a lookup in a server’s remote object registry, a copy of the stub is returned. Remote objects in such cases are thus effectively passed by (remote) reference rather than by value. For security reasons, an application can only bind, unbind, or rebind remote object references with a registry running on the same host. This restriction prevents a remote client from removing or overwriting any of the entries in a server’s registry. A lookup, however, can be requested from any host, local or remote. Once the server has registered with the local RMI registry, it prints a message indicating that it is ready to start handling calls. Then, the main method completes. It is not necessary to have a thread wait to keep the server alive. As long as there is a reference to the ComputeEngine object in another Java virtual machine, local or remote, the ComputeEngine object will not be shut down or garbage collected. Because the program binds a reference to the ComputeEngine in the registry, it is reachable from a remote client, the registry itself. The RMI system keeps the ComputeEngine‘s process running. The ComputeEngine is available to accept calls and won’t be reclaimed until its binding is removed from the registry and no remote clients hold a remote reference to the ComputeEngine object. The final piece of code in the ComputeEngine.main method handles any exception that might arise. The only checked exception type that could be thrown in the code is RemoteException, either by the UnicastRemoteObject.exportObject invocation or by the registry rebind invocation. In either case, the program cannot do much more than exit after printing an error message. In some distributed applications, recovering from the failure to make a remote invocation is possible. For example, the application could attempt to retry the operation or choose another server to continue the operation.","tags":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/tags/RMI/"}],"categories":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/categories/RMI/"}]},{"title":"Writing an RMI Server","date":"2020-12-05T17:43:19.561Z","path":"wiki/2021-03-03-Writing an RMI Server/","text":"Designing a Remote InterfaceAt the core of the compute engine is a protocol that enables tasks to be submitted to the compute engine, the compute engine to run those tasks, and the results of those tasks to be returned to the client. This protocol is expressed in the interfaces that are supported by the compute engine. The remote communication for this protocol is illustrated in the following figure. Each interface contains a single method. The compute engine’s remote interface, Compute, enables tasks to be submitted to the engine. The client interface, Task, defines how the compute engine executes a submitted task. The&lt;code&gt;compute.Compute interface defines the remotely accessible part, the compute engine itself. Here is the source code for the Compute interface: 12345678910package compute;import java.rmi.Remote;import java.rmi.RemoteException;public interface Compute extends Remote &#123; &lt;T&gt; T executeTask(Task&lt;T&gt; t) throws RemoteException;&#125; By extending the interface java.rmi.Remote, the Compute interface identifies itself as an interface whose methods can be invoked from another Java virtual machine. Any object that implements this interface can be a remote object. As a member of a remote interface, the executeTask method is a remote method. Therefore, this method must be defined as being capable of throwing a java.rmi.RemoteException. This exception is thrown by the RMI system from a remote method invocation to indicate that either a communication failure or a protocol error has occurred. A RemoteException is a checked exception, so any code invoking a remote method needs to handle this exception by either catching it or declaring it in its throws clause. The second interface needed for the compute engine is the Task interface, which is the type of the parameter to the executeTask method in the Compute interface. The&lt;code&gt;compute.Task interface defines the interface between the compute engine and the work that it needs to do, providing the way to start the work. Here is the source code for the Task interface: 1234567package compute;public interface Task&lt;T&gt; &#123; T execute();&#125; The Task interface defines a single method, execute, which has no parameters and throws no exceptions. Because the interface does not extend Remote, the method in this interface doesn’t need to list java.rmi.RemoteException in its throws clause. The Task interface has a type parameter, T, which represents the result type of the task’s computation. This interface’s execute method returns the result of the computation and thus its return type is T. The Compute interface’s executeTask method, in turn, returns the result of the execution of the Task instance passed to it. Thus, the executeTask method has its own type parameter, T, that associates its own return type with the result type of the passed Task instance. RMI uses the Java object serialization mechanism to transport objects by value between Java virtual machines. For an object to be considered serializable, its class must implement the java.io.Serializable marker interface. Therefore, classes that implement the Task interface must also implement Serializable, as must the classes of objects used for task results. Different kinds of tasks can be run by a Compute object as long as they are implementations of the Task type. The classes that implement this interface can contain any data needed for the computation of the task and any other methods needed for the computation. Here is how RMI makes this simple compute engine possible. Because RMI can assume that the Task objects are written in the Java programming language, implementations of the Task object that were previously unknown to the compute engine are downloaded by RMI into the compute engine’s Java virtual machine as needed. This capability enables clients of the compute engine to define new kinds of tasks to be run on the server machine without needing the code to be explicitly installed on that machine. The compute engine, implemented by the ComputeEngine class, implements the Compute interface, enabling different tasks to be submitted to it by calls to its executeTask method. These tasks are run using the task’s implementation of the execute method and the results, are returned to the remote client.","tags":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/tags/RMI/"}],"categories":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/categories/RMI/"}]},{"title":"An Overview of RMI Applications","date":"2020-12-05T17:43:18.101Z","path":"wiki/2021-03-03-An Overview of RMI Applications/","text":"Writing an RMI ServerThe compute engine server accepts tasks from clients, runs the tasks, and returns any results. The server code consists of an interface and a class. The interface defines the methods that can be invoked from the client. Essentially, the interface defines the client’s view of the remote object. The class provides the implementation. Designing a Remote Interface This section explains the Compute interface, which provides the connection between the client and the server. You will also learn about the RMI API, which supports this communication. Implementing a Remote Interface This section explores the class that implements the Compute interface, thereby implementing a remote object. This class also provides the rest of the code that makes up the server program, including a main method that creates an instance of the remote object, registers it with the RMI registry, and sets up a security manager.","tags":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/tags/RMI/"}],"categories":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/categories/RMI/"}]},{"title":"RMI","date":"2020-12-05T17:43:16.590Z","path":"wiki/2021-03-03-RMI/","text":"An Overview of RMI ApplicationsRMI applications often comprise two separate programs, a server and a client. A typical server program creates some remote objects, makes references to these objects accessible, and waits for clients to invoke methods on these objects. A typical client program obtains a remote reference to one or more remote objects on a server and then invokes methods on them. RMI provides the mechanism by which the server and the client communicate and pass information back and forth. Such an application is sometimes referred to as a distributed object application. Distributed object applications need to do the following: Locate remote objects. Applications can use various mechanisms to obtain references to remote objects. For example, an application can register its remote objects with RMI’s simple naming facility, the RMI registry. Alternatively, an application can pass and return remote object references as part of other remote invocations. Communicate with remote objects. Details of communication between remote objects are handled by RMI. To the programmer, remote communication looks similar to regular Java method invocations. Load class definitions for objects that are passed around. Because RMI enables objects to be passed back and forth, it provides mechanisms for loading an object’s class definitions as well as for transmitting an object’s data. The following illustration depicts an RMI distributed application that uses the RMI registry to obtain a reference to a remote object. The server calls the registry to associate (or bind) a name with a remote object. The client looks up the remote object by its name in the server’s registry and then invokes a method on it. The illustration also shows that the RMI system uses an existing web server to load class definitions, from server to client and from client to server, for objects when needed. Advantages of Dynamic Code LoadingOne of the central and unique features of RMI is its ability to download the definition of an object’s class if the class is not defined in the receiver’s Java virtual machine. All of the types and behavior of an object, previously available only in a single Java virtual machine, can be transmitted to another, possibly remote, Java virtual machine. RMI passes objects by their actual classes, so the behavior of the objects is not changed when they are sent to another Java virtual machine. This capability enables new types and behaviors to be introduced into a remote Java virtual machine, thus dynamically extending the behavior of an application. The compute engine example in this trail uses this capability to introduce new behavior to a distributed program. Remote Interfaces, Objects, and MethodsLike any other Java application, a distributed application built by using Java RMI is made up of interfaces and classes. The interfaces declare methods. The classes implement the methods declared in the interfaces and, perhaps, declare additional methods as well. In a distributed application, some implementations might reside in some Java virtual machines but not others. Objects with methods that can be invoked across Java virtual machines are called remote objects. An object becomes remote by implementing a remote interface, which has the following characteristics: A remote interface extends the interface java.rmi.Remote. Each method of the interface declares java.rmi.RemoteException in its throws clause, in addition to any application-specific exceptions. RMI treats a remote object differently from a non-remote object when the object is passed from one Java virtual machine to another Java virtual machine. Rather than making a copy of the implementation object in the receiving Java virtual machine, RMI passes a remote stub for a remote object. The stub acts as the local representative, or proxy, for the remote object and basically is, to the client, the remote reference. The client invokes a method on the local stub, which is responsible for carrying out the method invocation on the remote object. A stub for a remote object implements the same set of remote interfaces that the remote object implements. This property enables a stub to be cast to any of the interfaces that the remote object implements. However, only those methods defined in a remote interface are available to be called from the receiving Java virtual machine. Creating Distributed Applications by Using RMIUsing RMI to develop a distributed application involves these general steps: Designing and implementing the components of your distributed application. Compiling sources. Making classes network accessible. Starting the application. Designing and Implementing the Application ComponentsFirst, determine your application architecture, including which components are local objects and which components are remotely accessible. This step includes: Defining the remote interfaces. A remote interface specifies the methods that can be invoked remotely by a client. Clients program to remote interfaces, not to the implementation classes of those interfaces. The design of such interfaces includes the determination of the types of objects that will be used as the parameters and return values for these methods. If any of these interfaces or classes do not yet exist, you need to define them as well. Implementing the remote objects. Remote objects must implement one or more remote interfaces. The remote object class may include implementations of other interfaces and methods that are available only locally. If any local classes are to be used for parameters or return values of any of these methods, they must be implemented as well. Implementing the clients. Clients that use remote objects can be implemented at any time after the remote interfaces are defined, including after the remote objects have been deployed. Compiling SourcesAs with any Java program, you use the javac compiler to compile the source files. The source files contain the declarations of the remote interfaces, their implementations, any other server classes, and the client classes. Making Classes Network AccessibleIn this step, you make certain class definitions network accessible, such as the definitions for the remote interfaces and their associated types, and the definitions for classes that need to be downloaded to the clients or servers. Classes definitions are typically made network accessible through a web server. Starting the ApplicationStarting the application includes running the RMI remote object registry, the server, and the client. The rest of this section walks through the steps used to create a compute engine. Building a Generic Compute EngineThis trail focuses on a simple, yet powerful, distributed application called a compute engine. The compute engine is a remote object on the server that takes tasks from clients, runs the tasks, and returns any results. The tasks are run on the machine where the server is running. This type of distributed application can enable a number of client machines to make use of a particularly powerful machine or a machine that has specialized hardware. The novel aspect of the compute engine is that the tasks it runs do not need to be defined when the compute engine is written or started. New kinds of tasks can be created at any time and then given to the compute engine to be run. The only requirement of a task is that its class implement a particular interface. The code needed to accomplish the task can be downloaded by the RMI system to the compute engine. Then, the compute engine runs the task, using the resources on the machine on which the compute engine is running. The ability to perform arbitrary tasks is enabled by the dynamic nature of the Java platform, which is extended to the network by RMI. RMI dynamically loads the task code into the compute engine’s Java virtual machine and runs the task without prior knowledge of the class that implements the task. Such an application, which has the ability to download code dynamically, is often called a behavior-based application. Such applications usually require full agent-enabled infrastructures. With RMI, such applications are part of the basic mechanisms for distributed computing on the Java platform.","tags":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/tags/RMI/"}],"categories":[{"name":"RMI","slug":"RMI","permalink":"http://example.com/categories/RMI/"}]},{"title":"Java SE 8 Upgrade Exam","date":"2020-12-05T17:38:40.155Z","path":"wiki/2021-03-03-Java SE 8 Upgrade Exam/","text":"Trail: Java Naming and Directory InterfaceThis trail describes JNDI&#8482; (Java Naming and Directory Interface) an API to access the directory and naming services. Here you learn about the basic naming and directory services and how to use JNDI to write simple applications to use these services. The most popular directory service LDAP is used to demostrate the use of JNDI to access the directory services. Naming and Directory Concepts Start here to get an overview of naming and directory concepts. JNDI Overview Gives you an overview of JNDI, its architecture and packaging. Software Setup Describes instructions and steps involved in setting an environment that is required to run the examples described in this trail as well as any other JNDI application. Naming and Directory Operations Describes various naming and directory operations and demonstrates them through plenty of examples that access naming/directory services using JNDI. Advanced Topics for LDAP users A specialized lesson for the LDAP users. It talks about modeling JNDI as an LDAP API, how to perform LDAP authentication, SSL and managing connections in production environments. Accessing Objects in the Directory Shows you how to integrate your application with the directory, so that you can store and retrieve Java objects to and from the directory. Features in JDK 5.0 and JDK 6 Introduces to the features in the JNDI and the LDAP Service Provider that are available in JDK 5.0 and JDK 6. Note: This tutorial trail is based on the standalone JNDI tutorial located at https://docs.oracle.com/javase/jndi/tutorial/. The standalone JNDI tutorial, last updated under Java 2 SDK, Standard Edition, v 1.4.2, provides comprehensive coverage on JNDI, but is no longer supported. This tutorial excerpts the basics from the standlone tutorial and includes features added to JNDI in the Java Platform Standard Edition 5.0 and 6 releases. The older JNDI tutorial is preserved as an archive on docs.oracle.com.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Java SE 8 Programmer II Exam","date":"2020-12-05T17:38:38.996Z","path":"wiki/2021-03-03-Java SE 8 Programmer II Exam/","text":"Java SE 8 Upgrade ExamThis page maps sections in the Java Tutorials to topics covered in the Upgrade to Java SE 8 OCP (Oracle Certified Professional) (Java SE 6 and all prior versions) and Upgrade Java SE 7 to Java SE 8 OCP exams. These exams are associated with the Oracle Certified Professional, Java SE 8 Programmer certificate. Upgrade to Java SE 8 OCP (Java SE 6 and all prior versions)The topics covered in this exam are: Language Enhancements Concurrency Localization Java File I/O (NIO.2) Lambda Java Collections Java Streams Section 1: LanguageEnhancements Item 1: Develop code that uses String objects in theswitch statement, binary literals, and numeric literals, includingunderscores in literals [The switch Statement](../../java/nutsandbolts/switch.html) [Primitive Data Types](../../java/nutsandbolts/datatypes.html) [Primitive Data Types](../../java/nutsandbolts/datatypes.html) Item 2: Develop code that uses try-with-resourcesstatements, including using classes that implement theAutoCloseable interface [The try-with-resources Statement](../../essential/exceptions/tryResourceClose.html) Item 3: Develop code that handles multiple Exceptiontypes in a single catch block [The catch Blocks](../../essential/exceptions/catch.html) Item 4: Use static and default methods of an interfaceincluding inheritance rules for a default method [Default Methods](../../java/IandI/defaultmethods.html) Section 2: ConcurrencyItem 1: Use classes from the java.util.concurrent packageincluding CyclicBarrier and CopyOnWriteArrayList with a focus onthe advantages over and differences from the traditional java.utilcollections Item 2: Use Lock, ReadWriteLock, and ReentrantLockclasses in the java.util.concurrent.locks andjava.util.concurrent.atomic packages to support lock-freethread-safe programming on single variables [Atomic Variables](../../essential/concurrency/atomicvars.html) Item 3: Use Executor, ExecutorService, Executors,Callable, and Future to execute tasks using thread pools [Executor Interfaces](../../essential/concurrency/exinter.html) Item 4: Use the parallel Fork/Join Framework [Fork/Join](../../essential/concurrency/forkjoin.html) Section 3: LocalizationItem 1: Describe the advantages of localizing anapplication and developing code that defines, reads, and sets thelocale with a Locale object [Introduction](../../i18n/intro/index.html) [Creating a Locale](../../i18n/locale/create.html) Item 2: Build a resource bundle for a locale and call aresource bundle from an application [Isolating Locale-Specific Data](../../i18n/resbundle/index.html) Item 3: Create and manage date- and time-based events byusing LocalDate, LocalTime, LocalDateTime, Instant, Period, andDuration, including a combination of date and time in a singleobject [Date Classes](../../datetime/iso/date.html) [Date and Time Classes](../../datetime/iso/datetime.html) [Instant Class](../../datetime/iso/instant.html) [Period and Duration](../../datetime/iso/period.html) Item 4: Format dates, numbers, and currency values forlocalization with the NumberFormat and DateFormat classes,including number and date format patterns [Numbers and Currencies](../../i18n/format/numberintro.html) [Dates and Times](../../i18n/format/dateintro.html) Item 5: Work with dates and times across time zones andmanage changes resulting from daylight savings [Time Zone and Offset Classes](../../datetime/iso/timezones.html) Section 4: Java File I/O (NIO.2)Item 1: Operate on file and directory paths by using thejava.nio.Path class [Path Operations](../../essential/io/pathOps.html) Item 2: Check, delete, copy, or move a file or directoryby using the java.nio.Files class [Checking a File or Directory](../../essential/io/check.html) [Deleting a File or Directory](../../essential/io/delete.html) [Copying a File or Directory](../../essential/io/copy.html) [Moving a File or Directory](../../essential/io/move.html) Item 3: Recursively access a directory tree by using theDirectoryStream and FileVisitor interfaces [Creating and Reading Directories](../../essential/io/dirs.html) [Walking the File Tree](../../essential/io/walk.html) Item 4: Find a file by using the PathMatcher interface,and use Java SE 8 I/O improvements, including Files.find,Files.walk, and Files.lines methods [Finding Files](../../essential/io/find.html) [Walking the File Tree](../../essential/io/walk.html) Item 5: Observe the changes in a directory by using theWatchService interface [Watching a Directory for Changes](../../essential/io/notification.html) Section 5: LambdaThe sectionsLambda Expressions andAggregate Operations cover some of the following items: Item 1: Define and write functional interfaces anddescribe the interfaces of the java.util.function package Item 2: Describe a lambda expression; refactor the codethat uses an anonymous inner class to use a lambda expression;describe type inference and target typing Item 3: Develop code that uses the built-in interfacesincluded in the java.util.function package, such as Function,Consumer, Supplier, UnaryOperator, Predicate, and Optional APIs,including the primitive and binary variations of the interfaces Item 4: Develop code that uses a method reference,including refactoring a lambda expression to a method reference Section 6: JavaCollections The sectionsLambda Expressions andAggregate Operations cover some of the following items: Item 1: Develop code that uses diamond with genericdeclarations [The Diamond](../../java/generics/types.html#diamond) Item 2: Develop code that iterates a collection, filtersa collection, and sorts a collection by using lambdaexpressions Item 3: Search for data by using methods, such asfindFirst, findAny, anyMatch, allMatch, and noneMatch Item 4: Perform calculations on Java streams by usingcount, max, min, average, and sum methods and save results to acollection by using the collect method and Collector class,including the averagingDouble, groupingBy, joining, and partitioningBymethods Item 5: Develop code that uses Java SE 8 collectionimprovements, including the Collection.removeIf,List.replaceAll, Map.computeIfAbsent, andMap.computeIfPresent methods Item 6: Develop code that uses the merge, flatMap,and map methods on Java streams Section 7: Java StreamsThe sectionsLambda Expressions andAggregate Operations cover some of the following items: Item 1: Describe the Stream interface and pipelines;create a stream by using the Arrays.stream and IntStream.rangemethods; identify the lambda operations that are lazy Item 2: Develop code that uses parallel streams,including decomposition operation and reduction operation instreams Upgrade Java SE 7 to Java SE 8 OCP ProgrammerThe topics covered in this exam are: Lambda Expressions Using Built-in Lambda TypesJava Collections and Streams with Lambdas Collection Operations with Lambda Parallel Streams Lambda Cookbook Method Enhancements Use Java SE 8 Date/Time API Section 1: Lambda ExpressionsItem 1: Describe and develop code that uses Java innerclasses, including nested class, static class, local class, andanonymous classes [Nested Classes](../../java/javaOO/nested.html) [Local Classes](../../java/javaOO/localclasses.html) [Anonymous Classes](../../java/javaOO/anonymousclasses.html) [When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions ](../../java/javaOO/whentouse.html) Item 2: Describe and write functional interfaces Item 3: Describe a lambda expression; refactor the codethat uses an anonymous inner class to use a lambda expression;describe type inference and target typing Section 2: Using Built-inLambda Types The sectionsLambda Expressions andAggregate Operations cover some of the following items: Item 1: Describe the interfaces of the java.util.functionpackage Item 2: Develop code that uses the Function interface Item 3: Develop code that uses the Consumer interface Item 4: Develop code that uses the Supplier interface Item 5: Develop code that uses the UnaryOperatorinterface Item 6: Develop code that uses the Predicateinterface Item 7: Develop code that uses the primitive and binaryvariations of the base interfaces of the java.util.functionpackage Item 8: Develop code that uses a method reference,including refactoring a lambda expression to a method reference Section 3: JavaCollections and Streams with Lambdas The sectionsLambda Expressions andAggregate Operations cover some of the following items: Item 1: Develop code that iterates a collection by usingthe forEach() method and method chaining Item 2: Describe the Stream interface and pipelines Item 3: Filter a collection by using lambdaexpressions Item 4: Identify the operations, on stream, that arelazy Section 4: Collection Operations withLambda The sectionsLambda Expressions andAggregate Operations cover some of the following items: Item 1: Develop code to extract data from an object byusing the map() method Item 2: Search for data by using methods such asfindFirst(), findAny(), anyMatch(), allMatch(), and noneMatch() Item 3: Describe the unique characteristics of theOptional class Item 4: Perform calculations by using Java Streammethods, such as count(), max(), min(), average(), and sum() Item 5: Sort a collection by using lambda expressions Item 6: Develop code that uses the Stream.collect()method and Collectors class methods, such as averagingDouble(),groupingBy(), joining(), and partitioningBy() Section 5: Parallel StreamsItem 1: Develop code that uses parallel streams Item 2: Implement decomposition and reduction instreams Section 6: LambdaCookbook Item 1: Develop code that uses Java SE 8 collectionimprovements, including Collection.removeIf, List.replaceAll,Map.computeIfAbsent, and Map.computeIfPresent methods Item 2: Develop code that uses Java SE 8 I/Oimprovements, including Files.find, Files.walk, and Files.lines methods Item 3: Use flatMap() methods in the Stream API Item 4: Develop code that creates a stream by using theArrays.stream() and IntStream.range() methods Section 7: MethodEnhancements Item 1: Add static methods to interfaces Item 2: Define and use a default method of an interfaceand describe the inheritance rules for the default method Section 8: Use Java SE 8 Date/TimeAPI Item 1: Create and manage date- and time-based events,including a combination of date and time in a single object, byusing LocalDate, LocalTime, LocalDateTime, Instant, Period, andDuration [Date Classes](../../datetime/iso/date.html) [Date and Time Classes](../../datetime/iso/datetime.html) Item 2: Work with dates and times across time zones andmanage changes resulting from daylight savings, including Formatdate and times values [Time Zone and Offset Classes](../../datetime/iso/timezones.html) Item 3: Define, create, and manage date- and time-basedevents using Instant, Period, Duration, and TemporalUnit [Instant Class](../../datetime/iso/instant.html) [The Temporal Package](../../datetime/iso/temporal.html) [Period and Duration](../../datetime/iso/period.html)","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Java SE 8 Programmer I Exam","date":"2020-12-05T17:38:37.819Z","path":"wiki/2021-03-03-Java SE 8 Programmer I Exam/","text":"Java SE 8 Programmer II ExamThis page maps sections in the Java Tutorials to topics covered in the Java SE 8 Programmer II exam. This exam is associated with the Oracle Certified Professional, Java SE 8 Programmer certificate. The topics covered in this exam are: Java Class Design Advanced Class Design Generics and Collections Lambda Built-In Functional Interfaces Java Stream API Exceptions and Assertions Use Java SE 8 Date/Time API Java I/O Fundamentals Java File I/O (NIO.2) Concurrency Building Database Applications with JDBC Localization Section 1: Java Class DesignItem 1: Implement encapsulation. [What Is an Object?](../../java/concepts/object.html) Item 2: Implement inheritance including visibility modifiers and composition. [Inheritance](../../java/IandI/subclasses.html) [Overriding and Hiding Methods](../../java/IandI/override.html) Item 3: Implement polymorphism. [Polymorphism](../../java/IandI/polymorphism.html) Item 4: Override hasCode, equals, and toString methods from Object class. [Object as a Superclass](../../java/IandI/objectclass.html) Item 5: Create and use singleton classes and immutable classes. [The Singleton Design Pattern](../../ext/basics/spi.html#singleton) [A Strategy for Defining Immutable Objects](../../essential/concurrency/imstrat.html) Item 6: Develop code that uses the static keyword on initialize blocks, variables, methods, and classes. [Understanding Class Members](../../java/javaOO/classvars.html) [Initializing Fields](../../java/javaOO/initial.html) [Overriding and Hiding Methods](../../java/IandI/override.html) [Default Methods](../../java/IandI/defaultmethods.html) Section 2: Advanced Class DesignItem 1: Develop code that uses abstract classes and methods. [Abstract Methods and Classes](../../java/IandI/abstract.html) Item 2: Develop code that uses the final. [Variables](../../java/nutsandbolts/variables.html) [Understanding Class Members](../../java/javaOO/classvars.html) Item 3: Create inner classes including static inner classes, local classes, nested classes, and anonymous innter classes. [Nested Classes](../../java/javaOO/nested.html) [Inner Class Example](../../java/javaOO/innerclasses.html) [Local Classes](../../java/javaOO/localclasses.html) [Anonymous Classes](../../java/javaOO/anonymousclasses.html) [When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions ](../../java/javaOO/whentouse.html) Item 4: Use enumerated types including methods, and constructors in an enum type [Enum Types](../../java/javaOO/enum.html) [Default Methods](../../java/IandI/defaultmethods.html) [Enumerated Types](../../reflect/special/enum.html) Item 5: Develop code that declares, implements and/or extends interfaces and use the @Override annotation. [Predefined Annotation Types](../../java/annotations/predefined.html) Item 6: Create and use lambda expressions. [Lambda Expressions](../../java/javaOO/lambdaexpressions.html) Section 3: Generics and CollectionsTheGenerics (Updated) lesson, theCollections trail and, in particular, the specified pages. Item 1: Create and use a generic class. [Generic Types](../../java/generics/types.html) Item 2: Create and use ArrayList, TreeSet, TreeMap, and ArrayDeque objects. [The List Interface](../../collections/interfaces/list.html) [The Set Interface](../../collections/interfaces/set.html) [The Map Interface](../../collections/interfaces/map.html) [The Deque Interface](../../collections/interfaces/deque.html) Item 3: Use java.util.Comparator and java.lang.Comparable interfaces. [Object Ordering](../../collections/interfaces/order.html) Item 4: Collections, streams, and filters. [Aggregate Operations](../../collections/streams/index.html) Item 5: Iterate using forEach methods of Streams and List. [The Collection Interface](../../collections/interfaces/collection.html) [Aggregate Operations](../../collections/streams/index.html) Item 6: Describe the Stream interface and the Stream pipeline. [Aggregate Operations](../../collections/streams/index.html) Item 7: Filter a collection by using lambda expressions. [The Collection Interface](../../collections/interfaces/collection.html) [Aggregate Operations](../../collections/streams/index.html) Item 8: Use method references with streams. [Method References](../../java/javaOO/methodreferences.html) Section 4: Lambda Built-In Functional InterfacesThe sectionsLambda Expressions andAggregate Operations cover some of the following items: Item 1: Use the built-in interfaces included in the java.util.function package such as Predicate, Consumer, Function, and Supplier. Item 2: Develop code that uses primitive versions of functional interfaces. Item 3: Develop code that uses binary versions of functional interfaces. Item 4: Develop code that uses the UnaryOperator interface. Section 5: Java Stream APIThe sectionsLambda Expressions andAggregate Operations cover some of the following items: Item 1: Develop code to extract data from an object using peek() and map() methods including primitive versions of the map() method. Item 2: Search for data by using search methods of the Stream classes including findFirst, findAny, anyMatch, allMatch, noneMatch. Item 3: Develop code that uses the Optional class. Item 4: Develop code that uses Stream data methods and calculation methods. Item 5: Sort a collection using Stream API. Item 6: Save results to a collection using the collect method and group/partition data using the Collectors class. Item 7: Use flatMap() methods in the Stream API. Section 6: Exceptions and AssertionsItem 1: Use try-catch and throws statements. [Specifying the Exceptions Thrown by a Method](../../essential/exceptions/declaring.html) [How to Throw Exceptions](../../essential/exceptions/throwing.html) Item 2: Use catch, multi-catch, and finally clauses. [Catching and Handling Exceptions](../../essential/exceptions/handling.html) [The try Block](../../essential/exceptions/try.html) [The catch Blocks](../../essential/exceptions/catch.html) [The finally Block](../../essential/exceptions/finally.html) [Putting It All Together](../../essential/exceptions/putItTogether.html) Item 3: Use autoclose resources with a try-with-resources statement. [The try-with-resources Statement](../../essential/exceptions/tryResourceClose.html) Item 4: Create custom exceptions and autocloseable resources. [Creating Exception Classes](../../essential/exceptions/creating.html) Item 5: Test invariants by using assertions. [Questions and Exercises: Classes (assertion example)](../../java/javaOO/QandE/creating-questions.html) Section 7: Use Java SE 8 Date/Time API Item 1: Create and manage date-based and time-based events including a combination of date and time into a single object using LocalDate, LocalTime, LocalDateTime, Instant, Period, and Duration. [Date Classes](../../datetime/iso/date.html) [Date and Time Classes](../../datetime/iso/datetime.html) [Instant Class](../../datetime/iso/instant.html) [Period and Duration](../../datetime/iso/period.html) Item 2: Work with dates and times across timezones and manage changes resulting from daylight savings including Format date and times values. [Time Zone and Offset Classes](../../datetime/iso/timezones.html) Item 3: Define and create and manage date-based and time-based events using Instant, Period, Duration, and TemporalUnit. [Instant Class](../../datetime/iso/instant.html) [Period and Duration](../../datetime/iso/period.html) [The Temporal Package](../../datetime/iso/temporal.html) Section 8: Java I/O FundamentalsItem 1: Read and write data from the console. TheI/O Streams lesson and, in particular, the following pages: [Byte Streams](../../essential/io/bytestreams.html) [I/O from the Command Line](../../essential/io/cl.html) Item 2: Use BufferedReader, BufferedWriter, File, FileReader, FileWriter, FileInputStream, FileOutputStream, ObjectOutputStream, ObjectInputStream, and PrintWriter in the java.io package. TheFile I/O (Featuring NIO.2) lesson, and in particular, the following pages: [Reading, Writing, and Creating Files](../../essential/io/file.html) [Creating and Reading Directories](../../essential/io/dirs.html) [Random Access Files](../../essential/io/rafs.html) Section 9: Java File I/O (NIO.2)Item 1: Use the Path interface to operate on file and directory paths. [What Is a Path? (And Other File System Facts)](../../essential/io/path.html) [Path Operations](../../essential/io/pathOps.html) Item 2: Use the Files class to check, read, delete, copy, move, and manage metadata a file or directory. [File Operations](../../essential/io/fileOps.html) [Checking a File or Directory](../../essential/io/check.html) [Deleting a File or Directory](../../essential/io/delete.html) [Copying a File or Directory](../../essential/io/copy.html) [Moving a File or Directory](../../essential/io/move.html) [Managing Metadata (File and File Store Attributes)](../../essential/io/fileAttr.html) [Walking the File Tree](../../essential/io/walk.html) [Finding Files](../../essential/io/find.html) [What is a Glob?](../../essential/io/fileOps.html#glob) [Watching a Directory for Changes](../../essential/io/notification.html) Item 3: Use Stream API with NIO.2. Section 3: Object-Oriented Design PrinciplesThe Java Tutorials do not cover Design Patterns topics. The following references cover design patterns using the Java programming language: Head First Design Patterns by Elizabeth Freeman, et al. Java Design Pattern Essentials by Tony Bevis Item 1: Write code that declares, implements and/or extends interfaces. [Defining an Interface](../../java/IandI/interfaceDef.html) [Interfaces](../../java/IandI/createinterface.html) [Implementing an Interface](../../java/IandI/usinginterface.html) Item 2: Choose between interface inheritance and class inheritance. Item 3: Develop code that implements “is-a” and/or “has-a” relationships. Item 4: Apply object composition principles. Item 5: Design a class using the Singleton design pattern. Item 6: Write code to implement the DAO pattern. Item 7: Design and create objects using a factory, and use factories from the API. Section 5: String ProcessingItem 1: Search, parse and build strings. [Strings](../../java/data/strings.html) [Converting Between Numbers and Strings](../../java/data/converting.html) [Comparing Strings and Portions of Strings](../../java/data/comparestrings.html) [Manipulating Characters in a String](../../java/data/manipstrings.html) Item 2: Search, parse, and replace strings by using regular expressions. [Methods of the Pattern Class](../../essential/regex/pattern.html) [Methods of the Matcher Class](../../essential/regex/matcher.html) Item 3: Use string formatting. [Strings](../../java/data/strings.html) [Formatting Numeric Print Output](../../java/data/numberformat.html) Section 10: ConcurrencyItem 1: Create worker threads using Runnable, Callable and use an ExecutorService to concurrently execute tasks. [Executors](../../essential/concurrency/executors.html) [Executor Interfaces](../../essential/concurrency/exinter.html) [Thread Pools](../../essential/concurrency/pools.html) Item 2: Identify potential threading problems among deadlock, starvation, livelock, and race conditions. [Memory Consistency Errors](../../essential/concurrency/memconsist.html) [Deadlock](../../essential/concurrency/deadlock.html) Item 3: Use synchronized keyword and java.util.concurrent.atomic package to control the order of thread execution. [Atomic Variables](../../essential/concurrency/atomicvars.html) Item 4: Use java.util.concurrent collections and classes including CyclicBarrier and CopyOnWriteArrayList. [Concurrent Collections](../../essential/concurrency/collections.html) Item 5: Use parallel Fork/Join Framework. [Fork/Join](../../essential/concurrency/forkjoin.html) Item 6: Use parallel Streams including reduction, decomposition, merging processes, pipelines and performance. Section 11: Building Database Applicatons with JDBCItem 1: Describe the interfaces that make up the core of the JDBC API including the Driver, Connection, Statement, and ResultSet interfaces and their relationship to provider implementations. [JDBC Basics: Getting Started](../../jdbc/basics/gettingstarted.html) Item 2: Identify the components required to connect to a database using the DriverManager class including the JDBC URL. [Establishing a Connection](../../jdbc/basics/connecting.html) [Connecting with DataSource Objects](../../jdbc/basics/sqldatasources.html) Item 3: Submit queries and read results from the database including creating statements, returning result sets, iterating through the results, and properly closing result sets, statements, and connections. [Processing SQL Statements with JDBC](../../jdbc/basics/processingsqlstatements.html) [Using Transactions](../../jdbc/basics/transactions.html) [Using RowSet Objects](../../jdbc/basics/rowset.html) [Using JdbcRowSet Objects](../../jdbc/basics/jdbcrowset.html) Section 12: LocalizationItem 1: Read and set the locale by using the Locale object.. [Setting the Locale](../../i18n/locale/index.html) [Creating a Locale](../../i18n/locale/create.html) Item 2: Create and read a Properties file. [About the ResourceBundle Class](../../i18n/resbundle/concept.html) [Backing a ResourceBundle with Properties Files](../../i18n/resbundle/propfile.html) Item 3: Build a resource bundle for each locale and load a resource bundle in an application. [Customizing Resource Bundle Loading](../../i18n/resbundle/control.html)","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Preparation for Java Programmer Language Certification","date":"2020-12-05T17:38:36.642Z","path":"wiki/2021-03-03-Preparation for Java Programmer Language Certification/","text":"Java SE 8 Programmer I ExamThis page maps sections in the Java Tutorials to topics covered in the Java SE 8 Programmer I exam. This exam is associated with the Oracle Certified Associate, Java SE 8 Programmer certificate. The topics covered in this exam are: Java Basics Working with Java Data Types Using Operators and Decision Constructs Creating and Using Arrays Using Loop Constructs Working with Methods and Encapsulation Working with Inheritance Handling Exceptions Working with Selected classes from the Java API Section 1: Java BasicsItem 1: Define the scope of variables. [Variables](../../java/nutsandbolts/variables.html) Item 2: Define the structure of a Java class. [A Closer Look at the \"Hello World!\" Application](../../getStarted/application/index.html) [Classes](../../java/javaOO/classes.html) Item 3: Create executable Java applications with a main method; run a Java program from the command line; produce console output. [\"Hello World!\" for the NetBeans IDE](../../getStarted/cupojava/netbeans.html) [\"Hello World!\" for Microsoft Windows](../../getStarted/cupojava/win32.html) [\"Hello World!\" for Solaris OS and Linux](../../getStarted/cupojava/unix.html) [A Closer Look at the \"Hello World!\" Application](../../getStarted/application/index.html) Item 4: Import other Java packages to make them accessible in your code. [Creating and Using Packages](../../java/package/packages.html) [Using Package Members](../../java/package/usepkgs.html) Item 5: Compare and contrast the features and components of Java such as: platform independence, object orientation, encapsulation, etc. [About the Java Technology](../../getStarted/intro/definition.html) [Object-Oriented Programming Concepts](../../java/concepts/index.html) Section 2: Working with Java Data TypesItem 1: Declare and initialize variables (including casting of primitive data types). [Variables](../../java/nutsandbolts/variables.html) [Initializing Fields](../../java/javaOO/initial.html) Item 2: Differentiate between object reference variables and primitive variables. [Primitive Data Types](../../java/nutsandbolts/datatypes.html) [The Numbers Classes](../../java/data/numberclasses.html) Item 3: Know how to read or write to object fields. [Inheritance](../../java/IandI/subclasses.html) [Declaring Member Variables](../../java/javaOO/variables.html) [Creating Objects](../../java/javaOO/objectcreation.html) [Using Objects](../../java/javaOO/usingobject.html) Item 4: Explain an object’s lifecycle (creation, “dereference by reassignment” and garbage collection). [Objects](../../java/javaOO/objects.html) [Creating Objects](../../java/javaOO/objectcreation.html) [Using Objects](../../java/javaOO/usingobject.html) Section 3: Using Operators and Decision ConstructsItem 1: Use Java operators; use parentheses to override operator precedence. [Operators](../../java/nutsandbolts/operators.html) [Assignment, Arithmetic, and Unary Operators](../../java/nutsandbolts/op1.html) [Equality, Relational, and Conditional Operators ](../../java/nutsandbolts/op2.html) [Bitwise and Bit Shift Operators](../../java/nutsandbolts/op3.html) [Expressions, Statements, and Blocks](../../java/nutsandbolts/expressions.html) Item 2: Test equality between strings and other objects using == and equals(). [Object as a Superclass](../../java/IandI/objectclass.html) Item 3: Create and use if, if-else, and ternary constructs. [The if-then and if-then-else Statements](../../java/nutsandbolts/if.html) [Equality, Relational, and Conditional Operators ](../../java/nutsandbolts/op2.html) Item 4: Use a switch statement. [The switch Statement](../../java/nutsandbolts/switch.html) Section 4: Creating and Using ArraysItem 1: Declare, instantiate, initialize and use a one-dimensional array. [Arrays](../../java/nutsandbolts/arrays.html) Item 2: Declare, instantiate, initialize and use a multi-dimensional array. [Arrays](../../java/nutsandbolts/arrays.html) Section 5: Using Loop ConstructsItem 1: Create and use while loops. [The while and do-while Statements](../../java/nutsandbolts/while.html) Item 2: Create and use for loops including the enhanced for loop. [The for Statement](../../java/nutsandbolts/for.html) Item 3: Create and use do-while loops. [The while and do-while Statements](../../java/nutsandbolts/while.html) Item 4: Compare loop constructs. [Summary of Control Flow Statements](../../java/nutsandbolts/flowsummary.html) Item 5: Use break and continue. [Branching Statements](../../java/nutsandbolts/branch.html) Section 6: Working with Methods and EncapsulationItem 1: Create methods with arguments and return values, including overloaded methods. [Returning a Value from a Method](../../java/javaOO/returnvalue.html) [Defining Methods](../../java/javaOO/methods.html) Item 2: Apply the static keyword to methods and fields. [Variables](../../java/nutsandbolts/variables.html) [Understanding Class Members](../../java/javaOO/classvars.html) [Default Methods](../../java/IandI/defaultmethods.html) Item 3: Create an overloaded method; differentiate between default and user defined constructors. [Defining Methods](../../java/javaOO/methods.html) [Providing Constructors for Your Classes](../../java/javaOO/constructors.html) Item 4: Apply access modifiers. [Controlling Access to Members of a Class](../../java/javaOO/accesscontrol.html) Item 5: Apply encapsulation principles to a class. [Inheritance](../../java/IandI/subclasses.html) [Inner Class Example](../../java/javaOO/innerclasses.html) [Nested Classes](../../java/javaOO/nested.html) Item 6: Determine the effect upon object references and primitive values when they are passed into methods that change the values. [Passing Information to a Method or a Constructor](../../java/javaOO/arguments.html) Section 7: Working with InheritanceItem 1: Describe inheritance and its benefits. [Inheritance](../../java/IandI/subclasses.html) [Overriding and Hiding Methods](../../java/IandI/override.html) Item 2: Develop code that makes use of polymorphism; develop code that overrides methods; differentiate between the type of a reference and the type of an object. [Polymorphism](../../java/IandI/polymorphism.html) [Creating Objects](../../java/javaOO/objectcreation.html) [Using Objects](../../java/javaOO/usingobject.html) Item 3: Determine when casting is necessary. [Inheritance](../../java/IandI/subclasses.html) Item 4: Use super and this to access objects and constructors. [Using the Keyword super](../../java/IandI/super.html) [Using the this Keyword](../../java/javaOO/thiskey.html) Item 5: Use abstract classes and interfaces. [Abstract Methods and Classes](../../java/IandI/abstract.html) [Defining an Interface](../../java/IandI/interfaceDef.html) [Implementing an Interface](../../java/IandI/usinginterface.html) Section 8: Handling ExceptionsItem 1: Differentiate among checked exceptions, RuntimeException, and Error. [The Catch or Specify Requirement](../../essential/exceptions/catchOrDeclare.html) Item 2: Create a try-catch block and determine how exceptions alter normal program flow. [Catching and Handling Exceptions](../../essential/exceptions/handling.html) [The try Block](../../essential/exceptions/try.html) [The catch Blocks](../../essential/exceptions/catch.html) Item 3: Describe the advantages of exception handling . [What Is an Exception?](../../essential/exceptions/definition.html) [Advantages of Exceptions](../../essential/exceptions/advantages.html) Item 4: Create and invoke a method that throws an exception. [Catching Exceptions](../../essential/io/fileOps.html#exception) Item 5: Recognize common exception classes and categories (such as NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ClassCastException). Section 9: Working with Selected classes from the Java APIItem 1: Manipulate data using the StringBuilder class and its methods. [The StringBuilder Class](../../java/data/buffers.html) [Summary of Characters and Strings](../../java/data/stringsummary.html) Item 2: Create and manipulate strings. [Strings](../../java/data/strings.html) [Converting Between Numbers and Strings](../../java/data/converting.html) [Comparing Strings and Portions of Strings](../../java/data/comparestrings.html) [Manipulating Characters in a String](../../java/data/manipstrings.html) Item 3: Create and manipulate calendar data using classes from java.time.LocalDateTime, java.time.LocalDate, java.time.LocalTime, java.time.format.DateTimeFormatter, java.time.Period. [Date and Time Classes](../../datetime/iso/datetime.html) [Date Classes](../../datetime/iso/date.html) [Parsing and Formatting](../../datetime/iso/format.html) [Period and Duration](../../datetime/iso/period.html) Item 4: Declare and use an ArrayList of a given type. [The List Interface](../../collections/interfaces/list.html) [List Implementations](../../collections/implementations/list.html) Item 5: Write a simple Lambda expression that consumes a Lambda Predicate expression. [Lambda Expressions](../../java/javaOO/lambdaexpressions.html) [Aggregate Operations](../../collections/streams/index.html)","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Examples","date":"2020-12-05T17:38:35.476Z","path":"wiki/2021-03-03-Examples/","text":"Lesson: Preparation for Java Programmer Language CertificationOracle provides four certification examinations and two certificates for Java SE 8 programmers. The Java Tutorials can be a valuable resource to help you prepare for the certification exams; however, they do not cover all topics in the certification exams. See the Java SE page on the Oracle University site for more information about Java SE 8 training and certification offered by Oracle. The following links provide more information on the certification topics and their mapping to tutorial content: Programmer Level I Exam: Successfully passing the Java SE 8 Programmer I exam results in the Oracle Certified Associate, Java SE 8 Programmer certification. Programmer Level II Exam: Successfully passing the Java SE 8 Programmer II exam results in the Oracle Certified Professional, Java SE 8 Programmer certification. Java SE 8 Upgrade Exam: Successfully passing one of the Upgrade to Java SE 8 Programmer exams results in the Oracle Certified Professional, Java SE 8 Programmer certification. For a high-level guide on how to approach learning the Java language, seeJava Tutorials Learning Paths.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"BufferStrategy and BufferCapabilities","date":"2020-12-05T17:38:34.303Z","path":"wiki/2021-03-03-BufferStrategy and BufferCapabilities/","text":"ExamplesCapabilitiesTest demonstrates the different buffering capabilities available for the machine on which it is run. DisplayModeTest shows a Swing application that uses passive rendering. If full-screen exclusive mode is available, it will enter full-screen exclusive mode. If display mode changes are allowed, it allows you to switch between display modes. MultiBufferTest enters full-screen mode and uses multi-buffering through an active render loop.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Double Buffering and Page Flipping","date":"2020-12-05T17:38:33.139Z","path":"wiki/2021-03-03-Double Buffering and Page Flipping/","text":"BufferStrategy and BufferCapabilitiesBufferStrategyIn Java 2 Standard Edition, you don’t have to worry about video pointers or video memory in order to take full advantage of either double-buffering or page-flipping. The new class java.awt.image.BufferStrategy has been added for the convenience of dealing with drawing to surfaces and components in a general way, regardless of the number of buffers used or the technique used to display them. A buffer strategy gives you two all-purpose methods for drawing: getDrawGraphics and show. When you want to start drawing, get a draw graphics and use it. When you are finished drawing and want to present your information to the screen, call show. These two methods are designed to fit rather gracefully into a rendering loop: 12345678910BufferStrategy myStrategy;while (!done) &#123; Graphics g &#x3D; myStrategy.getDrawGraphics(); render(g); g.dispose(); myStrategy.show();&#125; Buffer strategies have also been set up to help you monitor VolatileImage issues. When in full-screen exclusive mode, VolatileImage issues are especially important because the windowing system can sometimes take back the video memory it has given you. One important example is when the user presses the ALT+TAB key combination in Windows–suddenly your full-screen program is running in the background and your video memory is lost. You can call the contentsLost method to find out if this has happened. Similarly, when the windowing system returns your memory to you, you can find out using the contentsRestored method. BufferCapabilitiesAs mentioned before, different operating systems, or even different graphics cards on the same operating system, have different techniques available at their disposal. These capabilities are exposed for you so that you can pick the best technique for your application. The class java.awt.BufferCapabilities encapsulates these capabilities. Every buffer strategy is controlled by its buffer capabilities, so picking the right ones for your application is very crucial. To find out what capabilities are available, call the getBufferCapabilities method from the GraphicsConfiguration objects available on your graphics device. The capabilities available in Java 2 Standard Edition version 1.4 are: `isPageFlipping` This capability returns whether or not hardware page-flipping is available on this graphics configuration. `isFullScreenRequired` This capability returns whether or not full-screen exclusive mode is required before hardware page-flipping should be attempted. `isMultiBufferAvailable` This capability returns whether or not multiple buffering (two or more back buffers plus the primary surface) in hardware is available. `getFlipContents` This capability returns a hint of the technique used to do hardware page-flipping. This is important because the contents of the back buffer after a show are different depending on the technique used. The value returned can be null (if isPageFlipping returns false) or one of the following values. Any value can be specified for a buffer strategy so long as the isPageFlipping method returns true, though performance will vary depending on the available capabilities. `FlipContents.COPIED` This value means that the contents of the back buffer are copied to the primary surface. A \"flip\" is probably performed as a hardware blt, which means that hardware double-buffering is probably done using blitting instead of true page-flipping. This should (in theory) be faster, or at least as fast, as blitting from a VolatileImage to the primary surface, though your mileage may vary. The contents of the back buffer are the same as the primary surface after a flip. `FlipContents.BACKGROUND` This value means that the contents of the back buffer have been cleared with the background color. Either a true page-flip or a blt has occurred. `FlipContents.PRIOR` This value means that the contents of the back buffer are now the contents of the old primary surface, and vice versa. Generally this value indicates that true page-flipping occurs, though this is not guaranteed and, once again, your mileage on this operation may vary. `FlipContents.UNKNOWN` This value means that the contents of the back buffer are undefined after a flip. You may have to experiment to find which technique works best for you (or you may not care), and you will definitely have to set up the contents of the back buffer yourself each time you draw. To create a buffer strategy for a component, call the createBufferStrategy method, supplying the number of buffers desired (this number includes the primary surface).&#160; If any particular buffering technique is desired, supply an appropriate BufferCapabilities object. Note that when you use this version of the method, you must catch an AWTException in the event that your choice is not available. Also note that these methods are only available on Canvas and Window. Once a particular buffer strategy has been created for a component, you can manipulate it using the getBufferStrategy method. Note that this method is also only available for canvases and windows. Programming TipsSome tips about using buffer capabilities and buffer strategies: Getting, using, and disposing a graphics object are more robust in a try...finally clause: BufferStrategy myStrategy; while (!done) &#123; Graphics g; try &#123; g = myStrategy.getDrawGraphics(); render(g); &#125; finally &#123; g.dispose(); &#125; myStrategy.show();&#125; - Check the available capabilities before using a buffer strategy. - For best results, create your buffer strategy on a full-screen exclusive window. Make sure you check the isFullScreenRequired and isPageFlipping capabilities before using page-flipping. - Don't make any assumptions about performance. Tweak your code as necessary, but remember that different operating systems and graphics cards have different capabilities. Profile your application! - You may want to subclass your component to override the createBufferStrategy method. Use an algorithm for choosing a strategy that is best suited to your application. The FlipBufferStrategy and&#160; BltBufferStrategy inner classes are protected and can be subclassed. - Don't forget that you may lose your drawing surfaces!&#160; Be sure to check contentsLost and contentsRestored before drawing. All buffers that have been lost have to be redrawn when they are restored. - If you use a buffer strategy for double-buffering in a Swing application, you probably want to turn off double-buffering for your Swing components, since they will already be double-buffered. Video memory is somewhat valuable and should only be used whenever absolutely necessary. - It may be end up being wasteful to use more than one back buffer. Multi-buffering is only useful when the drawing time exceeds the time spent to do a show. Profile your application!","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Passive vs. Active Rendering","date":"2020-12-05T17:38:31.960Z","path":"wiki/2021-03-03-Passive vs. Active Rendering/","text":"Double Buffering and Page FlippingSuppose you had to draw an entire picture on the screen, pixel by pixel or line by line. If you were to draw such a thing directly to the screen (using, say, Graphics.drawLine), you would probably notice with much disappointment that it takes a bit of time. You will probably even notice visible artifacts of how your picture is drawn. Rather than watching things being drawn in this fashion and at this pace, most programmers use a technique called double-buffering. The traditional notion of double-buffering in Java applications is fairly straightforward: create an offscreen image, draw to that image using the image’s graphics object, then, in one step, call drawImage using the target window’s graphics object and the offscreen image. You may have already noticed that Swing uses this technique in many of its components, usually enabled by default, using the setDoubleBuffered method. The screen surface is commonly referred to as the primary surface, and the offscreen image used for double-buffering is commonly referred to as the back buffer. The act of copying the contents from one surface to another is frequently referred to as a block line transfer, or blitting (blt is typically pronounced “blit” and shouldn’t be confused with a BLT sandwich). The primary surface is usually manipulated through the graphics object of any showing component; when in full-screen mode, any operation using the graphics of the full-screen window is a direct manipulation of screen memory. For this reason, you can take advantage of other capabilities in full-screen exclusive mode that may otherwise be unavailable due to the overhead of the windowing system. One such technique that is only available in full-screen exclusive mode is a form of double-buffering called page-flipping. Page FlippingMany graphics cards have the notion of a video pointer, which is simply an address in video memory. This pointer tells the graphics card where to look for the contents of the video to be displayed during the next refresh cycle. In some graphics cards and on some operating systems, this pointer can even be manipulated programmatically. Suppose you created a back buffer (in video memory) of the exact width, height, and bit depth of the screen, then drew to that buffer the same way as you would using double-buffering. Now imagine what would happen if, instead of blitting your image to the screen as in double-buffering, you simply changed the video pointer to your back buffer. During the next refresh, the graphics card would now use your image to display. This switch is called page-flipping, and the performance gain over blt-based double-buffering is that only a single pointer needs to be moved in memory as opposed to copying the entire contents from one buffer to another. When a page flip occurs, the pointer to the old back buffer now points to the primary surface and the pointer to the old primary surface now points to the back buffer memory. This sets you up automatically for the next draw operation. Sometimes it is advantageous to set up multiple back buffers in a flip chain. This is particularly useful when the amount of time spent drawing is greater than the monitor’s refresh rate. A flip chain is simply two or more back buffers (sometimes called intermediary buffers) plus the primary surface (this is sometimes called triple-buffering, quadruple-buffering, etc.). In a flip chain, the next available back buffer becomes the primary surface, etc., all the way down to the rearmost back buffer that is used for drawing. Benefits of Double-Buffering and Page-FlippingIf your performance metric is simply the speed at which double-buffering or page-flipping occurs versus direct rendering, you may be disappointed. You may find that your numbers for direct rendering far exceed those for double-buffering and that those numbers far exceed those for page-flipping. Each of these techniques is for used for improving perceived performance, which is much more important in graphical applications than numerical performance. Double-buffering is used primarily to eliminate visible draws which can make an application look amateurish, sluggish, or appear to flicker. Page-flipping is used primarily to also eliminate tearing, a splitting effect that occurs when drawing to the screen happens faster than the monitor’s refresh rate. Smoother drawing means better perceived performance and a much better user experience.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Display Mode","date":"2020-12-05T17:38:30.790Z","path":"wiki/2021-03-03-Display Mode/","text":"Passive vs. Active RenderingAs mentioned before, most full-screen applications usually function better if they are at the helm during drawing. In traditional windowed GUI applications, the question of when to paint is usually handled by the operating system. When operating in a windowed environment, this makes perfect sense. A windowed application does not know when the user is going to move, resize, expose, or cover an application by another window until it actually happens. In a Java GUI application, the operating system delivers a paint event to the AWT, which figures out what needs to be painted, creates a java.awt.Graphics object with the appropriate clipping region, then calls the paint method with that Graphics object: 12345678&#x2F;&#x2F; Traditional GUI Application paint method:&#x2F;&#x2F; This can be called at any time, usually &#x2F;&#x2F; from the event dispatch threadpublic void paint(Graphics g) &#123; &#x2F;&#x2F; Use g to draw my Component&#125; This is sometimes referred to as passive rendering. As you can imagine, such a system incurs a lot of overhead, much to the annoyance of many performance-sensitive AWT and Swing programmers. When in full-screen exclusive mode, you don’t have to worry anymore about the window being resized, moved, exposed, or occluded (unless you’ve ignored my suggestion to turn off resizing). Instead, the application window is drawn directly to the screen (active rendering). This simplifies painting quite a bit, since you don’t ever need to worry about paint events. In fact, paint events delivered by the operating system may even be delivered at inappropriate or unpredictable times when in full-screen exclusive mode. Instead of relying on the paint method in full-screen exclusive mode, drawing code is usually more appropriately done in a rendering loop: 123456789public void myRenderingLoop() &#123; while (!done) &#123; Graphics myGraphics &#x3D; getPaintGraphics(); &#x2F;&#x2F; Draw as appropriate using myGraphics myGraphics.dispose(); &#125;&#125; Such a rendering loop can done from any thread, either its own helper thread or as part of the main application thread. Programming TipsSome tips about using active rendering: Don’t put drawing code in the paint routine. You may never know when that routine may get called! Instead, use another method name, such as render(Graphics g), which can be called from the paint method when operating in windowed mode, or alternately called with its own graphics from the rendering loop. Use the setIgnoreRepaint method on your application window and components to turn off all paint events dispatched from the operating system completely, since these may be called during inappropriate times, or worse, end up calling paint, which can lead to race conditions between the AWT event thread and your rendering loop. Separate your drawing code from your rendering loop, so that you can operate fully under both full-screen exclusive and windowed modes. Optimize your rendering so that you aren’t drawing everything on the screen at all times (unless you are using page-flipping or double-buffering, both discussed below). Do not rely on the update or repaint methods for delivering paint events. Do not use heavyweight components, since these will still incur the overhead of involving the AWT and the platform’s windowing system. If you use lightweight components, such as Swing components, you may have to fiddle with them a bit so that they draw using your Graphics, and not directly as a result of calling the paint method. Feel free to call Swing methods such as paintComponents, paintComponent, paintBorder, and paintChildren directly from your rendering loop. Feel free to use passive rendering if you just want a simple full-screen Swing or AWT application, but remember that paint events may be somewhat unreliable or unnecessary while in full-screen exclusive mode. Additionally, if you use passive rendering, you will not be able to use more advanced techniques such as page-flipping. Finally, be very careful to avoid deadlocks if you decide to use both active and passive rendering simultaneously–this approach is not recommended.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Full-Screen Exclusive Mode","date":"2020-12-05T17:38:29.631Z","path":"wiki/2021-03-03-Full-Screen Exclusive Mode/","text":"Display ModeOnce an application is in full-screen exclusive mode, it may be able to take advantage of actively setting the display mode. A display mode (java.awt.DisplayMode) is composed of the size (width and height of the monitor, in pixels), bit depth (number of bits per pixel), and refresh rate (how frequently the monitor updates itself). Some operating systems allow you to use multiple bit depths at the same time, in which case the special value BIT_DEPTH_MULTI is used for the value of bit depth. Also, some operating systems may not have any control over the refresh rate (or you may not care about the refresh rate setting). In this case, the special value REFRESH_RATE_UNKNOWN is used for the refresh rate value. How to Set the Display ModeTo get the current display mode, simply call the getDisplayMode method on your graphics device. To obtain a list of all possible display modes, call the getDisplayModes method. Both getDisplayMode and getDisplayModes can be called at any time, regardless of whether or not you are in full-screen exclusive mode. Before attempting to change the display mode, you should first call the isDisplayChangeSupported method. If this method returns false, the operating system does not support changing the display mode. Changing the display mode can only be done when in full-screen exclusive mode. To change the display mode, call the setDisplayMode method with the desired display mode. A runtime exception will be thrown if the display mode is not available, if display mode changes are not supported, or if you are not running in full-screen exclusive mode. Reasons for Changing the Display ModeThe main reason for setting the display mode is performance. An application can run much more quickly if the images it chooses to display share the same bit depth as the screen. Also, if you can count on the display to be a particular size, it makes drawing to that display much simpler, since you do not have to scale things down or up depending on how the user has set the display. Programming TipsHere are some tips for choosing and setting the display mode: Check the value returned by the isDisplayChangeSupported method before attempting to change the display mode on a graphics device. Make sure you are in full-screen exclusive mode before attempting to change the display mode.As with using full-screen mode, setting the display mode is more robust when in a `try...finally` clause: GraphicsDevice myDevice; Window myWindow; DisplayMode newDisplayMode; DisplayMode oldDisplayMode = myDevice.getDisplayMode(); try &#123; myDevice.setFullScreenWindow(myWindow); myDevice.setDisplayMode(newDisplayMode); …&#125; finally &#123; myDevice.setDisplayMode(oldDisplayMode); myDevice.setFullScreenWindow(null);&#125; - When choosing a display mode for your application, you may want to keep a list of preferred display modes, then choose the best one from the list of available display modes. - As a fallback, if the display mode you desire is not available, you may want to simply run in windowed mode at a fixed size.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Full-Screen Exclusive Mode API","date":"2020-12-05T17:38:27.818Z","path":"wiki/2021-03-03-Full-Screen Exclusive Mode API/","text":"Full-Screen Exclusive ModeProgrammers who use Microsoft’s DirectX API may already be familiar with full-screen exclusive mode. Other programmers may be somewhat new to the concept. In either case, full-screen exclusive mode is a powerful feature of J2SE&#8482; version 1.4 that allows the programmer to suspend the windowing system so that drawing can be done directly to the screen. This is a slight paradigm shift from the usual kind of GUI program in many ways. In traditional Java GUI programs, the AWT is responsible for propagating paint events from the operating system, through the event dispatch thread, and by calling AWT’s Component.paint method when appropriate. In full-screen exclusive applications, painting is usually done actively by the program itself. Additionally, a traditional GUI application is limited to the bit depth and size of the screen chosen by the user. In a full-screen exclusive application, the program can control the bit depth and size (display mode) of the screen. Finally, many more advanced techniques, such as page flipping (discussed below) and stereo buffering (utilizing systems which use a separate set of frames for each eye) require, on some platforms, that an application first be in full-screen exclusive mode. Hardware-Accelerated Image BasicsTo understand the full-screen exclusive mode API, you need to understand some basic principles of hardware-accelerated images. The VolatileImage interface encapsulates a surface which may or may not take advantage of hardware acceleration. Such surfaces may lose their hardware acceleration or their memory at the behest of the operating system (hence, the name ‘volatile’). See the VolatileImage Tutorial (coming soon) for more information on volatile images. Full-screen exclusive mode is handled through a java.awt.GraphicsDevice object. For a list of all available screen graphics devices (in single or multi-monitor systems), you can call the method getScreenDevices on the local java.awt.GraphicsEnvironment; for the default (primary) screen (the only screen on a single-monitor system), you can call the method getDefaultScreenDevice. Once you have the graphics device, you can call one of the following methods: public boolean isFullScreenSupported() This method returns whether or not full-screen exclusive mode is available. On systems where full-screen exclusive mode is not available, it is probably better to run an application in windowed mode with a fixed size rather than setting a full-screen window. public void setFullScreenWindow(Window w) Given a window, this method enters full-screen exclusive mode using that window. If full-screen exclusive mode is not available, the window is positioned at (0,0) and resized to fit the screen. Use this method with a null parameter to exit full-screen exclusive mode. Programming TipsHere are some tips about programming using full-screen exclusive mode: Check for isFullScreenSupported before entering full-screen exclusive mode. If it isn’t supported, performance may be degraded.Entering and exiting full-screen mode is more robust when using a try...finally clause. This is not only good coding practice, but it also prevents your program from staying in full-screen exclusive mode longer than it should: GraphicsDevice myDevice; Window myWindow; try &#123; myDevice.setFullScreenWindow(myWindow); …&#125; finally &#123; myDevice.setFullScreenWindow(null);&#125; - Most full-screen exclusive applications are better suited to use undecorated windows. Turn off decorations in a frame or dialog using the setUndecorated method. - Full-screen exclusive applications should not be resizable, since resizing a full-screen application can cause unpredictable (or possibly dangerous) behavior. - For security reasons, the user must grant fullScreenExclusive permission when using full-screen exclusive mode in an applet.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Acknowledgements","date":"2020-12-05T17:38:26.016Z","path":"wiki/2021-03-03-Acknowledgements/","text":"Lesson: Full-Screen Exclusive Mode APIby Michael MartakDo you want to use high-performance graphics in the Java development environment? Have you always wanted to program a game, but your images wouldn’t move fast enough? Has your slide show program not worked properly because you had no control over the user’s display resolution? If you’ve been asking any of these questions, then the full-screen exclusive mode API, introduced in release 1.4, may be what you’re looking for.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Converting Legacy Code to Use Generics","date":"2020-12-05T17:38:23.967Z","path":"wiki/2021-03-03-Converting Legacy Code to Use Generics/","text":"AcknowledgementsErik Ernst, Christian Plesner Hansen, Jeff Norton, Mads Torgersen, Peter von der Ahe and Philip Wadler contributed material to this trail . Thanks to David Biesack, Bruce Chapman, David Flanagan, Neal Gafter, Orjan Petersson, Scott Seligman, Yoshiki Shibata and Kresten Krab Thorup for valuable feedback on earlier versions of this trail. Apologies to anyone I’ve forgotten.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"More Fun with Wildcards","date":"2020-12-05T17:38:21.705Z","path":"wiki/2021-03-03-More Fun with Wildcards/","text":"Converting Legacy Code to Use GenericsEarlier, we showed how new and legacy code can interoperate. Now, it’s time to look at the harder problem of “generifying” old code. If you decide to convert old code to use generics, you need to think carefully about how you modify the API. You need to make certain that the generic API is not unduly restrictive; it must continue to support the original contract of the API. Consider again some examples from java.util.Collection. The pre-generic API looks like: 123456**interface** Collection &#123; **public boolean** containsAll(Collection c); **public boolean** addAll(Collection c);&#125; A naive attempt to generify it would be the following: 1234567**interface** Collection&lt;E&gt; &#123; **public boolean** containsAll(Collection&lt;E&gt; c); **public boolean** addAll(Collection&lt;E&gt; c);&#125; While this is certainly type safe, it doesn’t live up to the API’s original contract. The containsAll() method works with any kind of incoming collection. It will only succeed if the incoming collection really contains only instances of E, but: The static type of the incoming collection might differ, perhaps because the caller doesn’t know the precise type of the collection being passed in, or perhaps because it is a Collection&amp;lt;S&amp;gt;,where S is a subtype of E. It’s perfectly legitimate to call containsAll() with a collection of a different type. The routine should work, returning false. In the case of addAll(), we should be able to add any collection that consists of instances of a subtype of E. We saw how to handle this situation correctly in sectionGeneric Methods. You also need to ensure that the revised API retains binary compatibility with old clients. This implies that the erasure of the API must be the same as the original, ungenerified API. In most cases, this falls out naturally, but there are some subtle cases. We’ll examine one of the subtlest cases we’ve encountered, the method Collections.max(). As we saw in sectionMore Fun with Wildcards, a plausible signature for max() is: 1234**public static** &lt;T **extends** Comparable&lt;? **super** T&gt;&gt; T max(Collection&lt;T&gt; coll) This is fine, except that the erasure of this signature is: 123**public static** Comparable max(Collection coll) which is different than the original signature of max(): 123**public static** Object max(Collection coll) One could certainly have specified this signature for max(), but it was not done, and all the old binary class files that call Collections.max() depend on a signature that returns Object. We can force the erasure to be different, by explicitly specifying a superclass in the bound for the formal type parameter T. 1234**public static** &lt;T **extends** Object &amp; Comparable&lt;? **super** T&gt;&gt; T max(Collection&lt;T&gt; coll) This is an example of giving multiple bounds for a type parameter, using the syntax T1 &amp;amp; T2 ... &amp;amp; Tn. A type variable with multiple bounds is known to be a subtype of all of the types listed in the bound. When a multiple bound is used, the first type mentioned in the bound is used as the erasure of the type variable. Finally, we should recall that max only reads from its input collection, and so is applicable to collections of any subtype of T. This brings us to the actual signature used in the JDK: 1234**public static** &lt;T **extends** Object &amp; Comparable&lt;? **super** T&gt;&gt; T max(Collection&lt;? **extends** T&gt; coll) It’s very rare that anything so involved comes up in practice, but expert library designers should be prepared to think very carefully when converting existing APIs. Another issue to watch out for is covariant returns, that is, refining the return type of a method in a subclass. You should not take advantage of this feature in an old API. To see why, let’s look at an example. Assume your original API was of the form: 12345678910111213141516**public class** Foo &#123; &#x2F;&#x2F; *Factory. Should create an instance of* &#x2F;&#x2F; *whatever class it is declared in.* **public** Foo create() &#123; ... &#125;&#125;**public class** Bar **extends** Foo &#123; &#x2F;&#x2F; *Actually creates a Bar.* **public** Foo create() &#123; ... &#125;&#125; Taking advantage of covariant returns, you modify it to: 12345678910111213141516**public class** Foo &#123; &#x2F;&#x2F; *Factory. Should create an instance of* &#x2F;&#x2F; *whatever class it is declared in.* **public** Foo create() &#123; ... &#125;&#125;**public class** Bar **extends** Foo &#123; &#x2F;&#x2F; *Actually creates a Bar.* **public** Bar create() &#123; ... &#125;&#125; Now, assume a third party client of your code wrote the following: 12345678**public class** Baz **extends** Bar &#123; &#x2F;&#x2F; *Actually creates a Baz.* **public** Foo create() &#123; ... &#125;&#125; The Java virtual machine does not directly support overriding of methods with different return types. This feature is supported by the compiler. Consequently, unless the class Baz is recompiled, it will not properly override the create() method of Bar. Furthermore, Baz will have to be modified, since the code will be rejected as written–the return type of create() in Baz is not a subtype of the return type of create() in Bar.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Class Literals as Runtime-Type Tokens","date":"2020-12-05T17:38:19.662Z","path":"wiki/2021-03-03-Class Literals as Runtime-Type Tokens/","text":"More Fun with WildcardsIn this section, we’ll consider some of the more advanced uses of wildcards. We’ve seen several examples where bounded wildcards were useful when reading from a data structure. Now consider the inverse, a write-only data structure. The interface Sink is a simple example of this sort. 12345**interface** Sink&lt;T&gt; &#123; flush(T t);&#125; We can imagine using it as demonstrated by the code below. The method writeAll() is designed to flush all elements of the collection coll to the sink snk, and return the last element flushed. 1234567891011121314**public static** &lt;T&gt; T writeAll(Collection&lt;T&gt; coll, Sink&lt;T&gt; snk) &#123; T last; **for** (T t : coll) &#123; last &#x3D; t; snk.flush(last); &#125; **return** last;&#125;...Sink&lt;Object&gt; s;Collection&lt;String&gt; cs;String str &#x3D; writeAll(cs, s); &#x2F;&#x2F; *Illegal call.* As written, the call to writeAll() is illegal, as no valid type argument can be inferred; neither String nor Object are appropriate types for T, because the Collection element and the Sink element must be of the same type. We can fix this error by modifying the signature of writeAll() as shown below, using a wildcard. 123456**public static** &lt;T&gt; T writeAll(Collection&lt;? **extends** T&gt;, Sink&lt;T&gt;) &#123;...&#125;...&#x2F;&#x2F; *Call is OK, but wrong return type.* String str &#x3D; writeAll(cs, s); The call is now legal, but the assignment is erroneous, since the return type inferred is Object because T matches the element type of s, which is Object. The solution is to use a form of bounded wildcard we haven’t seen yet: wildcards with a lower bound. The syntax ? **super** T denotes an unknown type that is a supertype of T (or T itself; remember that the supertype relation is reflexive). It is the dual of the bounded wildcards we’ve been using, where we use ? **extends** T to denote an unknown type that is a subtype of T. 123456**public static** &lt;T&gt; T writeAll(Collection&lt;T&gt; coll, Sink&lt;? **super** T&gt; snk) &#123; ...&#125;String str &#x3D; writeAll(cs, s); &#x2F;&#x2F; *Yes!* Using this syntax, the call is legal, and the inferred type is String, as desired. Now let’s turn to a more realistic example. A java.util.TreeSet&amp;lt;E&amp;gt; represents a tree of elements of type E that are ordered. One way to construct a TreeSet is to pass a Comparator object to the constructor. That comparator will be used to sort the elements of the TreeSet according to a desired ordering. 123TreeSet(Comparator&lt;E&gt; c) The Comparator interface is essentially: 12345**interface** Comparator&lt;T&gt; &#123; **int** compare(T fst, T snd);&#125; Suppose we want to create a TreeSet&amp;lt;String&amp;gt; and pass in a suitable comparator, We need to pass it a Comparator that can compare Strings. This can be done by a Comparator&amp;lt;String&amp;gt;, but a Comparator&amp;lt;Object&amp;gt; will do just as well. However, we won’t be able to invoke the constructor given above on a Comparator&amp;lt;Object&amp;gt;. We can use a lower bounded wildcard to get the flexibility we want: 123TreeSet(Comparator&lt;? **super** E&gt; c) This code allows any applicable comparator to be used. As a final example of using lower bounded wildcards, lets look at the method Collections.max(), which returns the maximal element in a collection passed to it as an argument. Now, in order for max() to work, all elements of the collection being passed in must implement Comparable. Furthermore, they must all be comparable to each other. A first attempt at generifying this method signature yields: 123**public static** &lt;T **extends** Comparable&lt;T&gt;&gt; T max(Collection&lt;T&gt; coll) That is, the method takes a collection of some type T that is comparable to itself, and returns an element of that type. However, this code turns out to be too restrictive. To see why, consider a type that is comparable to arbitrary objects: 1234567**class** Foo **implements** Comparable&lt;Object&gt; &#123; ...&#125;Collection&lt;Foo&gt; cf &#x3D; ... ;Collections.max(cf); &#x2F;&#x2F; *Should work.* Every element of cf is comparable to every other element in cf, since every such element is a Foo, which is comparable to any object, and in particular to another Foo. However, using the signature above, we find that the call is rejected. The inferred type must be Foo, but Foo does not implement Comparable&amp;lt;Foo&amp;gt;. It isn’t necessary that T be comparable to exactly itself. All that’s required is that T be comparable to one of its supertypes. This give us: 1234**public static** &lt;T **extends** Comparable&lt;? **super** T&gt;&gt; T max(Collection&lt;T&gt; coll) Note that the actual signature of Collections.max() is more involved. We return to it in the next section,Converting Legacy Code to Use Generics. This reasoning applies to almost any usage of Comparable that is intended to work for arbitrary types: You always want to use Comparable&amp;lt;? **super** T&amp;gt;. In general, if you have an API that only uses a type parameter T as an argument, its uses should take advantage of lower bounded wildcards (? **super** T). Conversely, if the API only returns T, you’ll give your clients more flexibility by using upper bounded wildcards (? **extends** T). Wildcard CaptureIt should be pretty clear by now that given: 12345678Set&lt;?&gt; unknownSet &#x3D; new HashSet&lt;String&gt;();...&#x2F;* Add an element t to a Set s. *&#x2F; **public static** &lt;T&gt; **void** addToSet(Set&lt;T&gt; s, T t) &#123; ...&#125; The call below is illegal. 123addToSet(unknownSet, &quot;abc&quot;); &#x2F;&#x2F; *Illegal.* It makes no difference that the actual set being passed is a set of strings; what matters is that the expression being passed as an argument is a set of an unknown type, which cannot be guaranteed to be a set of strings, or of any type in particular. Now, consider the following code: 12345678910**class** Collections &#123; ... &lt;T&gt; **public static** Set&lt;T&gt; unmodifiableSet(Set&lt;T&gt; set) &#123; ... &#125;&#125;...Set&lt;?&gt; s &#x3D; Collections.unmodifiableSet(unknownSet); &#x2F;&#x2F; *This works! Why?* It seems this should not be allowed; yet, looking at this specific call, it is perfectly safe to permit it. After all, unmodifiableSet() does work for any kind of Set, regardless of its element type. Because this situation arises relatively frequently, there is a special rule that allows such code under very specific circumstances in which the code can be proven to be safe. This rule, known as wildcard capture, allows the compiler to infer the unknown type of a wildcard as a type argument to a generic method.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"The Fine Print","date":"2020-12-05T17:38:17.906Z","path":"wiki/2021-03-03-The Fine Print/","text":"Class Literals as Runtime-Type TokensOne of the changes in JDK 5.0 is that the class java.lang.Class is generic. It’s an interesting example of using genericity for something other than a container class. Now that Class has a type parameter T, you might well ask, what does T stand for? It stands for the type that the Class object is representing. For example, the type of String.class is Class&amp;lt;String&amp;gt;, and the type of Serializable.class is Class&amp;lt;Serializable&amp;gt;. This can be used to improve the type safety of your reflection code. In particular, since the newInstance() method in Class now returns a T, you can get more precise types when creating objects reflectively. For example, suppose you need to write a utility method that performs a database query, given as a string of SQL, and returns a collection of objects in the database that match that query. One way is to pass in a factory object explicitly, writing code like: 1234567891011121314151617**interface** Factory&lt;T&gt; &#123; T make();&#125; **public** &lt;T&gt; Collection&lt;T&gt; select(Factory&lt;T&gt; factory, String statement) &#123; Collection&lt;T&gt; result &#x3D; new ArrayList&lt;T&gt;(); &#x2F;* *Run sql query using jdbc* *&#x2F; **for** (&#x2F;* *Iterate over jdbc results.* *&#x2F;) &#123; T item &#x3D; factory.make(); &#x2F;* &lt;i&gt;Use reflection and set all of item&#39;s * fields from sql results.&lt;&#x2F;i&gt; *&#x2F; result.add(item); &#125; **return** result; &#125; You can call this either as 123456select(new Factory&lt;EmpInfo&gt;()&#123; **public** EmpInfo make() &#123; **return** new EmpInfo(); &#125;&#125;, &quot;selection string&quot;); or you can declare a class EmpInfoFactory to support the Factory interface 12345678**class** EmpInfoFactory **implements** Factory&lt;EmpInfo&gt; &#123; ... **public** EmpInfo make() &#123; **return** new EmpInfo(); &#125;&#125; and call it 123select(getMyEmpInfoFactory(), &quot;selection string&quot;); The downside of this solution is that it requires either: the use of verbose anonymous factory classes at the call site, or declaring a factory class for every type used and passing a factory instance at the call site, which is somewhat unnatural. It is natural to use the class literal as a factory object, which can then be used by reflection. Today (without generics) the code might be written: 12345678910111213141516Collection emps &#x3D; sqlUtility.select(EmpInfo.class, &quot;select * from emps&quot;);...**public static** Collection select(Class c, String sqlStatement) &#123; Collection result &#x3D; new ArrayList(); &#x2F;* *Run sql query using jdbc.* *&#x2F; **for** (&#x2F;* *Iterate over jdbc results.* *&#x2F; ) &#123; Object item &#x3D; c.newInstance(); &#x2F;* &lt;i&gt;Use reflection and set all of item&#39;s * fields from sql results.&lt;&#x2F;i&gt; *&#x2F; result.add(item); &#125; **return** result; &#125; However, this would not give us a collection of the precise type we desire. Now that Class is generic, we can instead write the following: 1234567891011121314151617Collection&lt;EmpInfo&gt; emps &#x3D; sqlUtility.select(EmpInfo.class, &quot;select * from emps&quot;);...**public static** &lt;T&gt; Collection&lt;T&gt; select(Class&lt;T&gt; c, String sqlStatement) &#123; Collection&lt;T&gt; result &#x3D; new ArrayList&lt;T&gt;(); &#x2F;* *Run sql query using jdbc.* *&#x2F; **for** (&#x2F;* *Iterate over jdbc results.* *&#x2F; ) &#123; T item &#x3D; c.newInstance(); &#x2F;* &lt;i&gt;Use reflection and set all of item&#39;s * fields from sql results.&lt;&#x2F;i&gt; *&#x2F; result.add(item); &#125; **return** result; &#125; The above code gives us the precise type of collection in a type safe way. This technique of using class literals as run time type tokens is a very useful trick to know. It’s an idiom that’s used extensively in the new APIs for manipulating annotations, for example.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Interoperating with Legacy Code","date":"2020-12-05T17:38:15.468Z","path":"wiki/2021-03-03-Interoperating with Legacy Code/","text":"The Fine PrintA Generic Class is Shared by All Its InvocationsWhat does the following code fragment print? 12345List &lt;String&gt; l1 &#x3D; new ArrayList&lt;String&gt;();List&lt;Integer&gt; l2 &#x3D; new ArrayList&lt;Integer&gt;();System.out.println(l1.getClass() &#x3D;&#x3D; l2.getClass()); You might be tempted to say false, but you’d be wrong. It prints true, because all instances of a generic class have the same run-time class, regardless of their actual type parameters. Indeed, what makes a class generic is the fact that it has the same behavior for all of its possible type parameters; the same class can be viewed as having many different types. As consequence, the static variables and methods of a class are also shared among all the instances. That is why it is illegal to refer to the type parameters of a type declaration in a static method or initializer, or in the declaration or initializer of a static variable. Casts and InstanceOfAnother implication of the fact that a generic class is shared among all its instances, is that it usually makes no sense to ask an instance if it is an instance of a particular invocation of a generic type: 12345Collection cs &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F; *Illegal.*if (cs **instanceof** Collection&lt;String&gt;) &#123; ... &#125; similarly, a cast such as 1234&#x2F;&#x2F; *Unchecked warning,*Collection&lt;String&gt; cstr &#x3D; (Collection&lt;String&gt;) cs; gives an unchecked warning, since this isn’t something the runtime system is going to check for you. The same is true of type variables 123456&#x2F;&#x2F; *Unchecked warning.* &lt;T&gt; T badCast(T t, Object o) &#123; **return** (T) o;&#125; Type variables don’t exist at run time. This means that they entail no performance overhead in either time nor space, which is nice. Unfortunately, it also means that you can’t reliably use them in casts. ArraysThe component type of an array object may not be a type variable or a parameterized type, unless it is an (unbounded) wildcard type.You can declare array types whose element type is a type variable or a parameterized type, but not array objects. This is annoying, to be sure. This restriction is necessary to avoid situations like: 12345678910111213&#x2F;&#x2F; *Not really allowed.*List&lt;String&gt;[] lsa &#x3D; new List&lt;String&gt;[10];Object o &#x3D; lsa;Object[] oa &#x3D; (Object[]) o;List&lt;Integer&gt; li &#x3D; new ArrayList&lt;Integer&gt;();li.add(new Integer(3));&#x2F;&#x2F; *Unsound, but passes run time store check*oa[1] &#x3D; li;&#x2F;&#x2F; *Run-time error: ClassCastException.*String s &#x3D; lsa[1].get(0); If arrays of parameterized type were allowed, the previous example would compile without any unchecked warnings, and yet fail at run-time. We’ve had type-safety as a primary design goal of generics. In particular, the language is designed to guarantee that if your entire application has been compiled without unchecked warnings using javac -source 1.5, it is type safe. However, you can still use wildcard arrays. The following variation on the previous code forgoes the use of both array objects and array types whose element type is parameterized. As a result, we have to cast explicitly to get a String out of the array. 123456789101112&#x2F;&#x2F; *OK, array of unbounded wildcard type.*List&lt;?&gt;[] lsa &#x3D; new List&lt;?&gt;[10];Object o &#x3D; lsa;Object[] oa &#x3D; (Object[]) o;List&lt;Integer&gt; li &#x3D; new ArrayList&lt;Integer&gt;();li.add(new Integer(3));&#x2F;&#x2F; *Correct.*oa[1] &#x3D; li;&#x2F;&#x2F; *Run time error, but cast is explicit.*String s &#x3D; (String) lsa[1].get(0); In the next variation, which causes a compile-time error, we refrain from creating an array object whose element type is parameterized, but still use an array type with a parameterized element type. 1234&#x2F;&#x2F; *Error.*List&lt;String&gt;[] lsa &#x3D; new List&lt;?&gt;[10]; Similarly, attempting to create an array object whose element type is a type variable causes a compile-time error: 12345&lt;T&gt; T[] makeArray(T t) &#123; **return** new T[100]; &#x2F;&#x2F; *Error.*&#125; Since type variables don’t exist at run time, there is no way to determine what the actual array type would be. The way to work around these kinds of limitations is to use class literals as run time type tokens, as described in the next section,Class Literals as Runtime-Type Tokens.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Generic Methods","date":"2020-12-05T17:38:13.643Z","path":"wiki/2021-03-03-Generic Methods/","text":"Interoperating with Legacy CodeUntil now, all our examples have assumed an idealized world, where everyone is using the latest version of the Java programming language, which supports generics. Alas, in reality this isn’t the case. Millions of lines of code have been written in earlier versions of the language, and they won’t all be converted overnight. Later, in theConverting Legacy Code to Use Generics section, we will tackle the problem of converting your old code to use generics. In this section, we’ll focus on a simpler problem: how can legacy code and generic code interoperate? This question has two parts: using legacy code from within generic code and using generic code within legacy code. Using Legacy Code in Generic CodeHow can you use old code, while still enjoying the benefits of generics in your own code? As an example, assume you want to use the package com.Example.widgets. The folks at Example.com market a system for inventory control, highlights of which are shown below: 12345678910111213141516171819202122**package** com.Example.widgets;**public interface** Part &#123;...&#125;**public class** Inventory &#123; &#x2F;** * Adds a new Assembly to the inventory database. * The assembly is given the name name, and * consists of a set parts specified by parts. * All elements of the collection parts * must support the Part interface. **&#x2F; **public static void** addAssembly(String name, Collection parts) &#123;...&#125; **public static** Assembly getAssembly(String name) &#123;...&#125;&#125;**public interface** Assembly &#123; &#x2F;&#x2F; *Returns a collection of Parts* Collection getParts();&#125; Now, you’d like to add new code that uses the API above. It would be nice to ensure that you always called addAssembly() with the proper arguments - that is, that the collection you pass in is indeed a Collection of Part. Of course, generics are tailor made for this: 12345678910111213141516171819202122**package** com.mycompany.inventory;**import** com.Example.widgets.*;**public class** Blade implements Part &#123; ...&#125;**public class** Guillotine implements Part &#123;&#125;**public class** Main &#123; **public static void** main(String[] args) &#123; Collection&lt;Part&gt; c &#x3D; new ArrayList&lt;Part&gt;(); c.add(new Guillotine()) ; c.add(new Blade()); Inventory.addAssembly(&quot;thingee&quot;, c); Collection&lt;Part&gt; k &#x3D; Inventory.getAssembly(&quot;thingee&quot;).getParts(); &#125;&#125; When we call addAssembly, it expects the second parameter to be of type Collection. The actual argument is of type Collection&amp;lt;Part&amp;gt;. This works, but why? After all, most collections don’t contain Part objects, and so in general, the compiler has no way of knowing what kind of collection the type Collection refers to. In proper generic code, Collection would always be accompanied by a type parameter. When a generic type like Collection is used without a type parameter, it’s called a raw type. Most people’s first instinct is that Collection really means Collection&amp;lt;Object&amp;gt;. However, as we saw earlier, it isn’t safe to pass a Collection&amp;lt;Part&amp;gt; in a place where a Collection&amp;lt;Object&amp;gt; is required. It’s more accurate to say that the type Collection denotes a collection of some unknown type, just like Collection&amp;lt;?&amp;gt;. But wait, that can’t be right either! Consider the call to getParts(), which returns a Collection. This is then assigned to k, which is a Collection&amp;lt;Part&amp;gt;. If the result of the call is a Collection&amp;lt;?&amp;gt;, the assignment would be an error. In reality, the assignment is legal, but it generates an unchecked warning. The warning is needed, because the fact is that the compiler can’t guarantee its correctness. We have no way of checking the legacy code in getAssembly() to ensure that indeed the collection being returned is a collection of Parts. The type used in the code is Collection, and one could legally insert all kinds of objects into such a collection. So, shouldn’t this be an error? Theoretically speaking, yes; but practically speaking, if generic code is going to call legacy code, this has to be allowed. It’s up to you, the programmer, to satisfy yourself that in this case, the assignment is safe because the contract of getAssembly() says it returns a collection of Parts, even though the type signature doesn’t show this. So raw types are very much like wildcard types, but they are not typechecked as stringently. This is a deliberate design decision, to allow generics to interoperate with pre-existing legacy code. Calling legacy code from generic code is inherently dangerous; once you mix generic code with non-generic legacy code, all the safety guarantees that the generic type system usually provides are void. However, you are still better off than you were without using generics at all. At least you know the code on your end is consistent. At the moment there’s a lot more non-generic code out there then there is generic code, and there will inevitably be situations where they have to mix. If you find that you must intermix legacy and generic code, pay close attention to the unchecked warnings. Think carefully how you can justify the safety of the code that gives rise to the warning. What happens if you still made a mistake, and the code that caused a warning is indeed not type safe? Let’s take a look at such a situation. In the process, we’ll get some insight into the workings of the compiler. Erasure and Translation12345678**public** String loophole(Integer x) &#123; List&lt;String&gt; ys &#x3D; new LinkedList&lt;String&gt;(); List xs &#x3D; ys; xs.add(x); &#x2F;&#x2F; *Compile-time unchecked warning* **return** ys.iterator().next();&#125; Here, we’ve aliased a list of strings and a plain old list. We insert an Integer into the list, and attempt to extract a String. This is clearly wrong. If we ignore the warning and try to execute this code, it will fail exactly at the point where we try to use the wrong type. At run time, this code behaves like: 12345678**public** String loophole(Integer x) &#123; List ys &#x3D; new LinkedList; List xs &#x3D; ys; xs.add(x); **return**(String) ys.iterator().next(); &#x2F;&#x2F; *run time error*&#125; When we extract an element from the list, and attempt to treat it as a string by casting it to String, we will get a ClassCastException. The exact same thing happens with the generic version of loophole(). The reason for this is, that generics are implemented by the Java compiler as a front-end conversion called erasure. You can (almost) think of it as a source-to-source translation, whereby the generic version of loophole() is converted to the non-generic version. As a result, the type safety and integrity of the Java virtual machine are never at risk, even in the presence of unchecked warnings. Basically, erasure gets rid of (or erases) all generic type information. All the type information betweeen angle brackets is thrown out, so, for example, a parameterized type like List&amp;lt;String&amp;gt; is converted into List. All remaining uses of type variables are replaced by the upper bound of the type variable (usually Object). And, whenever the resulting code isn’t type-correct, a cast to the appropriate type is inserted, as in the last line of loophole. The full details of erasure are beyond the scope of this tutorial, but the simple description we just gave isn’t far from the truth. It’s good to know a bit about this, especially if you want to do more sophisticated things like converting existing APIs to use generics (see theConverting Legacy Code to Use Generics section), or just want to understand why things are the way they are. Using Generic Code in Legacy CodeNow let’s consider the inverse case. Imagine that Example.com chose to convert their API to use generics, but that some of their clients haven’t yet. So now the code looks like: 123456789101112131415161718192021222324**package** com.Example.widgets;**public interface** Part &#123; ...&#125;**public class** Inventory &#123; &#x2F;** * Adds a new Assembly to the inventory database. * The assembly is given the name name, and * consists of a set parts specified by parts. * All elements of the collection parts * must support the Part interface. **&#x2F; **public static void** addAssembly(String name, Collection&lt;Part&gt; parts) &#123;...&#125; **public static** Assembly getAssembly(String name) &#123;...&#125;&#125;**public interface** Assembly &#123; &#x2F;&#x2F; *Returns a collection of Parts* Collection&lt;Part&gt; getParts();&#125; and the client code looks like: 12345678910111213141516171819202122232425**package** com.mycompany.inventory;**import** com.Example.widgets.*;**public class** Blade implements Part &#123;...&#125;**public class** Guillotine implements Part &#123;&#125;**public class** Main &#123; **public static void** main(String[] args) &#123; Collection c &#x3D; new ArrayList(); c.add(new Guillotine()) ; c.add(new Blade()); &#x2F;&#x2F; *1: unchecked warning* Inventory.addAssembly(&quot;thingee&quot;, c); Collection k &#x3D; Inventory.getAssembly(&quot;thingee&quot;).getParts(); &#125;&#125; The client code was written before generics were introduced, but it uses the package com.Example.widgets and the collection library, both of which are using generic types. All the uses of generic type declarations in the client code are raw types. Line 1 generates an unchecked warning, because a raw Collection is being passed in where a Collection of Parts is expected, and the compiler cannot ensure that the raw Collection really is a Collection of Parts. As an alternative, you can compile the client code using the source 1.4 flag, ensuring that no warnings are generated. However, in that case you won’t be able to use any of the new language features introduced in JDK 5.0.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Wildcards","date":"2020-12-05T17:38:11.560Z","path":"wiki/2021-03-03-Wildcards/","text":"Generic MethodsConsider writing a method that takes an array of objects and a collection and puts all objects in the array into the collection. Here’s a first attempt: 1234567**static void** fromArrayToCollection(Object[] a, Collection&lt;?&gt; c) &#123; **for** (Object o : a) &#123; c.add(o); &#x2F;&#x2F; *compile-time error* &#125;&#125; By now, you will have learned to avoid the beginner’s mistake of trying to use Collection&amp;lt;Object&amp;gt; as the type of the collection parameter. You may or may not have recognized that using Collection&amp;lt;?&amp;gt; isn’t going to work either. Recall that you cannot just shove objects into a collection of unknown type. The way to do deal with these problems is to use generic methods. Just like type declarations, method declarations can be generic&#151;that is, parameterized by one or more type parameters. 1234567**static** &lt;T&gt; **void** fromArrayToCollection(T[] a, Collection&lt;T&gt; c) &#123; **for** (T o : a) &#123; c.add(o); &#x2F;&#x2F; *Correct* &#125;&#125; We can call this method with any kind of collection whose element type is a supertype of the element type of the array. 123456789101112131415161718192021222324252627282930313233343536Object[] oa &#x3D; new Object[100];Collection&lt;Object&gt; co &#x3D; new ArrayList&lt;Object&gt;();&#x2F;&#x2F; *T inferred to be Object*fromArrayToCollection(oa, co); String[] sa &#x3D; new String[100];Collection&lt;String&gt; cs &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F; *T inferred to be String*fromArrayToCollection(sa, cs);&#x2F;&#x2F; *T inferred to be Object*fromArrayToCollection(sa, co);Integer[] ia &#x3D; new Integer[100];Float[] fa &#x3D; new Float[100];Number[] na &#x3D; new Number[100];Collection&lt;Number&gt; cn &#x3D; new ArrayList&lt;Number&gt;();&#x2F;&#x2F; *T inferred to be Number*fromArrayToCollection(ia, cn);&#x2F;&#x2F; *T inferred to be Number*fromArrayToCollection(fa, cn);&#x2F;&#x2F; *T inferred to be Number*fromArrayToCollection(na, cn);&#x2F;&#x2F; *T inferred to be Object*fromArrayToCollection(na, co);&#x2F;&#x2F; *compile-time error*fromArrayToCollection(na, cs); Notice that we don’t have to pass an actual type argument to a generic method. The compiler infers the type argument for us, based on the types of the actual arguments. It will generally infer the most specific type argument that will make the call type-correct. &lt;!–% show examples from library % show wildcard examples and show how they could be done using% type parameters, and explain when to use generic methods and when not–&gt; One question that arises is: when should I use generic methods, and when should I use wildcard types? To understand the answer, let’s examine a few methods from the Collection libraries. 123456**interface** Collection&lt;E&gt; &#123; **public boolean** containsAll(Collection&lt;?&gt; c); **public boolean** addAll(Collection&lt;? **extends E**&gt; c);&#125; We could have used generic methods here instead: 1234567**interface** Collection&lt;E&gt; &#123; **public** &lt;T&gt; **boolean** containsAll(Collection&lt;T&gt; c); **public** &lt;T **extends** E&gt; **boolean** addAll(Collection&lt;T&gt; c); &#x2F;&#x2F; *Hey, type variables can have bounds too!*&#125; However, in both containsAll and addAll, the type parameter T is used only once. The return type doesn’t depend on the type parameter, nor does any other argument to the method (in this case, there simply is only one argument). This tells us that the type argument is being used for polymorphism; its only effect is to allow a variety of actual argument types to be used at different invocation sites. If that is the case, one should use wildcards. Wildcards are designed to support flexible subtyping, which is what we’re trying to express here. Generic methods allow type parameters to be used to express dependencies among the types of one or more arguments to a method and/or its return type. If there isn’t such a dependency, a generic method should not be used. It is possible to use both generic methods and wildcards in tandem. Here is the method Collections.copy(): 123456**class** Collections &#123; **public static** &lt;T&gt; **void** copy(List&lt;T&gt; dest, List&lt;? **extends** T&gt; src) &#123; ...&#125; Note the dependency between the types of the two parameters. Any object copied from the source list, src, must be assignable to the element type T of the destination list, dst. So the element type of src can be any subtype of T&#151;we don’t care which. The signature of copy expresses the dependency using a type parameter, but uses a wildcard for the element type of the second parameter. We could have written the signature for this method another way, without using wildcards at all: 123456**class** Collections &#123; **public static** &lt;T, S **extends** T&gt; **void** copy(List&lt;T&gt; dest, List&lt;S&gt; src) &#123; ...&#125; This is fine, but while the first type parameter is used both in the type of dst and in the bound of the second type parameter, S, S itself is only used once, in the type of src&#151;nothing else depends on it. This is a sign that we can replace S with a wildcard. Using wildcards is clearer and more concise than declaring explicit type parameters, and should therefore be preferred whenever possible. Wildcards also have the advantage that they can be used outside of method signatures, as the types of fields, local variables and arrays. Here is an example. Returning to our shape drawing problem, suppose we want to keep a history of drawing requests. We can maintain the history in a static variable inside class Shape, and have drawAll() store its incoming argument into the history field. 1234567891011**static** List&lt;List&lt;? extends Shape&gt;&gt; history &#x3D; new ArrayList&lt;List&lt;? extends Shape&gt;&gt;();**public void** drawAll(List&lt;? **extends** Shape&gt; shapes) &#123; history.addLast(shapes); **for** (Shape s: shapes) &#123; s.draw(**this**); &#125;&#125; Finally, again let’s take note of the naming convention used for the type parameters. We use T for type, whenever there isn’t anything more specific about the type to distinguish it. This is often the case in generic methods. If there are multiple type parameters, we might use letters that neighbor T in the alphabet, such as S. If a generic method appears inside a generic class, it’s a good idea to avoid using the same names for the type parameters of the method and class, to avoid confusion. The same applies to nested generic classes. &lt;!–% somewhere figure out how to explain any&#39;&#39; and some’’ -% subtlety between taking any type and some unknown type, why each% occurence of ? is different. % more details - definitions with bounds, multiple type params % interfacing with legacy code - raw types–&gt;","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Generics and Subtyping","date":"2020-12-05T17:38:10.478Z","path":"wiki/2021-03-03-Generics and Subtyping/","text":"WildcardsConsider the problem of writing a routine that prints out all the elements in a collection. Here’s how you might write it in an older version of the language (i.e., a pre-5.0 release): 12345678**void** printCollection(Collection c) &#123; Iterator i &#x3D; c.iterator(); **for** (k &#x3D; 0; k &lt; c.size(); k++) &#123; System.out.println(i.next()); &#125;&#125; And here is a naive attempt at writing it using generics (and the new for loop syntax): 1234567**void** printCollection(Collection&lt;Object&gt; c) &#123; **for** (Object e : c) &#123; System.out.println(e); &#125;&#125; The problem is that this new version is much less useful than the old one. Whereas the old code could be called with any kind of collection as a parameter, the new code only takes Collection&amp;lt;Object&amp;gt;, which, as we’ve just demonstrated, is not a supertype of all kinds of collections! So what is the supertype of all kinds of collections? It’s written Collection&amp;lt;?&amp;gt; (pronounced “collection of unknown”), that is, a collection whose element type matches anything. It’s called a wildcard type for obvious reasons. We can write: 1234567**void** printCollection(Collection&lt;?&gt; c) &#123; **for** (Object e : c) &#123; System.out.println(e); &#125;&#125; and now, we can call it with any type of collection. Notice that inside printCollection(), we can still read elements from c and give them type Object. This is always safe, since whatever the actual type of the collection, it does contain objects. It isn’t safe to add arbitrary objects to it however: 1234Collection&lt;?&gt; c &#x3D; new ArrayList&lt;String&gt;();c.add(new Object()); &#x2F;&#x2F; Compile time error Since we don’t know what the element type of c stands for, we cannot add objects to it. The add() method takes arguments of type E, the element type of the collection. When the actual type parameter is ?, it stands for some unknown type. Any parameter we pass to add would have to be a subtype of this unknown type. Since we don’t know what type that is, we cannot pass anything in. The sole exception is null, which is a member of every type. On the other hand, given a List&amp;lt;?&amp;gt;, we can call get() and make use of the result. The result type is an unknown type, but we always know that it is an object. It is therefore safe to assign the result of get() to a variable of type Object or pass it as a parameter where the type Object is expected. Bounded WildcardsConsider a simple drawing application that can draw shapes such as rectangles and circles. To represent these shapes within the program, you could define a class hierarchy such as this: 12345678910111213141516171819**public abstract class** Shape &#123; **public abstract void** draw(Canvas c);&#125;**public class** Circle **extends** Shape &#123; **private int** x, y, radius; **public void** draw(Canvas c) &#123; ... &#125;&#125;**public class** Rectangle **extends** Shape &#123; **private int** x, y, width, height; **public void** draw(Canvas c) &#123; ... &#125;&#125; These classes can be drawn on a canvas: 1234567**public class** Canvas &#123; **public void** draw(Shape s) &#123; s.draw(**this**); &#125;&#125; Any drawing will typically contain a number of shapes. Assuming that they are represented as a list, it would be convenient to have a method in Canvas that draws them all: 1234567**public void** drawAll(List&lt;Shape&gt; shapes) &#123; **for** (Shape s: shapes) &#123; s.draw(**this**); &#125;&#125; Now, the type rules say that drawAll() can only be called on lists of exactly Shape: it cannot, for instance, be called on a List&amp;lt;Circle&amp;gt;. That is unfortunate, since all the method does is read shapes from the list, so it could just as well be called on a List&amp;lt;Circle&amp;gt;. What we really want is for the method to accept a list of any kind of shape: 12345**public void** drawAll(List&lt;? **extends** Shape&gt; shapes) &#123; ...&#125; There is a small but very important difference here: we have replaced the type List&amp;lt;Shape&amp;gt; with List&amp;lt;? **extends** Shape&amp;gt;. Now drawAll() will accept lists of any subclass of Shape, so we can now call it on a List&amp;lt;Circle&amp;gt; if we want. List&amp;lt;? **extends** Shape&amp;gt; is an example of a bounded wildcard. The ? stands for an unknown type, just like the wildcards we saw earlier. However, in this case, we know that this unknown type is in fact a subtype of Shape. (Note: It could be Shape itself, or some subclass; it need not literally extend Shape.) We say that Shape is the upper bound of the wildcard. There is, as usual, a price to be paid for the flexibility of using wildcards. That price is that it is now illegal to write into shapes in the body of the method. For instance, this is not allowed: 123456**public void** addRectangle(List&lt;? **extends** Shape&gt; shapes) &#123; &#x2F;&#x2F; *Compile-time error!* shapes.add(0, **new** Rectangle());&#125; You should be able to figure out why the code above is disallowed. The type of the second parameter to shapes.add() is ? **extends** Shape– an unknown subtype of Shape. Since we don’t know what type it is, we don’t know if it is a supertype of Rectangle; it might or might not be such a supertype, so it isn’t safe to pass a Rectangle there. Bounded wildcards are just what one needs to handle the example of the DMV passing its data to the census bureau. Our example assumes that the data is represented by mapping from names (represented as strings) to people (represented by reference types such as Person or its subtypes, such as Driver). Map&amp;lt;K,V&amp;gt; is an example of a generic type that takes two type arguments, representing the keys and values of the map. Again, note the naming convention for formal type parameters–K for keys and V for values. 123456789**public class** Census &#123; **public static void** addRegistry(Map&lt;String, ? **extends** Person&gt; registry) &#123;&#125;...Map&lt;String, Driver&gt; allDrivers &#x3D; ... ;Census.addRegistry(allDrivers);","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Defining Simple Generics","date":"2020-12-05T17:38:09.409Z","path":"wiki/2021-03-03-Defining Simple Generics/","text":"Generics and SubtypingLet’s test your understanding of generics. Is the following code snippet legal? 1234List&lt;String&gt; ls &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F; 1List&lt;Object&gt; lo &#x3D; ls; &#x2F;&#x2F; 2 Line 1 is certainly legal. The trickier part of the question is line 2. This boils down to the question: is a List of String a List of Object. Most people instinctively answer, “Sure!” Well, take a look at the next few lines: 1234lo.add(new Object()); &#x2F;&#x2F; 3String s &#x3D; ls.get(0); &#x2F;&#x2F; 4: Attempts to assign an Object to a String! Here we’ve aliased ls and lo. Accessing ls, a list of String, through the alias lo, we can insert arbitrary objects into it. As a result ls does not hold just Strings anymore, and when we try and get something out of it, we get a rude surprise. The Java compiler will prevent this from happening of course. Line 2 will cause a compile time error. In general, if Foo is a subtype (subclass or subinterface) of Bar, and G is some generic type declaration, it is not the case that G&amp;lt;Foo&amp;gt; is a subtype of G&amp;lt;Bar&amp;gt;. This is probably the hardest thing you need to learn about generics, because it goes against our deeply held intuitions. We should not assume that collections don’t change. Our instinct may lead us to think of these things as immutable. For example, if the department of motor vehicles supplies a list of drivers to the census bureau, this seems reasonable. We think that a List&amp;lt;Driver&amp;gt; is a List&amp;lt;Person&amp;gt;, assuming that Driver is a subtype of Person. In fact, what is being passed is a copy of the registry of drivers. Otherwise, the census bureau could add new people who are not drivers into the list, corrupting the DMV’s records. To cope with this sort of situation, it’s useful to consider more flexible generic types. The rules we’ve seen so far are quite restrictive.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Generics","date":"2020-12-05T17:38:06.751Z","path":"wiki/2021-03-03-Generics/","text":"IntroductionJDK 5.0 introduces several new extensions to the Java programming language. One of these is the introduction of generics. This trail is an introduction to generics. You may be familiar with similar constructs from other languages, most notably C++ templates. If so, you’ll see that there are both similarities and important differences. If you are unfamiliar with look-a-alike constructs from elsewhere, all the better; you can start fresh, without having to unlearn any misconceptions. Generics allow you to abstract over types. The most common examples are container types, such as those in the Collections hierarchy. Here is a typical usage of that sort: 12345List myIntList &#x3D; new LinkedList(); &#x2F;&#x2F; 1myIntList.add(new Integer(0)); &#x2F;&#x2F; 2Integer x &#x3D; (Integer) myIntList.iterator().next(); &#x2F;&#x2F; 3 The cast on line 3 is slightly annoying. Typically, the programmer knows what kind of data has been placed into a particular list. However, the cast is essential. The compiler can only guarantee that an Object will be returned by the iterator. To ensure the assignment to a variable of type Integer is type safe, the cast is required. Of course, the cast not only introduces clutter. It also introduces the possibility of a run time error, since the programmer may be mistaken. What if programmers could actually express their intent, and mark a list as being restricted to contain a particular data type? This is the core idea behind generics. Here is a version of the program fragment given above using generics: 123456List&lt;Integer&gt; myIntList &#x3D; new LinkedList&lt;Integer&gt;(); &#x2F;&#x2F; 1&#39;myIntList.add(new Integer(0)); &#x2F;&#x2F; 2&#39;Integer x &#x3D; myIntList.iterator().next(); &#x2F;&#x2F; 3&#39; Notice the type declaration for the variable myIntList. It specifies that this is not just an arbitrary List, but a List of Integer, written List&amp;lt;Integer&amp;gt;. We say that List is a generic interface that takes a type parameter–in this case, Integer. We also specify a type parameter when creating the list object. Note, too, that the cast on line 3’ is gone. Now, you might think that all we’ve accomplished is to move the clutter around. Instead of a cast to Integer on line 3, we have Integer as a type parameter on line 1’. However, there is a very big difference here. The compiler can now check the type correctness of the program at compile-time. When we say that myIntList is declared with type List&amp;lt;Integer&amp;gt;, this tells us something about the variable myIntList, which holds true wherever and whenever it is used, and the compiler will guarantee it. In contrast, the cast tells us something the programmer thinks is true at a single point in the code. The net effect, especially in large programs, is improved readability and robustness.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Bonus","date":"2020-12-05T17:38:05.290Z","path":"wiki/2021-03-03-Bonus/","text":"Lesson: Genericsby Gilad BrachaIntroduced in J2SE 5.0, this long-awaited enhancement to the type system allows a type or method to operate on objects of various types while providing compile-time type safety. It adds compile-time type safety to the Collections Framework and eliminates the drudgery of casting.","tags":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"}],"categories":[{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"}]},{"title":"Inheritance","date":"2020-12-01T05:06:40.697Z","path":"wiki/2021-03-03-Inheritance/","text":"继承的技巧： 将共同的操作和属性放在父类中 尽量不使用protected属性，因为protected提供的保护并不到位，每个人都可以写一个子类来访问你的保护的变量，会破坏封装性，同样，在同一个包下的类也可以访问该保护变量。但是，当你需要在子类重新定义或者还没准备一般使用的方法来说，protected很有用 不要滥用了继承中的is-a关系，只用继承来模拟is-a关系，对于不是is-a关系的不用继承关系，不然有时候使用继承反而使得代码更复杂。 除非所有继承的方法都有意义，否则不适用继承 重写方法时不要改变expected behavior，应该要满足替换原则才好 使用多态而不是类型信息，多态的使用可以省去不必要的代码 不要过度使用反射机制，反射是很脆弱的，编译器不能帮助你找出问题，而且反射很容易出错 继承首先创建一些具有特定内容的对象，但是突然有需要添加一个新的对象，但是只是在原有类的基础上添加了一些新的内容，这个时候，我们想要有一种方法可以在原有的对象上面进行修改添加，从而可以节省许多的工作量和代码量，这种方法就是继承。 继承是指新生类继承了原有类的内容，并在原有类的基础上进行了内容的丰富添加。 123456789101112public Animal &#123; public void getSex()&#123; System.out.print(&quot;sex&quot;); &#125;&#125;public Cat extends Animal&#123; public void printName()&#123; System.out.print(&quot;name&quot;); &#125;&#125; 如上代码，就是在Animal的基础上，通过继承而生成了新类。Cat类继承了原有类的getSex方法，同时自己又新添加了printName方法。 子类继承时，对于父类中的private的变量是没有访问权限的，子类只可以进行重定义覆盖。 继承时，若是重写了构造方法，而没有重写无参数的构造方法时，来使用这个会报错。如果子类没有显示invoke父类的构造方法，java编译器会自动调用父类的无参数构造方法，如果父类没有无参数构造方法，会报编译时错误。Object确实有无参数方法，如果==object是唯一父类，没啥问题== override子类对于父类的方法可以进行override，就是定义和父类的方法名参数和返回值一样的方法，但是访问权限可以比父类的更放松（比如protected 可以是public或者default）当父类的==type cast==应用到子类的时候，调用override方法时，==优先调用的是子类中的==。如果重写方法的时候没有满足条件，并不会出现重写。在annotation中有一个==@Override==，可以在子类重写的方法上标注，如果==编译的时候重写未成功会出现编译错误==。 1234567891011public Animal&#123; public void getName()&#123; System.out.print(&quot;name&quot;); &#125;&#125;public Cat extends Animal&#123; @Override // 带上这个annotation时，重写不成功就会报错 public void getName()&#123; System.out.print(&quot;cat&quot;); &#125;&#125; 重写不成功： 变量数量和变量顺序对不上 变量类型不匹配 返回值类型不匹配 名称不匹配 hide如果定义一个和父类的静态方法同名的方法，只会隐藏父类中的静态方法，并不会重写该方法，并且在决定调用哪一个方法时，主要通过查看是哪个类调用该静态方法 hide fields当子类中的fileds名字和父类的fields一致时，就会隐藏父类中的fields（类型不一样也会，并不建议这样去隐藏父类的fields）==在父类中的fields在子类中访问不能用变量名而需要使用super关键字来进行访问== this keyword用来在构造方法或者实例方法中指代当前对象（当方法的参数变量名和fields冲突时，利用this防止冲突），可以用来调用类中的filedsthis.fieldsName也可以用来调用实例方法this.instanceMethodsName()，还可以用来调用当前类的其他构造方法this()可以传入参数。 super keyword如果父类的方法被重写了但是还想调用父类的重写方法可以使用super关键字来达成super.methodName();也可用来调用父类中的构造方法super()，当然也可以用来调用父类的fieldssuper.fieldsName。不过super只能在非静态方法中使用或者构造器或者在方法外类中也可使用。==NOTE：==如果构造器中没有明确invoke父类的构造器，编译器会自动invoke父类的没有参数的构造器，如果==父类中没有这样一个构造器，就会编译错误==。Object确实有这样一个构造器，如果object是唯一父类，没啥问题 在调用父类构造方法时，不管显式还是隐式，都会有一系列的构造器调用，直到回到Object（所有类的父类）这种叫做构造器链（constructor chainning），==当有长而多的class descent时，需要注意了== type casttype cast是使用父类的类型引用，但是指向的是子类的new构造方法，由于这种情况的存在，可以实现多态这另外一个oop的特性。 12345678910111213141516public Animal&#123; public void getName()&#123; System.out.print(&quot;name&quot;); &#125;&#125;public Cat extends Animal&#123; public void getName()&#123; System.out.print(&quot;cat&quot;); &#125; public static void main(String[] args)&#123; Animal animal = new Cat(); Cat cat = new Cat(); Cat cat1 = (Cat)animal; // 使用这种强制类型引用，可以将拥有父类引用的调用了子类构造方法的变量强制转换为子类,但如果子类索引转换为父类会报错 animal.getName(); // 尽管使用的父类引用，但是调用被子类重写的方法时，会调用子类的方法 &#125;&#125; [[Object]]所有类的父类，类等级制度中的最高一层，每个类都显示或者隐式的是Object的子类。","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"generic Array List","date":"2020-11-30T16:17:57.099Z","path":"wiki/2021-03-03-generic Array List/","text":"public class ArrayList&lt;T&gt;&#123;&#125; 用来对数组进行随心所欲的操作，可以动态变化的数组。正常的数组只能实现定义好数组的长度再进行使用 123456Scanner s &#x3D; new Scanner(System.in);if s.hasNextInt()&#123; int arraySize &#x3D; s.nextInt();&#125;int[] array &#x3D; new int[arraySize]; &#x2F;&#x2F; 只能使用类似的方法做到按运行的值来确定指定数组长度 但是这种方式并不能达到动态修改添加数组元素的目的，因此为了达到动态修改数组，就需要使用ArrayList类，他是一个泛型，在创建的时候需要指定类型。ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;();创建了一个数组列表，此时利用这个对象来进行动态增加修改删除和获取数组元素了。 get(int index)：获取指定索引处的值 add(T obj)和 add(int index, T obj)：向数组中添加值，第二个是向指定索引处添加值，如果超出范围，数组列表会重新分配存储 set(int index, T obj)：替换修改指定索引处的值，如果该索引无值，这个方法并不会添加值 T remove(int index)：去除指定索引处的值并返回 int size()获取数组列表的数量,数组使用length属性获取 void eusureCapacity(int capacity)设定数组列表大小，也可在构造方法传入一个数组指定 void trimToSize()减少数组列表的存储能力为当前的数量，gc会回收多余的内存 由于trimToSize方法的存在，当你确定你的列表已经完成修改时，可以使用这个方法来释放内存。如果你想要使用灵活变化和访问方便的时候，可以先用数组列表，进行操作，当你 确定你已经完成多有操作时，可以使用toArray方法来转换为数组，这时候就可以使用[]操作符来方便的访问元素了 泛型和原始类型之间的兼容性为了保证兼容性，JVM会在运行时将泛型的类型擦除。 当你将泛型作为变量转递到指定要原始类型的参数时，并不会报错和警告，但是并不是完全安全的。不过由于虚拟机的作用，并不会出错，只是丢失了编译时检查的好处。 而如果将原始类型给到泛型，会出现警告信息，入如果使用类型转换，又会出现另外一种警告信息，可以使用 -xlint:unchecked查看警告信息。这是由于泛型的缺陷导致的，由于泛型的类型擦除的存在，在运行时，并不会带有类型信息，因此都是一样的，对于这种情况没啥可以解决的，如果不严重就可以使用@SuppressWarning(“unchecked”)去除警告信息。","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Object","date":"2020-11-30T15:45:30.204Z","path":"wiki/2021-03-03-Object/","text":"object内部有许多的方法： protected Object clone() throws CloneNotSupportedException：如果类或者他的父类implements了Cloneable接口，可以使用clone方法去获得已有对象的副本。最简单的实现可以调用clone()的方法是定义类去implements Cloneable接口。对于某些类，其Object的clone()方法可以正常工作，但是，当对象包含==外部对象的reference时，需要重写clone()方法，以防外部类修改从而导致副本也跟着一起修改==（意味着原来的对象和他的副本并不是独立的）为了decouple他们，==需要重写clone()来复制对象和外部对象，原来对象指向外部对象，对象副本指向外部对象的副本==，从而使得对象和副本真正独立。 public boolean equals(Object obj)：用来测试两个对象是否相等。Objects的equals方法通过==判断，对于原始数据类型这是正确的，但是对于对象，只是判断object reference是否相等（是否两个对象指向的是同一个对象，需要进行复杂的判断时，需要自己重写这个方法才好）因此为了测试是否含有相同信息，需要重写这个方法。判断的是是否指向的是同一个reference对象写一个完美的equals方法需要有一下几点： 把明确的参数命名为otherObject，随后，需要将其转换为其他类型时，将其命名为other。并且参数类型需要时Object 测试this是否和otherObject一致if (this == otherObject) return true,测试身份比测试fields更方便 测试是否otherObject为null，if (otherObject == null) return false.这个测试是有要求有的 比较this和otherObject的classes，当子类父类的equals的语义不变时，可以使用instanceof：if !(otherObject instanceof ClassNmae) return false;,语义可以改表时，使用getClass：if (getClass != otherObject.getClass()) return false; 转换变量时，将其命名为other，并转换为你的ClassName 比较fields，原始数据类可以用等于判断，类就可以使用Object.equals()判断，数组元素可以使用Arrays.equals()判断，如果所有都匹配，返回trueJAVA Specification 要求equals有以下特点： 映射性（自等性），x.equals(x)要返回true 对称性，x.equals(y)和y.equals(x)返回相同值 可交换性，类似交换律，xy和yz相等，则xz相等 一致性，只要refer没改变，前后返回相同值 任何非null对象和null比较要为false。 protected void finalize() throws Throwable public Class getClass()：这个方法返回一个类对象，这个类对象下有你可以获取类信息的方法：getSimpleName()、getSuperClass()、and so on。就是Class类，在java.lang包中 public int hashCode()：返回对象的hashcode，是对象的存储地址。equal的两个对象的hashcode值相等。如果重写了equals方法，必须重写hashCode方法，返回多个值的hash和可用，Object.hash(Object... object)。 public String toString()：返回对象的字符串，在debug时很有用 以下几个方法使用在线程活动的synchronize public final void notify() public final void notifyAll() public final void wait() public final void wait(long timeout) public final void wait(long timeout, int nanos)","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Enum","date":"2020-11-30T15:26:22.910Z","path":"wiki/2021-03-03-Enum/","text":"枚举类型public enum EnumName&#123;CONSTANT1(values), CONSTANT2(values),...,CONSTANTn(values);&#125; 示例： 123456789101112131415161718public enum Size&#123; SMALL(&quot;S&quot;),MEDIUM(&quot;M&quot;),LARGE(&quot;L&quot;),EXTRAL_LARGE(&quot;XL&quot;); private String abbrevation; private Size(String abbrevation)&#123; this.abbrevation = abbrevation; &#125;// 构造方法需要根据常量后括号里面的值来确定怎么生成 public Stirng getAbbrevation()&#123; return this.abbrevation; &#125;&#125;// 所有的Enum类型都是Enum类的子类。Size s = Enum.valueOf(Size.class, &quot;SMALL&quot;);String string = Size.SMALL.toString(); // 返回的是常量的名字Size[] size = Size.values(); // 返回的是所有元素的数组int i = Size.SMALL.ordinal(); // 返回的是元素的位置，从0开始int bool = Size.SMALL.compareTo(Size.LARGE); // 比较两个元素的位置，也就是定义的顺序，int compareTo(E other)","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Java modifier","date":"2020-11-29T08:46:37.161Z","path":"wiki/2021-03-03-Java modifier/","text":"Java modifier 访问控制符 default：默认控制符，仅在同一个包下的类可以访问 public：公共控制符，所有的类都可以访问 private：仅类自己可以访问。类和接口不可以定义为private。用来实现类中的封装。 protected：类自己和子类可以访问，以及同一包下的其他类可以访问。不能修饰类（==内部类==可以），可修饰==构造方法、方法成员、数据成员==。接口、接口成员变量和成员方法不可修饰为protected。子类可以访问符类继承来的protected方法，而不能使用类实例的protected方法 非访问控制符 static：用来声明静态成员的。静态方法不能访问类中的非静态成员(只能通过类的实例来访问类中的非静态成员)。静态成员通过ClassName.memberName来访问 final：变量中主要用来声明常量(static final)。final还能用来声明final方法（可以被子类继承但不能override）。final还能用来定义不可变类（不能被继承，final类下的方法默认是final的，但是fields不是） abstract：用来声明抽象类（抽象类不可实例化，只能被继承，必须对抽象类中的抽象方法实现重写。）和抽象方法（包含abstract关键字的方法，没有body方法实现，需要子类重写来实现方法定义，如果类中有抽象方法，必须声明为抽象类） transient：定义的变量不会持久化（序列化对象包含该修饰符修饰的内容时JVM会自动跳过它） synchronized：该关键字声明的方法，在同一时间只能有一个线程可访问。 volatile：用来保证线程中通信，每次修改都会准确的返回到共享内存。任何时刻，不同的线程都能看到相同的变量值。","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Abstraction","date":"2020-11-29T08:40:38.304Z","path":"wiki/2021-03-03-Abstraction/","text":"当你不care类的某些方法的具体实现逻辑的时候，可以将其定义为抽象方法等待继承它的类来进行其特有的该方法的实现逻辑，当类中有方法定义为抽象方法的时候，就可以将该类定义为抽象类。 对于抽象类的继承，有两种选择： 不用全部重新定义方法，但是这样的话子类还是抽象类 定义全部的方法，子类不再是抽象类 抽线类不可以实例化，抽象类么有实际对象，但是抽象类是可以使用多态的，抽象类变量可以指向子类对象。 ==定义抽象类的时候，若是implements接口，如果没有覆盖接口中的方法，也不会出错== 抽象是Java的一个重要特性，可以定义抽象类抽象方法。使用abstract关键字来定义 抽象类：abstract class ClassName{}，抽象类中可以有抽象方法也可以无抽象方法，但是有抽象方法的类必须定义为抽象类。抽象类中可以定义fields，和正常类一样，只是==抽象类不可以实例化==，只能被继承。抽象类和接口类似，但是抽象类相比接口，还可以定义非静态的fields，有主体的方法（和类中方法定义一样） 123456789101112131415public abstract class MyAbstractClass&#123; public String Name; // 可以和接口一样定义public变量 private String password; // 比接口还可以定义非public变量 public static final ID = 12345; abstract String getName(); // 抽象方法，需要abstract关键字 // 如果类中有这个，需要定义为抽象类 // 抽象类中还可以定义非public的其他修饰符的方法 protected void printName()&#123; System.out.println(this.name); &#125; public static void getID()&#123; System.out.println(this.ID); &#125;&#125;// 抽象类不可实例化，只可以被继承，也可以使用抽象类来做type cast 抽象方法：在抽象类中，以abstract为修饰符定义的方法，接口中，方法默认为抽象方法，可以省略不写abstract。抽象方法不可以有主体。 抽象类和接口的使用情形： 使用抽象类 当你需要和几个相近的类共享代码的时候 你期望扩展拥有共同方法和属性的抽象类或者需要有除了public 之外的其他修饰符的时候 想要定义非静态和非final的属性的时候，这样使得你可以对对象的状态进行修改 使用接口 你需要不相关的类可以使用该接口 想要使用多种继承的好处的时候 只想指定需要的方法而不考虑具体方法如何实现","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Document Comment","date":"2020-11-28T04:57:50.343Z","path":"wiki/2021-03-03-Document Comment/","text":"javadocjavadoc是Java中一个很有用的工具，可以从源文件生成HTML你的文献，比如Online API documentation就是javadoc从标准Java库的源文件生成的。换到包含源文件的目录下，如com.horstman.corejava，你需要定位到包含com子目录的目录下（这个目录包含有overview.html文件）然后就可以执行命令来运行javadoc。需要生成documentation的源代码的包名需要对应上才可以，否则可能会出错 javadoc -d destDirectory nameOfPackage javadoc -d destDirectory nameOfPackage1 nameOfPackage2 ..可以生成多个包源文件的documentation到指定目录 javadoc -d destDirectory source.java可以生成default包下的源文件的documentation如果省略-d选项，HTML文件生成在当前目录下详细的使用看官方javadoc的使用介绍 javadoc -link standardclassHyperlink举个例子：javadoc -link http://docs.oracle.com/javase/doc/api *.java这就将标准库连接到你的documentation中来了 javadoc -linksource将原文件转变为html的代码文件，没有颜色的区别对比，纯文本代码，拥有行数字 javadoc生成文献使用的注释是/**……*/。正是由于javadoc的存在，让你的文档和代码放在了一起，这样可以随时更新文档 很方便。如果放在不同文件中，可能文件分离后很难找到，同时更新不方便。 可以插入注释的位置javadoc可以提取以下几个项目中的信息： Package public class and interface public and protected fields public and protected constructor and methods 注释文档块中还可以使用tag@，@开头的有annotation还有一些特定的内容，如：@author、@param、@depreciated等等，还支持HTML标签如：、、、，最好不适用heading标签，可能会扰乱生成的HTML。 如果注释包含其他文件中的链接，最好将他们放在包含源文件的目录下的子目录doc-files中，javadoc会自动复制这个目录并将其放在生成的documentation目录下 class commentsclass的注释必须放在import语句后class语句前。 123456&#x2F;** *this is a example of class comment *&lt;code&gt;ClassName&lt;&#x2F;code&gt; is used to do some useful things. *every line don&#39;t have &#39;*&#39; is also ok @author Lijiabao*&#x2F; method comment每一个方法注释都必须紧跟着方法的描述，除了可以使用正常的tag和文本之外，还可以使用以下几个标签： @return description：这个标签是用来增加return返回值这一项描述的，这个描述可以跨越多行并且可以使用HTML标签 @param variable description：这个标签使用来增加parameter参数选项的，可以使用HTML标签，可跨行。所有的parameter标签需要和方法对应 @throws class description：增加的是方法可抛出的异常的描述 filed comments对属性，一般只需要document公共属性，一般说来也就是常量了。 1234&#x2F;** * this is a constant used for describing PI*&#x2F;public static final PI &#x3D; 3.1415926; general comments以下几个标签是用来描述class的： @author name这个标签是用来声明作者的，@author lijiabao @version text用来描述版本信息的，text可以是对版本的描述 以下几个用在所有的documentation注释中的 @since text用来描述哪个版本开始使用这个功能的，@since version 1.7.2 @deprecated text这个标签用来告知某个item不再开始使用，text应该表明用来替换的内容，@deprecated Use &lt;code&gt;setVisible(true)&lt;/code&gt; instead 文档中引用超链接 @see reference这个标签再see also部分添加一个超链接，可以在类和方法中使用，下面显示了reference的样式123package.class#feature label&lt;a href&#x3D;&quot;...&quot;&gt;label&lt;&#x2F;a&gt;&quot;text&quot; 第一种情况很有用，你提供类】方法或者变量的名字，javadoc插入一个超链接到你的documentation@see com.horstman.corejava.Employee#raiseSalary(double)上面的例子将超链接给到com.horstman.corejava包下的raiseSalary(true)方法。可以省略包名和类名，这样就智慧在当前包或者当前类去定位。==注意==：必须使用#而不是空格，javadoc不想java编译器一样可以精确识别分割包和类。 如果@see后面跟着a标签，你需要指定一个超链接，可以自己指定超链接的名字label，也可不指定使用目标代码的名字或者url作为超链接名。 如果后面跟着”符号，在see also部分出现文本内容 可以添加多个@see标签，但是需要保证全部在一起还可以将超链接放在文档中你喜欢的任何位置，使用一种特殊标签即可：&#123;@link package.class#feature label&#125;，和@see的规则一样 package and overview comments在源文件中可以对类、方法、变量进行注释，然而为了生成package注释，需要在每个包目录下添加一个单独的文件。有两种方法： 提供一个HTML文件命名为package.html，所有的在标签内包裹内容会被提取。 提供一个package-info.java。这个文件必须包含最开始的/**…*/包注释，紧跟着包的声明，不需要再包含多余的代码或者注释了 还可提供一个overview注释，用在所有的源文件上的，把这个文件命名为overview.html并且放在包含所有源文件的父目录下。需要使用-overview选项指定overview文件。所有的body标签下的内容会被提取出来，这些注释当用户点击导航栏中的Overview选项时展现","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Java","date":"2020-11-28T01:35:22.209Z","path":"wiki/2021-03-03-Java/","text":"Java conclusion[[Java basic]]![[aggregation operation]] [[Java data type]][[Java OOP]][[Java String]][[Java Number]][[Generic]][[Essential Class]][[Document Comment]]","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"unchecked exception","date":"2020-11-27T14:19:38.338Z","path":"wiki/2021-03-03-unchecked exception/","text":"unchecked异常的几个争议点： JAVA编程并不要求捕获和处理unchecked异常，因此程序员可能会想要写那些==只抛出unchecked异常==或者==让所有的异常类继承RuntimeException==。这是由于这些捷径的出现，使得程序员可以写出不用接收编译错误的代码，并且不用指定异常的处理。==这种行为虽然看起来很方便，但是它抛弃了捕获异常处理异常的原有目的，并且可能会造成其他使用你的类的人出现很多问题== 设计者会强制一个方法去指定所有的未被捕获的检查异常可以在它的scope内抛出：任何可以被抛出的异常是这个方法的公共接口的一部分，那些使用这个方法的人==必须知道方法可以抛出的异常==，从而决定用这个方法去干什么。这些==异常和参数返回值一样都是方法的程序接口的一部分==。 那为什么不去指定RuntimeException呢：由于RuntimeException代表的是那些编程问题产生的结果，往往==不能预料==并且去处理这些问题（比如算术问题，除零错误pointerNull错误以及数组越界问题等）这类错误可以在程序的任何地方出现，并且==错误种类太多==，如果都去指定的话，程序就变得过于==庞杂不清楚==。因此编译器并不要求去捕获这类异常并处理（比如：NullPointerException） ==一般情况，不抛出RuntimeException或者创建该异常子类，只是因为不想因为指定异常而被弄得筋疲力尽。== ==Bottom line guideline==：如果可以合理的预料并修复这个问题，使用checked异常，如果不能从异常修复，使它成为unchecked异常。 [[Error exception]] [[Runtime exception]]","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Specify Exception thrown by method","date":"2020-11-26T05:26:43.959Z","path":"wiki/2021-03-03-Specify Exception thrown by method/","text":"指定被方法抛出的异常： 1234public void writeList() throws Exception1, Exception2&#123; code;&#125;","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Runtime exception","date":"2020-11-26T05:22:27.876Z","path":"wiki/2021-03-03-Runtime exception/","text":"RuntimeException class： 这个错误主要是API的错误使用","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"checked exception","date":"2020-11-26T05:21:28.234Z","path":"wiki/2021-03-03-checked exception/","text":"Exception class： 大部分程序抛出和捕获的异常都是Exception或者子类的对象。Exception代表发生了一个错误，但不是严重的错误。","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Error exception","date":"2020-11-26T05:19:41.606Z","path":"wiki/2021-03-03-Error exception/","text":"Error class：当一个动态链接失效或硬件错误，JVM抛出一个Error，一般的程序并不会捕获或者抛出Error","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Essential Class","date":"2020-11-25T12:51:43.285Z","path":"wiki/2021-03-03-Essential Class/","text":"[[Exception]][[IO Operation]][[Concurrency]]","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Java String","date":"2020-11-24T06:49:06.533Z","path":"wiki/2021-03-03-Java String/","text":"Character类不可变的，一旦创建就不可再更改其和原始数据类型char存在autoboxing和unboxing 一些static methods： boolean isLetter()：判断是否是字母 boolean isDigit()：判断是否是数字 boolean isWhitespace()：判断是否是空格 boolean isUpperCase()：判断是否是大写字母 boolean isLowerCase()：判断是否是小写 char toUpperCase()、toLowerCase() toString()：返回字符串 Escape Sequence：\\t:tab,\\b:backspace,\\n:newline,\\r:return,\\f:formfeed(0x0c),\\\\,\\&#39;,\\&quot; Stringstring类是不可变的，因此创建完后不可更改创建字符串： String s = &quot;hhh&quot;; String s = new String(char[] a); 字符串拼接： String s1 += s2; String s = s1.concat(s2); format格式化方式输出拼接内容：printf()或者String.format(); 字符串长度： String.length() String和Number的转换： Float.valueOf(String s).floatValue()，将获取的字符串值返回成数值 Float.parseFloat(String s)，解析字符串为数值 String.valueOf(num)，将数值转换为字符串 Float.toString(num) 字符串操作character：","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Math","date":"2020-11-24T06:01:10.920Z","path":"wiki/2021-03-03-Math/","text":"Math的一些方法： public static xxx abs(xxx) public static double sin(double) public static double cos(double) public static double tan(double) public static double atan2(double,double) public static double sqrt(double) public static double log(double) public static double log10(double) public static double pow(double,double) public static double exp(double) public static xxx min(xxx,xxx) public static xxx max(xxx,xxx) public static double floor(double) public static double ceil(double) public static double rint(double) public static int addExact(int,int) public static long addExact(long,long) public static long decrementExact(long) public static int decrementExact(int) public static int incrementExact(int) public static long incrementExact(long) public static int multiplyExact(int,int) public static long multiplyExact(long,long) public static long multiplyExact(long,int) public static long multiplyHigh(long,long) public static long negateExact(long) public static int negateExact(int) public static long subtractExact(long,long) public static int subtractExact(int,int) public static float fma(float,float,float) public static double fma(double,double,double) public static float scalb(float,int) public static double scalb(double,int) public static double copySign(double,double) public static float copySign(float,float) public static int getExponent(float) public static int getExponent(double) public static double signum(double) public static float signum(float) public static int floorMod(long,int) public static int floorMod(int,int) public static long floorMod(long,long) public static double asin(double) public static double acos(double) public static double atan(double) public static double cbrt(double) public static double IEEEremainder(double,double) public static long floorDiv(long,long) public static int floorDiv(int,int) public static long floorDiv(long,int) static double powerOfTwoD(int) static float powerOfTwoF(int) public static double sinh(double) public static double cosh(double) public static double tanh(double) public static double hypot(double,double) public static double expm1(double) public static double log1p(double) public static double toRadians(double) public static double toDegrees(double) public static long round(double) public static int round(float) public static double random() public static int toIntExact(long) public static long multiplyFull(int,int) public static int absExact(int) public static long absExact(long) public static double ulp(double) public static float ulp(float) public static double nextAfter(double,double) public static float nextAfter(float,double) public static double nextUp(double) public static float nextUp(float) public static double nextDown(double) public static float nextDown(float)","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Java Number","date":"2020-11-24T05:18:27.640Z","path":"wiki/2021-03-03-Java Number/","text":"Number Class有六大类（Number子类），这六大子类和原始数据类型存在==auotoboxing==装箱（需要对象时，原始数据类型被转换为六大类的过程）和==unboxing==（六大类转换为原始数据的过程）操作。 使用类而不使用原始数据类型的情况 作为参数传递到需要类参数的方法中 需要使用类创建的常量时，如最大值最小值 用类中的类方法实现类和原始数据类型的转换时 Number的子类 Byte（byte） Short（short） Integer（int） Long（long） Float（float） Double（double） BigDecimal：用于高精度计算 BigInteger：用于高精度计算 AtomicInteger和AtomicLong：用于多线程的应用 Number子类可以使用的实例方法 xxx xxxValue()：返回Number类或者子类代表的原始数据类型 int compareTo(SubClass obj)：和另外一个子类比较，相等返回0，小于返回-1，大于1. boolean equals(Object obj)，当参数不为null且数值相等，且是相同类型时返回true static Integer decode(String s)：decode字符串为Integer static int parseInt(String s)：解析字符串为int，只接受10进制的字符串 static int parseInt(String s, int radix)：接收字符串解析，可以选择进制，可以是2，8，10，16 String toString()：将数值转换为字符串 static String toString(int i)：转换为特定值的字符串 static Integer valueOf(int i)：将特定值转换为Integer类 static Integer valueOf(String s) static Integer valueOf(String s, int radix) Java的数值格式化输出 %f、%d、%n：浮点数，10进制integer和换行符 %td、%te：一个月中的第几天，td有前导0，te没有 %tB：特定locale月份全名 %ty、%tY：2位数年份和四位数年份 %tl：12小时制的小时 %tM：2位数的分钟数，有前导0 %tp：特定locale的am/pm %tm：2位的月份，有前导0 %tD：日期，格式位%tm%td%ty %08：八位数字，看情况是否有前导0 %+：带符号，不管正还是负 %, ：包含有特定locale的grouping字符 %-：左靠近 %。3：小数点后三位 %10.3：10位，小数点后有三位 DecimalFormat类用来控制==前缀、后缀、前导后导0、grouping 分隔符（千位分隔符）和decimal分隔符==。对于数值的格式化出书提供了很大的便利，但是是代码变得复杂 ###,###.### ：123456.789的输出是123,456.789 ###.##：123456.79是123456.789的输出 000000.000：000123.780是123.78 $###,###.###：$12,345.67，是12345.67的输出 除了运算符之外的方法[[Math]] ==Math.random()：是一个用来获取随机数的方法==","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"python_knowledges","date":"2020-11-23T06:50:10.984Z","path":"wiki/2021-03-03-python_knowledges/","text":"python知识os模块os的常用函数 os.getcwd()获取当前进程下的工作目录 os.name当前系统的名字,nt是windowsposix表示linux os.chdir()更改当前工作目录 os.mkdirs()递归创建文件夹,需要求有子目录os.mkdirs(r&#39;C:\\Users\\shinelon\\Desktop\\hhh\\1122&#39;, mode=0o777) os.mkdir()创建文件夹 os.listdir(path)列出当前路径下的所有文件和文件夹 os.remove()删除指定目录的文件,如果是目录会报错 os.rename(src, dst)文件重命名 os.renames(old,new)类似于rename但是可以命名文件的上级目录 os.linesep()获取当前系统的行分隔符 os.pathsep()获取分割搜索路径的分隔符 os.close()关闭文件描述符 os.stat()获取文件或者目录信息 os.sep()获取系统的路径分隔符 os.path(abspath)获取绝对路径 os.path.basename()获取文件名 os.commonprefix()所有path路径最大的共有路径 os.path.dirname(path)获取文件路径 os.path.exists(path)判断文件路径是否存在 os.path.lexists()存在或者损坏返回true不存在返回false os.path.expanduser()将包含和user路径切换为user目录 os.path.expandvars()根据环境变量切换包含的$name和${name} os.path.getatime()返回最近访问时间的秒数 os.path.getmtime()返回最近修改时间的秒数 os.path.getctime()返回创建时间秒数 os.path.getsize9)返回文件大小,不存在报错 os.path.isabs()判断是否为绝对路径 os.path.isfile()判断是否为文件 os.path.isdir()判断是否为文件夹 os.path.join()合并文件名,自动添加文件分隔符 os.path.normcase(path)转换路径 的大小写和斜杠 os.path.normpath()规范文件路径 os.path.realpath()返回path的真实路径 os.path.relpath()返回到达该路径文件的相对路径 os.path.samefile()判断目录或文件是否相同 os.path.split()路径分割为dirname和basename os.path.splitdrive()路径分割为驱动器和路径的元组 os.path.splitext()返货路径名和文件扩展名 os.path.walk()遍历文件的路径,遍历结果是dirs,folders,files,文件路径,文件路径下的文件夹,所有文件python对接shell的方法 1. os.system该函数返回命令执行结果的返回值，system()函数在执行过程中进行了以下三步操作： fork一个子进程； 在子进程中调用exec函数去执行命令； 在父进程中调用wait（阻塞）去等待子进程结束。 对于fork失败，system()函数返回-1。由于使用该函数经常会莫名其妙地出现错误，但是直接执行命令并没有问题，所以一般建议不要使用。 2. os.popenpopen() 创建一个管道，通过fork一个子进程,然后该子进程执行命令。返回值在标准IO流中，该管道用于父子进程间通信。父进程要么从管道读信息，要么向管道写信息，至于是读还是写取决于父进程调用popen时传递的参数（w或r）。通过popen函数读取命令执行过程中的输出示例如下： 1234567#!&#x2F;usr&#x2F;bin&#x2F;pythonimport osp&#x3D;os.popen(&#39;ssh 10.3.16.121 ls&#39;)x&#x3D;p.read()print(x)p.close() 3. subprocess模块1）概述 subprocess模块是在2.4版本中新增的，官方文档中描述为可以用来替换以下函数：os.system、os.spawn、os.popen、popen22）参数官方对于``subprocess`模块的参数解释如下： args is required for all calls and should be a string, or a sequence of program arguments. Providing a sequence of arguments is generally preferred, as it allows the module to take care of any required escaping and quoting of arguments (e.g. to permit spaces in file names). If passing a single string, either shell must be True (see below) or else the string must simply name the program to be executed without specifying any arguments. 参数既可以是string，也可以是list。 123subprocess.Popen([“cat”,”test.txt”])subprocess.Popen(“cat test.txt”, shell&#x3D;True)对于参数是字符串，需要指定shell&#x3D;True 3）使用示例其中==subprocess.call==用于代替os.system，示例： 1234import subprocessreturnCode &#x3D; subprocess.call(&#39;adb devices&#39;)print(returnCode)subprocess.check_output ==使用subprocesss.run()== 1234import subprocesscompleted = subprocess.run([&#x27;ls&#x27;, &#x27;-1&#x27;])print(completed.returncode) subprocess.Popen的使用 1.执行结果保存在文件 1234cmd &#x3D; &quot;adb shell ls &#x2F;sdcard&#x2F; | findstr aa.png&quot;fhandle &#x3D; open(r&quot;e:\\aa.txt&quot;, &quot;w&quot;)pipe &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdout&#x3D;fhandle).stdoutfhandle.close() 2.执行结果使用管道输出 12pipe&#x3D;subprocess.Popen(cmd,shell&#x3D;True,stdout&#x3D;subprocess.PIPE).stdoutprint pipe.read() 4. commands.getstatusoutput()使用commands.getstatusoutput() 方法就可以获得到返回值和输出： 12status, output &#x3D; commands.getstatusoutput(&#39;sh hello.sh&#39;)print(status, output) time模块time.time()获取时间戳time.localtime(time.time())获取当地时间的结构化字符串time.asctime(time.time())将时间戳转化为可识别的易读时间表达式time.strftime(&#39;%Y-%m-%d %H:%M:S&#39;, time.localtime())将当地时间转换为特定的时间字符串模式time.strptime(&#39;2015-12-22 15:33:55&#39;)将格式化时间字符转换为时间戳 每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。 什么是时间元组？很多Python函数用一个元组装起来的9组数字处理时间: 序号 字段 值 0 4位数年 2008 1 月 1 到 12 2 日 1到31 3 小时 0到23 4 分钟 0到59 5 秒 0到61 (60或61 是闰秒) 6 一周的第几日 0到6 (0是周一) 7 一年的第几日 1到366 (儒略历) 8 夏令时 -1, 0, 1, -1是决定是否为夏令时的旗帜 上述也就是struct_time元组。这种结构具有如下属性： 序号 属性 值 0 tm_year 2008 1 tm_mon 1 到 12 2 tm_mday 1 到 31 3 tm_hour 0 到 23 4 tm_min 0 到 59 5 tm_sec 0 到 61 (60或61 是闰秒) 6 tm_wday 0到6 (0是周一) 7 tm_yday 1 到 366(儒略历) 8 tm_isdst -1, 0, 1, -1是决定是否为夏令时的旗帜 获取当前时间从返回浮点数的时间戳方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。 获取格式化的时间你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是asctime(): 格式化日期我们可以使用 time 模块的 strftime 方法来格式化日期，： 1time.strftime(format[, t]) %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00-59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身 Time 模块Time 模块包含了以下内置函数，既有时间处理的，也有转换时间格式的： 序号 函数及描述 1 time.altzone 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 2 [time.asctime(tupletime]) 接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 3 time.clock( ) 用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 4 [time.ctime(secs]) 作用相当于asctime(localtime(secs))，未给参数相当于asctime() 5 [time.gmtime(secs]) 接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 6 [time.localtime(secs]) 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 7 time.mktime(tupletime) 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。 8 time.sleep(secs) 推迟调用线程的运行，secs指秒数。 9 [time.strftime(fmt,tupletime]) 接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 10 time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’) 根据fmt的格式把一个时间字符串解析为时间元组。 11 time.time( ) 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 12 time.tzset() 根据环境变量TZ重新初始化时间相关设置。 Time模块包含了以下2个非常重要的属性： 序号 属性及描述 1 time.timezone 属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;=0大部分欧洲，亚洲，非洲）。 2 time.tzname 属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。 日历（Calendar）模块此模块的函数都是日历相关的，例如打印某月的字符月历。 星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数： 序号 函数及描述 1 calendar.calendar(year,w=2,l=1,c=6) 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。 2 calendar.firstweekday( ) 返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。 3 calendar.isleap(year) 是闰年返回 True，否则为 False。&gt;&gt;&gt; import calendar &gt;&gt;&gt; print(calendar.isleap(2000)) True &gt;&gt;&gt; print(calendar.isleap(1900)) False 4 calendar.leapdays(y1,y2) 返回在Y1，Y2两年之间的闰年总数。 5 calendar.month(year,month,w=2,l=1) 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 6 calendar.monthcalendar(year,month) 返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 7 calendar.monthrange(year,month) 返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。 8 calendar.prcal(year,w=2,l=1,c=6) 相当于 **print calendar.calendar(year,w=2,l=1,c=6)**。 9 calendar.prmonth(year,month,w=2,l=1) 相当于 print calendar.month(year,month,w=2,l=1) 。 10 calendar.setfirstweekday(weekday) 设置每周的起始日期码。0（星期一）到6（星期日）。 11 calendar.timegm(tupletime) 和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 12 calendar.weekday(year,month,day) 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 函数相关知识作用域的知识 L(Local) 局部作用域 E(Enclosing) 闭包函数外的函数中 G(Global) 全局作用域 B(Build-in) 内建作用域变量的查找顺序：L -&gt; E -&gt; G -&gt; B会影响 函数/变量 的作用域的有 函数：def 或者lambda 类：class 关键字：global和nonlocal 文件：*py 推导式：[]{}() 变量相关的内建函数 globals()：以dict形式存储所有全局变量 locals()：以dict形式存储所有局部变量 函数定义 函数参数 函数闭包闭包满足条件： 必须是嵌套函数，即函数内部定义了另外一个函数 内部函数必须调用外部函数变量 外部函数返回了内部函数或者外部函数调用了内部函数查看是否是闭包：__closure__内部函数的调用：outer = outer(),outer() ==注意：==内函数不能直接被调用。闭包中内部函数引用的变量不会因为外部函数的结束而释放，如果外函数在结束的时候发现自己的临时变量再将来会被内部函数用到，就把变量绑定给了内部函数，自己再结束，这个变量而是一直在内存中，直到内部函数结束。 内部函数想要修改外部函数变量，有两种方法： 将外部函数的变量在内部函数声明位非局部变量，nonlocal variable_name 将闭包变量改成可变数据类型进行改变，如列表。 ==注意：== nonlocal关键字只能用与嵌套函数中，外部函数定义了相关的变量。 外部函数调用一次返回了内函数，实际闭包变量只有一份，以后每次调用内函数，都是用同一份闭包变量，一旦闭包变量内部修改了外部变量的值，则这个变量值就已经修改了，不是最初值。 柯里化和偏函数 函数修饰器装饰器本质是一个函数，使用了闭包的特性，可以让其他函数不需要做任何代码变动的情况下增加额外的功能，装饰器的返回值也是一个函数对象。装饰器的定义就是将外部使用装饰器的函数作为参数，然后装饰器内部在定义需要增加的功能内函数。 12345678910def timer(func): def inner(): time_start = time.time() func(*args, **kwargs) end_time = time.time() print(f&#x27;函数运行了&#123;time_end - time_start&#x27;) return inner@timerfunc(*args, **kwargs) # 这时调用timer装饰器即可直接得出函数运行的时间# 如此定义完之后再使用函数即可 装饰器类别： 装饰器不带参数：如上一段代码中的内容 带参数：123456789101112def flog(name): def timer(func): def inner(): print(f&#x27;调用&#123;name&#125;模块进行装饰器演示&#x27;) time_start = time.time() func(*args, **kwargs) end_time = time.time() print(f&#x27;函数运行了&#123;time_end - time_start&#x27;) return inner return timer@flog(&quot;模块1&quot;)func(*args, **kwargs) python虚拟环境虚拟环境的管理管理好用的是virtualenv和virtualenvwrapper-win和Linux下是virtualenvwrapper virtualenv和wrapper的使用方法 virtualenv使用： 创建：virtualenv env_name或virtualenv -p /usr/bin/python-version env_nameLinux可以指定版本并写入环境变量`echo “export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python-version”&gt;&gt;~/.bashrc 进入：cd source_name\\bin thenactivate,退出：deactivate cd Env_namethen rm-rf virtual_env_name 使用全局一样的包：导出依赖包：pip freeze &gt; requirements.txt安装依赖包：`pip install -r requirements.txt virtualenvwrapper使用配置：find / -name virtualenvwrapper.sh然后在~/.bashrc新增：1234export WORK_HOME&#x3D;$HOME&#x2F;.virtualenvsexport PROJECT_HOME&#x3D;$HOME&#x2F;workpaceexport VIRTUALENVWRAPPER_SCRIPT&#x3D;&#x2F;usr&#x2F;binvirtuawrapper.shsource &#x2F;usr&#x2F;bin&#x2F;virtualwrapper.sh 基本语法mkvirtualenv [-a project_path] [-i package] [-r requirements_file][virtualenv options] env_name 创建mkvrtualenv env_name 进入：workon env_name退出：deactivate 列出所有虚拟环境：workonorlsvirtualenv 删除：rmvirtualenv env_name切换workon env_name即可 其他命令1234567virtualenvwrapper # 列出帮助文档cpvirtualenv env_name [target_env] # 拷贝虚拟环境allvirtualenv pip install -U pop # 在所有虚拟环境执行命令wipeenv # 删除当前环境所有第三方包 cdsitepavkages # 进入当前虚拟环境目录cdvirtualenv # 进入当前环境的site-package目录lssitepavkage # 显示site-package 内容 实战使用 交互式环境中：workon env_name 然后python命令进入虚拟环境的python 工程项目：哟=有一个入口环境，其首行可以指定python解释器，想要在想要的虚拟环境中使用，改变该头部信息即可。#!/root/.virtualenvs/env_name/bin/python然后命令行运行，运行前添加权限chomd +x file_name.pythen./file_name.py pycharm中：设置里面设定文件的python解释器即可 类相关知识类方法的强制重写和禁止重写 强制重写需求：父类的一个方法，需要强制子类重写实现方法： 把父类变为抽象基类，然后给指定的方法加上装饰器@abc.abstractmethod 指定方法抛出NotImplementedError异常第一种方法代码实现：123456789101112131415161718# python2import abcclass Animal(object): __metaclass__ = abc.ABCMeta @abc.abstractmethod def speak(self): pass# python3 class Animal(metaclass=abc.ABCMeta): @abc.abstractmethod def speak(self): passclass Dog(Animal): def speak()# 如果子类不重写，在子类的实例化对象的时候就会报错Typeerror,不需要到调用方法才抛出 第二种方法：12345678class Animal(): def speak(self): raise NotImplementedclass Dog(Animal): def speak(self): print(&quot;ss&quot;)# 如果不重写写了抛出异常的方法，会在子类的方法调用时抛出异常 禁止重写说法不太准确，实际可重写，只是无法生效123456789101112131415161718192021# 常规例子class Base: def go(self): print(&quot;base&quot;) def run(self): self.go()cass Extend(Base): def go(self): print(&quot;Extend&quot;)# 这时实例化对象并调用run方法返回的分别时base和extendclass Base: def __go(self): print(&quot;base&quot;) def run(self): self.__go()class Extend(Base): def __go(self): peint(&quot;extend&quot;)# 这时实例化对象并调用run方法全部返回base# 两者区别在于一个公开函数一个是私有函数# 私有函数作用范围仅在当前类，其表象上可以被重写，实际并无重写的效果 类的多继承与Mixin设计模式 认识Mixin模式 不使用Mixin的弊端 python调试pdb调试python3.7以后设置断点直接使用breakpoint()方法即可，之前的需要自己导入pdb，打断点调用set_trace()，这时就可以使用pdb调试了在命令行下python运行就可以debug了 这时出现的第一行：告诉我们打断点的位置第二行：执行执行的暂停位置第三行：可以输入相关的debug命令了 pdb常用命令：利用help可以查看相关的帮助信息 p + 参数名 ：查看参数的值 n ：单步跳过 s ：单步进入 c ：继续执行 w ：显示上下文信息 a ：查看函数的参数列表 ll ：列出当前的源码 b ：设置断点 q ：推出debug在debug的过程中可以修改参数值继续进行调试 还可以不设置断点直接命令行的方式执行，直接在第一行打断点python3 -m pdb xxx.py python对象不可更改对象和可更改对象如何判别： 利用id()函数查看对象或变量或参数进行某种操作前后的值，如果不相等，则为不可更改对象，如果相等，则为可更改对象。 利用hash()函数查看，如果不报错，证明可被hash，即不可更改，反之，不可hash，可更改。 一般创建一个变量就创建了一个PyObject，可更改对象起始时一直再这个对象上进行操作，所以器指向的id是不变的，不可更改对象在每一次操作都会重新创建一个PyObject，因此id是变化的。数组字符串可更改，数字不可更改 函数默认参数函数的默认参数值只能被初始化一次，如果使用的是可更改对象为参数值，那么每次修改的值会椅子保留 print()函数的细节python3中，print()是函数而不是语句，因此函数中的参数需要在调用函数前被估值，因此里面的参数都是先得到值后，再传入函数中打印。而且每个函数的指向id都是不变的。如果定义了多个变量，但是都传入同一函数同一参数，则这两个变量的id指向一致 None类型None和整数、浮点数、布尔一样是一种不可变参数，类型是Nonetype，所以一般默认参数值选择使用None。 python异常相关知识不要滥用try: except:语句 如果滥用异常捕获语句，可能有时候会隐藏掉异常信息难以发现错误所在 在程序开发初期，不用try: except: 语句，需要让错误暴露出来，通过报错信息，可以明确知道错误所在。有时候还需要主动抛出异常。第三方库最好多主动抛出异常，这样才能让别人知道错误所在，有时候甚至可以使用python的断言语句，assert。 一般异常捕获语句最好是用来捕获具体的异常而不是所有异常，这样才能清晰的知道是什么异常，才能更好的分析原因。 又是甚至可以利用自带的traceback模块，强行打印报错信息。123456# traceback的用法import tracebacktry: 1 + &quot;a&quot;except: print(traceback.format_exc()) ==总结：==try: except语句可以让代码看起来没有问题，但有时也会掩盖你想查找的问题，所有尽量删除不需要的语句，拥抱异常，让代码的纠正查错更加方便，让代码不带着问题继续运行。 python文件操作方法函数 os.getcwd()获取当前运行路径 os.path.join()连接路径 # 是mac和Linux的路径符，windows是\\ os.listdir()和os.scandir()列出路径下文件夹中的所有文件夹和文件，后者返回的是一个迭代器对象 os.isdir()判断路径是否为文件夹 os.walk()遍历路径下的文件夹中的文件并返回列表 os.startwith()和os.endwith()是否以传入字符开头或者结尾 glob模块glob.glob()进行文件匹配,*匹配所有,?匹配单个字符,[]和[!]匹配在和任何不在方括号内的字符 os.scandir()返回的文件可以使用stat()方法查看文件的信息 st_size：文件体积大小（单位bytes） st_atime：文件的最近访问时间 st_mtime：文件的最近修改时间 st_ctime和st_birthtime：windows创建时间和macLinux创建时间 os.mkdir()：创建文件夹文件夹已经存在会报错 shutil模块的复制：shutil.copy(&#39;copy_file&#39;,&#39;copy_path&#39;)复制文件，shutil.copytree()参数同上，复制文件夹 shutil.move(&#39;file&#39;,&#39;move_peth&#39;)移动：文件文件夹都是这个 os.rename(&#39;old_file&#39;,&#39;new_file&#39;)重命名：文件文件夹都可 os.remove(&#39;file_name&#39;)删除文件：只删除文件 shutil.rmtree()删除文件夹 zipfile模块：创建和解压压缩包 zipfile.ZipFile(&#39;file&#39;,&#39;r&#39;)读取：可用上下文管理器读取，对象的namelist()返回压缩包里的文件，obj.getinfo(&#39;file_name&#39;)查看文件的信息 extract(&#39;解压文件名&#39;,&#39;解压路径&#39;)和`extractall(‘解压路径’)解压 zipfile.ZipFile(&#39;file_name&#39;,&#39;w&#39;)创建压缩包：利用write(&#39;file&#39;)方法写入’w’改为’a’往已有压缩包添加文件 python的random模块 random.random()是返回零到一的随机浮点数 random.uniform(a,b)返回a到b的随机浮点数 random.randint(start,stop,step)返回随机整数,在指定范围和步长的范围选 random.randrange()和上面一样 random.choice()从序列中选取一个随机元素,sequece参数指tuple,list字符串 random.shuffle()用于将列表元素打乱 random.sample(seq,k)指定序列许纳泽指定长度片段,不修改原序列 python提升性能的方法 使用局部变量：尽量使用局部变量代替全局变量，便于维护，提高性能并节省内存。还可以使用局部变量来替换模块中的命名空间的变量，这样可以提升程序性能，局部变量的查找顺序更快，另外使用阶段的标识符变量来取代冗长的模块变量。提升可读性。 减少函数的调用次数：对象类型判断的时候使用isinstance()最优，id()次之，type()较次。对于需要重复操作的内容不要放在循坏条件中去，尽量以变量或者其他方便形式，减少重复内容的计算。如需使用某些模块下的某个函数或者对象，使用from x import y 采用映射关系来代替条件查找：映射（如dict等）的搜索速度远快于条件语句 直接迭代序列元素：不利用索引遍历，直接遍历 生成器表达式代替列表表达式：生成器表达式返回的是生成器，更节省内存i = (i*2 for i in range(10)), j = [i*2 for i in range(10)] 先编译后调用：使用eval()和exec()函数执行代码时，最好调用代码对象，即经过编译函数compile()编译的对象，可避免重复编译提高性能，正则表达式也是这样类似。 模块编程习惯：模块中最高级别的代码（没有缩进的代码）会在模块导入时执行，尽量让模块的功能代码放入到函数内部中去，还可使用`if name == ‘__main’避免调用模块执行测试代码 python生成器和协程一些概念 可迭代：是指可以使用for语句获取内部内容的对象，元组，列表，字典，字符串都是，dir()查看，内部有_iter_说明时可迭代，没有也不一定不可迭代，实现了_getitem_也是可迭代，最好通过for循环或者iter()真实运行 迭代器：使用iter()生成的对象，其实际就是在内部实现了__next_魔法方法。可使用isinstance()结合Iterable，Iterator和Generator来判断相关内容。迭代器有个函数next()可以获取其子元素。 生成器：yield关键字生成的内容属于生成器迭代器在可迭代的基础实现了next()方法，生成器在迭代器上实现了yieldyield生成器生成器是为了实现一个在计算下一个值时不需要浪费空间的结构yield：相当于函数中的return，在每一次next()或者for迭代时，将这个yield的值返回，并在这里阻塞，等待下一次的调用。生成器创建： 生成器表达式i = (i**2 for i in range(10)) 实现了yield的函数==优点==：生成器是在元素需要的时候才临时生成，节省时间和内存，迭代器和可迭代对象，将所有值都放在内存空间不节省内存。生成器激活运行： next()方法 使用生成器的send()方法：generator.send(None) 生成器的执行状态： GEN_CREATED等待开始执行 GEN_RUNNING解释器正在执行（只有在多线程应用中才能看到这个状态） GEN_SUNPENDED在yield表达式出暂停 GEN_CLOSED执行结束使用getgenerotorstate()方法传入generator查看状态，生成器的close()方法可以手动关闭结束生成器生成器的异常处理：在生成器的工作过程中，若生成器不满足元素的条件，会或者应该抛出异常生成器创建自动实现了Stopiteration异常。创建生成器时，也应该在不满足生成器条件时主动抛出异常生成器过渡到协程：生成器其实为我们引入了暂停函数执行的功能，在暂停之后，可以通过生成器的send()函数发送东西给生成器。这催生了协程的诞生。协程通过yield暂停生成器，可以将协程的执行流程交给其他子程序，从而实现不同子程序的交替进行。1234567891011121314def jump_range(N): index = 0 while index &lt; N: jump = yield index if jump is None: jump = 1 index += jumpif __name__ == &#x27;__main__&#x27;: gen = jump_range(10) print(next(gen)) # 0 print(gen.send(2)) # 2 print(next(gen)) # gen.send(None) == next(gen) # 3 print(gen.send(-1)) # 2# jump = yield index 分两部分，yield index将index至返回给外部调用函数，jump = yield可以接收外部程序通过send()发送的值并赋值给jump 为什么要使用协程：爬虫时遇到请求网页这种需要耗时的请求，可以先暂停一下去处理其他的事情，过一段时间再回来处理，这种就可以节省等待的时间。而yield正好提供了这样的一个暂停功能使用常规的同步编程要实现异步并发效果不是很理想。由于线程锁的机制存在，加锁解锁切换线程，极大的降低了并发性能特点： 协程是在单线程下实现的任务切换 利用同步的方式实现异步 不需要使用锁，提升了并发性能yield from：简单用法：拼接可迭代对象yield from后面需要加的是可迭代对象，可以是普通可迭代对象，也可以是迭代器和生成器1234567891011astr = &#x27;hello&#x27;alist = [1, 2, 3, 4]atuple = (5, 6, 7, 8)adict = &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2, &#x27;c&#x27;:3&#125;def gen_iter(*args, **kw): for item in args: for i in item: yield idef gen_iter_from(*args, **kw): for item in args: yield from item 复杂应用：生成器的嵌套，yield from后面加生成器就实现了生成器的嵌套，使用yield from可以避免我们自己处理其中遇到的意想不到的异常。一些概念： 调用方：调用委派生成器的客户端代码 委托生成器：包含yield from表达式的生成器函数 子生成器：yield from后面加的生成器函数1234567891011121314151617181920212223# 子生成器def gen_average(): total = 0 count = 0 average = 0 while True: new_num = yield average count += 1 total += new_num average = tatal / count# 委托生成器def gen_average_client(): while True: yield from gen_average# 调用方def main(): calc_average = gen_average_client() next(calc_average) # 预激生成器 print(calc_average.send(10)) # 10 print(calc_average.send(20)) # 15 print(calc_average.send(30)) # 30 委托生成器的作用：在生成器和调用方之间生成一个双向通道，调用方可以通过send发送消息给子生成器，子生成器的yield的值可以返回给调用方123456789101112131415161718192021222324252627# 子生成器def gen_average(): total = 0 count = 0 average = 0 while True: new_num = yield average if new_num is None: break count += 1 total += new_num average = tatal / count return count, total, average# 委托生成器def gen_average_client(): while True: yield from gen_average# 调用方def main(): calc_average = gen_average_client() next(calc_average) # 预激生成器 print(calc_average.send(10)) # 10 print(calc_average.send(20)) # 15 print(calc_average.send(30)) # 30 print(calc_average.send(None)) # 结束生成器协程 为什么用yield from：用它可以帮助我们处理异常而不需要我们自己去书写异常代码块 迭代器（子生成器）生成的值直接返回给调用者 任何使用send()方法发送给委派生成器的值直接传递给子生成器。send()值为None，调用next，不为None，调用send方法如果迭代器调用产生StopIteration异常，委派生成器继续执行yield from后面的语句，产生其他异常，则都传递给委派生成器 python装饰器1234567def hello_decorator(func): def wrapper(*args, **kw): return func() return wrapper@hello_decoratordef hello(): print(&#x27;hello decorator&#x27;) 日志装饰器1234567891011import timedef logger_deco(func): def wrapper(*args, **kw): print(&#x27;开始运行，time.strftime(&quot;%Y-%m-%d %H:%M:S&quot;, time.localtime(time.time()))&#x27;) func() print(&#x27;开始运行，time.strftime(&quot;%Y-%m-%d %H:%M:S&quot;, time.localtime(time.time()))&#x27;) return wrapper@timer_decodef calculate_1_plus2(): print(1 + 2) time.sleep(0.5) 运行时间装饰器123456789101112import timedef timer_deco(func): def wrapper(*args, **kw): start_time = time.time() func() end_time = time.time() print(f&#x27;END:&#123;start_time - end_time&#125;s&#x27;) return wrapper@timer_decodef calculate_1_plus2(): print(1 + 2) time.sleep(0.5) 带参数的装饰器1234567891011121314def args_decorator(nationality=&#x27;China&#x27;): def inner_fun(func): def wrapper(*args, **kw): if nationality is &#x27;China&#x27;: print(f&#x27;你好，我是&#123;func()&#125;&#x27;) elif nationality is &#x27;american&#x27;: print(f&#x27;hello my name is &#123;func()&#125;&#125;&#x27;) return wrapper return inner_fun@args_decorator(&#x27;China&#x27;)def xiaoming(): return &#x27;小明&#x27;xiaoming() 高阶：不带参数的装饰器类。基于类的装饰器，必须实现__call__和__init__前者实现装饰的逻辑，后者接受被装饰的函数1234567891011121314class logger(object): def __int__(self, func): self.func = func def __call__(self): print(&#x27;我要被调用了&#x27;) self.func() print(&#x27;我被调用完毕了&#x27;) return self.func()@loggerdef hello(): print(&#x27;hello world&#x27;)hello() 带参数的装饰器类1234567891011class logger(object): def __init__(self, level, func): self.level = level self.func = func def __call__(self): print(f&#x27;&#123;self.level&#125;: &#123;self.func()&#125;&#x27;)@logger(&#x27;Info&#x27;)def hello(): return &#x27;hello world&#x27;hello() 使用偏函数和类实现装饰器：大部分装饰器是通过函数和闭包来创建的，这并不是位移途径。python某个对象能否通过装饰器形式使用只有一个要求，decorator必须是一个可被调用的对象，除了函数外，类只要实现__call__也是callable对象，还有偏函数也是callable对象123456789101112131415161718import functoolsclass DelayFunc: def __init__(self, duration, func): self.func = func self.duration = duration def __call__(self, *args, **kwargs): print(f&#x27;wait for &#123;self.duration&#125;s&#x27;) time.sleep(self.duration) return self.func(*args, **kwargs)def delay(duration): return functools.partial(DelayFunc, duration)@ delay(2)def hello(): print(&#x27;hello world&#x27;) return 5hello() python注释类型标注类型注解的语法： 在生声明变量的时候，在变量的后面添加冒号，后面加上变量类型，int,str,list,tuple,float, dict, 声明方法函数的返回值的时候，在方法的后面加个箭头，后面加上返回值的类型 pep8的语法规定在变量后面紧跟冒号再接空格接变量类型，方法注解箭头左边时方法定义，右边是返回值类型，左右两边都要有空格，这种声明只是一个变量注释，不会对函数的运行产生影响，只是一种提示，在pycharm会有提示12345a: int = 2b: str = &#x27;hello&#x27;def func(a: int, b: str) -&gt; float: print(a, b) return 1.5 尽管这种注释已经可以告诉一些变量的类型了，但对于列表字典，并不能指导其内部内容的类型，这就需要用到typing模块了，它提供非常强的类型支持，如List[str],Tuple[int, int, int],Dict[str, bool]表示为字符串类型的列表，整型的元组和键为str值为布尔类型的字典，typing已经加入标准库12345678910111213141516171819202122232425262728from typing import List, Turple, Dict # 引入即可用上述的类型注解# 列表Listvar: List[int or float] = [1, 1.5]var: List[List[int]] = [[1],[1,2]] # 也支持嵌套声明# 元组Tuple和NamedTuple，推荐使用attrs而不是namedtupleperson: Tuple[str, int, float] = (&#x27;li&#x27;, 20, 1.5) # 也可类型嵌套# Dict、Mapping，MutableMapping(mapping子类，很多库用这个)# Dict推荐用于返回值注解，Mapping用于参数注解，两者用法一致，Dict[str, bool]def recognize(rect: Mapping[str, float]) =&gt; Dict[str, float]: return &#123;&#x27;dd&#x27;: 1.2&#125;# Set 和AbsractSet，前者返回值注解，后者参数注解# Sequence在不需要严格区分元组列表用这个# NoReturn没有返回结果用这个# Any代表所有类型，用这个和无声明是相等的# TypeVar 借助它来定义自定义兼容类型的变量，比如有的变量可以是多个类型都符合要求，可以使用这个类型来定义Height = TypeVar(&#x27;Height&#x27;, int, float, None) # 定义一个身高类型，整数浮点数None都可以def return_height() -&gt; Height: return 1.83# NewType可以借助这个来定义具有特殊含义的类型，例如tuple，我们可以定义一个person的tuple例子Person = NewType(&#x27;Person&#x27;, Tuple[str, int, float])person = Person((&#x27;li&#x27;, 18, 18.5)) # 这个person就和正常的tuple一样# Callable可调用类型，通常注解方法声明时需使用Callable[[arg1type, arg2type], returntype]类似注解，将参数和返回值注释出来# Union联合类型Union[X, Y],要么X要么Y，联合的联合类型就是展平的类型，多余参数会跳过，一个参数即等同于该参数# Optional可以为空或者声明的类型，Optional[int]等同于Union[int, None]# 为None不代表可以不传递，只是说可传为None# Generate生成器的类型声明Generate[yieldType, sendType, ReturnType]# yieldType是指yield紧跟的变量类型，snedType返回的结果类型，第三个是最后返回的类型# 很多情况不需要设置snedType和ReturnType，可以将其设置为None python代码退出强制执行一段代码利用python自带模块atexit，使用方法： 123456789import atexit@atexit.regsiterdef clean(): print(&quot;我是最后代码结束执行的代码&quot;)start()execute_fun()# 不需要显示调用clean()函数都能再结束的时候自动运行 atexit模块的使用要点： 可以定义多个推出函数，按照注册时间从晚到早依次执行。 如果函数有参数，可以不利用装饰器。直接调用atexit.register(fun_name, arg1, arg2, argn) 如果程序被你没有处理过的系统信号杀死的，那么注册的函数无法正常执行 如果发生了严重的python内部错误，无法正常执行 如果手动调用了os._exit()，注册的函数无法正常执行 python使用技巧 查看源代码，使用inspect模块inspect.getsource(func_name)或者传入参数为模块名 异常关联上下文处理异常时，处理不当或者其他问题，再次抛出一个异常时，往外抛出的异常会携带原始异常一般处理时： 123456try： print(1 / 0)except Exception as exc: raise RunError(&#x27;something bad happend&#x27;) from exc raise RunError(&#x27;something bad happend&#x27;).with_traceback(exc) raise RunError(&#x27;something bad happend&#x27;) from None # 彻底关闭原始已成信息 查看包搜索路径：import sys, from pprint import pprint, pprint(sys.path)python -c &#39;print(&#39;\\n&#39;.join(__import__(&#39;sys&#39;).path))&#39;命令行查看 python -m site`另外一种更方便的命令行查看，包含了用户环境的目录 嵌套for循环的简洁写法 123456from itertools import productlist1 = range(1, 3)list2 = range(4, 6)list3 = range(7, 9)for item1, item2, item3 in product(list1, list2, list3): print(item1 + item2 + item3) 使用print输出日志with open(&#39;test.log&#39;, &#39;w&#39;) as f:print(&#39;hello&#39;, file=file, flush=True) 计算函数运行时间：import timeit, timeit.timeit(func_name, number=5)后面参数为函数的运行次数 利用python自带的缓存机制提升效率。缓存就是将定量数据加以保存，一边后续获取处理的处理方式。如果一个数据需要多次使用，每次都重新生成会耗费大量的时间，如果利用缓存机制就可以减少运算时间提高效率。 123456from functools import lru_cache# 装饰器的参数说明，maxsize：最多可以缓存多少个函数的调用结果，None为无限制，设置为2的幂次性能最佳，typed是否不同类型参数调用分别缓存@lru_cache(maxsize=None, typed=False)def func(x, y): return x + y# 此时如果调用两次func(1, 2)则后一次不会调用函数，直接返回结果 python实现golang的延迟调用,golang通过defer关键字定义延迟调用 123456import contextlibdef callback(): print(&#x27;B&#x27;)with contextlib.ExitStack() as stack: stack,callback(callback) print(&#x27;A&#x27;) # 此时输出为AB 读取文件时，最好指定每次读取的内容大小 12345678910111213def read_chunk_from_file(filename, block_size=1024 * 8):with open(filename, &#x27;r&#x27;) as fp: while True: chunk = fp.read(block_size) if not chunk: break yield chunk# 借助偏函数优化一下from functools import partialdef read_chunk_from_file(filename, block_size): with open(filename, &#x27;r&#x27;) as fp: for chunk in iter(partial(fp.read, block_size), &#x27;&#x27;): yield chunk 正则表达式中的re.sub(pattern, repl, string)其中的第二个参数可以是一个函数对象，函数传入值是匹配的对象，函数的返回值就是匹配的字符串替换字符。该参数可以利用于需要对不同的匹配对象进行相应的操作的时候 当if else层数过多时可以考虑使用python的字典来进行一定的美化: 123456789def hello(): print(&#x27;hello&#x27;)def requests_url(url): print(url)# 字典定义的函数可以单独放在一个文件，再进行调用就好dict_select = &#123;&#x27;hello&#x27;:hello, &#x27;world&#x27;:requests_url&#125;dict_select.get(&#x27;hello&#x27;)()dict_select.get(&#x27;world&#x27;)(&#x27;sssssss&#x27;) # 字典函数可以传参数，这样结合会有不错的效果 模块文件中的__all__ = [&#39;func_name&#39;, &#39;class_name&#39;]有这个东西之后智慧影响from module import *的行为,不会影响from module import fun_name之类的操作 生成器表达式：generator_exp = (i **2 for i in range(5))生成器表达式是对内存空间的优化，比列表解析式稍慢，但是较节省空间。生成器只能遍历一次。 列表解析式：list_exp = [i **2 for i in range(5)] 字典解析式：dict_exp = &#123;i:i ** 2 for i in range(5)&#125; pythonic的代码实例 变量交换a,b = b,a 列表推导式a = [i + 3 for i in range(10)] 单行表达式123456789# bad示例print(&quot;1&quot;);print(2)if &lt;complex comparison&gt; and &lt;another complex comparison&gt;# good示例print(1)print(2)a &#x3D; &lt;complex comparison&gt;b &#x3D; &lt;another complex comparison&gt;if a and b 利用enumerate带索引遍历 序列解包12a, *rest &#x3D; [1,2,3] # a&#x3D;1,rest&#x3D;[2,3]a, *rest, c &#x3D;[1,2,3,4] # a&#x3D;1,c&#x3D;4,rest&#x3D;[2,3] 利用join进行字符串的拼接 真假判断：if attr: or if not attr: or if attr is None: 访问字典元素最安全的是利用get()方法,参数为键名和找不到时返回的值，或者使用if判断键名是否在字典中 代码续行最好使用括号括起来进行续行 显示代码：代码尽量简明易看懂 使用占位符：12filename &#x3D; &#39;file.txt&#39;basename, _, ext &#x3D; filename.rpartition(&#39;.&#39;) 链式比较：1234# bad示例if a &gt; 18 and a &lt; 20:# good示例if 18 &lt; a &lt; 20: # 链式比较时先前两个比较然后后两个比较，再一起比较 等号后边多个值可以打包成元组t = &quot;hello&quot;, &#39;world&#39;, &#39;nice tool&#39;变量t就变为元组了 遇见编译错误的需要visual c++14.0的情况安装visualstudio2015，或者安装mingw GCC - MinGW-w64 (x86, x64)遇到报错版本号的问题，修改cygwinccompiler文件的内容 123elif msc_ver &#x3D;&#x3D; &#39;1914&#39;: # 按照相应的版本写个elif就好# VS2010 &#x2F; MSVC 10.0 return [&#39;msvcr100&#39;] MinGW-w64 is an alternative C/C++ compiler that works with all Python versions up to 3.4. Install Win-builds into C:\\MinGW_w64. Open Win-builds, switch to install at least binutils, gcc, gcc-g++, getext, mingw-w64, win-iconv, winpthreads, zlib, and click Process. Add C:\\MinGW_w64\\bin to the PATH environment variable. Create a distutils.cfg file with the following contents in the folder \\Lib\\distutils in Python install directory : Toggle line numbers 12345[build]compiler&#x3D;mingw32[build_ext]compiler&#x3D;mingw32 GCC - MinGW (x86)MinGW is an alternative C/C++ compiler that works with all Python versions up to 3.4. Install Minimalist GNU For Windows into C:\\MinGW. Open MinGW Installation Manager, check mingw32-base and mingw32-gcc-g++, and Apply Changes in the Installation menu. Add C:\\MinGW\\bin to the PATH environment variable. Create a distutils.cfg file with the following contents in the folder \\Lib\\distutils in Python install directory :Toggle line numbers 12345[build]compiler&#x3D;mingw32[build_ext]compiler&#x3D;mingw32","tags":[{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/tags/python-notebook/"}],"categories":[{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/categories/python-notebook/"}]},{"title":"aggregation operation","date":"2020-11-21T17:01:16.585Z","path":"wiki/2021-03-03-aggregation operation/","text":"lambda expressionyou can use it to complements functionality interface with a simple declarationInterfaceName varName = (a, b) -&gt; a + b;in (), these contents are paraeters, after -&gt; it is a expression which has a result, this result was return value, you also can use {} to include return clause.Like this () -&gt; &#123;return &quot;hello&quot;&#125; method reference static method reference：ClassName::StaticMethodName instance method reference：ClassObj::MethodName type cast method reference：TypeCast::MthodName constructor reference：ClassName::new functionality interfaceit is a interface with just one method. streamit represents a sequences of objects from a source, which supports aggragate operation. We can use stream(),parallelStream() method to get stream. The former is a popular method. The later is to get stream which support parallel processing. pipelinepipelines is a sequence of aggregate operation.aggregate operation is like as forEach()、filter() pipeline component: A source: could be a collection、array、generator function or a I/O channel。 zero or more intermediate operation：use it can get a new stream terminal operation：use it to get a non-stream value— primitive value、collection、or forEach（no value)","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Override","date":"2020-11-21T13:52:22.937Z","path":"wiki/2021-03-03-Override/","text":"重写是指子类中的方法名称、变量类型、变量数量、变量顺序以及返回值类型和父类中的一致这种作法。当然，若是子类的返回值类型是父类的子类也可以满足重写的情况 1234567891011121314public Animal&#123; public Number getNum()&#123; Number num = new Integer(1); return num; &#125;&#125;// 返回值类型子类的是父类的返回值的子类时，也是可以满足重写条件的public Cat extends Animal&#123; @Override public Integer getNum()&#123; Integer num = new Integer(1); return num; &#125;&#125;","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"Encapsulation","date":"2020-11-21T13:04:38.402Z","path":"wiki/2021-03-03-Encapsulation/","text":"封装是指保证类中的某些内容只能通过其他的公共的方法去访问修改，用户并不能直接访问获取这些内容，保证了内容的保密性。Java的封装是由访问修饰符private来实现","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"批处理的参数传递","date":"2020-11-21T12:33:05.167Z","path":"wiki/2021-03-03-批处理的参数传递/","text":"%0:批处理文件本身%1:第一个参数%num:第num个参数%*：从第一个参数开始的所有参数%f1：扩充到一个完全合格的路径名%d1：扩充到一个驱动器%p1：扩充到一个路径，没有驱动器和文件名扩展名的完整路径%n1：扩充到文件名，就只有文件名%x1：扩充到文件扩展名%s1：扩充的路径含有短名，整个文件所在的路径加扩展名%a1%t1%z1%$PATH:1：查找列在Path环境变量中的目录。并将%1扩充在找到的第一个完全合格的名称，如果环境变量名未定义，或者没有找到文件，此组合会扩充到空字符串。==这些是支持多个组合一起获取内容的==","tags":[{"name":"bat批处理的使用","slug":"bat批处理的使用","permalink":"http://example.com/tags/bat%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"bat批处理的使用","slug":"bat批处理的使用","permalink":"http://example.com/categories/bat%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/"}]},{"title":"Java data type","date":"2020-11-13T14:55:13.906Z","path":"wiki/2021-03-03-Java data type/","text":"primitive type 前六个原始数据类型有相关的数据类，他们是[[Java Number]]类的子类。这些数据类和原始数据类型之间发生的类型和类的转换称为装箱（将原始数据转变为类）和拆箱（将引用类型转变为原始数据类型） byte：字节型，八位，默认值0。 和Byte类存在box和unbox关系 short：16位，默认值0。Short int：32位，默认值0。Integer long：64默认值0L。 Long float：32位，默认值位0.0f。Float double：64位，默认值0d。Double char：16位Unicode，字符型，’a’, Character boolean：表示true或者false，默认false。 Boolean [[Java String]] 字符串类：定义为了final，因此String类不可以被继承。可以通过类对象创建方法创建字符串对象，也可以使用””传入想要的内容创建。 reference type指的是引用类型，类似C中的指针。指向的是一个对象，指向对象的这个变量叫做引用变量，这些类型在声明的时候被指定为特定的对象，一旦指定就不再更改，但可以再将其assign给另外的引用变量（类型需要匹配）引用类型的默认值为null。","tags":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"}],"categories":[{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"}]},{"title":"plaxis_workflow","date":"2020-11-13T02:32:21.042Z","path":"wiki/2021-03-03-plaxis_workflow/","text":"plaxis工作流程前处理1. 土层frame​ 这个界面主要是用来模拟土层情况，即ground modeling​ soil contour（土层轮廓边界）可以在文件菜单的子菜单进行设置调整 钻孔设置​ 通过土界面的钻孔进行选点绘制钻孔位置，位置设置完毕之后还可进入钻孔设置工具进行详细的修改，可增加减少钻孔，设置钻孔的层厚，设置初始水位，钻孔修改面板有： 土层：设置土层位置和材料属性。 水：设置土层的上下面的水头 初始条件：设置土层的初始K0值（设置K0x或者使用gravity loading，k0设置需设置k0x：水平有效应力和数值有效应力的比值），在土层材料属性里面设置的初始条件 预固结：土层的pop值，一般在土层材料属性设置的初始界面设置OCR和POP，需要spatial distribution的POP时选择从钻孔来设置土层的pop 场数据：可以自己定义具体的场地数据。自定义场地数据，比较高级，运用到了SBT chart，利用ISBT值对土层进行分类，考虑cone resistance和friction ratio，还有一个CUR 3layers method进行土层分类的标准 模型土层的绘制​ 模型土层的定义设置可在钻孔修改工具进行设置定义同钻孔设置，在钻孔修改界面进行土层增减和层厚的设置，按自己的实际工况进行相应的设置和绘制。 ​ 也可以利用导入土层工具进行导入。设置好土层之后可在该处分配土层的材料属性。 dry条件是用来去除土层水压。interpolate能够土层上部边界压力和土层下部边界眼里之间进行垂直内插head根据指定的水头生成孔压hydrostatic给定土层上边界压力值，程序相应的计算土层孔压分布 场地响应分析只能用于钻孔定义的土层。这个场地响应分析被认为是一个结构必要动力分析的预备研究，地震响应主要被支撑土层的岩土性质所影响。 材料模型设置​ 材料的模型设置在材料设置里面的子菜单里面进行选择设置，材料模型有许多种： 线弹性模型（适用于土体刚性结构模拟） 摩尔库伦模型（一般用于岩土性状的初步近似） 硬化土体模型（用于砂土，砾石，粘土和分土等软土性状的模拟） 小应变硬化土体模型 软土模型（适用于正常固结土和泥炭等软土性状模拟） 软土蠕变模型（模拟和时间有关的软土性状） 节理岩体模型（适用于成层岩体和节理发育的岩体） 混凝土模型（模拟随时间变化的混凝土的性状） ​ 根据实际的工况并选择相应的适应该工况土体的模型，模型设置之后还可设置土体的排水性能：排水（适用于干土，不产生超静水压），不排水（适用于研究超静水压的完全发展过程），非多孔性状（无论初始孔压还是超静水压都不考虑）。也在相同子菜单进行设置。 不同模型和排水条件下的参数设置都不一样。 ==土和界面材料属性和材料数据组==2. 结构Frame模型的结构绘制​ 根据自己的实际工况进行模型的简化和设定，设定好模型之后确定模型需要的结构、荷载位移条件和排水等条件，再利用plaxis软件界面进行模型结构的绘制。 绘制可选的结构有： ​ 土多边形soil polygon（定义一个封闭的土层），点和线（很多结构的依托绘制基准），板，铰和转动约束，点对点锚杆，锚定杆，界面，土工隔栅，隧洞。荷载和边界排水等也在这个部分进行绘制设定，有指定位移，约束，边界条件设置，集中荷载，转动约束，排水线，排水点。 ​ 依托点绘制的结构（point load、point displacement、fix-end anchor）依托线绘制的结构distribution load、prescribed displacement、plate、geogrid、groundwater flow boundary condition etc（line load、linedisplacement、line contraction、plate、geogrid、embeddedbeam row， interface、node-to-node anchor、well、drain，groundwater flow bc、thermal flow bc） 结构和荷载位移单元几何结构（geometric entity） 点和线 主要是用来绘制依托结构（右击可现实可创建assign如下提到的高级结构），或者用来视觉上分割图形显得更直观 板 ​ 主要用来模拟有flexural rigidity（bending stiffness）和normal stiffness的slender structure，可用来模拟wall、plate、shell、或lining extending in z-direction。 ==最重要的属性==：flexural rigidity（弯曲刚度EI）和axial stiffness（轴向刚度EA），deq=（12*EI/EA）^0.5^等效平面厚度equivalent plate thickness。 ==提示==：两个板的连接可以通过使用创建连接功能。在输出程序可以选择双击板查看受力变形等内容 土工隔栅 ​ 是具有axial stiffness无bending stiffness的slender structure，只能承拉力不能承压，一般用来模拟soil reinforcements。材料参数是EA（elastic axial stiffness）大部分应用需要使用各向异性属性避免不真实的剪切变形unrealistic shear deformation而且要求使用updated mesh calculation考虑membrane effect。 界面 ​ 界面是一个用来为了更好的模拟土-结构相互作用（soil-structure interaction）的连接单元joint element。interface可能用来模拟在板和土之间的连接处的剧烈剪切材料区域。 ​ 界面可以创建在板、土工格构和两个土多边形的之间的地区。如果已经有几何实体（line），尽量右击对象去创建而不是再创建一个，避免模型变得不必要的large和unwieldy。界面有正负界面，只是为了更好区分，而不会影响实际的模拟。 ==界面的属性==： ①材料模式： 从相邻土层：界面的roughness通过选择合适的strength reduction factor进行模拟，这个是在界面的土层材料集设置给相邻土层的。可选的还有residual strength如果界面强度达到可以指定。这个因子和界面强度（wall friction and cohesion）和土强度（friction angle and cohesion）有关。 定制：选择这个选项可以直接赋值材料属性给界面，strength reduction factor默认设置为1. ② permeability渗透性：默认像plate和geogrid这些结构单元是可渗的。把界面赋给处结构单元外的几何实体可设置为不可渗的。原则上In principle，界面渗透性是在相应的材料集中设置，但对象浏览器中界面的一可选框是可以激活界面是否flow，这可以影响实际计算的界面渗透性。In Flow，只有计算非结构单元需要设置几何实体为deformation的不考虑。因此只是用interface阻挡flow不充分insufficient。界面的endpoint始终可渗。 ③虚拟界面厚度：是一个假想尺寸，用来定义界面材料属性，厚度越大产生的变形越大。一般来说，界面假定产生很小的变形，因此界面厚度设置很小，另一方面如果数值设置过小，会出现ill-condition。虚拟厚度等于虚拟厚度因子乘以全局元素尺寸global element size。global element size有生成网格是由全局粗糙度设置global coarseness setting决定。默认因子为0.1，在对象浏览器中这个值可以被更改。如果界面受较大的应力，应减少factor。 ④靠近角点的界面：有些需要特别注意的点，钢体结构的角点和边界条件突然改变的点可能会引起应力应变的高峰值。这些引起的问题（non-physical stress oscillations）可以通过设置界面单元来解决。 ⑤连接：两个界面单元的连接点默认共享自由度，这意味着连接时刚性的，这个连接点可以通过连接功能自定义。 点对点锚杆 点对点锚杆不能放置在已经分布了feature的line 锚定杆 锚定杆可以用来模拟简单的pile，不考虑pile-soil相互作用，也可模拟锚杆或者props支撑挡土墙retaining wall。 隧道 隧道创建只能在隧道设计器进行创建，lining衬里、负向界面等都只能在隧道设计器里面设置创建，一旦创建完成，不能在frame阶段修改。 隧洞设计器里面有两个frame，截面（设置隧洞截面形状的界面）和属性（设置linning负向界面等的界面，还可设置reinforcement设施） 截面下有三个子界面 general设置：1.截面形态类型：①自由（可以自己选择绘制线或者弧，按自己需要的隧道截面设置即可）②圆形。2.起始点偏移的情况 线段：绘制隧洞的截面形状的各个线段信息，具体看情况选择，其中边栏有：延伸至对称轴选项，关闭对称轴选项，添加线段、插入、删除选项 子阶段：可以在这里定义隧洞开挖的不同的阶段位置情况，侧边栏有：添加子阶段、插入、删除选项，从点添加子阶段，连接两点添加子阶段，添加直接子阶段等。还有相交选项（将线段相交点绘制出来） 属性下有两个子界面 一般：在这里添加linning衬里、负向界面、线荷载、线收缩、板和土工隔栅等结构。 reinforcement增强结构：创建里面多了一个创建reinforcements选项，可以绘制特定线段的加强结构（应该是类似喷锚支护） 建立好之后就可以点击生成了，生成好之后就可关闭，关闭之后不可修改。 1可以设置任意性状的隧洞放置于几何模型，隧道形状包含了cross section（横截面）拱或者直线，还可以补充其他特性如plates、interface、load、prescibed displacement、contraction，groundwater flow boundary condition etc。可通过隧道浏览器窗口设置具体的隧道形状和属性 NATM： 新奥隧洞开挖法，又被称为顺序开挖法（SEM，Sequencial）或者喷射混凝土衬砌法（SCL，Sprayed concrete lining method），是一种现代隧洞设计和建造的方法。这项技术首先获得关注是1960年代澳大利亚的科学家的成果，命名是为了和之前老方法做出区分。最基本的区别是经济效益，新奥法利用隧洞周围岩体的可用的inherent strength来稳定隧洞，减少了建造所花费的经济和时间代价。新奥法被认为促进了现代隧洞行业的变革，许多现代隧洞都是使用这个方法开挖。从经济角度看，新奥法非常有吸引力，同时在岩溶条件下使用该方法更为合理。 新奥法整合了岩土体在荷载下的形状准则和建造过程中的监控。这个方法常被称为’design as you go’挖到那设计到哪，通过观察到的ground condition提供优化的support。更准确的说应该被描述为’design as you monitor’方法，基于观察到的衬里的收敛和发散以及主要岩石条件（prevailing rock conditions）的mappings。并不是特定的一组挖掘和支护技术。 荷载和边界条件 指定位移 是一种特殊的条件，可以指定模型位移到指定的位置。有三种位移类型：指定，自由和固定。指定位移是设置最后阶段的总位移而不是附加的阶段位移，如果某一阶段没有指定位移增量，那么设定为指定位移的数值应该和上一阶段一样，如果将值设置为0，会在反方向产生一个位移抵消，导致最后阶段位移为0 线收缩 模型边界条件 ​ 模型的边界条件可在模型浏览器中选择其中的子菜单进行模型的许多条件的设置，其中，变形、地下水流边界和动力条件子菜单可以设置相应的边界条件 嵌入式排梁embeddedbeam row 嵌入式排梁的性状behaviour选项有： pile（桩） rock bolt（锚杆） grout body（注浆体） 在选择对象浏览器里面可以进行修改，模型浏览器可以总管全部的结构和土体的各种设置。选择不一样的选项时，又会有其他不一样的属性设置。 前两种类型pile和锚杆，会多出来连接点connection point（桩：顶部和底部，锚杆：第一连接到线的点和第二）和连接方式connection options两个下拉选择框drop-down menu。主要用来模拟一排用来传递荷载到周围土体或岩石的长细结构成员，只在plane strain models可用，需求的信息需要包含单桩（或注浆体或锚杆）属性和平面外方向的spacing间距。 ==提示==：嵌入式梁适合在安装过程中只对周围岩土体造成有限扰动的桩类型。这包含了一些bored pile但并不是所有的the technologies for replacement pile or displacement pile。桩的安装对soil stress ratio和pile skin resistance有很大影响，在这种情况，在模拟pile installation effect 时适当计算这些因素是有必要的。 ==提示==：当嵌入式排梁位于有线弹性材料性状的ploygon cluster，指定的spacing和shaft resisitance被忽略。 ==参数设置==：pile或rock bolt的几何特性，材料属性，平面外out-of-plane direction的间距，表面摩擦力skin friction，承载力bearing capacity以及界面刚度因子interface stiffness factor 分布荷载 荷载的激活冻结在分布施工界面设置。荷载可以在选择对象浏览器种设置静荷载和动荷载。 （荷载类型有四种，uniform每个位置都一致，linear成线性分布，perpendicular垂直的方向，设置数值为正时向下的荷载方向，垂直增量，垂直不断递增，不太懂创建出来的感觉都是一样的） 集中荷载 固定结构计算优先于荷载，因此荷载作用在固定的几何实体上是没用的。，如果只有一端固定是可以应用荷载的动荷载的设置有许多参数需要了解，按需选择。 Design Approachplaxis2D可以为荷载和模型参数进行partial factor 处理，使得plaxis可以利用Eurocode、LRFD或者其他的基于partial factor的设计方法的框架结构去设计计算内容和步骤等。 主要的idea是一个项目首先是在没有使用设计方法的在Severceablity Limit State条件进行分析。这些输入值都被假定为特征值或者代表值，因此计算的结果就可能是变形应力和结构力的保守估计。 如果在正常使用极限状态下可以达到满足条件的值，可以考虑使用设计方法去处理Ultimate Limit State设计。为了进行设计的计算，除了正常使用极限状态的计算阶段外，还需要定义新的计算阶段，有两种方案去实现： 首先按顺序执行正常使用极限状态的各个计算阶段，然后再在每个正常使用状态下分别新建一个极限应力状态，parent phase就是每一个正常状态 正常使用极限状态和极限状态分别进行，互不干扰，各自都从initial phase开始计算。 对于岩土工程师，考虑到所有可能影响设计的条件是他们的责任，工程师的判断对于考虑在设计中的不同混合起着至关重要的作用。 不同的设计方法，本质上也就是一连串的partial factors，可以根据实际可用的design methods为荷载和模型参数定义这些partial factors。定义好之后，也可将其导出到全局数据集中，也可中全局数据集中导入设计方法。==Note==：设计方法在土层、结构、water condition、construction stage都可以选择。 为荷载定义partial factors可以定义design approach的荷载类型有： 线荷载 点荷载 指定位移 不同的partial factors可以应用到不同的荷载或者荷载组里面 荷载的design approach是在模型浏览器里面的phase definition mode进行设置。 ==Note==：荷载的partial factors是用来multiplied reference values获取design values 为材料参数定义partial factors在设计方法里面的材料那一栏可以设置定义。 材料的设置在材料的设置里面，其中可以设置的参数旁边有个下拉框可以选择。 ==Note==：材料的partial factors是用来除的，design values是reference values divided partial factors ==Note==：有几个高级模型不能用设计方法：NGI-ADP、UDCAM-S、Sekiguchi-Ohta和用户定义的模型 为了完成design calculation的定义，需要进入到construction stage定义的阶段选择设计方法，并荷载和材料需要选中为改设计方法才能生效。必须在阶段定义的设计方法和荷载材料里面的标签要对上，不然不能使用。 当使用高级模型和设计方法结合的时候，这些高级模型仍然保持高级特征和性状，和安全性计算不同的是，因为安全性计算时，高级模型会失去他们的高级特性并且转换为摩尔库伦模型。当比较安全性分析和使用了相同$c和\\psi$的设计方法的目标值时，应该意识到由于这个原因结果可能不一样。 水力条件​ hydraulic condition作为一个基于钻孔和土聚合体的水条件自动生成孔压的替代者，孔压分布可以用来地下水流计算或者完全配对的flow-deformation analysis。这要求定义地下水流边界条件groundwater flow boundary condition，即水力条件。 水力条件同样包含特殊条件可以施加给模型去控制特定位置的孔压，在地下水流计算或者完全配对的flow-deformation analysis时的。通过右击geometric entity或者对象浏览器的内容然后去创建。 除了在这里考虑的特定边界条件，全局模型条件关于开放和封闭边界以及precipitation condition可以在每个计算阶段在模型浏览器的模型条件子菜单设置，指定的水力条件优先于全局模型条件。对于临时transient 水利流动和fully coupled flow-deformation analysis。 水力条件可以使用流函数将其定义为时间的函数。 水井well ​ 创建一个水井，这个结构创建类似创建line，是用来创建抽水井或者注水井表示该位置指定的flux（discharge）流入或流出，属性可以在对象浏览器进行修改。设置属性由1. behaviour：抽水或者排水2. Q：抽水或者注水流量3. hmin水井的可能最小水头，当地下水水头低于该值，不再有水被抽出。 排水drain ​ 是用来在几何模型里面定义一条线来表示这个位置的额外的孔压缩减reduced pore pressure，和line创建方式一样。创建好drain后，需要设置参数，其参数设置和behaviour选择有关：1. normal：当选择这个参数，需要输入地下水头，这个选项只和地下水流计算groundwater flow calculation或fully coupled analysis。在这个计算下，drain所有节点node的孔压衰减到和给定水头一致，低于该水头的不受影响。在consolidation analysis，drain减小这个excess pore pressure to zero并且指定的水头被忽略。2. 真空vacuum：选择这个参数，要求输入groundwater head，这个水头是用来定义vacuum consolidation过程地下的underpressure，这个选项之和固结分析consolidation analysis、groundwater flow calculation 或fully coupled analysis。在这个计算中，drain的所有的节点孔压衰减到和给定水头一致，和上一个不一致的是，低于该水头的受drain影响。在分布计算激活冻结，可在对象浏览器进行修改。 地下水流动边界 ​ 这个是用来设置地下水的流动边界情况，创建的时候和line类似，设置参数的时候behaviour有许多参数，不同的选择，边界条件和使用情况都不一样。 ​ 模型的边界可以很方便的在模型条件子菜单进行指定，默认情况模型底部设置为closed，others设置为open（seepage）。 ​ 在计算阶段，在水力条件定义的流动边界功能总是优先于模型条件。在fully coupled analysis，被布置到任何内部几何体的水条件都考虑到step0（计算开始阶段）plaxis忽略指定的水条件设置并基于之前步骤的结果进行flow calculation.闭合边界值适用于外部模型边界，如果closed赋给了内部的几何体，plaxis会忽略掉 ​ 水流边界类型： 渗漏seepage：渗漏边界时谁可以自由流入流出的边界条件，一般用在地表，在潜水面（phreatic level）上部或者在外部水面上部的，比如水坝和dike。如果边界被设置为seepage且完全在水面上方，则会设置为渗漏可自由流出流入。如果低于水面，该自由边界自动设置为水头边界（groundwater head condition），这个时候每个边界点的水头由该点距离水面的距离。水位线和几何体边界平面线的交点孔压为零，该transition line上部被认为上部边界，下部为下部边界不同条件可应用这个，因为plaxis是按节点进行计算，上部节点按上部边界，下部按下部边界，当有降水，seepage不会自动变为Infiltration边界 closed闭合：不能发生流动，表现为地下水流动（groundwater flow calculation和fullycoupled flow-deformation analysis）和额外孔压消散（在固结计算时），只用于模型外部边界，在土体内部需要一条不可渗透的线时，需要插入合适的界面 水头head：除了可以在模型条件设置一般潜水面设置水力边界，还可用这个选项进行设置。如果外部几何体边界给定水头，这个边界将会生成外部水压，变形分析程序将会把这个水压当作traction loads并一起考虑到土重和孔压里。这个选项还有三个可选参数：变化规律（设置水头的变化形式）、水头值、时间相关性（是否和时间有关，设置了之后可以自定义时间有段的流函数。只适用于transient flow和fully coupled flow-deformation analysis） inflow流入：和水头模式参数类似，只是设置有点不一样。设置流入模型边界 outflow渗出：和流入类似 Infiltration回灌：除了在模型条件的precipation降水条件中设置，还可在这里进行设置。参数有：q降水量，单位为单位长度除以单位时间，负值可用来模拟蒸发运输。还有两个参数为最大最小孔压水头，和边界的计算有关，长度单位。最后一个为与时间相关性：不变和随时间变化的流函数。 流函数Flow function这个函数代表水头或者discharge随时间的变化函数。，可在水位和地下水流动边界进行设置定义（==不能定义到非水平水面==）。流函数的时间值代表的是全计算阶段的时间而不是每个阶段的时间间隔interval。这代表了每一个计算阶段的取值，只取在和该阶段时间相关的值上面。 流函数参数： 信号：该参数选择不同，接下来的参数也不同。 简谐：是指一个于简谐运动有关的时间函数， 表：从表中的特定的值和对应时间导入 线性：指随时间成线性变化，进行一些必要的值的设置即可 热力学条件在温度是土和结构性状的影响因素的情况下，plaxis可以将温度效应考虑进来。ground温度分布的计算基于thermal calculation。 由于地下水流动在ground的热能传输起重要作用，因此thermal计算伴随着groundwater flow计算（thermal-hydraulic（TH） coupling） 热流动边界 ==结构材料模型设置==板材料属性设置土工隔栅材料属性设置embedded beam row材料属性设置锚杆材料属性设置3. 划分网格frame当几何模型建立完毕之后，在计算开始之前，为了执行有限元计算需要进行有限元网格单元划分。网格需要充分详细可以获得准确的计算结果，但不必要过于精细，过精细会导致过多的计算时间。plaxis2D自动生成的网格，考虑了土层和结构荷载和边界条件等。 网格划分网格划分是自动的，自动根据用户选择的设置机型网的划分，也可以进行局部的细化或者糙化处理。 有限元元素elements的类型：15节点和6节点，也是用户自己选择设置，除了土层单元，也有结构的elements设置，但是这些会自动调整为兼容土体element。 target element dimension：计算element distribution的公式 $$l_e=r_e\\times0.06\\times\\sqrt{(x_{max}-x_{min})^2+(y_{max}-y_{min})^2}$$ 网格划分是元素分布选择有： very coarse：re=2.00（30-70elements） coarse：re=1.33（50-200elements） medium：re=1（90-350elements） fine：re=0.67（250-700elements） very fine：re=0.5（500-1250elements） elements数量取决于几何模型的形状和可选的局部refinement有关，并不会受element type影响。 ==note==：15节点单元会得到更详细的节点分布，因此结果更准确，但时间开销更大。当然，这个elements distribution可以使用专家设置自定义。 网格细化和糙化设置local refinement： 在较大的应力集中或者大的变形梯度地区，要求进行局部处理，这样可以获取更加准确的finite element mesh，但是其他部位不需要细化处理，这种情况一般发生在几何模型有edges 或corners或structural objects时。 local refinement是基于几何实体中可以定义的local coarse factor处理的。这个factor指示了相对于target element size定义的相对元素尺寸，由element distribution parameter决定的。默认情况，大多数几何实体的coarseness factor设置为1.0，structural object和loads设置为0.25。0.5是将element尺寸减小为目标尺寸的一半。这个factor可以选中几何实体在选择浏览器的coarseness factor进行设置，接受的范围0.03125-8.0，大于1的值是将网格进行糙化。 局部refine可以点击refine mesh按钮或者选中需要refine的几何实体右击然后选择finer mesh选项。局部糙化（以factor为$$\\sqrt{2}$$）进行，也是和局部细化类似，选择按钮或者右击实体进行。同样的操作还有一个重置局部操作。 在网格frame整个土层材料设置无效，且整个模型为灰色，refine或者coarsened object显示为绿色和黄色。 Enhancd mesh refinement：为了更好的在structural elements、loads和prescribed displacement生成准确的网格，plaxis自动采用mesh refinement。适用的条件有： 点点或者点线或者线线距离过于接近，要求更小的elements尺寸避免大的aspect ratios geometry line之间的角度不是90的倍数，为了获取geometry discontinuity的更准确的应力，不同角度对应的local element size factor会按照表格的值去取。==提示==：automatic refinement在mesh选项窗口不选,默认为关闭。 4. 渗流条件frame渗流设置5. 分布施工frame有限元计算可以分为几个连续的计算阶段，每个计算阶段对应特定的loading或者construction stage。construction stage可以在stage construction mode进行定义，不同计算阶段可在阶段浏览器查看。 5.1 阶段浏览器Toolbar有五种按钮： 添加按钮：添加一个计算阶段，选中参考阶段（父阶段）并点击，就在该父阶段下创建了新的阶段 插入按钮：选择一个阶段并点插入按钮，插入一个新的阶段，以选中阶段的父阶段为父阶段，新建的简短为选中阶段的父阶段。这种操作可能会导致后面定义的简短发生变化，因此后面的阶段可能需要进行修改，因为开始阶段condition发生了变化。 删除按钮：删除阶段，会自动进行阶段的父阶段的修改但还是要求进行重新定义后面的阶段。 编辑按钮：进行阶段的具体设置和定义 复制按钮：复制阶段的一般信息到clipboard。 计算状态每个定义好的阶段前面有一个指示器，显示此时阶段的状态，有六种状态图标： 播放图标：需要进行计算的阶段 空白图标：不进行计算的阶段 对勾图标：就算完毕的阶段，没有发生错误 感叹号图标：计算完毕，但是中途将程序进行了猜测让计算继续进行，可在日志进行查看 叉图标：计算失败，具体信息日志查看 问号图标：计算失败，但是子阶段still possible，信息在日志查看 阶段识别每个定义好的阶段有他自己的ID，在阶段浏览器展示，由caption和name组成，name程序自动生成，可修改，caption of the可在阶段窗口进行修改 计算类型标识荷载类型、孔压计算类型由阶段浏览器阶段ID旁边的标识表示 5.2 计算阶段的顺序计算阶段的顺序可以通过选择reference phase然后再添加阶段或者再阶段窗口选择reference phase。默认情况，先前选中的阶段式parent phase。注意之后出现再阶段列表的该阶段不可再被选取 影响顺序的特殊情况在某些特殊情况下，计算阶段的顺序并不是直接顺序往下走的: 如果不同的荷载或荷载结果在同一个项目被分别考虑，initial phase可被选择为reference phase不止一次。 特定的情形下，荷载逐渐增大直到失效来决定safety margin，当继续建造过程，下一个阶段将应该从先前的建造阶段开始而不是从失效情形继续。 当在建造阶段中需要进行safety analysis，这个计算阶段是Safety。一般来说，这个阶段的计算结果是出于failure状态。当继续建造过程，下一阶段应该从先前的计算阶段开始而不是安全性计算结果继续。相应的，如果安全性分析是在计算过程的末尾机型，这种情况，reference phase应该选择相应的建造阶段。 5.3 phase window每一个计算包含一系列参数用来控制计算过程的，这些参数的修改定义都是在阶段窗口中进行，双击阶段或者右键修改唤出该窗口。 在这个窗口，用户至少需要为每一个阶段选择计算类型和荷载类型，plaxis为大多数的计算控制参数提供了方便的默认设置，用户可以修改这些值，最右边界面展示了相关计算类型和参数的描述。 初始阶段计算类型该阶段的计算类型选择是非常重要的，后续的阶段计算大多都是基于此阶段开始之后的计算 K0 过程直接生成初始有效应力、孔压力、和状态参数。不能保证平衡。需要设置==∑Mweight==参数，用来设定初始应力状态的 场应力直接生成初始有效应力、孔压力、和状态参数。不能保证平衡。 重力加载从有限元单元计算初始化应力。将被用于非水平土层。需要设置==∑Mweight==参数 仅渗流没有有效应力计算。用孔压力计算类型定义流 计算类型： 塑性弹塑性排水或不排水分析。不考虑固结 固结变形和超孔隙压力的时间相关分析。需要输入土的渗透率和使用非零时间间隔。 安全性用强度折减发计算总安全因数. 在安全分析中网格没有被更新。 动力在时间域内进行动力分析，用非零时间间隔。 渗流与变形完全吻合总孔隙水压力和变形的时间相关分析。需要输入渗透率和使用非零时间间隔。 Dynamic with consolidationDynamic drained analysis in the time domain. Use non-zero time interval. 5.4 分析计算类型plaxis分析的第一步是在phase window的计算类型下拉菜单中选择定义阶段的计算类型。可选的参数有：在初始阶段的K0 procedure and Gravity loading来生成初始土壤的应力状态。Flow only选项尽在需要进行地下水流动分析的时候选择。Deformation analysis选项如：塑性、固结、安全性计算、动力、Dynamic with consolidation和渗流变形完全吻合。 5.4.1 初始应力生成许多的岩土工程分析要求指定一系列的初始应力，土体的初始应力状态受土体的重量和形成历史的影响。初始应力状态通常由初始vertical 有效应力决定，初始horizontal有效应力和vertical有效应力有关，$$\\sigma^{‘}{h,0}=K_0\\times\\sigma^{‘}{v,0}$$，K0是cofficient of lateral earth pressure，土壤侧压力系数。 在plaxis中，有效应力可以用K0 procedure、Gravity loading或场地应力选项来生成，==这些选项仅在初始阶段才有，建议先生成初始应力之后并inspect结果之后再进行计算阶段的定义和计算。== ==提示==：K0 procedure 不同于Gravity loading是由于field equilibrium场地平衡在初始阶段没有被检查。K0尤其适合水平地表和土层与phreatic level潜水面平行地表的情况，在这个情况下，平衡自动满足（平衡条件：vertical stresses = gravity weight，horizontal stresses = lateral reaction forces along the model boundaries）对于其他的所有情况，K0的使用可能导致out-of-balance forces 初始阶段可能包含pre-loading或者over-consolidation，特别的，高级土体模型可能会考虑over-consolidation，这需要over-consolidation ratio（ocr）或者pre-overburden pressure（pop），这些参数数据可在钻孔设置定义，也可在材料数据定义设置。 作为部分initial stress generation，principal stress history parameter（$$\\sigma^{‘}{1,max}$$）需要initialised。The principal stress history （$$\\sigma^{‘}{1,max},\\sigma^{‘}{2},\\sigma^{‘}{3}$$）用来计算对等的preconsolidation pressure $$P_{p}^{eq}$$，这个参数被用在高级土体模型中initialise a cap-type yield surface。 5.4.1.1 K0 过程直接生成初始有效应力、孔压力、和状态参数。不能保证平衡。需要设置==∑Mweight==参数（代表激活的土重），用来设定初始应力状态。 是plaxis特殊的计算方法，考虑了土体的loading history。初始应力生成过程要求的参数在材料数据的初始tabsheet中进行设置，只是有一个K0值可以指定。 $$K~{0,x}=\\sigma{xx}^{‘}/\\sigma_{yy}^{‘}$$，$$K_{0,z}=K_{0,x}=\\sigma_{zz}^{‘}/\\sigma^{‘}_{yy}$$。 实际上，正常固结土的K0值通常被认为和摩擦角有关。Jaky’s empirical expression ：$K_0=1-sin\\psi$。对于超固结土，值可能比这个值大。 对于摩尔库伦模型，默认的K0值基于Jaky’s formula计算的。对于高级模型（硬化土体模型、小应变硬化土体模型、软土模型、软土蠕变模型、modified Cam-Clay 模型、Sekiguchi-Ohta模型），默认值基于K0^nc^参数同样受到超固结比和前期固结应力POP： $K_{0,x}=K_0^{nc}.OCR-\\frac{\\nu_{ur}}{1-\\nu_{ur}}(OCR-1)+\\frac{K_0^{nc}POP-\\frac{\\nu_{ur}}{1-\\nu_{ur}}POP}{|\\sigma_{yy}^0|}$ 使用很小或者很大的K0值可能会导致应力违反摩尔库伦失效条件failure condition。这种情况下，plaxis自动减小侧面应力到满足failure condition。此后，这些应力点处于塑性状态并被看成塑性点，尽管修正的应力状态满足，可能会导致应力场不相等。一般来说，生成不包含摩尔库伦塑性点的应力场才是preferable。==提示==：在初始有效应力的输出程序选择应力菜单选项的Plastic点选项查看plastic point plot。 对于cohesionless material，为了避免摩尔库伦plasticity，K0取值范围：$\\frac{1-sin\\psi}{1+sin\\psi}&lt;K_0&lt;\\frac{1+sin\\psi}{1-sin\\psi}$ 当采用K0过程，plaxis自动生成等同于土重的垂直应力，水平应力则根据K0计算。如果值选在了plasticity不发生的情况，这个K0过程并不能确保最终的应力场是equilibrium的，因为并不产生剪应力。完全equilibrium只在水平地表下地层平行地表和水平潜水面。因此：==K0过程并不建议处理非水平地表，非水平地表需要剪应力去形成equilibrium stress filed== 如果应力场仅需要很小的equilibrium correction，可以采用K0过程跟着Plastic nil-phase（就是不加额外荷载的塑性计算类型），如果应力out of equilibrium，就不能采用而应选择Gravity loading procedure。 K0过程的最后，完全土重被激活$\\sum{Mweight}=1$ 5.4.1.2 场应力直接生成初始有效应力、孔压力、和状态参数。不能保证平衡。仅在初始阶段可以使用，在计算类型中可选择。 场应力选项允许在模型中设置honmegenous initial stress state，考虑主应力（principal stress）rotation。这个选项与深土层或者岩石层的在地质历史的形成过程造成了principal stress rotation（shearing）这种情况比较相关。 在计算类型中选择了这个选项后，还需要指定三个主应力的大小（$\\sigma_1、\\sigma_2、\\sigma_3$）以及主应力方向的朝向（Axis1），$\\sigma_1、\\sigma_2$是平面内主应力方向，$\\sigma_3$平面外方向应力。==NOTE==：compression is negative。压力是负值。 三个应力值不需要指定，默认$\\sigma_1是最大，\\sigma_3最小$，此外，（x,y)coefficient不必要是单位矢量（vector）。在输出程序查看主应力结果时，展示的最大最小不仅包含平面内也包含平面外。 作为模型条件场应力的全局定义的替代选项，用户还可利用它定义每个soil ploygon的场地应力条件。在土层模式下，选中土块右击选中create filed stress然后在对象浏览器中clusterfiledstress进行设置相关数值即可。这种给不同的cluster定义应力状态可用来模拟有disturbance zone，在这里，软弱层可能有着和disturbance zone外部岩块不同的应力状态。 在进行场应力初始计算后，用户仍然需要应用nil-phase去处理模型中任何的不平衡去获得正确的应力状态。 这个计算不考虑由于重力引起的随深度增加的应力，因此，$\\sum{Mweight}$设置为0。然而，定义在材料属性设置时的是非零的，因为为了在dynamic计算生成正确的mass和inertia。==需注意==：跟随场应力计算之后的计算阶段都需要设置为0去避免突然unbalance发生。 除了输入场应力条件，还需要将模型边界设置为fully fixed，需要在模型浏览器变形菜单设置边界为fixed。==NOTE==：场应力选项可能产生shear stress，错误的边界条件并不能承受，因此需要设置正确的模型边界。 这个计算类型的结果是根据预定义的应力大小和主应力方向的矢量方向产生的。如果采用这个类型，应力状态不仅产生在volume elements，同样生成在interface elements。==注意==：场应力选项不影响结构单元同样不考虑外部荷载和边界条件，和K0过程类型一样。因此，在这个计算类型下的初始阶段，需要冻结这些单元。 5.4.1.3 重力加载从有限元单元计算初始化应力。将被用于非水平土层。需要设置==∑Mweight==参数 重力加载是塑性计算的一种，初始应力基于土体体积的重量产生。如果采用重力加载，通过在第一个计算阶段利用土体自重生成初始应力。这通过设置$\\sum{Mweight}=1.0$完成。当采用像摩尔库伦模型的elastic perfectly-plastic soil model，K0主要取决于设定的泊松比$\\nu$，因此选择合适的泊松比获得真实的K0很重要。如果有必要，各自的材料属性集也需设置各自的泊松比以在重力加载计算中提供合适的K0值。这些设置可能在后续被其他材料数据集代替，对于一维压缩，让弹性计算公式：$K_0=\\frac{\\nu}{1-\\nu}$ 如果设置K0为0.5，需要指定泊松比值为0.333.由于泊松比小于0.5，重力加载阶段不可能产生大于1的K0。如果需要大于1的K0，模拟加载历史并在加载卸载使用不同的泊松比或者使用K0 procedure。 当使用高级土体模型，重力加载后的K0和材料集的$K_0^{nc}$参数有关。 ==提示：==为了确保模拟中采用了不排水材料的初始有效应力，忽略排水性状的选项需要勾选。==如果采用的重力加载生成了初始应力，下个阶段的开始需将位移设置为0。==这消除了初始应力生成过程对随后计算阶段产生的位移的影响，应力始终维持。重力加载过程中忽略OCR和POP参数。 在某些情况下，重力加载过程中可能产生塑性点，对于one-dimensional compression一维压缩的无粘性土cohesionless soil，如塑性摩尔库伦点，除非满足不等式：$\\frac{1-sin\\psi}{1+sin\\psi}&lt;\\frac{\\nu}{1-\\nu}&lt;1$ 5.4.1.4初始应力生成的结果在初始应力结果产生后，可查看初始有效应力的结果图，同样可以查看塑性点的图。 使用本质上和单元有差异的K0值有时候可能导致产生的应力状态违反了摩尔库伦criterion，如果图标显示了很多的红点，K0值应该选择为接近1.0的值。 如果有少量的plastic point，采用plastic nil-phase是可取的。当使用硬化土体模型且定义了正常固结的初始应力状态（OCR=1,POP=1），图表会产生许多的hardening points，不应该关注这些点，因为他们只是显示了正常固结的应力状态。 5.4.1.5 仅渗流没有有效应力计算。用孔压力计算类型定义流 这个选项允许纯粹的饱和和不饱和条件下的地下水渗流计算，只在初始计算阶段可被选择。这个选项会影响接下来的阶段。这个选项下，接下来的额计算类型将被自动选择为Flow Only，且不能做修改。如果初始阶段没有选择flow only，是不可能选择flow only计算阶段的。 当选择了这个，在孔压计算类型只有稳定状态地下水渗流选项可选。 5.4.1.6塑性 nil-phase如果K0 procedure生成了不平衡的初始应力场或者出现了摩尔库伦塑性点，需要采用这个阶段进行修正。它是一个不施加额外荷载的塑性计算阶段，在这个计算阶段完成后，应力场将会是平衡的并且所有的应力遵循failure condition。 如果产生的应力场过于不平衡，这个阶段可能救不回来。发生情况：K0运用到steep slope上，这种情况，应采用gravity loading procedure。 确保在这个阶段计算产生的位移不会影响后续计算很重要，通过在后面的计算阶段中选择Reset displacement to zero参数即可。 5.4.2塑性计算塑性计算是用来开展弹塑性变形分析，这个==没必要考虑孔压随时间的变化==，如果Updated mesh参数没有被选择，计算根据小变形理论进行。正常塑性阶段的stiffness matrix基于original undeformed geometry，这个计算类型在大多数的实际岩土应用都合适。 尽管可以指定时间间隔，塑性计算并不考虑时间的效应，除了使用软土蠕变模型考虑饱和粘土的快速加载，塑性计算可以使用完全不排水性状的限制性条件，使用undrained（A\\B\\C）在材料数据集设置。另一方面，进行完全排水分析可以评估长期的沉降，这可以给出最终情形的较为准确的预测，尽管没有准确的荷载历史并且没有详细的处理固结过程。 弹塑性变形分析，需要暂时忽略排水性状（A\\B不排水），可以选择Ignore undr参数，这种情况下，不考虑stiffness of water。这个参数并部影响设置了C类排水的材料 改变geometry configuration 同样可以重新定义水边界条件并重新计算孔压，在scientific Manual有相关理论介绍和细节。 在塑性计算中荷载可以通过改变load combination，stress state，weight，strength或stiffness of elements修改，通过改变荷载和geometry configuration或孔压分布在staged construction。在这种情况下，最终阶段达到的总的load level 通过指定新的geometry 和load configuration或pore pressure distribution在staged construction mode。 孔压计算类型： phreatic use pressures from previous phase steady state groundwater flow 5.4.3固结分析计算当有必要分析==饱和粘土的随时间的excess pore pressures的发展和dissipation==时，采用这个分析类型。plaxis可以进行真的弹塑性固结分析。一般来说，没有附加荷载的固结分析在不排水的塑性计算之后进行固结分析时施加荷载也是可行的。但是，需要注意当failure situation 达到，since the iteration process may not converge in such a situation。 固结分析要求额外的边界条件生成excess pore pressures。 ==提示：==在plaxis中，孔压被分成steady-state pore pressure和excess pore pressures。稳定状态孔压根据每个阶段设置到到土层的水条件产生，而超净孔压是由于不排水A\\B或者固结产生的。plaxis的固结分析仅会超净孔压。除了考虑排水类型设定，固结分析还考虑相应的定义在材料数据集地下水tab的permeability。固结分析并不影响undrained（C），因为不允许产生超净孔压。 固结分析的可选选项： 分布施工：固结和simultaneous loading从改变荷载组合，应力状态，重量，强度或者单元刚度来看，在分布施工阶段通过改变荷载和几何体配置来激活。指定时间间隔参数是有必要的，这个时间间隔指定了应用在当前计算阶段的整个固结阶段。荷载在这个时间间隔下线性增加到指定的大小。开始增加时间时基于在数值控制参数Numerical control子菜单的First time step 参数。分布施工阶段在没有额外荷载的特定的固结时期时可选择。 没有额外荷载的固结，直到超净孔压衰减到指定的最小值，通过最小超净孔压参数指定的。默认最小孔压设置为1 stress unit，也可自己设定，这个值是一个绝对值，可以设置为压力 也可拉力tensile stress。时间间隔选项不可设置，不确定什么时候衰减到。applied first time increment在numerical control参数子菜单的first time step参数。 没有额外荷载的固结，直到达到特定的固结程度，通过指定固结度参数。默认固结度设置为90%，可改变。时间间隔参数不可设置。同上最后一句。==提示==：固结度官方定义目标沉降除以最终沉降，但是plaxis定义为目标最小孔压除以初始最大孔压。 5.4.4渗流-变形同步分析当有必要分析==饱和和部分饱和的土体由于水力边界条件随时间改变而引起的变形和孔压的同步发展==时，可以进行这个分析。使用这个分析的例子有：大坝后部库水位的draw down，容易受到tidal wave和partially draind excavation 影响的坝岸以及建筑场地的排水。和固结分析直接影响超净孔压不同的是，该分析直接作用于总的孔隙水压力（稳定孔压 + 超净孔压）然而，为了和其他计算类型一致，稳定状态孔压基于计算阶段的后期的水力条件进行计算，计算阶段后期enables the back-calculation of excess pore pressures from the total pore water pressures。 该分析考虑潜水面上部非饱和区的非饱和土的性状和suction。这是最高级和真实的分析类型，考虑了非饱和区的reduced permeability 和饱和度degree of saturation，因此忽略suction选项在这个计算类型下不可选。 一般来说，该分析考虑潜水面上部的非饱和区的非饱和性状和suction。然而非饱和区的positive pore stresses可以通过使用Ignore suction选项 当该分析阶段和temperature calculation，fully coupled Thermo-Hydro-Mechanical（THM）分析是可选的 提示：在这个分析阶段不能使用updated mesh 选项 5.4.5安全计算分析在plaxis安全计算分析是计算global 安全系数factor。这个选项可以在一般tabsheet中选择为单独的计算阶段。 在这个安全性计算方法中，土体剪切强度参数$tan\\phi$和C以及抗拉强度连续衰减直到结构失稳发生。膨胀角原则上来说不会被这个应力折减（phi/c reduction procedure）过程影响。但是膨胀角不能大于摩擦角，当摩擦角减少到和膨胀角一样大时，再减少就会随着摩擦角的减小而同等减小。如果使用了界面，界面强度以同样的方式减小。结构对象如plates和锚杆同样可以减小。 total multiplier$\\sum{Msf}$用来在分析中给定阶段去定义土体强度参数的值： $\\sum{Msf}=\\frac{tan_{\\psi input}}{tan\\psi reduced}=\\frac{c_{input}}{c_{reduced}}=\\frac{S_{u,input}}{S_{u,reduced}}=\\frac{Tensile strength_{input}}{Tensile strength_{reduced}}$ 其中带有input下标的参考的是在材料数据集中设置的属性，带有reduced下标的参考的是在分析过程中是同的衰减值。$\\sum{Msf}$计算开始时设置为1用来设置材料强度为输入值。 安全计算分析使用load advancement number of steps procedure来进行。incremental multiplier Msf是用来指定第一计算步的强度衰减的变化值，默认设置为0.1，这是一个比较合适的开始值。强度参数自动连续的衰减直到所有的Additional steps计算完毕。默认下计算步设置为100，如果有必要也可给定10000。必须总是检查是否最终步是否导致了完全发展的failure mechanism。如果满足条件，则factor of safety通过下面公式计算： $SF=\\frac{available \\ strength}{strength\\ at\\ failure}=value\\ of\\ \\sum{Msf}\\ at\\ failure$ 安全系数计算主要的结果是failure mechanism和相应的$\\sum{Msf}$这就是安全系数。随着输出程序Project 菜单的不同选项选中，每个计算步的$\\sum{Msf}$值在计算信息窗口显示。建议使用曲线选择窗口去查看整个阶段的$\\sum{Msf}$的发展，在这个曲线查看器中，可以查看在变形不断发展时，是否可以达到一个恒定不变的值，换种方式说就是failure mechanism是否完全发展，如果没有达到，则这个计算需要加大计算步进行再次计算 ==提示==：在Numerical control参数子菜单定义的数值参数不应该对principal results产生较大影响。然而，在安全分析过程安全系数接近一的情况，其他的输出结果（结构内力）可能对数值参数很敏感，特别是：Desired min and max number of iteration这两个参数 为了抓取更准确的结构失效，需要使用Arc-control参数，同时需要使用不超过1%Tolerated error。当使用默认iteration 参数，所有要求complied with。 ==提示==：当使用没有Arc-length control的安全计算时，reduction factor 不能降低，会导致过大的安全系数出现。为了准确获取结构的failure，需要使用足够fine mesh。当有高级土体模型混合了安全计算，这些模型将都会表现为标准的摩尔库伦模型，因为stress-dependent stiffness behaviour和硬化效应在这个分析里面不考虑。in this case，在计算阶段的开始基于起始刚度计算刚度并保持常量不变直到计算阶段完成。==注意==：当使用修改Cam-clay模型和Sekiguchi-Ohta模型时，强度一点也不会衰减，因为这两个模型没有cohesion和friction angle。 在安全计算采用的强度折减方法计算的安全系数和基于Limit Equilibrium Method（LEM）slip-circle analysis的传统稳定性分析方法相同类似。想要了解更详细的强度折减方法（phi/c reduction），可以参考Brinkgreve&amp;Bakker的文章。 ==提示==：在Jointed Rock model的条件下，所有plane平面的强度将会按$\\sum{Msf}$减少。在NGI-ADP模型和UDCAM-S模型条件下，所有不排水强度are reduced by $\\sum{Msf}$。在Cam-clay模型和Sekiguchi-Ohta模型条件，强度一点也不会衰减。安全分析使用用户定义的土体模型时，参数衰减值需要in the code为用户定义模型详细指定 ==提示==：当考虑suction时，可以为Fully coupled flow-deformation analysis获取更加贴合实际的安全系数值。这个值一般涞水比忽略suction的常规安全系数更高，因此解读这个值时需要注意 ==提示==：一般来说，不建议有使用了residual （残余的，剩余的）强度的structural elements的模型进行安全计算。在安全计算过程中，有structural elements的模型会进行stresses和forces的重新分布，会导致structural forces的增加。当结构的强度达到了，而且这个结构有一个低于正常值的residual strength（残余强度），结构force将会减小到residual strength。这可能会导致不平衡的情况，进而导致安全系数不合实际的减小。 在安全计算以下的参数时可选的： 逐渐减小强度参数来进行的安全分析。默认first calculation step的衰减增量为0.1，可修改。 衰减强度参数直到目标的total multiplier达到进行的安全分析。程序首先会尝试探寻一个安全值（大于目标值）然后在passing the target之前把值给last step，然后将做最后一个step去达到目标值。 enhanced safety analysis对于安全计算，所有的soil cluster和interface都自动考虑进来。增强的安全分析使得施加强度折减到soil cluster 和结构变得可能，此外，还可以指定特定的soil cluster和结构不参与应力折减过程。 安全计算通过强度折减的multiplier来控制。进行enhanced safety analysis的目的如下： 沿着边坡的表层soil sluster可以不进行强度折减过程来避免不真实的浅层failure mechanism 和soil cluster一样，倘若这些结构表现为elastoplatic并且有limit strength，所有的结构可以选中进行应力折减。 需要慎重的为不同阶段手动选择特定的soil cluster和structure，进行enhanced safety analysis。 5.5计算阶段定义在工程实际运用中，一个项目被分成多个项目阶段，在plaxis的模拟中，也将计算过程分成多个计算阶段。 计算阶段可以是： 特定时间的特定荷载的激活 建造阶段的模拟 固结阶段的引入 安全系数的计算 每个计算阶段可以被分成多个计算步，由于土体的非线性性状要求荷载小部分阶段的施加（被称为荷载step）。在大多数情况，指定计算阶段最终达到的情形是sufficient，plaxis会考虑合适的荷载step到sub-division。 construction stages可以在flow condition和staged construction modes选择。 ==first calculation phase（initial phase）是初始模型的初始应力场的计算，通过Gravity loading或者K0来计算==。相应的，也可指定计算只在考虑地下水流动。初始阶段之后，之后的阶段可以用户自定义，每个阶段计算类型是必选的。 5.6塑性计算后处理","tags":[{"name":"md_photos","slug":"md-photos","permalink":"http://example.com/tags/md-photos/"}],"categories":[{"name":"md_photos","slug":"md-photos","permalink":"http://example.com/categories/md-photos/"}]},{"title":"python_data_anlysis_notes","date":"2020-11-13T02:32:06.720Z","path":"wiki/2021-03-03-python_data_anlysis_notes/","text":"python数据分析笔记123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import reimport pandas as pdimport numpy as np# pandas的属性设置：pd.set_option(&#x27;max_rows&#x27;, 10)datas = &#123;&#x27;hello&#x27;: np.random.rand(10)&#125;data = pd.DataFrame(datas)# 1. 数据读取：data = pd.read_csv(&#x27;F:/data/csv_documents/box/thesis_data.xlsx&#x27;)# 2. 异常值或者特殊值的查询data.isnull() # 查询空值还可以series系列的isnull方法来查看列数据的空值情况data.duplicated() # 查询是否有重复值，还可以查询series的duplicated方法查看单列的重复值data.drop_duplicates([&#x27;word&#x27;], keep=&#x27;last&#x27;) # 去除列表的列中的重复值并保留最后一个重复值data[&#x27;word&#x27;].unique() # 查询所有的数据中的唯一值，也有单列数据的该方法data.isin([&#x27;hello&#x27;, 1, 5]) # 查询是否有数据在该列表的数据中data[data[&#x27;word&#x27;].str.contains(&#x27;王&#x27;, na=False)] # 模糊匹配查找word中包含王的数据data[data[&#x27;word&#x27;].between(1, 5)] # 查找word列在1到5的行# data[~((df[&#x27;word&#x27;] &lt; 1) | (data[&#x27;word&#x27;] &lt; 5))]等价于下面的# ~代表取反也就是非，|代表或的意思data[(data[&#x27;word&#x27;] &gt; 1 &amp; data[&#x27;word&#x27;] &lt; 5)] # 查找word列的大于1小于5的数据# 3. 删除重复或缺失data.drop_duplicates([&#x27;word&#x27;, &#x27;definition&#x27;], keep=&#x27;first&#x27;, inplace=True)# 参数代表的意思：删除列表中两列的重复值并保留第一项重复，并保留更改到数据data.dropna(subset=[&#x27;word&#x27;], how=&#x27;all&#x27;, axis=0)# 参数：subset是指删除空值的子列，how代表删除整行全部为空值的行，axis代表操作的方向为列还是行# 4. 补全缺失data.fillna(&#x27;hhh&#x27;)data.fillna(method=&#x27;bfill&#x27;)# 指定使用相邻的值来填充，使用method参数来指定，bfill是空值下面行的值填充data.fiina(&#123;&#x27;word&#x27;: &#x27;hhh&#x27;, &#x27;definition&#x27;: &#x27;你好&#x27;&#125;)# 使用字典的数据来指定特定行列的填充值# 5. 数据排序data.sort_values(axis=1, ascending=True)# 对列的数据进行排序操作data.sort_indexs()# 对数据的index进行排列操作data.reset_index()# 重置索引，对索引顺序出现混乱时可以使用# 对接excel的python的pandas的常见操作data = pd.read_excel(&#x27;F:/data/csv_documents/box/thesis_data.xlsx&#x27;)# 1. 读取数据源# 2. 查看一些基础信息data.index # 索引data.columns # 列名data.dtypes # 查看数据类型data.ndim # 查看数组维度data.shape # 查看数据的行列元组data.describe() # 查看描述信息data.info() # 查看详细信息data.head(10) # 查看前10行data.tail(10) # 查看后十行data.loc[&#x27;最大值&#x27;] # 查看指定行列数据data.loc[-(data[&#x27;最大值&#x27;] &gt; 5)] # 删除最大值列中大于5的行data.rename(columns=list(&#x27;heldfo&#x27;)) # 修改列名data.iloc[1:2] # 查看指定的行列数据# 3. 描述性统计：data.describe()data.info()data.unique() # 查看唯一值data.value_counts() # 查看数值统计情况，也可指定行的该方法bins = [i * 10 for i in range(1, 11)]labels = [f&#x27;&#123;(i - 1) * 10 - &#123;i * 10&#125;&#125;&#x27; for i in range(1, 10)]data_cut = data.cut(data[&#x27;最大值&#x27;], bins, labels=labels)# 将列数据含特定的分割组类进行分组分段统计data_cut.value_counts(sort=False)df = pd.concat([data, data_cut], axis=1, ignore_index=True) # 利用合并增加一列df_group = df[&#x27;最大值&#x27;].groupby([df[0], df[1], df[7]]) # 多维数据的分组df_fum = df_group.agg(&#x27;count&#x27;) # 频数统计# 4. 缺失值处理df[df.isnull().values == True] # 显示有缺失值的行df_na = (df.isnull()).sum(axis=1) # 统计每行的缺失值数量df = pd.concat([df, df_na], axis=1) # 拼接df = df.loc[df[&#x27;na_num&#x27;] &gt;= 5] # 筛选出满足条件的行df.dropna() # 删除含缺失值的行df.dropna(how=&#x27;any&#x27;) # 删除掉其中行全为空值的行df.fiina(0) # 填充固定值df.fillna(df[df[&#x27;最大值&#x27;].median()]) # 填充数据框架的特定数据特征值df.fiina(0, method=&#x27;pad&#x27;) # 填充前一条数据df.fiina(0, method=&#x27;bfill&#x27;) # 填充后一条数据# 5. 数据筛选df.loc[(df[&#x27;最大值&#x27;] &lt; 5) &amp; (df[&#x27;最大值&#x27;] &gt; 1)]# 6. 数据替换df.map(lambda x: x.strip()) # 利用map函数进行特定的数据处理df.replace(&#123;&#x27;最大值&#x27;: &#x27;应届毕业生&#x27;&#125;, &#x27;一年以下工作经验&#x27;) # 替换最大值列的应届毕业生为一年工作df[&#x27;最大值&#x27;].replace(&#123;&#x27;应届毕业生&#x27;: &#x27;一年以下工作经验&#x27;&#125;) # 选出列再替换也可# 7. 数据排序df.sort_values(by=[&#x27;最大值&#x27;, &#x27;最小值&#x27;], ascending=True) # 对列表中的列进行排序# 8. 数据关联pd.merge(df, data, on=&#x27;最大值&#x27;, how=&#x27;left&#x27;) # 对最大值进行左关联pd.concat([df, data], axis=1, ignore_index=True) # 合并# 利用reduce对数据帧列表结合merge方法进行多表关联# 9. 数据聚合df_group = df[&#x27;最大值&#x27;].groupby([df[&#x27;最小值&#x27;, &#x27;年均值&#x27;]]) # 根据最小值和年均值对最大值进行聚合df_group.agg([&#x27;max&#x27;, &#x27;median&#x27;, &#x27;sum&#x27;]) # 对df_group进行聚合运算，最大值，中位数，求和# 10. 数据透视表pd.pivot_table( df, index=[&#x27;最大值&#x27;], columns=[&#x27;最小值&#x27;], values=[&#x27;年均值&#x27;], aggfunc=[np.sum, np.median, np.max], fill_value=0)# index代表数据透视表的列，columns是行，values是进行分类的值# aggfunc代表函数处理，fill_value是空值填充值# 数据清洗# 1. 插入数据df[&#x27;hello&#x27;] = [i for i in range(20)]df.insert(0, &#x27;你好&#x27;, [i + 10 for i in range(20)]) # 在列索引下增加一列名为**的数据df.append(data, ignore_index=True, sort=False) # 增加数据，要求列一致# 2. 删除行列df.drop([0, 1]) # 删除第一行第二行df.drop([&#x27;hello&#x27;], axis=1) # 删除列# 3. 数据替换df.replace([&#x27;dd&#x27;, &#x27;ss&#x27;], &#x27;&#x27;, regex=True) # 替换字符， 还可使用正则表达式df.loc[0, &#x27;hello&#x27;] = 0 # 查询到的数据可以直接进行复制修改# 4. 数据查询# 正则匹配进行查询df[df.hello.str.match(&#x27;[jk]&#x27;, flags=re.IGNORENCE, na=False)]card = [&#x27;A&#x27;, 30]# query()函数贼好用，学会用查询数据很方便# 查询index大于小于5且hello列不包含A和30的数据，还可直接在表达式中使用统计函数df.query( &#x27;1 &lt;= index &lt;= 5 and hello not in @card&#x27;)# 查询最大值大于最大值平均数且hello列为A的数据df.query( &#x27;最大值 &gt; 最大值.mean() and hello == &quot;A&quot;&#x27;)","tags":[{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/tags/python-notebook/"}],"categories":[{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/categories/python-notebook/"}]},{"title":"python_spider","date":"2020-11-13T02:31:22.349Z","path":"wiki/2021-03-03-python_spider/","text":"python爬虫知识python爬虫解析方法1.bs4的BeautifulSoup:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from bs4 import BeautifulSoupsoup = BeautifulSoup(&#x27;html&#x27;, &#x27;lxml&#x27;)soup.prettify() # 将html内容进行美化# 一、beautifulsoup有四大种类，Tag，NavigableString,BeautifulSoup，Commenta = soup.tag_name # 1.利用tag_name来进行查找a.name,a.attrs # 分别得到Tag的名字和属性，后者为一个字典类型，soup的name是[document]获取属性可用a[&#x27;class&#x27;]或者a.get(&#x27;class&#x27;),还可对其进行修改a.string # 2. 是用来获取标签内的文本# 3. beautifulsoup是特殊的tag对象# 4. comment是特殊类型的navigablestring，可以通过type(a.string) == bs4.element.Comment来判断是否为注释对象# 二、遍历文档树a.contents # 1. 将tag的子节点以列表方式输出a.children # 返回的是所有子节点，可以遍历获取所有子节点a.descendants # 2. 返回所有子孙节点，遍历获取a.string # 3. 返回节点内容，只当节点tag唯一才可获取，多个tag时返回Nonea.strings # 4. 获取多个内容，遍历获取a.stripped_strings # 获取多个内容，且为去除多余空白的字符串a.parent # 5. 父节点a.parents # 6. 所有父节点a.next_sibling, a.previous_sibling # 7. 兄弟节点a.next_siblings,a.previous_siblings # 8. 所有兄弟节点a.next_element, a.precious_element # 9. 不分层次的下一节点a.next_elements,a.previous_elements # 所有的下一节点，遍历即可# 三、搜索文档树soup.find_all(name, attrs, recusive, text, **kwargs)# 1. name:查所有名字为name的tag#可传字符串# 正则表达式（查找匹配正则的标签）# 列表（查找列表内的标签），True（查找所有节点标签）#方法，方法接受的是标签，函数返回True则选择，为False则跳过，# tag.has_attr()返回bool# 2. keyword参数，如果指定名字参数不是内置参数名，搜索时会将该参数当作指定名字的tag属性来搜索soup.find_all(id=&#x27;hh&#x27;) # 会搜索tag的id属性满足条件的tag# 3. text参数可用来搜索文档的字符串内容，与name参数可选值一样# 4. limit参数限制搜索的结果数量# 5. recursive默认检索当前tag的所有子孙节点，如果只搜索直接子节点，可设置该参数为Falsesoup.find() # 和find_all一样只是直接返回第一个结果soup.find_parents(),soup.find_parent() # 查找的时所有父辈节点soup.find_next_siblings() # 找所有后面的兄弟节点soup.find_previous_siblings() # 查找所有之前的兄弟节点soup.find_all_next(),soup.find_next() # 查找当前节点后面的所有节点soup.find_all_previous(),soup.find_previous() # 之前的所有节点# 四、css选择器soup.select() # 查找的内容都是列表形式，获取节点内容用get_text()方法soup.select(&#x27;p&#x27;) # 标签名查找soup.select(&#x27;.sister&#x27;) # 类名查找soup.select(&#x27;#link&#x27;) # id名查找soup.select(&#x27;p#link&#x27;) # 组合查找， 不在同一节点空格分开soup.select(&#x27;head &gt; title&#x27;) # 直接子节点查找soup.select(&#x27;p[class=&quot;sister&quot;]&#x27;) # 属性查找 2. xpath解析方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import lxmlfrom lxml import etreehtml_text = &#x27;&lt;html&gt;&#x27;html = lxml.etree.HTML(html_text)result = html.xpath(&#x27;//div/text()&#x27;) # 选择div节点的文字,,xpath的text()选取文本# 一、节点选择：# 1. / 从根节点选取，选择直接子节点，//选子孙节点# 当子节点没有文本而子孙节点有，使用/a/text()并不能选取子孙节点的文本# 可用这个过滤不需要的文本，/a//text()则可获取子孙节点的文本# 2. // 从匹配的当前节点选择节点不考虑他们的位置# 3. . 选取当前节点 ... 选择当前节点的父节点# 4. @ 选取属性# div 表示选取div节点的所有子节点# /div 选取根元素div# /div/a 选取所有div子元素的所有a节点# //a 选取所有的a节点，不管具体位置# div//a 选取所有div子节点的所有a节点不管位置# //@lang 选取lang的属性值# 二、 谓语用来查找特定节点或者含有特定值的节点# /div/a[1] 选取第一个a节点# /div/a[last()] 选取最后一个元素# /div/a[last()-1] 选取倒数第二个a节点# /div/a[position()&gt;2] 选取位置第二个之后的节点# //title[@lang] 选取有lang属性的title# //title[@lang=&quot;zh&quot;] 选取lang属性为zh的title# //title[contains(@lang, &#x27;en&#x27;)] 选取lang属性包含en的节点# //title[contains(@lang, &#x27;en&#x27;) and @title=&#x27;hhh&#x27;] 多属性条件匹配还有or，mod等运算符可以使用# /div/li[price &gt; 35] 选取属div的a的price元素大于35的# 三、选取未知节点，可使用通配符# *匹配任何节点 @*匹配任何属性的节点 node()匹配任何类型的节点# 利用 | 符号可以选取满足多个条件的内容如：# //div/a[@*]/* | //div/span/@title,,,选择满足两者之一的就选择出来# 四、节点轴的利用进行选择# //div[@class=&#x27;sister&#x27;]/ancestor::*选择满足条件的div节点的祖先节点，双冒号后再接一个选择器# //div/attribute::* 返回节点的所有属性# /div/child::* 获取所有子节点，或者::a[@class=&#x27;link&#x27;],选择子节点a属性为link的a# div/a/descendant::* 获取所有子孙节点# div/a/following::* 选取所有a之后的节点# div/a/follwing-sibling::* 所有之后的同级节点 轴名称 结果 ancestor 选取当前节点的所有先辈（父、祖父等）。 ancestor-or-self 选取当前节点的所有先辈（父、祖父等）以及当前节点本身。 attribute 选取当前节点的所有属性。 child 选取当前节点的所有子元素。 descendant 选取当前节点的所有后代元素（子、孙等）。 descendant-or-self 选取当前节点的所有后代元素（子、孙等）以及当前节点本身。 following 选取文档中当前节点的结束标签之后的所有节点。 namespace 选取当前节点的所有命名空间节点。 parent 选取当前节点的父节点。 preceding 选取文档中当前节点的开始标签之前的所有节点。 preceding-sibling 选取当前节点之前的所有同级节点。 self 选取当前节点。 例子 结果 child::book 选取所有属于当前节点的子元素的 book 节点。 attribute::lang 选取当前节点的 lang 属性。 child::* 选取当前节点的所有子元素。 attribute::* 选取当前节点的所有属性。 child::text() 选取当前节点的所有文本子节点。 child::node() 选取当前节点的所有子节点。 descendant::book 选取当前节点的所有 book 后代。 ancestor::book 选择当前节点的所有 book 先辈。 ancestor-or-self::book 选取当前节点的所有 book 先辈以及当前节点（如果此节点是 book 节点） child::*/child::price 选取当前节点的所有 price 孙节点。 运算符 描述 实例 返回值 | 计算两个节点集 //book | //cd 返回所有拥有 book 和 cd 元素的节点集 + 加法 6 + 4 10 - 减法 6 - 4 2 * 乘法 6 * 4 24 div 除法 8 div 4 2 = 等于 price=9.80 如果 price 是 9.80，则返回 true。如果 price 是 9.90，则返回 false。 != 不等于 price!=9.80 如果 price 是 9.90，则返回 true。如果 price 是 9.80，则返回 false。 &lt; 小于 price&lt;9.80 如果 price 是 9.00，则返回 true。如果 price 是 9.90，则返回 false。 &lt;= 小于或等于 price&lt;=9.80 如果 price 是 9.00，则返回 true。如果 price 是 9.90，则返回 false。 &gt; 大于 price&gt;9.80 如果 price 是 9.90，则返回 true。如果 price 是 9.80，则返回 false。 &gt;= 大于或等于 price&gt;=9.80 如果 price 是 9.90，则返回 true。如果 price 是 9.70，则返回 false。 or 或 price=9.80 or price=9.70 如果 price 是 9.80，则返回 true。如果 price 是 9.50，则返回 false。 and 与 price&gt;9.00 and price&lt;9.90 如果 price 是 9.80，则返回 true。如果 price 是 8.50，则返回 false。 mod 计算除法的余数 5 mod 2 1 3. css使用pyquery:1234567891011from pyquery import PyQuery as pqdoc = pq(&#x27;html&#x27;) # 还可pq(url=&#x27;&#x27;)或者pq(filr_path)# 然后就可以利用doc进行css的选择result = doc(&#x27;p a#link&#x27;)for i in result.items(): i.text() # 返回的是标签内部的内容 i.attr(&#x27;attr_name&#x27;) # 返回属性名或者i.attr.attr_name i.html()# div,p 选择div和p元素# div p 选取div内的所有p# div&gt;p 选取所有父元素为div的p 选择器 例子 例子描述 CSS .class .intro 选择 class=”intro” 的所有元素。 1 #id #firstname 选择 id=”firstname” 的所有元素。 1 * * 选择所有元素。 2 element p 选择所有 元素。 1 element,element div,p 选择所有 元素和所有 元素。 1 element element div p 选择 元素内部的所有 元素。 1 element&gt;element div&gt;p 选择父元素为 元素的所有 元素。 2 element+element div+p 选择紧接在 元素之后的所有 元素。 2 [attribute] [target] 选择带有 target 属性所有元素。 2 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素。 2 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 2 [attribute|=value] [lang|=en] 选择 lang 属性值以 “en” 开头的所有元素。 2 :link a:link 选择所有未被访问的链接。 1 :visited a:visited 选择所有已被访问的链接。 1 :active a:active 选择活动链接。 1 :hover a:hover 选择鼠标指针位于其上的链接。 1 :focus input:focus 选择获得焦点的 input 元素。 2 :first-letter p:first-letter 选择每个 元素的首字母。 1 :first-line p:first-line 选择每个 元素的首行。 1 :first-child p:first-child 选择属于父元素的第一个子元素的每个 元素。 2 :before p:before 在每个 元素的内容之前插入内容。 2 :after p:after 在每个 元素的内容之后插入内容。 2 :lang(language) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 元素。 2 element1~element2 p~ul 选择前面有 元素的每个 元素。 3 [attribute^=value] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 元素。 3 [attribute$=value] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 元素。 3 [attribute*=value] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 元素。 3 :first-of-type p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 3 :last-of-type p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 3 :only-of-type p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 3 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 元素。 3 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 3 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 3 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 元素的每个 元素。 3 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 3 :last-child p:last-child 选择属于其父元素最后一个子元素每个 元素。 3 :root :root 选择文档的根元素。 3 :empty p:empty 选择没有子元素的每个 元素（包括文本节点）。 3 :target #news:target 选择当前活动的 #news 元素。 3 :enabled input:enabled 选择每个启用的 元素。 3 :disabled input:disabled 选择每个禁用的 元素 3 :checked input:checked 选择每个被选中的 元素。 3 :not(selector) :not(p) 选择非 元素的每个元素。 3 ::selection ::selection 选择被用户选取的元素部分 4. 正则表达式解析：re.compile 函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： 1re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为 . 并且包括换行符在内的任意字符（**.** 不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和 # 后面的注释修饰符： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 re.match函数：re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法： 1re.match(pattern, string, flags&#x3D;0) re.search方法：re.search 扫描整个字符串并返回第一个成功的匹配。 函数语法： 1re.search(pattern, string, flags&#x3D;0) re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 检索和替换：Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。 语法： 1re.sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 findall：在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次 findall 匹配所有。 语法格式为： 1findall(string[, pos[, endpos]]) 参数： string : 待匹配的字符串。 pos : 可选参数，指定字符串的起始位置，默认为 0。 endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。 re.finditer：和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 1re.finditer(pattern, string, flags&#x3D;0) re.split：split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： 1re.split(pattern, string[, maxsplit&#x3D;0, flags&#x3D;0]) 参数： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。 re.MatchObjectgroup() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 匹配成功re.match方法返回一个匹配的对象，否则返回None。 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。不输入num返回所有匹配字符组成的字符串 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号 groupdict() 返回所有命名分组的字典 正则表达式模式模式字符串使用特殊的语法来表示一个正则表达式： 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。 多数字母和数字前加一个反斜杠时会拥有不同的含义。 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。 反斜杠本身需要使用反斜杠转义。 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 ‘\\t’)匹配相应的特殊字符。 下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。 re{ n,} 匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 对正则表达式分组并记住匹配的文本 （?P） 对分组进行命名并开始该分组的匹配 （?P=name） 匹配与命名为name的分组匹配的相同的内容 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。表示开启这种特殊匹配 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。当re表达式在后面字符串存在时才从该处开始匹配 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。(?&lt;=+86)表示字符串前面包含+86才开始去匹配,(?&lt;!+86)表示前面没有+86才开始匹配 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 JavaScript逆向Ajax入口的寻找有两种Ajax的逆向寻求入口的方式： 全局搜索标志字符串 设置Ajax断点全局搜索标志字符串一些关键字符串通常可以用作寻找JavaScript混淆入口的依据，我们可以利用全局搜索的方式来找寻，通过关键字的搜寻到的结果取找寻是否满足入口条件，一般通过Ajax请求的请求参数里面去找关键字符，通过大体的观察参数重要性和参数的复杂度确定关键参数，然后进行全局多的搜索。往往这种加密混淆的入口都在js文件中。 XHR断点有时候在js文件中，关键参数也是经过加密混淆或者特殊的编码处理之类的，这时候第一种方法就容易不奏效。XHR断点可以解决这种状况。 XHR断点就是在进行XHR请求的时候进入断点调试模式，JavaScript就会在发起Ajax请求的时候停住，然后就可以利用调用栈的逻辑一步一步的去找寻入口。 设置断点的方式：在source的debugger处找到XHR/fetch Breakpoint，点击+添加匹配的url内容。由于Ajax的接口形式是api/movie/?limit=0之类的，所以选取一段填入即可。 断点添加完毕之后刷新页面进入调试模式，然后查看需要找寻的特殊参数在何处。在Call Stack处记录了JavaScript方法的逐层调用的过程，可以在这个过程去找寻想要找寻的特殊参数，逐步查找最后也可以找到参数的构造位置。 XHR断点查找方法还是很好用的，通过对你想要判断的url的部分网址添加进断点，等运行到该处会停下，然后可在call stack处查看具体的运行过程，在这其中去找寻你需要找寻的特殊参数或者网站密码的加密逻辑。 hook关键函数进行入口的找寻 加密逻辑的找寻在上一步的入口找寻找到特定参数的构造逻辑之后可以在js中去打断点看看生成逻辑和方法，之前打的XHR断点取消掉，因为只有一个断点。 打完新断点之后就可以查看其中可能的相关的变量的情况，通过查看变量的具体信息可以找到具体的位置和基本参数情况之类的。也可通过debugger里面的watch添加你想要看的变量名字也可以出现具体的参数情况和位置等信息。 通过里面的一些详细信息可以找到具体的构造逻辑，然后利用JavaScript的知识结合找出最终的构造逻辑。找出最终的构造逻辑之后就可以开始语言的爬取实现。 python语言的逻辑重现并爬取利用之前找出来的逻辑利用python语言重现，然后获取到最后的目标信息，然后利用最终获取的目标信息取爬取想要的内容。 B站的密码加密逻辑首先访问https://passport.bilibili.com/login?act=getkey&amp;r=Math.random()获取public_key和hash值，然后JSEncrypt设置获取的public_key，再用获取到的hash值与密码进行拼接并进行JSEncrypt加密处理。最后再访问https://passport.bilibili.com/web/login/v2。表单传入需传入的参数访问即可。 12345678data = &#123;&#x27;captchaType&#x27;: 6,&#x27;username&#x27;: 用户名,&#x27;password&#x27;: 加密之后的密码,&#x27;keep&#x27;: true,&#x27;key&#x27;: this.key,# 可不用的参数&#x27;goUrl&#x27;: &#x27;https://www.bilibili.com&#x27;&#125;","tags":[{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/tags/python-notebook/"}],"categories":[{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/categories/python-notebook/"}]},{"title":"plaxis指导手册笔记","date":"2020-11-13T02:31:19.935Z","path":"wiki/2021-03-03-plaxis指导手册笔记/","text":"plaxis案例笔记1.砂土上圆形地基的沉降1.1案例目的 轴对称模型的模拟可以只模拟一半 钻孔工具创建土层 分配特定的土体模型和材料数据集 土层水平可以使用K0过程生成初始应力 计算阶段塑性计算类型可以满足大多数的阶段和条件 特定的阶段激活需要的结构和土层 查看计算结果 利用曲线管理器（需要提前选好需要绘制曲线的点）生成需要的曲线 1.2步骤1.2.1前处理土层界面钻孔工具生成需要的土层模样并分配好材料数据集和土体模型。 结构界面选择指定位移来模拟刚性地基的沉降。选择板和线荷载来模拟柔性地基的沉降的产生。前者设置指定位移的位移大小和方向即可，后者需要设置板的材料属性并设荷载的大小和方向。 网格界面按正常的默认设置生成网格即可。 渗流界面该案例不需要设置水流条件，利用钻孔工具生成的潜水位即可。 阶段施工界面分成两个阶段。 初始应力阶段初始应力阶段都选择K0过程来生成即可。 对于变形问题存在两种边界条件：指定位移和指定应力。一般来说，所有的边界条件必须在每一个方向有一个边界条件，也就是说，没有指定的边界条件时，选用天然条件，指定应力为零，自由位移。 为了避免几何体的位移被undetermined，有些点必须有指定位移，最简单的指定位移形式是fixity，当然非零位移也需要应用。 第二阶段刚性地基的第二阶段选择指定位移并激活即可（需要设置变形的边界条件）。柔性地基需要激活板和线荷载并设置线荷载的大小（计算的达到指定位移需要的力） 2.水下基坑的开挖模拟2.1案例目的 使用界面结构单元模拟土体和结构体之间的相互作用。 使用高级土体模型：软土模型（soft soil model）和硬化土体模型（hardening soil model） 在土体模型参数设置时选取不排水的排水量类型 使用锚定杆模拟板间支撑 创建锚杆需设置材料属性 模拟开挖过程（冻结土体即可模拟开挖） 2.2步骤2.2.1前处理土层界面根据实际情况创建土层，并可以适当的将模型简化，轴对称的图形可以只分析一半，此时的边界条件需按照实际情况选择合适的边界条件和水力边界条件。 需要绘制的是软土粘土（上），和刚度较大的砂土（下）。设定土体材料数据集，选定合适的模型和合适的参数。 结构界面首先根据实际情况来将其中特殊单元简化为软件的结构单元，然后将这些结构绘制到模型中，根据实际，设定需要的材料属性和材料类型。 在该案例中，利用板来模拟支撑墙，利用锚定杆来模拟墙之间的支撑。并根据实际设定材料属性和类型。 网格界面设定好土层条件和结构之后，进行网格划分。默认精度即可。 渗流条件界面该案例中就按钻孔工具中设置的潜水位即可，不需要在渗流界面设置水力条件和水位。 阶段施工界面在该界面分三个开挖阶段，第一步开挖之后需要激活锚定杆。 初始阶段选择K0过程生成初始应力即可。 第二个阶段激活荷载和板来模拟墙的修建和荷载的产生。 第三个阶段选择某一个阶段后点击添加阶段，自动就以点击的阶段为parent阶段，这样才可以自动的复制parent阶段的设置。 ==提示==：如果是在阶段设置的下拉框选择parent阶段，并不会复制选择的parent阶段的设置。 第一步开挖阶段，将最上面一部分土体冻结即可 第四个阶段锚定杆的激活 第五个阶段第二步开挖。这个阶段开挖后将处于水下。==提示==：plaxis中冻结土体并不会自动将土体中的水冻结，因此，开挖后如果不设置该部分土体的水条件（选择浏览器可以设置），水位仍然保持在该部分土体内。 第六个阶段第三步开挖，冻结第三部分土体即可 2.2.2后处理在阶段定义完成后，就可以选择自己需要绘制曲线的节点，选择完毕后更新即可回到输入程序。开始计算。结算完毕后查看结果。 ==提示==：输出程序中，loads、fixities和prescribed displacement可以在集合菜单中点击相应的按钮来显示或者隐藏。 菜单栏的不同菜单项选择会出现不同的结果。 查看结构处的建立和弯矩这类内力可以双击结构显示的窗口去选择就可显示或者菜单栏的force栏选择需要查看的内力即可。 选择工具的曲线管理器绘制自己需要的曲线。 3. 点对点锚杆和嵌固端支撑的降水开挖3.1案例目的3.2步骤3.2.1前处理3.2.2后处理4. 极限承载条件下的降水开挖4.1案例目的4.2步骤4.2.1前处理4.2.2后处理5. 路基建造模拟5.1案例目的5.2步骤5.2.1前处理5.2.2后处理6. 由于隧洞建造长生的沉降6.1案例目的6.2步骤6.2.1前处理6.2.2后处理7. NATM隧洞开挖7.1案例目的 使用Deconfinement method模拟NATM隧洞的开挖建造 含有非水平地层选择重力加载来生成初始应力 了解特殊形状的隧洞截面的生成 7.2步骤7.2.1前处理土层生成特殊形状的土层也可使用钻孔工具来生成，选取特定的几个位置生成钻孔，然后就可根据实际土层情况去设置不同土层的层厚。最左面和最右面的钻孔会自动生成，因此不需要创建钻孔。 土层生成完毕后就可以定义土层材料属性并附到特定的土层上。 结构生成进入到结构截面，创建隧洞点击需要创建隧洞的位置，进入到隧洞设计器界面。 有截面和属性两个界面，前者设置隧洞截面的形状和大小，后者设置衬里和其他的一些隧洞需要的结构和reinforcement。 隧洞设计器/截面设计界面可以选择自由截面和圆形截面。自由截面设计可以选择线段和弧来绘制需要的截面形状。在子阶段界面里面可以自定义需要的子阶段。 该案例设置为两个阶段开挖。截面绘制完毕后进入属性设计linning和负向界面，创建好之后并为需要设置属性的结构附材料属性。设计完毕后生成即可在绘图区看到生成的隧洞（生成后关闭隧洞生成器就不可修改）。 网格生成结构和土层绘制完毕并附上材料属性就可以生成网格了，该实例并没有局部细化和糙化需求，选择默认网格生成选项即可 渗流条件因为在钻孔工具里面设置了潜水位，因此不需要在这个界面生成水利条件 阶段施工初始应力阶段由于土层存在非水平土层界面，因此不能使用K0过程生成初始应力，需要选择重力加载来生成，保证隧洞是冻结的 第一步开挖阶段选取上半部分的隧洞，冻结，并且在选择对象浏览器的deconfinement设置为60%，模拟上半部分的隧洞开挖并且使用60%的解除限制模拟NATM隧洞开挖建造。 第一步支护阶段选取上半部分的板和子阶段处的板（模拟开挖后的linning），激活，并将deconfinement设置为100%，模拟完全解除限制 第二部开挖阶段选取下半部分的土层并冻结，然后将子阶段的板冻结，模拟下半部分隧洞的开挖，还需设置下半部分的deconfinement为60%，模拟该部分土体的部分解除限制。 第二步支护阶段选择下半部分的板结构并激活，然后将d econfinement设置为100%完全解除限制。 计算阶段和曲线点选择阶段在各个阶段定义完毕后，就可以选取曲线点，然后开始计算了，计算需要花费一小会。计算完毕之后就可以进入到后处理阶段了 7.2.2后处理点击查看计算结果即可进入到输出程序查看具体的结果。主要查看变形情况和隧洞周围的应力情况，可以通过选择结构选择lining查看lining的内力情况。后处理可以查看的内容有许多，根据自己的实际需要选择查看的内容：曲线管理器可以选择生成不同横纵坐标内容的曲线，具体选择按需选取。变形内力、水压、最大主应力、位移增量等都可在输出程序进行查看 8. 圆形水下地基的循环竖向承载力和刚度8.1案例目的 利用plaxis计算圆形水下地基的循环竖向承载力和刚度。 进行cyclic accumulation procedure获取UDCAM-S模型的输入参数 计算全部的cyclic vertical bearing capacity 计算循环荷载作用下的竖向刚度calculate the stiffness of accounting for cyclic loading for both the total and the cyclic component","tags":[{"name":"md_photos","slug":"md-photos","permalink":"http://example.com/tags/md-photos/"}],"categories":[{"name":"md_photos","slug":"md-photos","permalink":"http://example.com/categories/md-photos/"}]},{"title":"javascript_grammar","date":"2020-11-13T02:30:13.878Z","path":"wiki/2021-03-03-javascript_grammar/","text":"javascript语法 1. 常用数据类型字面量是常量，有数字(int，float，科学计数)，有字符串，表达式(用于计算)，数组(python列表)，对象(python字典)，函数 字符串： 拼接有加号和模板字符串，‘mynameis${name}’类似的，模板字符串用的中文字符的符号，字符串的属性length获得长度，属性没有括号，方法才有toUpperCase()变成大写，toLowerCase()小写，substring(start，endindex)截取片段，split()分割字符串成为数组，参数为分割字符，字符和数字相加，数字会被转为字符，运算都是先后顺序 数组： 创建，结构体：const arrayname = new Arrays(1， 2， 3)或者用[]即可数组，const定义的数组也可改变，push()想尾部添加元素，unshift()像头部添加元素，pop()去掉最后一项，判断变量是否为数组，Array.isArray(variables)，获取索引，indexOf()方法 对象： object访问值object.key，添加键值对object.key = values，新特性对象可以解构赋值，JSON.stringify()转为json字符串，对象的共享方法:valueOf()和toString()(转换为字符串类型)空值null是对象，undefined就是undefined，不是一个东西，值相等，类型不同，可以通过设置值为null或者undefined清空对象.typeof返回值string，number，boolean，undefined，object，function.这么几种。对象有属性和方法，属性是由键值对组成，方法则是由函数名和函数组成.访问对象属性:object.propertyname或者object[‘propertyname’]，访问对象方法:object.funcname()，不带括号返回函数定义 如果通过关键字new来声明变量，该变量会被创建为对象，需要避免字符串数值或者逻辑对象，会增加代码复杂性并降低运行速度 this关键字：在JavaScript中指的是它所属的对象 this总是指向调用该函数的对象，在全局函数中this指向window对象 方法中：this指的是所有者对象 单独情况：this指的是全局对象 [object Window] 函数中：this指的是全局对象，严格模式下，指的是undefined，//“use strict”值使用严格模式 事件中：this指的是接受事件的元素，HTML中指接受事件的html元素call()和apply()这样的方法可将this引用到任何对象123456789101112var person1 = &#123; firstName: &quot;BILL&quot;; lastName: &quot;GATE&quot;; function_1: function &#123; return this.firseName + this.lastName &#125;&#125;var person2 = &#123; firstName: &quot;Li&quot;; lastName: &quot;jiabao&quot;&#125;person1.fullname.call(person2); // 返回值是Lijiabao 12345678var person = &#123; firstName: &quot;Li&quot;; lastName: &quot;jiabao&quot;; age: 22; fullName: function() &#123; this.firstName + this.lastName &#125;// 函数定义中：this 是引用该函数的拥有者，而上述的代码示例中this指代该对象。&#125; 2. 变量使用关键字var定义变量，用等号为变量赋值，还有let和const，，在脚本的开头声明所有变量是个好习惯！ 声明变量可跨多行， 1234567891011121314151617var person = &quot;Bill Gate&quot;， age=18;//一行声明// 也可多行声明var person = &quot;Bill Gate&quot;;age = 18;var age; // 声明后不赋值则为undefined// 重复声明变量仍会保持原有变量值var name = &quot;Gate&quot;;var name;var a = &quot;8&quot; + 3 + 5; //result: 835: stringvar a = 3 + 5 + &quot;8&quot;: // result: 88: string// 有条件的进行变量声明const timezone = user.preferred_timezone || &quot;China/Beijing&quot;// 比下面的方式更简洁干净let timezone = &quot;China/Beijing&quot;;if (user.preferred_timezone) &#123; timezone = user.preferred_timezone;&#125; 3. 操作符与赋值运算符与python基本一致，文本字符串中使用\\对代码进行换行。换行最好在运算符或者逗号之后，长度80以内 4. 运算符: 算数运算符 ++低价–递减运算 字符串可用+和+=运算符来进行字符串级联 比较运算符 == 等于 === 等值等型 != 不相等， !== 不等值或不等型 ? 三元运算符 逻辑运算符 &amp;&amp; 逻辑与 || 逻辑或 ! 逻辑非 类型运算符 typeof() 返回变量的类型 isinstanceof() 返回bool，判断是否是对象的实例 位运算符 &amp; 与 | 或 ~ 非 ^ 异或 值 运算符 优先级 20 () 表达式分组 19 .and[] 成员 19 () 函数调用 19 new 创建 17 ++and– 后缀递增递减 16 ** ++and–** 前缀递增递减 16 ! 逻辑否 16 typeof 类型判读 15 ** ** ** 幂运算 14 ** * / % ** 乘除模数除法 13 + - 加减 12 &lt;&lt;，， 左位移右位移，右无符号 11 &lt;，，&lt;=，=，in，instanceof 比较运算符，对象中属性，对象实例 10 ** ==，===，!=，!==** 相等判断 9 &amp; 按位与 3 ** =，+=，-=** 赋值运算符 2 yield 暂停函数 1 ， 逗号 5. 语句用分号隔开，分号在每条可执行语句的末尾添加，另一用处是一行编写多条语句，，分号结束语句时可选的，可以不写 6. 变量声明JavaScript通常以关键词开头，var关键词告诉浏览器创建一个新的变量 7. 标识符保留下来为自己所用，有关键字，数字不允许在开头出现，标识符必须以字母下划线或美元符开始 break：跳出循环，continue：跳出循环的一次迭代，try…catch：try语句出错时执行，do…while，switch：用于基于不同的条件执行不同的动作。throw：抛出生成错误。function：定义一个函数，var声明变量，debugger停至执行并调用调试函数 8. 注释//双斜杠后的内容会被浏览器忽略，/*开始*/结尾的可以进行多行注释 9. 函数函数基本内容函数最好看作是对象，有属性和方法语句写在函数中，函数可以重复引用，引用一个函数等于调用函数JavaScript忽略空格，因此可以增加空格提高代码可读性function的属性length可以返回函数定义参数个数函数的toString()方法返回函数的定义argument对象可以用来检测参数或者查看参数个数在函数内部使用，argument[0]返回第一个参数，argument.length返回参数的个数函数申明结尾一般不需要分号，因为不是可执行语句parameter是函数定义的参数名，argument是函数接受的实际数值函数可被用在赋值和表达式中定义为对象属性的函数，被称为对象的方法为创建新对象设计的函数，被称为对象构造器函数（对象构造器） 函数语法123456789101112131415// 常规定义function function_name(para1， para2， ..) &#123; 执行的代码块&#125;// 表达式定义var x = function (*parameters) &#123;代码块&#125;;// 构造函数定义var function_name = new Function(&#x27;para&#x27;， &#x27;para2&#x27;， &#x27;console.log(para1 + param2)&#x27;);// 自调用函数：执行到这直接运行函数(function () &#123; 代码块&#125;)() // 这是一个匿名自调用函数// 箭头函数var x = function(x,y) &#123;return x*y;&#125;; // ES5用法const x = (x,y) =&gt; x * y; // ES6用法 函数参数parameter是函数定义的名称argument是函数运行时传递或者接受的真实值 参数规则：不为参数规定数据类型不对传递参数进行类型检查不会检查接受参数的数量 参数默认：如果省略了声明参数，则丢失值被设置为undefined，有时最好为参数设置默认参数12345function myFunction(x, y) &#123; if(y == undefined) &#123; y =0; &#125;&#125; // 这种方法为函数定义默认参数值 arguments对象：函数具有一个arguments的内置对象arguments包含函数调用时使用的参数数组 argiments.length返回参数个数 类似数组访问方法arguments[num]可获取参数 参数通过值传递： 函数通过值传递，只知道值不知道参数的位置如果函数改变了参数的值，不会改变函数参数的原始值==参数的改变在函数之外是不可见的== 对象时引用传递，对象引用是值如果函数改变了对象属性，也就改变了原始值==对象的属性改变在外部时可见的== 箭头函数1const x = (x,y) =&gt; x * y; 箭头函数没有自己的this。不适合定义对象方法箭头函数未被提升，必须在使用前进行定义使用const比使用var安全，函数表达式始终是常量函数是单个语句，只能省略return和大括号，最好保留他们IE11 或更早的版本不支持箭头函数。箭头函数的this指向外层函数作用域中的this箭头函数的this时定义函数是所在的上下文中的this箭头函数的this就是定义是所在的对象而不是调用时的对象 函数调用与返回在JavaScript中，始终存在一种默认的全局对象HTML中。默认全局对象时HTML页面本身，所有上面的函数属于HTML页面浏览器中，这个也买你对象就是浏览器创建，上面的函数字符自动成为一个窗口函数myFunction()和window.myFunction()是同一个函数 ==全局变量、方法或函数很容易在全局对象中产生命名冲突和漏洞== this关键字：拥有当前代码的对象，在函数中指拥有该函数的对象 函数调用:调用函数名而不加()会返回函数定义 事件发生时，如用户点击 JavaScript代码调用时 自调用 作为方法调用1234var person = &#123; name:&quot;lijiabao&quot;, fullName:function&#123;return this.name;&#125;&#125;;person.fullName() // 方法调用 函数构造器调用函数构造器调用会创建新对象。新对象会从其构造器继承属性和方法。构造器内的 this 关键词没有值。==this 的值会成为调用函数时创建的新对象==12345function myFunction(arg1)&#123; this.firstName = arg1;&#125;var x = myFunction();x.firstName; // 函数构造器调用 函数返回: 函数执行到return即结束函数并返回结果，定义函数之后可以复用 函数中声明的变量是局部变量，可在不同函数中定义相同变量名 开始创建结束删除局部变量 函数的call与applycall使用call()方法，可以编写能够在不同对象使用的方法JavaScript中函数是对象的方法，如果怒视对象方法，那就是全局对象的函数call()是预定义的方法，用来调用所有者对象作为参数的方法通过call()可以使用属于另外对象的方法 12345678910var person = &#123;firstName: &quot;john&quot;,;astName: &quot;jjj&quot;,fullName: function()&#123;return this.fistName + this.lastName;&#125;&#125;var person1 = &#123;firstName: &quot;li&quot;,lastName: &quot;jiabao&quot;&#125;person.fullName.call(person1);// 调用person的fullName方法// 带参数的call()var persons =&#123;fullName: function(city)&#123;return this.firstName + this.lastName + city;&#125;&#125;;persons.fuuName.call(person1, &quot;hunan&quot;); apply通过apply()可以编写用于不同对象的方法与call()非常类似基本用法一致，只是传参不一样，apply以数组传参数二者区别： call()分别接受参数 apply()接受数组形式参数，使用数组，apply非常方便1234567// 数组中模拟max方法Math.max.apply(null, [1,2,3]);Math.max.apply(&quot;&quot;, [1,2,3]);Math.max.apply(0, [1,2,3]);Math.max.apply(Math, [1,2,3]);// 都会返回3// 严格模式下，如果apply的第一个参数不是对象，则他将成为该调用函数的所有者// 非严格模式下，他将成为全局对象 函数闭包JavaScript变量属于本地或全局作用域全局变量可以通过闭包实现局部私有函数可以访问函数内部定义变量，也能访问全局变量网页全局变量属于window对象，全局变量能够被页面中的所有脚本使用和修改JavaScript中，所有函数都有权访问他们上面的作用域==不通过var创建的变量总是全局的，即使在函数中创建==变量的声生命周期：全局变量和应用程序（窗口和网页）活得一样久局部变量活得不长，函数调用创建，结束删除 定义：函数中定义另一个函数闭包是有权访问父作用域的函数，即使在父函数关闭后JavaScript 支持嵌套函数。嵌套函数可以访问其上的作用域。 123456789101112131415161718192021function addNum(num1， num2) &#123; function doAdd() &#123; return num1 + num2; &#125; return doAdd()&#125;// 计数器实例——闭包function counterNum() &#123; var counter = 0; function plus() &#123;counter +=1;&#125; return plus;&#125;const counter = counterNum();counter();// 自调用也可类似闭包var add = (function () &#123; var counter = 0; return function () &#123; return counter +=1; &#125;&#125;)(); 10. HTML事件：发生在HTML元素上的事 常见的HTML事件 事件 描述 onchange html元素已被改变 onclick html元素被点击 onmouseover 鼠标移动到元素上 onmouseout 鼠标移开元素位置 onkeydown 用户按下键盘按键 onload 浏览器完成页面的加载 JavaScript能够做什么？事件处理程序可用于处理、验证用户输入、用户动作和浏览器动作： 每当页面加载时应该做的事情 当页面被关闭时应该做的事情 当用户点击按钮时应该被执行的动作 当用户输入数据时应该被验证的内容等等 让 JavaScript 处理事件的不同方法有很多： HTML 事件属性可执行 JavaScript 代码 HTML 事件属性能够调用 JavaScript 函数 您能够向 HTML 元素分配自己的事件处理函数 您能够阻止事件被发送或被处理等等 11. 条件语句： if…else语句123456if (condition1) &#123; condition is true ,execute this;&#125;else if (contion2) &#123; condition2 is true，execute this;&#125;else &#123;false ,execute this;&#125; switch语句Switching 的细节如果多种 case 匹配一个 case 值，则选择第一个 case。如果未找到匹配的 case，程序将继续使用默认 label。如果未找到默认 label，程序将继续 switch 后的语句。1234567891011switch (表达式) &#123; case n: 代码块 break; case n: case n: // 共享相同代码块可这样写 代码块 break; default: 默认代码块 // 不存在case匹配运行的代码不是最后位置需用break&#125;// switch 使用严格比较 === for 循环123for (语句1; 语句2; 语句3) &#123; 执行代码块 // 1循环开始前执行，2定义循环条件，3循环每次执行后执行&#125; 语句1： 通常，您会使用语句 1 来初始化循环中所使用的的变量（i = 0）但情况并不总是这样，JavaScript 不会在意。语句 1 是可选的。您可以在语句 1 中初始化多个值（由逗号分隔）： 语句2： 通常语句 2 用于计算初始变量的条件。但情况并不总是这样，JavaScript 不会在意。语句 2 也是可选的。如果语句 2 返回 true，那么循环会重新开始，如果返回 false，则循环将结束。如果省略语句 2，那么必须在循环中提供一个 break。否则循环永远不会结束。 语句3： 通常语句 3 会递增初始变量的值。但情况并不总是这样，JavaScript 不会在意。语句 3 也是可选的。语句 3 可做任何事情，比如负递增（i–），正递增（i = i + 15），或者任何其他事情。语句 3 也可被省略（比如当您在循环内递增值时 for/in循环for (x in arr或者obj) &#123;代码块;&#125; while循环：条件为真一致执行代码while (condition) &#123;代码块;&#125; do/while循环：检查条件之前执行一次，为真继续执行do &#123;代码块;&#125; while (condition);记得递增变量，不然循环没法结束 循环中的break和continue语句 JavaScript标签：标记JavaScript语句，用标签名和冒号置于语句前Label:statements,,,代码块是指{}包裹的语句break用于跳出循环或者switch，有标签引用用于跳出任意代码块break labelnamecontinue只用于跳出循环的一次迭代 12. 基本语法JavaScript对大小写敏感JavaScript使用Unicode字符集JavaScript命名规则为驼峰命名法，倾向于小写字母开头的驼峰命名法JavaScript是在读取代码时，逐行的执行脚本代码，而传统编程语言先编译再执行JavaScripJavaScript逐行运行，按语句编写先后执行，代码块用{}包裹，代码块为一同执行的语句不能使用连字符，是为减法预留的 13.异常及处理try语句能够测试代码块中的错误catch语句用来处理错误throw语句用来自定义抛出错误finally语句用来执行代码在try和catch后，无论如何都执行 14. 技巧 every和some的妙用：array.every(functionName)数组里面元素的函数返回值全为true返回truearray.some(functionName)只要有一个为true就返回true 有条件的设置变量：const timezone = user.preferred_timezone || &quot;China/Beijing&quot; 数组利用map进行转换：array.map(Number);array.map(functionName) 对象解构：123456var person = &#123;firstNmae: &quot;Li&quot;,lastName: &quot;jiabao&quot;&#125;;const firstName = person.firstName// 利用对象解构const &#123; firstName, lastName&#125; = person;// 直接访问变量名就好console.log(firstName); console控制台函数有许多好用的调试功能：1234// console的time可以查看代码运行时间，time和timeEnd函数参数提供相同字符串即可console.time(&#x27;loop&#x27;)for (i=0; i&lt;10; i++) &#123;dosome;&#125;console.timeEnd(&#x27;loop&#x27;) 过滤出唯一值（ES6）：利用set集合123const array = [1,1,3,3,2,1,4,5];const soloArray = [...new Set(array)];console.log(soloArray); 与或运算：123456789101112131415// 三元运算符编写简单条件语句的快速方法x &gt; 10 ? &quot;above 10&quot; : &quot;below 10&quot;;x &gt; 10 ? (x &gt; 20 ? &quot;above 20&quot; : &quot;between 10 &amp; 20&quot;) : &quot;below 10&quot;;// 当三元运算符比较复杂时，可以用&amp;&amp; 和 ||运算符// &amp;&amp; return value when condition false, or, return last valueler one = 1, two = 2, three = 3;console.log(one &amp;&amp; two &amp;&amp; three); // return 3// || return value when condition true, or, return last valueconsole.log(one || two || three); // return 1// || can use to get variable&#x27;s length,when don&#x27;t kown typeconsole.log((variableName || []).length);console.log(this.state.data || &quot;not have this property&quot;);// new property ,optional chaining appended ? operator// ? first judge front value,null or undefined,end call return null or undefinedthis.state.date?.();this.state?.data; 转换为布尔值、字符串和数字：12345678// convert to booleanconst isTrue = !0, isFalse = !1, alsoFalse = !!0;// convert to stringlet strconvert = 1 + &quot;&quot;;// convert to numberlet numconvert = +&quot;15&quot;,num1 = +true;// if +operator don&#x27;t work ,and you want int number,use ~~operatorlet numconvert = ~~&quot;15&quot;; **幂运算符,ES7出现的，之前只有2的幂运算有简写，2 &lt;&lt;(n-1) ==2**n,Math.pow()是常规的幂运算使用方法 快速浮点数转整数，利用位或运算符，如果数字为整数，向下取整，为负，向下取整，实际就是将小数位舍去，还可用~~来取得相同的效果。123456console.log(23.9 | 0); // 23console.log(-23.9 | 0); // -23console.log(~~23.9,~~-23.9); //23 -23// delete last numberconsole.log(Number(&quot;1553&quot;.substring(0,&quot;1553&quot;.length-1)));console.log(1553/10 | 0, 1553/100 | 0, 1553//1000 | 0); 类中的自动绑定：在ES6使用箭头表示法，通过这样的操作隐含绑定，为类构造函数保存几行代码，告别重复的表达式this.myMethod = this.myMethod.bind(this)12345678910111213141516171819import React, &#123; Component &#125; from React;export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125;myMethod = () =&gt; &#123; // this method is bound implicitly!&#125;render() &#123;return ( &lt;&gt; &lt;div&gt; &#123;this.myMethod()&#125; &lt;/div&gt; &lt;/&gt; )&#125;&#125;; 数组截断：没有python[0:3]类似操作，只能切片函数或者改变length属性123456const array = [1,4,55,6,5,4,7,8,9];array.length = 4; // result is [1,4,55,6]// slice()array = array.slice(0,4); // velocity/tempo/rate is faster// array&#x27;s last numberarray = array.slice(-1);array = array.slice(-2); 格式化JSON：console.log(JSON.stringify(&#123;1:2,3:4&#125;, null, &quot;\\t&quot;))JSON.stringify() is use for standardize json or object type","tags":[{"name":"JavascriptNotebook","slug":"JavascriptNotebook","permalink":"http://example.com/tags/JavascriptNotebook/"}],"categories":[{"name":"JavascriptNotebook","slug":"JavascriptNotebook","permalink":"http://example.com/categories/JavascriptNotebook/"}]},{"title":"data_anlyze","date":"2020-11-12T16:57:50.025Z","path":"wiki/2021-03-03-data_anlyze/","text":"数据清洗的步骤 读取数据：pd.read_****() 数据预览：data.info(),data.describe() 检查null值：data1 = data.copy(),data1.isnull().sum() 补全空值：123data1[&#x27;age&#x27;].fillna(data1[&#x27;age&#x27;].median(), inplace=True)data1[&#x27;ddd&#x27;].fillna(data1[&#x27;ddd&#x27;].mode()[0], inplace=True)data1.isnull().sum() 去掉一些无用的数据列，增加一些必须的数据列12345del_columns = [&#x27;hhh&#x27;, &#x27;ddd&#x27;]data1.drop(del_column, axis=1, inplace=True) # 删除列data1[&#x27;新增的&#x27;] = data1[&#x27;age&#x27;] + data1[&#x27;sss&#x27;] + 1 # 增加列data1[&#x27;新增的分箱的列&#x27;] = pd.qcut(data1[&#x27;sss&#x27;], 4) # 分箱data1[&#x27;agecut&#x27;] = pd.cut(data1[&#x27;age&#x27;].astype(int), 6) # 分箱 sklearn的labelencode编码处理让算法模型可以认出，并用get_dummies()将长dataframe变为宽dataframe 最后再检查一下清洗完的数据","tags":[{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/tags/python-notebook/"}],"categories":[{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/categories/python-notebook/"}]},{"title":"common_encrypt_algorithms_python","date":"2020-11-12T16:57:47.387Z","path":"wiki/2021-03-03-common_encrypt_algorithms_python/","text":"MD5加密 全称：MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。md5加密算法是不可逆的，所以解密一般都是通过暴力穷举方法，通过网站的接口实现解密。 Python代码： 1234import hashlibm = hashlib.md5()m.update(str.encode(&quot;utf8&quot;))print(m.hexdigest()) SHA1加密 全称：安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA），SHA1比MD5的安全性更强。对于长度小于2^ 64位的消息，SHA1会产生一个160位的消息摘要。 Python代码： 123456import hashlibsha1 = hashlib.sha1()data = &#x27;2333333&#x27;sha1.update(data.encode(&#x27;utf-8&#x27;))sha1_data = sha1.hexdigest()print(sha1_data) HMAC加密 全称：散列消息鉴别码（Hash Message Authentication Code）， HMAC加密算法是一种安全的基于加密hash函数和共享密钥的消息认证协议。实现原理是用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即 MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。 Python代码： 123456import hmacimport hashlib# 第一个参数是密钥key，第二个参数是待加密的字符串，第三个参数是hash函数mac = hmac.new(&#x27;key&#x27;,&#x27;hello&#x27;,hashlib.md5)mac.digest() # 字符串的ascii格式mac.hexdigest() # 加密后字符串的十六进制格式 DES加密 全称：数据加密标准（Data Encryption Standard），属于对称加密算法。DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8 位都用作奇偶校验），密钥可以是任意的56位的数，而且可以任意时候改变。 Python代码： 1234567891011121314151617181920import binasciifrom pyDes import des, CBC, PAD_PKCS5# 需要安装 pip install pyDesdef des_encrypt(secret_key, s): iv = secret_key k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5) en = k.encrypt(s, padmode=PAD_PKCS5) return binascii.b2a_hex(en)def des_decrypt(secret_key, s): iv = secret_key k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5) de = k.decrypt(binascii.a2b_hex(s), padmode=PAD_PKCS5) return desecret_str = des_encrypt(&#x27;12345678&#x27;, &#x27;I love YOU~&#x27;)print(secret_str)clear_str = des_decrypt(&#x27;12345678&#x27;, secret_str)print(clear_str) AES加密 全称：高级加密标准（英语：Advanced Encryption Standard），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。 Python代码： 1234567891011121314151617181920212223import base64from Crypto.Cipher import AES&#x27;&#x27;&#x27;AES对称加密算法&#x27;&#x27;&#x27;# 需要补位，str不是16的倍数那就补足为16的倍数def add_to_16(value): while len(value) % 16 != 0: value += &#x27;\\0&#x27; return str.encode(value) # 返回bytes# 加密方法def encrypt(key, text): aes = AES.new(add_to_16(key), AES.MODE_ECB) # 初始化加密器 encrypt_aes = aes.encrypt(add_to_16(text)) # 先进行aes加密 encrypted_text = str(base64.encodebytes(encrypt_aes), encoding=&#x27;utf-8&#x27;) # 执行加密并转码返回bytes return encrypted_text# 解密方法def decrypt(key, text): aes = AES.new(add_to_16(key), AES.MODE_ECB) # 初始化加密器 base64_decrypted = base64.decodebytes(text.encode(encoding=&#x27;utf-8&#x27;)) # 优先逆向解密base64成bytes decrypted_text = str(aes.decrypt(base64_decrypted), encoding=&#x27;utf-8&#x27;).replace(&#x27;\\0&#x27;, &#x27;&#x27;) # 执行解密密并转码返回str return decrypted_text RSA加密 全称：Rivest-Shamir-Adleman，RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。它被普遍认为是目前最优秀的公钥方案之一。RSA是第一个能同时用于加密和数字签名的算法，它能够抵抗到目前为止已知的所有密码攻击。 Python代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# -*- coding: UTF-8 -*-# reference codes: https://www.jianshu.com/p/7a4645691c68import base64import rsafrom rsa import common# 使用 rsa库进行RSA签名和加解密class RsaUtil(object): PUBLIC_KEY_PATH = &#x27;xxxxpublic_key.pem&#x27; # 公钥 PRIVATE_KEY_PATH = &#x27;xxxxxprivate_key.pem&#x27; # 私钥 # 初始化key def __init__(self, company_pub_file=PUBLIC_KEY_PATH, company_pri_file=PRIVATE_KEY_PATH): if company_pub_file: self.company_public_key = rsa.PublicKey.load_pkcs1_openssl_pem(open(company_pub_file).read()) if company_pri_file: self.company_private_key = rsa.PrivateKey.load_pkcs1(open(company_pri_file).read()) def get_max_length(self, rsa_key, encrypt=True): &quot;&quot;&quot;加密内容过长时 需要分段加密 换算每一段的长度. :param rsa_key: 钥匙. :param encrypt: 是否是加密. &quot;&quot;&quot; blocksize = common.byte_size(rsa_key.n) reserve_size = 11 # 预留位为11 if not encrypt: # 解密时不需要考虑预留位 reserve_size = 0 maxlength = blocksize - reserve_size return maxlength # 加密 支付方公钥 def encrypt_by_public_key(self, message): &quot;&quot;&quot;使用公钥加密. :param message: 需要加密的内容. 加密之后需要对接过进行base64转码 &quot;&quot;&quot; encrypt_result = b&#x27;&#x27; max_length = self.get_max_length(self.company_public_key) while message: input = message[:max_length] message = message[max_length:] out = rsa.encrypt(input, self.company_public_key) encrypt_result += out encrypt_result = base64.b64encode(encrypt_result) return encrypt_result def decrypt_by_private_key(self, message): &quot;&quot;&quot;使用私钥解密. :param message: 需要加密的内容. 解密之后的内容直接是字符串，不需要在进行转义 &quot;&quot;&quot; decrypt_result = b&quot;&quot; max_length = self.get_max_length(self.company_private_key, False) decrypt_message = base64.b64decode(message) while decrypt_message: input = decrypt_message[:max_length] decrypt_message = decrypt_message[max_length:] out = rsa.decrypt(input, self.company_private_key) decrypt_result += out return decrypt_result # 签名 商户私钥 base64转码 def sign_by_private_key(self, data): &quot;&quot;&quot;私钥签名. :param data: 需要签名的内容. 使用SHA-1 方法进行签名（也可以使用MD5） 签名之后，需要转义后输出 &quot;&quot;&quot; signature = rsa.sign(str(data), priv_key=self.company_private_key, hash=&#x27;SHA-1&#x27;) return base64.b64encode(signature) def verify_by_public_key(self, message, signature): &quot;&quot;&quot;公钥验签. :param message: 验签的内容. :param signature: 对验签内容签名的值（签名之后，会进行b64encode转码，所以验签前也需转码）. &quot;&quot;&quot; signature = base64.b64decode(signature) return rsa.verify(message, signature, self.company_public_key) ECC加密 全称：椭圆曲线加密（Elliptic Curve Cryptography），ECC加密算法是一种公钥加密技术，以椭圆曲线理论为基础。利用有限域上椭圆曲线的点构成的Abel群离散对数难解性，实现加密、解密和数字签名。将椭圆曲线中的加法运算与离散对数中的模乘运算相对应，就可以建立基于椭圆曲线的对应密码体制。 Python代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223# -*- coding:utf-8 *-# author: DYBOY# reference codes: https://blog.dyboy.cn/websecurity/121.html# description: ECC椭圆曲线加密算法实现&quot;&quot;&quot; 考虑K=kG ，其中K、G为椭圆曲线Ep(a,b)上的点，n为G的阶（nG=O∞ ），k为小于n的整数。 则给定k和G，根据加法法则，计算K很容易但反过来，给定K和G，求k就非常困难。 因为实际使用中的ECC原则上把p取得相当大，n也相当大，要把n个解点逐一算出来列成上表是不可能的。 这就是椭圆曲线加密算法的数学依据 点G称为基点（base point） k（k&lt;n）为私有密钥（privte key） K为公开密钥（public key)&quot;&quot;&quot;def get_inverse(mu, p): &quot;&quot;&quot; 获取y的负元 &quot;&quot;&quot; for i in range(1, p): if (i*mu)%p == 1: return i return -1def get_gcd(zi, mu): &quot;&quot;&quot; 获取最大公约数 &quot;&quot;&quot; if mu: return get_gcd(mu, zi%mu) else: return zidef get_np(x1, y1, x2, y2, a, p): &quot;&quot;&quot; 获取n*p，每次+p，直到求解阶数np=-p &quot;&quot;&quot; flag = 1 # 定义符号位（+/-） # 如果 p=q k=(3x2+a)/2y1mod p if x1 == x2 and y1 == y2: zi = 3 * (x1 ** 2) + a # 计算分子 【求导】 mu = 2 * y1 # 计算分母 # 若P≠Q，则k=(y2-y1)/(x2-x1) mod p else: zi = y2 - y1 mu = x2 - x1 if zi* mu &lt; 0: flag = 0 # 符号0为-（负数） zi = abs(zi) mu = abs(mu) # 将分子和分母化为最简 gcd_value = get_gcd(zi, mu) # 最大公約數 zi = zi // gcd_value # 整除 mu = mu // gcd_value # 求分母的逆元 逆元： ∀a ∈G ，ョb∈G 使得 ab = ba = e # P(x,y)的负元是 (x,-y mod p)= (x,p-y) ，有P+(-P)= O∞ inverse_value = get_inverse(mu, p) k = (zi * inverse_value) if flag == 0: # 斜率负数 flag==0 k = -k k = k % p # 计算x3,y3 P+Q &quot;&quot;&quot; x3≡k2-x1-x2(mod p) y3≡k(x1-x3)-y1(mod p) &quot;&quot;&quot; x3 = (k ** 2 - x1 - x2) % p y3 = (k * (x1 - x3) - y1) % p return x3,y3def get_rank(x0, y0, a, b, p): &quot;&quot;&quot; 获取椭圆曲线的阶 &quot;&quot;&quot; x1 = x0 #-p的x坐标 y1 = (-1*y0)%p #-p的y坐标 tempX = x0 tempY = y0 n = 1 while True: n += 1 # 求p+q的和，得到n*p，直到求出阶 p_x,p_y = get_np(tempX, tempY, x0, y0, a, p) # 如果 == -p,那么阶数+1，返回 if p_x == x1 and p_y == y1: return n+1 tempX = p_x tempY = p_ydef get_param(x0, a, b, p): &quot;&quot;&quot; 计算p与-p &quot;&quot;&quot; y0 = -1 for i in range(p): # 满足取模约束条件，椭圆曲线Ep(a,b)，p为质数，x,y∈[0,p-1] if i**2%p == (x0**3 + a*x0 + b)%p: y0 = i break # 如果y0没有，返回false if y0 == -1: return False # 计算-y（负数取模） x1 = x0 y1 = (-1*y0) % p return x0,y0,x1,y1def get_graph(a, b, p): &quot;&quot;&quot; 输出椭圆曲线散点图 &quot;&quot;&quot; x_y = [] # 初始化二维数组 for i in range(p): x_y.append([&#x27;-&#x27; for i in range(p)]) for i in range(p): val =get_param(i, a, b, p) # 椭圆曲线上的点 if(val != False): x0,y0,x1,y1 = val x_y[x0][y0] = 1 x_y[x1][y1] = 1 print(&quot;椭圆曲线的散列图为：&quot;) for i in range(p): # i= 0-&gt; p-1 temp = p-1-i # 倒序 # 格式化输出1/2位数，y坐标轴 if temp &gt;= 10: print(temp, end=&quot; &quot;) else: print(temp, end=&quot; &quot;) # 输出具体坐标的值，一行 for j in range(p): print(x_y[j][temp], end=&quot; &quot;) print(&quot;&quot;) #换行 # 输出 x 坐标轴 print(&quot; &quot;, end=&quot;&quot;) for i in range(p): if i &gt;=10: print(i, end=&quot; &quot;) else: print(i, end=&quot; &quot;) print(&#x27;\\n&#x27;)def get_ng(G_x, G_y, key, a, p): &quot;&quot;&quot; 计算nG &quot;&quot;&quot; temp_x = G_x temp_y = G_y while key != 1: temp_x,temp_y = get_np(temp_x,temp_y, G_x, G_y, a, p) key -= 1 return temp_x,temp_ydef ecc_main(): while True: a = int(input(&quot;请输入椭圆曲线参数a(a&gt;0)的值：&quot;)) b = int(input(&quot;请输入椭圆曲线参数b(b&gt;0)的值：&quot;)) p = int(input(&quot;请输入椭圆曲线参数p(p为素数)的值：&quot;)) #用作模运算 # 条件满足判断 if (4*(a**3)+27*(b**2))%p == 0: print(&quot;您输入的参数有误，请重新输入！！！\\n&quot;) else: break # 输出椭圆曲线散点图 get_graph(a, b, p) # 选点作为G点 print(&quot;user1：在如上坐标系中选一个值为G的坐标&quot;) G_x = int(input(&quot;user1：请输入选取的x坐标值：&quot;)) G_y = int(input(&quot;user1：请输入选取的y坐标值：&quot;)) # 获取椭圆曲线的阶 n = get_rank(G_x, G_y, a, b, p) # user1生成私钥，小key key = int(input(&quot;user1：请输入私钥小key（&lt;&#123;&#125;）：&quot;.format(n))) # user1生成公钥，大KEY KEY_x,kEY_y = get_ng(G_x, G_y, key, a, p) # user2阶段 # user2拿到user1的公钥KEY，Ep(a,b)阶n，加密需要加密的明文数据 # 加密准备 k = int(input(&quot;user2：请输入一个整数k（&lt;&#123;&#125;）用于求kG和kQ：&quot;.format(n))) k_G_x,k_G_y = get_ng(G_x, G_y, k, a, p) # kG k_Q_x,k_Q_y = get_ng(KEY_x, kEY_y, k, a, p) # kQ # 加密 plain_text = input(&quot;user2：请输入需要加密的字符串:&quot;) plain_text = plain_text.strip() #plain_text = int(input(&quot;user1：请输入需要加密的密文：&quot;)) c = [] print(&quot;密文为：&quot;,end=&quot;&quot;) for char in plain_text: intchar = ord(char) cipher_text = intchar*k_Q_x c.append([k_G_x, k_G_y, cipher_text]) print(&quot;(&#123;&#125;,&#123;&#125;),&#123;&#125;&quot;.format(k_G_x, k_G_y, cipher_text),end=&quot;-&quot;) # user1阶段 # 拿到user2加密的数据进行解密 # 知道 k_G_x,k_G_y，key情况下，求解k_Q_x,k_Q_y是容易的，然后plain_text = cipher_text/k_Q_x print(&quot;\\nuser1解密得到明文：&quot;,end=&quot;&quot;) for charArr in c: decrypto_text_x,decrypto_text_y = get_ng(charArr[0], charArr[1], key, a, p) print(chr(charArr[2]//decrypto_text_x),end=&quot;&quot;)if __name__ == &quot;__main__&quot;: print(&quot;*************ECC椭圆曲线加密*************&quot;) ecc_main()","tags":[{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/tags/python-notebook/"}],"categories":[{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/categories/python-notebook/"}]},{"title":"ansys_knowledges","date":"2020-11-12T16:57:45.743Z","path":"wiki/2021-03-03-ansys_knowledges/","text":"ANSYS有限元分析软件：一般的分析操作流程：模型简化&gt;&gt;&gt; CAD模型转化为CAE模型&gt;&gt;&gt;前处理（分析类型选择&gt;&gt;材料加载&gt;&gt;约束、载荷及接触&gt;&gt;进行离散化）&gt;&gt;&gt;求解&gt;&gt;&gt;后处理 ansys workbench界面： 用户主界面 DM界面 材料库界面 分析界面","tags":[{"name":"plaxis_notebook","slug":"plaxis-notebook","permalink":"http://example.com/tags/plaxis-notebook/"}],"categories":[{"name":"plaxis_notebook","slug":"plaxis-notebook","permalink":"http://example.com/categories/plaxis-notebook/"}]},{"title":"JavaScript_data_type","date":"2020-05-17T13:31:48.359Z","path":"wiki/2021-03-03-JavaScript_data_type/","text":"JavaScript数据结构字符串JavaScript字符串是引号中的零个或多个字节 12345var name = &quot;lijiabao&quot;;var car = &#x27;AUDIO&#x27;; // 字符串可使用单双引号定义var nation = &quot;China is a beautiful country &quot;china&quot;&quot;;// 会出错,这时可使用\\转义字符如:\\&quot;,或者使用不与字符串定义匹配的单引号.var str_length = name.length; // 字符属性length返回长度 格式化字符串1`$&#123;variable or expression or functionName or objectName&#125;` 字符串方法 字符串长度：length属性 字符串指定文本出现索引：首次出现，indexOf()方法。最后出现，lastIndexOf()方法未找到返回-1，可以设置第二个参数(起始查找位置) 搜索特定值字符串并返回匹配位置：search()，可以设置更强大的搜索值（正则） 提取部分字符串 slice(start, end)提取部分并返回给新字符串，起始索引和中止索引之间字符，可接受负值索引，如果忽略第二参数，直接提取到之后的所有（负索引不支持ie8及之前） substring()类似slice，不过不支持负索引 substr() 类似slice()不过第参数是提取长度，如果省略第二参数，都是直接取到最后 替换字符串 replace() 第一参数是原有，第二是替换字符，不改变原有字符串，而返回新字符串，replace()只替换首个匹配且大小写敏感正则i标志【/string/i】可替换大小写不敏感，，正则g标志【/string/g】替换全部匹配* 大小写转换：toUpperCase()和toLowerCase() 字符串连接：concat()连接两个或者多个字符，可替代加法运算符，不改变原有字符，字符串不能更改只能替换 删除两端空白符：trim()，ie8不支持，可用正则搭配replace实现123456if (!String.prototype.trim) &#123; String.prototype.trim = function () &#123; return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, &#x27;&#x27;);&#125;;// 把replace实现的函数trim添加到原型String.prototype中var str = &quot; Hello World! &quot;;alert(str.trim()); 提取字符串字符安全的方法：charAt(下标)返回指定下标字符串，charCodeAt()返回字符的Unicode编码，charAt()找不到返回空字符，[]返回undefined 字符串也支持[]属性访问，但不可更改，str[0] = &#39;a&#39;不工作也不报错 字符转为数组：split(para：分割字符) 数字只有一种数值类型，带不带小数点均可，也可科学计数法，数值始终是64为浮点数 JavaScript 数值始终以双精度浮点数来存储，根据国际 IEEE 754 标准。 此格式用 64 位存储数值，其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号 整数精确15位，小数最大17位，小数计算并部十分精准使用乘除可消减不精准问题 数字与字符相加会被视为字符再运算，但运算顺序从左至右 在数字运算中(加法运算之外的)，会尝试将字符转为数字计算 JavaScript的NaN是非数值，数字与字符相除不了返回NaN，全局函数isNaN()判读 Infinity（-Infinity）是计算超出最大可能数的返回值，Infinity和NaN二者类型均为number JavaScript会把前缀为0x的数值常量解释为十六进制 进制转换可用toString()传入进制的数字 数值方法 以字符串返回数值：toString()，也可传入数字转换进制 返回四舍五入的指数计数法数字的字符串值：toExponential()参数传入小数点后字符数 返回指定参数位数小数数值字符串：toFixed()，参数传入小数点位数 返回指定参数长度的字符串值：toPrecision()，不传参默认全部返回 数值返回数值：valueOf()可将数值对象转为原始值 全局方法适用所有数据类型| 方法 | 描述 || Numbenr() | 返回数字，不能返回则为NaN，还可把日期转为数字 || parseFloat()和paeseInt() | 返回浮点数，无法返回则为NaN，允许空格返回首个数字 |数值属性：不可用于变量，Number.属性名即可| 属性 | 描述 || MAX_VALUE | 返回可能的最大数 || MIN_VALUE | 返回可能的最小数 || POSITIVE_INFINITY | 表示无穷大（溢出返回） || NaN | 表示非数值 || NEGATIVE_INFINITY | 表示无穷小（溢出返回）| 运算符JavaScript将数字存储为64浮点数，但所有位按32位二进制执行，执行位运算前，JavaScript将数字转换位32位有符号整数，按位操作后，将数字转换回64JavaScript数JavaScript使用32位有符号整数，有符号整数最左边的位作为减号。~5返回-6 运算符 名称 描述 &amp; AND 一对数位，两位都为1返回1，否则0 | OR 两位之一为1，返回1 ^ XOR 只有一位1，返回1 ~ NOT 反转所有位 &lt;&lt; 零填充左位移 从右推入零向左位移，推出左边的位数 &gt;&gt;&gt; 零填充右位移 从左推入零向右位移，最左边推出 &gt;&gt; 有符号右位移 从左推入最左位的拷贝向右位移 12345678// 十进制转二进制function dec2bin(dec) &#123; return (dec &gt;&gt;&gt; 0).toString(2);&#125;// 二进制转十进制function bin2dec(bin) &#123; return parseInt(bin, 2).toString(10);&#125; 数组数组是对象 数组基本内容创建： 12var cars = [car1, car2,car3]; // 最后一个不需要逗号var cars = new Array(car1, car2, car3); // 最好用第一种方法 访问数组元素：cars[0]数字为元素的下标，索引从0开始，数组名访问所有元素改变数组元素：cars[0] = &#39;AUDIO&#39;;数组不接受负值索引，访问最后一个元素用array[array.length-1];遍历数组元素：最安全方法使用for循环,也可Array.foreach()函数 12345678var fruits, text, flen, i;fruits = [&#x27;banana&#x27;, &#x27;mongo&#x27;, &#x27;pear&#x27;];flen = fruits.length;text = &#x27;&lt;ul&gt;&#x27;;for (i = 0; i &lt; flen; i++) &#123; text += &#x27;&lt;li&gt;&#x27; + fruits[i] +&#x27;&lt;/li&gt;&#x27;;&#125;text += &#x27;&lt;ul&gt;&#x27;; 添加数组元素：最佳方法是push()方法。也可array[array.length] = &#39;mongo&#39;如果使用高索引会创建未定义的‘洞’，即undefined元素。array[10] = &#39;mongo&#39;关联数组：JavaScript不支持命名索引数组，var person = [];person[&#39;name&#39;] = &#39;li&#39;;// 不可，JavaScript只支持数字索引。数组和对象区别是数组使用数字索引，对象使用命名索引可以使用Array.isArray(array)判断是否是数组 数组方法 转换为数组值为逗号分割字符串：toString()方法，如需原始值，或自动将数组变成字符串，而不需使用toString(),是所有对象都有的方法 结合为一个字符串：join()参数为连接字符 删除数组值：pop()删除数组最后一个值并返回 添加元素：push()数组结尾添加一个值 位移元素：shift()删除首个元素并将其他元素位移到更低索引并返回删除值 开头添加元素：unshift()开头添加，并将其他元素往后位移，返回新数组长度 更改元素：array[index] = &#39;change_value&#39;或利用length属性 删除元素：delete()会留下空洞，最好用pop()或者shift() 合并数组：concat()可以接受多个数组参数，返回新数组 拼接数组：splice()参数有添加个数，删除个数，添加的值splice(0,1)可删除第一个值 裁剪数组：slice()与字符的slice()类似 数组排序 以字母顺序排序：sort()对数值排序会产生错误,可用array.sort(function(a, b)&#123;return a - b&#125;)升序排列，b-a降序排列，比值函数用来定义一种排序顺序，随机排序，可引用Math的random方法返回随机数去进行比较{return 0.5 - Math.random()}，数组包含对象仍可用该种方法，知识修改一下内容即可 反转数组：reverse() 查找最大最小值：Math.max.apply(null,array),Math.min.apply() 最快的方法可以自建：12345678910function myMaxArray(arr) &#123; var len = arr.length; var max = -Infinity; while (len--) &#123; if (arr[len] &gt; max) &#123; max = arr[len]; &#125; &#125; return max&#125; 数组迭代方法 Array.forEach(functon_name)方法：为每一个人数组元素调用一次函数，内部函数接受三个参数，value，index，arry Array.map(function_name)方法：对每个数组元素执行函数创建新数组，不改变原数组，对没有值的数组不执行函数 Array.filter()方法：创建一个通过测试数组元素的新数组，同样接受三个参数 Array.reduce()方法：不改变原数组，从左至右工作，接受四个参数，totol，其他参数同上。用以减少数组值，可接受初始值，即为totol的开始值``array.reduce(func, totol_primary)` Array.reduceRight()：从右至左运行，其他同reduce Array.every()：检查数组所有元素是否通过测试，三个参数 Array.some()：检查某些数组是否通过测试，三个参数 Array.indexOf()：搜索元素在数组中的位置，从零开始，参数为：item和start Aarry.lastIndexOf()：最后元素开始，其他同indexOf() Array.find()：查找并返回通过测试的第一个元素，三个参数同map()，未找到返回undefined Array.findIndex()：返回满足条件的值的索引，其他同find() 日期日期基本内容日期输出是按浏览器的失去并显示为全文文本字符串，日期对象是静态的创建： 12345new Date();// JavaScript日期存储为毫秒相对1970.1.100:00计算new Date(year, month, day, hours, minutes, seconds, milliseconds);// 参数一个视为毫秒参数，两个到七个则总年开始往后数即可new Date(milliseconds);// 月份从0开始为一月，一位两位的年份被解释为19**年new Date(datestring); // 从日期字符串创建日期对象 Date对象在html中自动调用toString()显示全文文本日期字符串toUTCString()将日期转换为UTC字符串toDateString()将日期转换更易读的形式 日期格式化：iso格式遵循严格标准，其他格式不明确可能浏览器特定的| 类型 | 实例 | 格式标准 || —– | —— | ——|| ISO日期 | “2020-04-18”(国际标准) | Date(&#39;YYYY-MM-DD&#39;)可不规定月日，也可加时分秒，用T隔开时间和日期 || 短日期 | “04/18/2020”or”2020/04/18” | MM/DD/YYYY格式，不带前导零可能出错 || 长日期 | “Ari 18 2020” or “18 Apr 2020” | MMM DD YYYY格式，月天可任意调换逗号忽略，大小写不敏感 || 完整日期 | “Saturday April 18 2020” | 完整JavaScript格式字符串，会忽略日期名称和一些错误 | 日期获取方法：获取的信息来自日期对象| 方法 | 描述 || —– | —–|| getDate() | 以数值返回天（1-31） || getDay（） | 以数值返回周名（0-6） || getFullYear() | 获取四位的年yyyy || getHours() | 获取小时（0-23） || getMilliseconds() | 获取毫秒（0-999）|| getMinutes() | 获取分钟（0-59） || getSeconds() | 获取秒（0-59） || getMonth() | 获取月（0-11） || getTime() | 获取时间（1970.1.1至今）返回毫秒数 |UTC时间方法在上述方法的get后面接上UTC即可日期的设置方法与获取类似，只是将get换成set即可日期很容易的进行比较，date1 &gt; date2，返回true或false Math对象属性和方法Math对象允许执行数学任务，里面包括许多的数学相关的运算符常量以及求和取整等方法| 方法或属性 | 描述 || —— | ——- || Math.PI | 返回Π值 || Math.round() | 四舍五入取整|| Math.pow(x,y) | x的y次幂 || Math.sqrt() | 返回平方根 || Math.abs() | 返回绝对值 || Math.floor() | 向下取整 || Math.ceil() | 向上取整 || Math.min()and max() | 最大最小 || E,PI,SQRT2,SQRT1_2,LN2,LN10,LOG2E,LOG10E | 欧拉指数，圆周率，2韦迪的e的对数 | 随机 Math.random()：返回[0,1)之间的随机数 Math.floor(Math.random()*num)：返回[0,num)的随机整数123function getInterRand(max, min) &#123; return Math.floor(Math.random()*(max - min) + min);&#125; // 自建获取某一范围的随机整数 布尔类型true和false可用Boolean()函数来确定表达式是否为真0和false和null和undefined和NaN和-0都为布尔类型的false比较运算符：===和==和！=和！==和大于大等于小于小等于逻辑运算符：&amp;&amp;与||或！非条件运算符（三元运算符）：vaiablename = (condition) ? value1:value2 对象JavaScript中对象是王几乎所有事物都是对象，除了原始值原始值指的是没有属性或者方法的值，原始数据类型值的是拥有原始值的数据类型有五种原始数据类型：boolean，string，number，null，undefined 布尔数值和字符如果用new定义的都是对象 日期永远是对象 算术永远是对象 正则表达式永远是对象 数组函数和对象永远是对象 对象是包含变量的变量，对象属性是对象中的命名值，对象方法是指对象执行的动作，对象方法是包含函数定义的对象属性，对象是属性和方法的命名值的容器。对象创建：JavaScript变量不易变，对象才是易变的 1234567var person = &#123;&#125;;var person = new Onject(); // 尽量不用var a = &#123;a:&#x27;jjj&#x27;&#125;;var foo = Object.create(a); // 这种构造对象的方法是将a作为foo的原型创建var foo = Object.create(null) // 创建一个没有原型的对象// 或者定义对象构造器然后创建构造类型的对象// ECMAScript可用Object.create()创建 JavaScript属性 访问：objectName.propertyName;objectName[&quot;propertyName&quot;]或者objectName[expression];// expresion最终得到的得是属性名或者for/in循环遍历for (variable in objectName) &#123;代码块;&#125; 添加：可直接赋值即可objectName.propertyName = values; 删除：delete关键字delete objectName.propetyName; delete删除属性的值和属性本身，删除后，添加回来前无法使用delete设计为作用于对象属性，对变量或者函数没有影响不应用于预定义的JavaScript对象属性delete不会删除被继承的属性，但如果删除了原型属性，会影响原型继承的属性 属性值：只有属性值可修改，属性是可读的 方法对象的方法指在对象上执行的动作，包含函数定义的属性 访问：objecname.methodName()用这种访问方法如果不带括号，返回函数定义 使用内建方法：如String对象的toUpperCase() 添加新的方法：在构造函数内部完成funcName = function ()&#123;&#125; this关键字被称为this的对象是拥有改代码的对象，函数中是指拥有该函数的对象this 的值，在对象中使用时，就是对象本身。在构造器函数中，this 是没有值的。它是新对象的替代物。 当一个新对象被创建时，this 的值会成为这个新对象。请注意 this 并不是变量。它是关键词。您无法改变 this 的值。 javascript对象访问器引入了Getter和Setter，允许定义对象访问器，利用set和get关键字定义，如： 123456789101112131415&#x2F;&#x2F;Setter对象访问器的定义var person &#x3D; &#123;&quot;firstName&quot;: &quot;bill&quot;,&quot;lastName&quot;: &quot;Gates&quot;,&quot;language&quot;: &quot;en&quot;,set lang(lang) &#123;return this.language &#x3D; lang&#125;;&#x2F;&#x2F;Getter对象访问器的定义var person &#x3D; &#123;&quot;firstName&quot;: &quot;bill&quot;,&quot;lastName&quot;: &quot;Gates&quot;,&quot;language&quot;: &quot;en&quot;,get lang() &#123;return this.language&#125;;&#125;&#x2F;&#x2F; 调用的时候直接类似属性调用一样即可&#x2F;&#x2F; 函数与访问器区别在于后者语法简便，可以确保更好的数据质量，有利于后台工作&#x2F;&#x2F; Object.defineProperty()也可用于添加Setter和GetterObject.defineProperty(objectName, getterName, &#123; get function() &#123;&#125;&#125;); javascript对象构造器对象类型（蓝图）（类）大写首字母对构造器函数命名 12345678910111213141516171819202122// 对象构造器函数，利用new调用构造器函数创建相同类型的对象function Person(first, last) &#123; this.firstName = first; this.lastName = last;&#125;class Person &#123; constructor(first, last) &#123; this.firstName = first; this.lastName = last; &#125; funcName(*args) &#123; return argument[0] + argument[1] &#125;&#125;var me = new Person(&quot;li&quot;, &quot;jiabao&quot;);// 添加属性很简单，与常规对象一样me.nation = &quot;China&quot;;// 属性只在当前对象添加// 添加方法me.name = function() &#123; return this.firstName + this.lastName;&#125;;// 同样只在当前对象添加// 构造器添加属性和方法并不能如此，只能在构造器函数重新添加 内建构造器 Stirng() Number() Boolean() Array() Object() RegExp() Function() Date() // Math()对象不在此列，其是全局对象，new不可用于Math 尽管JavaScript有内建构造器，但推荐使用： {}代替new Object() “”代替new String() 数值字面量代替Number() 布尔字面量代替Boolean() []代替Array() 模式字面量代替RegExp() () {} 代替Function() 对象原型所有的JavaScript对象都从原型继承属性和方法 原型继承： 日期对象继承自Date.prototype,数组继承Array.prototype,新建对象继承Object.prototype所有的对象都继承自Object.prototype prototype属性添加新属性新方法123456789function Person(first, last) &#123; this.firstName = first; this.lastName = last;&#125;Person.prototype.nation = &quot;China&quot;;// 添加新属性Person.prototype.name = function() &#123; return this.firstName + this.lastName;&#125;; // 添加新方法// 请只修改自己的原型，绝不要修改JavaScript对象的原型 JavaScript ES5对象方法新的对象方法12345678910111213141516171819202122232425// 添加或更改属性Object.defineProperty(object, property, descriptor)Object.defineProperty(me, language, &#123;value: &quot;ZH&quot;&#125;)// 添加或更改多个属性Object.defineProperties(object, descriptors)// 访问属性Object.getOwnPropertyDescriptor(object, property)// 以数组返回所有属性Object.getOwnPropertyNames(object)// 以数组返回所有可枚举的属性Object.keys(object)// 访问原型Object.getPrototypeOf(object)// 阻止向对象添加属性Object.preventExtensions(object)// 如果可将属性添加到对象，返回trueObject.isExtensible(object)// 防止更改对象属性（不是值）Object.seal(object)// 如果对象被密封，返回trueObject.isSealed(object)// 防止对对象进行任何修改Object.freeze(object)// 如果对象被冻结，返回trueObject.isFrozen(object) 属性元数据ES5允许更改以下属性元数据： 12345678writable : true // 属性可修改enumerable : true // 属性可枚举configurable : true // 属性可配置writable : false // 属性不可修改enumerble : false // 属性不可枚举configurable : false // 属性不可重新配置// 实例，设置属性为只可读，其他的属性设置类似Object.defineProperty(person, nation, &#123;writable: fasle&#125;) 设置访问对象访问器123Object.defineProperty(objectName, getterName, &#123; get function() &#123;&#125;&#125;); 数据类型转换数据类型：function，object，boolean，number，string，undefined对象类型：Date，Object，Array，nullNumber()转换数值，String()，转换为字符串，Boolean()转换为布尔类型 typeof 确定数据类型，不能确定数组和日期只返回objecttypeof &quot;string&quot;;typeof Date();typeof array constructor 属性返回变量的构造器函数，可用于判断数组array.constructor.toString().indexOf(&#39;Array&#39;) &gt; -1array.constructor === Array; 当试图输出对象或者变量时，JavaScript自动调用toString()方法，数字方法toString()也可将数字转换成字符，全局方法String()可将大部分数据转换册成字符，日期转换成字符可以利用日期方法 字符转数值可用Number()方法，也可用+运算符，无法运算转换成NaN类型，布尔类型和日期数据也可转换。 JavaScript拥有自动的类型转换，但结果并不一定是你期望的 正则表达式构成搜索模式的字符序列，可用于文本搜索和文本替换操作 语法直接量：/pattern/modifiers;，pattern是搜索是使用的模式，modifiers或attributes是修饰符，可以设置大小写不敏感之类的。创建RegExp对象的语法：`new RegExp(pattern, attributes); 返回值一个新的RegExp对象，具有指定的模式和标志，如果参数是正则表达式而不是字符串，那么，RegExp()构造函数将用与指定的RegExp()相同的模式和标志创建一个新的 RegExp对象如果不用new，而将RegExp()当成函数调用，与new调用一样，只是pattern位正则表达式时，只返回pattern，而不创建xindeRegExp对象。 异常pattern不是合法正则表达式，或attribute含有”i-g-m”外的字符，抛出语法错误如果pattern是RegExp对象，但没有省略attribute参数，抛出类型错误 修饰符： 修饰符 描述 i 执行时大小写不敏感的匹配 g 执行全局匹配而非找到第一个就结束 m 执行多行匹配 正则表达模式括号用于查找一定范围的字符串| 表达式 | 描述 || —- | —– || [abc] | 查找方括号里的任意字符 || [^abc] | 查找任何不在括号的字符 || [0-9] | 查找0到9的数字 || (a或b) | 查找由或符号分割的任何选项 | 元字符指拥有特殊含义的字符：| 元字符 | 描述 || —- | —– || . | 查找单个字符，除了换行符和行结束符 || \\w | 查找单词字符 || \\W | 查找非单词字符 || \\d | 查找数字字符（大写相反） || \\s | 查找空白字符（大写相反） || \\b | 匹配单词边界（大写相反） || \\0 | 查找NUL字符 || \\n | 查找换行符 || \\f | 查找换页符 || \\r | 查找回车符 || \\t | 查找制表符 || \\v | 查找垂直制表符 || \\xxx | 查找八进制xxx规定的字符 || \\xdd | 查找十六进制dd规定的字符 || \\uxxxx | 查找十六进制xxxx规定的Unicode字符 | 量词 量词 描述 n+ 至少一个 n* 零个或多个 n? 零个或一个 {x} x个 {x, y} x到y个 {x, } 至少x个 n$ n结尾的字符 ^n n开头的字符 ?=n 任何其后接着字符串n的字符串 ?!n 任何其后没有接字符串n的字符串 ** RegExp对象的属性** 属性 描述 global RegExp对象是否有标志g ignoreCase 是否有标志i lastIndex 一个整数，表示下一次匹配的字符位置 multiline 是否有标志m source 正则表达式的源文本 RegExp对象的方法 方法 描述 compile 编译正则表达式 exec 检索字符串中指定的值，返回找到的值并确定位置 test 检索字符串中指定的值，返回true或false 支持正则表达式的String对象的方法 方法 描述 search 检索与正则表达式相匹配的值 match 找到一个或多个正则表达式的匹配 replace 替换与正则表达式匹配的字串 spilt 把字符串分割位字符串数组 实例申明正则表达式对象：/W3CSCHOOL/i;const regexps = new RegExp(&#39;/W3CSCHOOL/&#39;, &quot;i&quot;);test()使用:regexps.test(&quot;i love w3cschool&quot;)exec()使用：regexps.exec(&#39;i love w3cschool&#39;)","tags":[{"name":"JavascriptNotebook","slug":"JavascriptNotebook","permalink":"http://example.com/tags/JavascriptNotebook/"}],"categories":[{"name":"JavascriptNotebook","slug":"JavascriptNotebook","permalink":"http://example.com/categories/JavascriptNotebook/"}]}],"categories":[{"name":"杂记","slug":"杂记","permalink":"http://example.com/categories/%E6%9D%82%E8%AE%B0/"},{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/categories/JavaNotebook/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Start","slug":"Start","permalink":"http://example.com/categories/Start/"},{"name":"Blog","slug":"Blog","permalink":"http://example.com/categories/Blog/"},{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/categories/Archlinux%E9%85%8D%E7%BD%AE/"},{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/categories/Web%E7%9B%B8%E5%85%B3/"},{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/categories/vim%E4%BD%BF%E7%94%A8/"},{"name":"git使用","slug":"git使用","permalink":"http://example.com/categories/git%E4%BD%BF%E7%94%A8/"},{"name":"maven-note","slug":"maven-note","permalink":"http://example.com/categories/maven-note/"},{"name":"plaxis_notebook","slug":"plaxis-notebook","permalink":"http://example.com/categories/plaxis-notebook/"},{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/categories/Deployment/"},{"name":"Collections","slug":"Collections","permalink":"http://example.com/categories/Collections/"},{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/categories/Internationalization/"},{"name":"Sound","slug":"Sound","permalink":"http://example.com/categories/Sound/"},{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/categories/JavaBeans-TM/"},{"name":"RMI","slug":"RMI","permalink":"http://example.com/categories/RMI/"},{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/categories/Bonus/"},{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/categories/python-notebook/"},{"name":"bat批处理的使用","slug":"bat批处理的使用","permalink":"http://example.com/categories/bat%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"md_photos","slug":"md-photos","permalink":"http://example.com/categories/md-photos/"},{"name":"JavascriptNotebook","slug":"JavascriptNotebook","permalink":"http://example.com/categories/JavascriptNotebook/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://example.com/tags/%E6%9D%82%E8%AE%B0/"},{"name":"JavaNotebook","slug":"JavaNotebook","permalink":"http://example.com/tags/JavaNotebook/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Start","slug":"Start","permalink":"http://example.com/tags/Start/"},{"name":"Blog","slug":"Blog","permalink":"http://example.com/tags/Blog/"},{"name":"Archlinux配置","slug":"Archlinux配置","permalink":"http://example.com/tags/Archlinux%E9%85%8D%E7%BD%AE/"},{"name":"Web相关","slug":"Web相关","permalink":"http://example.com/tags/Web%E7%9B%B8%E5%85%B3/"},{"name":"vim使用","slug":"vim使用","permalink":"http://example.com/tags/vim%E4%BD%BF%E7%94%A8/"},{"name":"git使用","slug":"git使用","permalink":"http://example.com/tags/git%E4%BD%BF%E7%94%A8/"},{"name":"maven-note","slug":"maven-note","permalink":"http://example.com/tags/maven-note/"},{"name":"plaxis_notebook","slug":"plaxis-notebook","permalink":"http://example.com/tags/plaxis-notebook/"},{"name":"Deployment","slug":"Deployment","permalink":"http://example.com/tags/Deployment/"},{"name":"Collections","slug":"Collections","permalink":"http://example.com/tags/Collections/"},{"name":"Internationalization","slug":"Internationalization","permalink":"http://example.com/tags/Internationalization/"},{"name":"Sound","slug":"Sound","permalink":"http://example.com/tags/Sound/"},{"name":"JavaBeans(TM)","slug":"JavaBeans-TM","permalink":"http://example.com/tags/JavaBeans-TM/"},{"name":"RMI","slug":"RMI","permalink":"http://example.com/tags/RMI/"},{"name":"Bonus","slug":"Bonus","permalink":"http://example.com/tags/Bonus/"},{"name":"python_notebook","slug":"python-notebook","permalink":"http://example.com/tags/python-notebook/"},{"name":"bat批处理的使用","slug":"bat批处理的使用","permalink":"http://example.com/tags/bat%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"md_photos","slug":"md-photos","permalink":"http://example.com/tags/md-photos/"},{"name":"JavascriptNotebook","slug":"JavascriptNotebook","permalink":"http://example.com/tags/JavascriptNotebook/"}]}